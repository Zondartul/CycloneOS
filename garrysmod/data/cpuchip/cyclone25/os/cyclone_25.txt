// Cyclone 25 OS
// - runs on the "guest" part of the supervisor-guest dual CPU computer system
// - CPU memory model is "no internal RAM/ROM" - external RAM is 1 MB (1024*1024 cells)

// currently: developing a filesystem, to later move it to the BIOS
// experiencing random code corruption. check:
//  - stack location/size/overflow (overflow check is not done because our libraries are not ready for non-zero ss)
//  - heap remaining mem (ok)
// eventually try to write-protect all the code.

//---------------------------------- LIST OF ISSUES ---------------------------------------
// type:
//  error - if the cpu has an exception, error or panic
//  bug - if the cpu behaves oddly
//  idea - to add stuff
//
// [Error] clm -> general fault. Attempting to turn off page protection from a shell command
//         causes a general fault. CLM is needed to call for device re-enumeration.
//         theory: check if we're calling from runlevel 0, as clm is a priviledged instruction
//         /fixed: added RL0 to the PagingDisable func.
//
// [Error] overstack dumbs on test
//
// [Bug]  stack trace is missing function names. As if the function table is stale.
// /FIXED the cycloneBuilder runs so it SEEMS like the function table should be correct?
//        /fixed: recompiled and fixed CycloneBuilder
//
// [Error] unclean reset. We get random errors (paging related) if something went wrong last
//         time and we reset the cpu. we end up having to re-upload the program. kinda
//         defeats the purpose of page protection, besides runtime error detection.
//
// [Error] program loading resulted in all sorts of errors
//         fixed: 1) made sure that kernel-side things that change paging are in RL0
//                2) made sure that kernel-interface used things are also in RL0
// 
// [Error] program loading error with printf
//         fixed: fixed a typo in the version of variadic.txt included by load2.txt
//
// [Todo] - make the page table generated by procload reusable and preloaded
//        - accelerate the program insertion (palloc and copy)
//        - minimize the pagetable needed by programs by putting the KCintH
//           right after the program code, and also generate a very short int table.
//        - make the layout of the loaded program match that of alcor i.e. begin straight at zero
//        - check how AlcorPC works i guess
//
// [Bug] loaded program runs at RL 0 and it's able to fuck up the kernel
//
// [Bug] loaded program is on the same stack as kernel, able to fuck up the kernel.
//
// [Todo] - fix a bunch of general OS bugs like faulty reset
//
// [Todo] - add an autorun script like "mount, cd, dump, run"
// 
// [Idea] give each library/module an "init" function that adds information to the kernel map (start/end of module, global vars section, init2 function to call)
//        and build the kernel pagetable from that.
//
// [Idea] - split the shell into the actual command processor and a terminal
//

//comment this for faster, more dangerous code
#define PAGE_PROTECT
#define FS_DEBUG

//as we are using an external memory model, we need to first tell the CPU where the stack is
#pragma set OutputFinalListing true
#pragma set OutputToFile true

#define int_kernell_call 40
#define int_unmapped 41
#define int_timer 42
#define kk_prints 1
#define kk_printn 2
#define kk_printf 3
#define kk_thread_exit 4
#define kk_proc_id 5

//mov esp, stack_buffer_end; //stack current is @ stack_buffer_end
//cpuset 9, stack_buffer_end; //stack zero is @ stack_buffer
#define STACK_SIZE 12800
mov esp, STACK_SIZE;              // stack is from stack_buffer     ss:[0]
cpuset 9, STACK_SIZE;             //            to stack_buffer_end ss:[1128] <- current
mov ss, stack_buffer;             // HOW MANY TIMES HAVE I TRIED THIS???
// we need to first change our code to accept nonzero SS (stackalloc, variadic, etc)


jmp main;
derpslot: db 7012;
programslot:
#include "kernelinterface.txt"
//alloc 10000;
//#include "trap10kb.txt"
programslot_end: db 0;
//#include "string.txt"
libmarker1: db 0;
#include "variadic.txt"
libmarker2: db 0;
#include "types.txt"
libmarker3: db 0;
#include "libstring.txt"
libmarker4: db 0;
#include "libconsolescreen.txt"
libmarker5: db 0;
#include "libextbus.txt"
libmarker6: db 0;
#include "iobus.txt"
libmarker7: db 0;
#include "printf.txt"
libmarker8: db 0;
#include "timer.txt"
libmarker9: db 0;
#include "process.txt"
libmarker10: db 0;
#include "pagealloc.txt"
libmarker11: db 0;
#include "zmalloc2.txt"
libmarker12: db 0;
#include "zvector2.txt"
libmarker13: db 0;0.
#include "libinterrupt.txt"
libmarker14: db 0;
#include "libkeyboard.txt"
libmarker15: db 0;
#include "libpaging.txt"
libmarker16: db 0;
#include "procloader.txt"
libmarker17: db 0;
#include "args_collector.txt"
libmarker18: db 0;
#include "shell2.txt"
libmarker19: db 0;
#include "pagemanager.txt"
libmarker20: db 0;
#include "libtrace.txt"
libmarker21: db 0;
#include "overstack.txt"
libmarker22: db 0;

#define ADDR_RAM 0
#define SIZE_RAM 1048576
#define ADDR_EB 1048576
#define SIZE_EB 1073741824

#define HEAP_SIZE 500000

alloc 128;
all_globals:
#include "libconsolescreen_globals.txt"
#include "libstring_globals.txt"
#include "zmalloc2_globals.txt"
#include "pagealloc_globals.txt"
#include "libkeyboard_globals.txt"
#include "overstack_globals.txt"
main_globals: //these all get zeroed on start
EBcb_1: alloc 50; //extended bus control block
float EB_Addr_Screen = 0;
float timerPeriod = 0;
float timerLogicTimeout = 0;
float v_proclist = 0;
float proclist_I = 0;
float switcherOn = 0;
float k_page_manager = 0;
float threadExit_ebp = 0;
float threadExit_esp = 0;
float threadExit_pos = 0;
strbuff: alloc 80;
trans_buffer: alloc 10;
main_globals_end: db 0;

alloc 128;
stack_buffer:
//alloc 1000;
//alloc 128;
alloc STACK_SIZE;
stack_buffer_end:
db 0;
alloc 128;

trap_unmapped:
int 41;
trap_unmapped_end: db 0;

float main(){
    clear_globals(main_globals, main_globals_end);
    libconsolescreen_init();
    
    //set_trampoline(programslot, programslot_end, trap_unmapped, trap_unmapped_end);
    EBcb_constructor(EBcb_1);
    
    float entry = EBcb_get_entry(EBcb_1, 0);
    EBcb_entry_set_addr(entry, ADDR_EB);
    EBcb_autoconf(EBcb_1);
    //EBcb_print(EBcb_1);
    
    EBcb_device_bind_addr(EBcb_1, UDH_CONSOLE_SCREEN, 1, &EB_Addr_Screen);
    if(!EB_Addr_Screen){error(32);}
    screen_set(EB_Addr_Screen);

    kernel_thread();
}

//fills the space between dest_start and dest_end with copies of code between trp_start and trp_end
float set_trampoline(float dest_start, float dest_end, float trp_start, float trp_end){
    float trp_len = trp_end - trp_start;
    float dest_len = dest_end - dest_start;
    float num_traps = floor(dest_len/trp_len);
    float I;
    for(I = 0; I < num_traps; I++){
        memcpy(dest_start,trp_start,trp_len);
        dest_start += trp_len;
    }
}

float clear_globals(float start, float end){
    float I;
    for(I = start; I < end; I++){
        *I = 0;
    }
}

float kprints(float s){kcall(kk_prints, s, 0, 0);}
float kprintn(float n){kcall(kk_printn, n, 0, 0);}
float kprintf(float fmt){
    float nargs = ecx;
    float va = va_start(&fmt);
    kcall(kk_printf, fmt, nargs, va);
}


float kernel_thread(){
    screen_clear();
    printf("%mHello World! I am OS\n",191);
   
    malloc_set_disk(heap, HEAP_SIZE);
    malloc_init();
    printf("malloc initialized (heap disk = %d)\n",heap);
    float a = malloc(100);
    printf("malloc(100) = %d\n",a);
    printf("initializing interrupts...\n");
    
    float flags = int_enabled;
    float flags_ext = int_enabled + int_external;
    //initInterrupts(float IT, float first, float size, float handler, float flags){
    //printf("done\n");
    initInterrupts(interruptTable, 2, 50, defaultIntHandler, flags);
    //stef;
    
    //addInterruptHandler(float IT, float num, float func,float flags)
    addInterruptHandler(interruptTable, int_kernell_call, KernellCallIntHandler, flags);
    //addInterruptHandler(interruptTable, 2, stopIntHandler, flags);
    //addInterruptHandler(interruptTable, int_unmapped, UnmappedPageIntHandler, flags);
    //addInterruptHandler(interruptTable, int_timer, timerIntHandler, flags_ext);
    //addInterruptHandler(interruptTable, 30, pageTrapHandler, flags_ext);
    //addInterruptHandler(interruptTable, 28, pageReadHandler, flags_ext);
    //addInterruptHandler(interruptTable, 29, pageWriteHandler, flags_ext);
    
#ifdef PAGE_PROTECT  
    printf("engaging page protection...\n");
    protect_kernel_pages();
    //printf("enabling paging...\n");
    cpuset 69, 1; //PageSelfProtect = true
    stef; //extended mode enable (interrupts)
    stm; //extended memory mode enable (paging)  //pagingEnable();
    printf("paging is on.\n");
#endif
    //write_test(kprintf);
    
    
    /*
    printf("exec test\n");
    float buff[10];
    if(exec_test(buff)){
        printf("exec test failed (full exec)\n");
    }else{
        printf("exec test failed (silent)\n");
    }
    */
    //printf("trying kernell call\n");
    //kcall(123, 456);
    printf("done\n");
    //printf("test krpints["); kprints("hello"); printf("]\n");
    //printf("test kprintn["); kprintn(1234); printf("]\n");
    //printf("test kprintf["); kprintf("%s|%s|%s", "one", "two", "three"); printf("]\n");
    
    printf("initializing page allocator...\n");
    float pageDiskSize = 12800;
    float pageDisk = malloc(pageDiskSize);
    palloc_set_disk(pageDisk, pageDiskSize);
    palloc_init();
    printf("done\n");
    printf("overstack init...");
    overstack_init();
    printf("done\n");
    
    printf("starting shell...\n");
    float shell = init_shell2();
    shell2_open(shell);
    printf("...back to kernel.\n");
    
    
    /*    
    float EB_ExtCpu = 0;
    EBcb_device_bind_addr(EBcb_1, UDH_ZCPU, 1, &EB_ExtCpu);
    if(EB_ExtCpu){
        printf("Ext CPU at %d\n",EB_ExtCpu);
        float prog = readProgramInfo(EB_ExtCPU);

        vector_constructor(v_proclist, 1);
        float process1 = generateProcess(prog, 1);
        //float process2 = generateProcess(2);
        
        //init_ktimer(); //we used the timer to investigate "first-instruction NMI bug", but we're gonna shelve it for now
        process_run(process1);
        
        while(1){
            printf("what now?\n");
        }
                
    }else{
        printf("External CPU not found\n",900);
    }
    */
        
    while(1){nop;}
}

//tests whether execution protection is enabled by copying the code to the buffer
//and calling it. the copied code jumps back to the function.
//buff:
float exec_test(float buff){
    float code_size = exec_test_code_end - exec_test_code;
    float x = 0;
    printf("exec code size is %d bytes\n",code_size);
    //memcpy(dest, src, size)
    printf("copying code...\n");
    memcpy(buff, exec_test_code, code_size);
    printf("calling code...\n");
    mov eax, 0;
    x = buff();
    printf("code returned %d.\n", x);
    return x;
}

exec_test_code:
mov eax, 1;
ret;
exec_test_code_end: db 0;

float write_test(float func){
    float x = func[0];
    printf("write test (x = %d)\n", x);
    kprintf[0] = 0;
    if(kprintf[0] == 0){
        printf("write test failed (full write)\n");
    }else if(kprintf[0] == x){
        printf("write test failed (but no write)\n");
    }else{
        printf("write test failed mysteriously (kprintf = %d)\n", kprintf[0]);
    }
}


float protect_kernel_pages(){
    //printf("protect_kernel_pages()\n");
    //set all code to "write-protected"
    //set stack to "writeable, no-execute"
    //set globals to "writeable, no-execute"
    //set heap to "writeable, no-execute"
    float PM = malloc(sizeof_page_manager);
    page_manager_constructor(PM);
    
    k_page_manager = PM;
    
    
    float pfrom; float pto;
    
    //set all code as no-write.
    float page[2];
    page[0] = 0;
    page[1] = 0;
    setPageRunlevel(page, 1);
    setPageFlags(page, page_no_write);
    //don't care about mapping since we have not set the "remap" flag.
      //kernel
      pfrom = toPage(0); pto = toPage(heap);   //start-stop of kernel code (everything)
      page_manager_assign_page_range(PM, page, pfrom, pto);
    
    //enable writing and disable executing on variables.
    setPageFlags(page, page_no_exec);
      //globals
      pfrom = toPage(all_globals); pto = toPage(main_globals_end);
      page_manager_assign_page_range(PM, page, pfrom, pto);
      //stack
      pfrom = toPage(stack_buffer); pto = toPage(stack_buffer_end);
      page_manager_assign_page_range(PM, page, pfrom, pto);
    
      page_manager_assign_default_page(PM, page);
    
    //set proper runlevel for the interrupt table
    page[0] = 0;
    page[1] = 0;
    setPageRunlevel(page, 1);
    setPageFlags(page, page_no_write);
        pfrom = toPage(interruptTable); pto = pfrom+1;
        page_manager_assign_page_range(PM, page, pfrom, pto);
    
    //set runlevel 0 (root) for interrupt handlers
    setPageRunlevel(page, 0);
    setPageFlags(page, page_no_write);
        pfrom = toPage(pg_int_handlers); pto = toPage(pg_int_handlers_end);
        page_manager_assign_page_range(PM, page, pfrom, pto);
    
    
    //04.03.2022 fix for "SetPageTable()" gives priviliged instruction error
     //set runlevel 0 (root) for the paging library (else it won't be able clm,stm)
     setPageRunlevel(page, 0);
     setPageFlags(page, page_no_write);
         pfrom = toPage(pg_paging_control); pto = toPage(pg_paging_control_end);
         page_manager_assign_page_range(PM, page, pfrom, pto);
        
      //wait, fuck. this causes a page write error for the heap.
      //let's try explicitly marking the heap read-writeable
      //well, we'll capture heap through the default page.
     setPageRunlevel(page, 1);
     setPageFlags(page, page_no_exec);
        page_manager_assign_default_page(PM, page);
 //end fix 04.03.2022
    //06.03.2022: also make the kernel interface have RL 0 because it deals with switching PTs
    setPageRunlevel(page, 0);
    setPageFlags(page, page_no_write);
        pfrom = toPage(user_kernel_interface); pto = toPage(user_ki_middle);
        page_manager_assign_page_range(PM, page, pfrom, pto);
    
    page_manager_activate(PM);
    
    //printf("reporting kprintf page:\n");
    //float PT = PM[2];
    //float pnum_kp = toPage(kprintf);
    //float kp_page = getPage(PT, pnum_kp);
    //printf("kprintf = %d\npage num = %d\nPT = %d, page = %d\n",kprintf, pnum_kp, PT, kp_page);
    //reportPage(PT, pnum_kp);
    
    //now we need to activate paging too.
    //printf("protect_kernel_pages() done\n");   
}

float init_ktimer(){
    printf("setting timer\n");
    //62 = TimerDT - current timer discrete step
    //66 = TimerPrevTime - previous timer fire time
    
    //float rate = 2; //trigger every 5 secs
    //CPUSET 65,rate; //TimerRate - trigger every 5 second
    //CPUSET 67,int_timer; //TimerAddress - trigger interrupt 42
    //CPUSET 64,1; //TimerMode (off,instructions,seconds) - count seconds
    
    //CPUSET 56,1; //external runlevel
    
    timerPeriod = 400000;
    timerN = 0;
    //float rate = 400000;//400000;
    CPUSET 65, timerPeriod;//rate;
    CPUSET 64, 2;
    CPUSET 67, int_timer;
}


derpTable:alloc 10;

float timerN = 0;


// fixes the external-interrupt-on-first-instruction-of-normal-interrupt bug.
// insert anywhere in the normal interrupt handler, preferrably after "cli".
// does not work on handlers for interrupts that are already external.
float unfuckEntry(float ptr){
    //any external interrupt that is triggered after an interrupt request, but before the first instruction
    //of the interrupt handler is executed, pushes the context to stack, and then forms an interrupt request,
    //that gets ignored because an interrupt is already in progress.
    //tl;dr: timer fucks up the stack and then doesn't actually jump to it's handler,
    //but only on the very first instruction of another interrupt handler.
    
    //this function is meant to detect the "timer interrupt stack fuckup" condition.
    //this function is called from an interrupt handler like so:
    //  the evolution of ESP and EBP registers is also shown (unless the context push triggered more interrupts)
    //                                           stack before the instruction:
    // intHandler:                   normal case:                    fucked case:                     from pov of isStackFucked():
    //   enter0;                     esp+1: IP0,        ebp: EBP0        esp+1: intHandler, ebp: EBP0  esp+6 ebp2+4
    //   cli;                        esp+1: EBP0,       ebp: EBP1        -identical-                   esp+5 ebp2+3
    //   push intHandler;            -no change-                         -identical-                   
    //   call isEntryFucked;         esp+1: intHandler, ebp: EBP1        -identical-                   esp+4 ebp2+2
    //
    //   isEntryFucked:              
    //   enter 1                     esp+1: IP1,        ebp: EBP1        -identical-                   esp+3 ebp2+1
    //                                          
    //                               esp+2: EBP1,                                                      esp+2 ebp
    //   ..my code                   esp+1: arg1,       ebp: EBP2        -identical-                   esp+1 ebp2-1
                           
    //waaaait, hold on.
    // ext int gets called, and pushes stack, including return ip.
    // then native interrupt switcher gets called, and pushes IP and CS again.            

    // stack if normal interrupt was called:
    // 0  
    // 1  <- ESP
    // 2  X (func_local)
    // 3  8 (func_enter_prevEBP) <- EBP
    // 4  112 (func_prevIP: code: call func)
    // 5  A (func_arg1)
    // 6  X (intH_local)
    // 7  X (intH_local) 
    // 8  Y (int_enter_prevEBP)
    // 9  0 (int_prevCS)
    // 10 0 (int_prevIP)
    //
    // code:
    // 100 int 110
    // 101 nop;
    //  intHandler:
    // 110 enter 2; 
    // 111 push A; 
    // 112 call func; 
    // 113
    //  func:
    // 120 enter 1;   
    // 121 xxxCODExxx <---   
               
    // stack if external interrupt was called:
    // 0  
    // 1  <- ESP
    // 2  X (func_local)
    // 3  8 (func_enter_prevEBP) <- EBP
    // 4  112 (func_prevIP: code: call func)
    // 5  A (func_arg1)
    // 6  X (intH_local)
    // 7  X (intH_local) 
    // 8  Y (int_enter_prevEBP)                                int_EBP
    // 10 0 (fucked int_prevIP)       1  IP   (copy of 10)
    // 11+ various registers          2  CMPR
    // 12                             3  EAX
    // 13                             4  EBX
    // 14                             5  ECX
    // 15                             6  EDX
    // 16                             7  EBP
    // 17                             8  ESP
    // 18                             9  ESI
    // 19                             10 EDI
    // 20                             11 CS
    // 21                             12 SS
    // 22                             13 DS
    // 23                             14 FS
    // 24                             15 GS
    // 25                             16 ES
    // 26                             17 KS  
    // 27                             18 LS      <- we also wanna move our prevEBP here, and point EBP to it
    // 28 (real int_prevCS)                                    int_EBP+19        
    // 29 (real int_prevIP)                                    int_EBP+20
    //
    // code:
    // 100 int 110
    // 101 nop;
    //  intHandler:
    // 110 enter 2; 
    // 111 push A; 
    // 112 call func; 
    // 113
    //  func:
    // 120 enter 1;   
    // 121 xxxCODExxx <---  
  
    float E = ebp;
    float EP = *ebp;
    //printf("&arg1 = %d\n", &ptr);
    
    //printf("ebp+0 = %d -> %d\n", E+0, E[0]);
    //printf("ebp+1 = %d -> %d\n", E+1, E[1]);
    //printf("ebp+2 = %d -> %d\n", E+2, E[2]);
    //printf("ebp+3 = %d -> %d\n", E+3, E[3]);
    //printf("ebp+4 = %d -> %d\n", E+4, E[4]);
    //printf("ebp+5 = %d -> %d\n", E+5, E[5]);
    //printf("ebp+6 = %d -> %d\n", E+6, E[6]);
    //printf("ebp+7 = %d -> %d\n", E+7, E[7]);
    //printf("ebp+8 = %d -> %d\n", E+8, E[8]);
    
    //while(1){}
    
    //float oldEsp = getPrevEBP(1)+1;
    float prevCS = EP[1];
    if(prevCS != 0){
        printf("%mentry fucked. Unfucking.\n",990);
        //note: prevIP at ebp+20
        //      prevCS at ebp+19 ?
        //or
        //
        EP[18] = EP[0]; //move stack frame
        *E = EP+18; 
        //EP[1] = EP[19];
        //EP[2] = EP[20];
        return 1;
    }//else{
        //printf("entry ok, pop = %d, esp = %d\n",ptr_actual, esp);
    //}
    return 0;
}

alloc 128;
pg_int_handlers:


float retAlert(float p){
    //p is esp given by caller
    p = p + ss; //stack segment
    float prevCS = p[1];
    float prevIP = p[2];
    if(prevCS != 0){
        CPUSET 64, 0; //disable timer so it doesn't trigger
        printf("Return alert!\n");
        printf("stack should have [IP;CS]\n");
        printf("but CS is non-zero\n");
        printf("printing given ptr:\n");
        printf("p-2 = %d -> %d\n",p-2,p[-2]);
        printf("p-1 = %d -> %d\n",p-1,p[-1]);
        printf("p+0 = %d -> %d\n",p+0,p[0]);
        printf("p+1 = %d -> %d\n",p+1,p[1]);
        printf("p+2 = %d -> %d\n",p+2,p[2]);
        printf("printing prevEBP:\n");
        
        float E = ebp;
        float EP = *ebp;
        p = EP;
        printf("p-2 = %d -> %d\n",p-2,p[-2]);
        printf("p-1 = %d -> %d\n",p-1,p[-1]);
        printf("p+0 = %d -> %d\n",p+0,p[0]);
        printf("p+1 = %d -> %d\n",p+1,p[1]);
        printf("p+2 = %d -> %d\n",p+2,p[2]);
        printf("and now i panik\n");
        clm;
        panic();
        //while(1){nop;}
    }
}
//------------- interrupt handlers
//KernellCallIntHandler:
//  mov r30, esp;
//  jmp KernellCallIntHandler2;
//
//void KernellCallIntHandler2(){
void KernellCallIntHandler(){
    //this section is for multiprocess pre-emptive switching
     //cli;
     //unfuckEntry(KernellCallIntHandler);
     //if(timerShouldRun()){
     //    printf("-running timer\n");
     //    timerLogic();
     //}
     //sti;
    preserve r0, r1, r2, r3;
    float arg1 = r0;
    float arg2 = r1;
    float arg3 = r2;
    float arg4 = r3;
    zap r0, r1, r2, r3;
    switchToKernel();
    //printf("\n%mKernellCall/esp %d/r0 %d\n",990,esp,arg1);
    //printf("KernellCall begin---\nesp = %d\n",esp);
    //printf("r0 = %d\n", r0);
    //float LADD; cpuget LADD,27;
    //float LINT; cpuget LINT,28;
    //float MEMADDR; cpuget MEMADDR,63;
    //float prevCS; mov prevCS, EBP:#1;
    //float prevIP; mov prevIP, EBP:#2;
    //float prevCol = PrintCol; PrintCol = 990111;
    //printf("INT %d:%d from %d:%d\n",LINT,LADD,prevIP,prevCS);
    //printf("kernell call %d, %d, %d, %d\n", arg1, arg2);
    float found = 0;
    if(arg1 == kk_prints){
        found = 1;
        float arg2_abs = toAbsSpace(arg2);
        printf("%m%s",990,arg2_abs);
        //printf("%s",arg2_abs);
    }
    if(arg1 == kk_printn){
        found = 1;
        printf("%m%d",990,arg2);
        //printf("%s",arg2);
    }
    if(arg1 == kk_printf){        
        
    //kcall(kk_printf, fmt, nargs, va);
        found = 1;
        float fmt = toAbsSpace(arg2);
        float nargs = arg3;
        float va = arg4;
        printf("%m-vprintf(fmt = %d, nargs = %d, va = %d)\n",990, fmt, nargs, va);
    //printf("KC check 1, esp = %d\n",esp);
        vprintf(fmt, nargs, va);
    //printf("KC check 2, esp = %d\n",esp);
    }
    if(arg1 == kk_thread_exit){
        found = 1;
        if(lastProcess){        
            current_thread = 0;
            jmpThreadExitPoint();
        }
    }
    if(arg1 == kk_proc_id){
    //printf("KC check 3, esp = %d\n",esp);
        found = 1;
        if(lastProcess){
            float id = process_h_get_procID(lastProcess);
            mov r0, id;
        }
   // printf("KC check 4, esp = %d\n",esp);
    }
    if(!found){
        printf("unrecognized kernell call %d, %d, %d, %d\n", arg1, arg2, arg3, arg4);
    }
    //float str = intnum_to_str(LINT);
    //printf("%s\n",str);
    //PrintCol = prevCol;
    //cpuset 27,LADD;
    //cpuset 28,LINT;
    //cpuset 63,MEMADDR;
   // printf("KC check 5, esp = %d\n",esp);
    switchToLastProcess(); //apparrently, once we switch to process, we can't return here, because we are ourselves no-exec from runlevel1
    //so we need to... make the other process a thing that we "will return to" once we do an iret, or something.
    //or we can make that part of kernel interface runlevel 0.
    //oh wait, it's actually the switchToLastProcess that can't return to itself from pagingEnable because pagingEnable isn't runlevel 0.
    
   // printf("KC check 6, esp = %d\n",esp);
    leave;
   // printf("KC check 7, esp = %d\n",esp);
    retAlert(esp); //so half the time this triggers a ret-alert and the other half we get a "walked into no-exec" when just calling the retAlert.
    
    //though maybe the "no-exec" happened after we made retAlert bigger.
    //sti;
    //printf("KernellCall end esp = %d\n", esp);
    iret;
}

void UnmappedPageIntHandler(){
    cli;
    //unfuckEntry(UnmappedPageIntHandler);
    float prevCS; mov prevCS, EBP:#1;
    float prevIP; mov prevIP, EBP:#2;
    switchToKernel();
    
    printf("%mu:Access to unmapped page from (IP %d:CS %d) \n",900,prevIP,prevCS);
    if(lastProcess){thread_terminate();}
    
    printf("Press any key to reset\n");
    while(!hasKey()){}
    readKey();
    int 0;
    
    
    leave;
    sti;
    iret;
}


void defaultIntHandler(){
    cli;
    //unfuckEntry(defaultIntHandler); //interrupt entry unfucker only works when ss = 0
    float LADD; cpuget LADD,27;
    float LINT; cpuget LINT,28;
    //float MEMADDR; cpuget MEMADDR,63;
    float prevCS; mov prevCS, EBP:#1;
    float prevIP; mov prevIP, EBP:#2;
//    switchToKernel();
    //float prevCol = PrintCol; PrintCol = 990111;
    printf("%md:INT %d:%d from %d:%d\n",810,LINT,LADD,prevIP,prevCS);
    float str = intnum_to_str(LINT);
    printf("%m%s\n",810,str);
//    if(lastProcess){thread_terminate();}
    //PrintCol = prevCol;
    //cpuset 27,LADD;
    //cpuset 28,LINT;
    //cpuset 63,MEMADDR;
//    switchToLastProcess();
    float col_trace = 148;
    //printf("%mprinting current frame...\n", col_trace);
    //float x = ebp;
    //printf("%mEBP = %d\n",col_trace, x);
    //float I;
    //for(I = -5; I < 5; I++){
    //    printf("EBP[%d] = %d\n", I, x[I]);
    //}
    
    printf("%mgathering stack trace...\n", col_trace);
    float buff[80];
    getIntStackTrace(buff);
    //printf("%mprinting stack trace:\n", col_trace);
    printStackTrace(buff);

    printf("%m~ halting CPU ~\n",159);
    while(1){} // loop forever (stop at first interrupt)
  
    leave;
    sti;
    iret;
}

float timerShouldRun(){
    //float T = getTime();
    //printf("[tsr: T = %d, TT = %d, diff = %d]\n",T,timerLogicTimeout,timerLogicTimeout-T);
    return timePassed(timerLogicTimeout);}

float timerLogic(){
    timerLogicTimeout = setTimeout(1.5); //1 second away
    printf("%m<T%d>",59,timerN);
    timerN++;
    if(switcherOn){
        float size = vector_size(v_proclist);
        float proc = vector_get(v_proclist, 0, proclist_I);
        proclist_I++;
        if(proclist_I >= size){proclist_I = 0;}
        lastProcess = proc;
    }
}

void timerIntHandler(){
    cli;
//    pusha;
    switchToKernel();
    timerLogic();
 //   switchToLastProcess();
 //   popa;
    switchToLastProcess();
    leave;
    sti;
    extret; //iret
}

void pageTrapHandler(){
    cli;
    switchToKernel();
    printf("---page trap---\n");
    switchToLastProcess();
    leave;
    sti;
    extret;
}

void pageReadHandler(){
    cli;
    float is_proc = current_thread;
    switchToKernel();
    printf("---read trap (%d)---\n", is_proc);
    switchToLastProcess();
    leave;
    sti;
    extret;
}

void pageWriteHandler(){
    cli;
    switchToKernel();
    printf("---write trap---\n");
    switchToLastProcess();
    leave;
    sti;
    extret;
}

alloc 128;
pg_int_handlers_end: db 0;
//----------------------- interrupt handlers

float thread_terminate(){
    printf("%mThread terminated\n",900);
    current_thread = 0;
    jmpThreadExitPoint();
}

//these floats moved to kernel globals
float setThreadExitPoint(float c_ebp, float c_esp, float c_pos){
    threadExit_ebp = c_ebp;
    threadExit_esp = c_esp;
    threadExit_pos = c_pos;
}
float jmpThreadExitPoint(){farjump(threadExit_ebp, threadExit_esp, threadExit_pos);}
float farjump(float c_ebp, float c_esp, float c_pos){
    mov r0, c_ebp;
    mov r1, c_esp;
    mov r2, c_pos;
    mov ebp, r0;
    mov esp, r1;
    jmp r2;
}


//finds the jump assembly instruction starting from addr
//and checking the next nbytes. If found, returns offset, else zero.
//if pres is set, *pres = jump destination
float findJmp(float addr, float nbytes, float pres){
    float I;
    for(I = 0; I < nbytes; I++){
        float ptr = addr+I;
        float b1 = (ptr[0] == 2);
        float b2 = (ptr[1] == 0);
        if(b1 && b2){
            if(pres){*pres = ptr[2];}
            return I;
        }
    }
    return -1;
}

//float kprints(float s){kcall(kk_prints, s, 0, 0);}
//float kprintn(float n){kcall(kk_printn, n, 0, 0);}
//float kprintf(float fmt){
//    float nargs = ecx;
//    float va = va_start(&fmt);
//    kcall(kk_printf, fmt, nargs, va);
//}

float toAbsSpace(float p){
    if(lastProcess){
        float pagemap = process_h_get_pagemap(lastProcess);
        float arr = vector_array(pagemap);
        float poffs = p%128;
        float pagenum = floor(p/128);
        float map_page = getPage(arr, pagenum);
        float phys_page = getPageMapping(map_page); //vector_get(pagemap, 0, pagenum*2+1);
        float phys_p = phys_page*128 + poffs;
        return phys_p;
    }else{
        return p;
    }
}

float kcall(float a, float b, float c, float d){
    preserve r0, r1, r2, r3;
    mov r0, a;
    mov r1, b;
    mov r2, c;
    mov r3, d;
    int int_kernell_call;
    zap r0, r1, r2, r3;
}

float vprintf(float fmt, float nargs, float va){
    //printf("nargs = %d\n",nargs);
    //warning: stack fuckery
    float args = stack_alloc(nargs-1);
    float I;
    for(I = -1; I < nargs-2; I++){
        float arg = va_next(&va);
        args[I] = arg;
    }
    push fmt;
    mov ecx, nargs;
    call printf;
}


#define BIOSCMD_PRINTS 1
#define BIOSCMD_PRINTN 2




float bios_prints(float s){
    while(ioRead(0) == 2){nop;}
    ioWrite(1,BIOSCMD_PRINTS);
    float len = strlen(s);
    ioWriteBuff(2,s,len+1);
    ioWrite(0,2);
    while(ioRead(0) != 2){nop;}
}

float bios_printn(float n){
    while(ioRead(0) == 2){nop;}
    ioWrite(1,BIOSCMD_PRINTN);
    ioWrite(2,n);
    ioWrite(0,2);
    while(ioRead(0) != 2){nop;}
}


float Perr(){error(45);}
float panic(){error(46);}
float error(float n){
    int n;
    while(1){}
}

float kernelSize(){return heap;}

//reference data for the debugger:
#include "generated/func_table.txt"

heap: db 0;
alloc 10000;



//other ideas
// bios mailbox - unused - changes transaction memory to have several spaces for multiple CPUs
