programslot:
MAIN_CODE:
     0 mov ECX,0
// main(...)
     3 call 80535
     6 alloc 10000
LIBSTRING_CODE:
memcpy:
// memcpy(dest,src,n)
 10006 enter -0
__1:
 10009 rstack ECX,EBP:3
// ESI=src
 10013 mov ESI,ECX
 10015 rstack ECX,EBP:2
// EDI=dest
 10019 mov EDI,ECX
 10021 rstack ECX,EBP:4
// rem=n
 10025 mov EAX,ECX
__3:
// if (rem
 10027 cmp 0,EAX
 10030 jz 10053
 10033 mov EBX,EAX
 10035 min EBX,8192
 10038 mcopy EBX
 10040 mov ECX,EBX
 10042 neg ECX
 10044 mov EDX,EAX
 10046 add EDX,ECX
// rem=rem-count
 10048 mov EAX,EDX
 10050 jmp 10027
__2:
 10053 rstack ECX,EBP:2
 10057 mov EAX,ECX
 10059 leave 
 10060 ret 
__0:
 10061 leave 
 10062 ret 
memchr:
// memchr(s,c,n)
 10063 enter -0
__5:
 10066 rstack ECX,EBP:2
 10070 mov EAX,ECX
 10072 rstack ECX,EBP:4
 10076 mov EBX,ECX
__7:
// if (rem
 10078 cmp 0,EBX
 10081 jz 10113
__9:
 10084 rstack ECX,EBP:3
 10088 sub ECX,#EAX
 10090 mov EDX,ECX
 10092 fabs EDX,EDX
 10094 fsgn EDX,EDX
 10096 lneg EDX
// if (*r==c)
 10098 cmp 0,EDX
 10101 jge 10106
 10104 leave 
 10105 ret 
__10:
__8:
// ++r
 10106 inc EAX
// --rem
 10108 dec EBX
 10110 jmp 10078
__6:
 10113 mov EAX,0
 10116 leave 
 10117 ret 
__4:
 10118 leave 
 10119 ret 
memset:
// memset(ptr,c,n)
 10120 enter -0
__12:
 10123 rstack EDX,EBP:2
 10127 mov EAX,EDX
 10129 rstack EDX,EBP:4
 10133 mov EBX,EDX
 10135 rstack EDX,EBP:3
 10139 mov ECX,EDX
__14:
// if (rem
 10141 cmp 0,EBX
 10144 jz 10158
 10147 mov EDX,EAX
 10149 inc EAX
// *p++=ch
 10151 mov #EDX,ECX
// --rem
 10153 dec EBX
 10155 jmp 10141
__13:
 10158 rstack EDX,EBP:2
 10162 mov EAX,EDX
 10164 leave 
 10165 ret 
__11:
 10166 leave 
 10167 ret 
strcat:
// strcat(src,dest)
 10168 enter -0
__16:
 10171 rstack ECX,EBP:2
// srcptr=src
 10175 mov EAX,ECX
__17:
 10177 inc EAX
 10179 mov ECX,EAX
// if (*++srcptr
 10181 cmp 0,#ECX
 10184 jz 10190
 10187 jmp 10177
__18:
 10190 rstack ECX,EBP:3
// destptr=dest
 10194 mov EBX,ECX
__19:
 10196 mov ECX,EBX
 10198 inc EBX
 10200 mov EDX,EAX
 10202 inc EAX
 10204 mov #EDX,#ECX
 10206 mov ESI,#EDX
// if (*srcptr++=*destptr++
 10208 cmp 0,ESI
 10211 jz 10217
 10214 jmp 10196
__20:
 10217 rstack ECX,EBP:2
 10221 mov EAX,ECX
 10223 leave 
 10224 ret 
__15:
 10225 leave 
 10226 ret 
strncat:
// strncat(src,dest,n)
 10227 enter -0
__22:
 10230 rstack EDX,EBP:2
// srcptr=src
 10234 mov EAX,EDX
// srcptr--
 10236 dec EAX
__23:
 10238 inc EAX
 10240 mov EDX,EAX
// if (*++srcptr
 10242 cmp 0,#EDX
 10245 jz 10251
 10248 jmp 10238
__24:
 10251 rstack EDX,EBP:3
// destptr=dest
 10255 mov EBX,EDX
 10257 rstack EDX,EBP:4
// i=n
 10261 mov ECX,EDX
__26:
 10263 mov EDX,ECX
 10265 dec ECX
// if (i--
 10267 cmp 0,EDX
 10270 jz 10297
__28:
 10273 mov EDX,EBX
 10275 inc EBX
 10277 mov ESI,EAX
 10279 inc EAX
 10281 mov #ESI,#EDX
 10283 mov EDI,#ESI
// if (*srcptr++=*destptr++)
 10285 cmp 0,EDI
 10288 jge 10294
 10291 jmp 10263
__27:
__29:
 10294 jmp 10263
__25:
// *srcptr=0
 10297 mov #EAX,0
 10300 rstack EDX,EBP:2
 10304 mov EAX,EDX
 10306 leave 
 10307 ret 
__21:
 10308 leave 
 10309 ret 
strchr:
// strchr(str,c)
 10310 enter -0
__31:
 10313 rstack ECX,EBP:2
// strptr=str
 10317 mov EAX,ECX
 10319 rstack ECX,EBP:3
// ch=c
 10323 mov EBX,ECX
__33:
// if (*strptr
 10325 cmp 0,#EAX
 10328 jz 10354
__35:
 10331 mov ECX,EBX
 10333 sub ECX,#EAX
 10335 fabs ECX,ECX
 10337 fsgn ECX,ECX
 10339 lneg ECX
// if (*strptr==ch)
 10341 cmp 0,ECX
 10344 jge 10349
 10347 leave 
 10348 ret 
__34:
__36:
// ++strptr
 10349 inc EAX
 10351 jmp 10325
__32:
 10354 mov EAX,0
 10357 leave 
 10358 ret 
__30:
 10359 leave 
 10360 ret 
strrchr:
// strrchr(str,c)
 10361 enter -0
__38:
// findptr=0
 10364 mov ECX,0
 10367 rstack EDX,EBP:2
// strptr=str
 10371 mov EAX,EDX
 10373 rstack EDX,EBP:3
// ch=c
 10377 mov EBX,EDX
__40:
// if (*strptr
 10379 cmp 0,#EAX
 10382 jz 10408
__42:
 10385 mov EDX,EBX
 10387 sub EDX,#EAX
 10389 fabs EDX,EDX
 10391 fsgn EDX,EDX
 10393 lneg EDX
// if (*strptr==ch)
 10395 cmp 0,EDX
 10398 jge 10403
// findptr=strptr
 10401 mov ECX,EAX
__41:
__43:
// ++strptr
 10403 inc EAX
 10405 jmp 10379
__39:
 10408 mov EAX,ECX
 10410 leave 
 10411 ret 
__37:
 10412 leave 
 10413 ret 
strcmp:
// strcmp(src,dest)
 10414 enter -0
__45:
 10417 rstack ECX,EBP:2
// srcptr=src
 10421 mov EAX,ECX
 10423 rstack ECX,EBP:3
// destptr=dest
 10427 mov EBX,ECX
__47:
 10429 mov ECX,#EBX
 10431 sub ECX,#EAX
 10433 fabs ECX,ECX
 10435 fsgn ECX,ECX
 10437 lneg ECX
// if (*srcptr==*destptr
 10439 cmp 0,ECX
 10442 jz 10474
__49:
 10445 mov ECX,0
 10448 sub ECX,#EAX
 10450 fabs ECX,ECX
 10452 fsgn ECX,ECX
 10454 lneg ECX
// if (*srcptr==0)
 10456 cmp 0,ECX
 10459 jge 10467
 10462 mov EAX,0
 10465 leave 
 10466 ret 
__48:
__50:
// ++srcptr
 10467 inc EAX
// ++destptr
 10469 inc EBX
 10471 jmp 10429
__46:
 10474 mov ECX,#EBX
 10476 neg ECX
 10478 mov EDX,#EAX
 10480 add EDX,ECX
 10482 mov EAX,EDX
 10484 leave 
 10485 ret 
__44:
 10486 leave 
 10487 ret 
strncmp:
// strncmp(src,dest,n)
 10488 enter -0
__52:
 10491 rstack EDX,EBP:2
// srcptr=src
 10495 mov EAX,EDX
 10497 rstack EDX,EBP:3
// destptr=dest
 10501 mov EBX,EDX
 10503 rstack EDX,EBP:4
// i=n
 10507 mov ECX,EDX
__54:
 10509 mov EDX,#EBX
 10511 sub EDX,#EAX
 10513 fabs EDX,EDX
 10515 fsgn EDX,EDX
 10517 lneg EDX
 10519 mov ESI,ECX
 10521 and ESI,EDX
// if (i&&(*srcptr==*destptr)
 10523 cmp 0,ESI
 10526 jz 10560
__56:
 10529 mov EDX,0
 10532 sub EDX,#EAX
 10534 fabs EDX,EDX
 10536 fsgn EDX,EDX
 10538 lneg EDX
// if (*srcptr==0)
 10540 cmp 0,EDX
 10543 jge 10551
 10546 mov EAX,0
 10549 leave 
 10550 ret 
__55:
__57:
// ++srcptr
 10551 inc EAX
// ++destptr
 10553 inc EBX
// --i
 10555 dec ECX
 10557 jmp 10509
__53:
__59:
// if (i)
 10560 cmp 0,ECX
 10563 jge 10578
 10566 mov EDX,#EBX
 10568 neg EDX
 10570 mov ESI,#EAX
 10572 add ESI,EDX
 10574 mov EAX,ESI
 10576 leave 
 10577 ret 
__58:
__60:
 10578 mov EAX,0
 10581 leave 
 10582 ret 
__51:
 10583 leave 
 10584 ret 
strcpy:
// strcpy(dest,src)
 10585 enter -0
__62:
 10588 rstack ECX,EBP:2
// destptr=dest
 10592 mov EBX,ECX
 10594 rstack ECX,EBP:3
// srcptr=src
 10598 mov EAX,ECX
__63:
 10600 mov ECX,EAX
 10602 inc EAX
 10604 mov EDX,EBX
 10606 inc EBX
 10608 mov #EDX,#ECX
 10610 mov ESI,#EDX
// if (*destptr++=*srcptr++
 10612 cmp 0,ESI
 10615 jz 10621
 10618 jmp 10600
__64:
 10621 rstack ECX,EBP:2
 10625 mov EAX,ECX
 10627 leave 
 10628 ret 
__61:
 10629 leave 
 10630 ret 
strncpy:
// strncpy(dest,src,n)
 10631 enter -0
__66:
 10634 rstack EDX,EBP:2
// destptr=dest
 10638 mov EBX,EDX
 10640 rstack EDX,EBP:3
// srcptr=src
 10644 mov EAX,EDX
 10646 rstack EDX,EBP:4
// i=n
 10650 mov ECX,EDX
__68:
 10652 mov EDX,ECX
 10654 dec ECX
 10656 mov ESI,0
 10659 sub ESI,EDX
 10661 neg ESI
 10663 fsgn ESI,ESI
 10665 max ESI,0
// if (i-->0
 10668 cmp 0,ESI
 10671 jz 10730
__70:
 10674 mov EDX,EAX
 10676 inc EAX
 10678 mov ESI,EBX
 10680 inc EBX
 10682 mov #ESI,#EDX
 10684 mov EDI,#ESI
// if (*destptr++=*srcptr++)
 10686 cmp 0,EDI
 10689 jge 10695
 10692 jmp 10652
__69:
__71:
__72:
 10695 mov EDX,ECX
 10697 dec ECX
 10699 mov ESI,0
 10702 sub ESI,EDX
 10704 neg ESI
 10706 fsgn ESI,ESI
 10708 max ESI,0
// if (i-->0
 10711 cmp 0,ESI
 10714 jz 10727
 10717 mov EDX,EBX
 10719 inc EBX
// *destptr++=0
 10721 mov #EDX,0
 10724 jmp 10695
__73:
 10727 jmp 10652
__67:
// *destptr=0
 10730 mov #EBX,0
 10733 rstack EDX,EBP:2
 10737 mov EAX,EDX
 10739 leave 
 10740 ret 
__65:
 10741 leave 
 10742 ret 
strlen:
// strlen(str)
 10743 enter -0
__75:
 10746 rstack ECX,EBP:2
// strptr=str
 10750 mov EAX,ECX
// n=0
 10752 mov EBX,0
__76:
 10755 mov ECX,EAX
 10757 inc EAX
// if (*strptr++
 10759 cmp 0,#ECX
 10762 jz 10770
// n++
 10765 inc EBX
 10767 jmp 10755
__77:
 10770 mov EAX,EBX
 10772 leave 
 10773 ret 
__74:
 10774 leave 
 10775 ret 
strspn:
// strspn(str,accept)
 10776 enter -0
__79:
 10779 rstack ECX,EBP:2
 10783 mov EAX,ECX
 10785 rstack ECX,EBP:3
 10789 mov EBX,ECX
__81:
// if (*p
 10791 cmp 0,#EBX
 10794 jz 10828
__83:
 10797 mov ECX,EBX
 10799 inc EBX
 10801 mov EDX,#EAX
 10803 sub EDX,#ECX
 10805 fabs EDX,EDX
 10807 fsgn EDX,EDX
 10809 lneg EDX
// if (*p++==*s)
 10811 cmp 0,EDX
 10814 jge 10825
// ++s
 10817 inc EAX
 10819 rstack ECX,EBP:3
// p=accept
 10823 mov EBX,ECX
__84:
__82:
 10825 jmp 10791
__80:
 10828 rstack ECX,EBP:2
 10832 neg ECX
 10834 mov EDX,ECX
 10836 mov ECX,EAX
 10838 add ECX,EDX
 10840 mov EAX,ECX
 10842 leave 
 10843 ret 
__78:
 10844 leave 
 10845 ret 
strcspn:
// strcspn(str,reject)
 10846 enter -0
__86:
 10849 rstack ECX,EBP:2
// init loop
 10853 mov EAX,ECX
__88:
 10855 cmp 0,#EAX
 10858 jz 10902
 10861 rstack ECX,EBP:3
// init loop
 10865 mov EBX,ECX
__90:
 10867 cmp 0,#EBX
 10870 jz 10897
__92:
 10873 mov ECX,#EAX
 10875 sub ECX,#EBX
 10877 fabs ECX,ECX
 10879 fsgn ECX,ECX
 10881 lneg ECX
// if (*p==*s)
 10883 cmp 0,ECX
 10886 jge 10892
 10889 jmp 10902
__91:
__93:
// loop step
 10892 inc EBX
 10894 jmp 10867
__89:
// loop step
 10897 inc EAX
 10899 jmp 10855
__87:
done:
 10902 rstack ECX,EBP:2
 10906 neg ECX
 10908 mov EDX,ECX
 10910 mov ECX,EAX
 10912 add ECX,EDX
 10914 mov EAX,ECX
 10916 leave 
 10917 ret 
__85:
 10918 leave 
 10919 ret 
strpbrk:
// strpbrk(str,accept)
 10920 enter -0
__95:
 10923 rstack ECX,EBP:2
// init loop
 10927 mov EAX,ECX
__97:
 10929 cmp 0,#EAX
 10932 jz 10975
 10935 rstack ECX,EBP:3
// init loop
 10939 mov EBX,ECX
__99:
 10941 cmp 0,#EBX
 10944 jz 10970
__101:
 10947 mov ECX,#EAX
 10949 sub ECX,#EBX
 10951 fabs ECX,ECX
 10953 fsgn ECX,ECX
 10955 lneg ECX
// if (*p==*s)
 10957 cmp 0,ECX
 10960 jge 10965
 10963 leave 
 10964 ret 
__100:
__102:
// loop step
 10965 inc EBX
 10967 jmp 10941
__98:
// loop step
 10970 inc EAX
 10972 jmp 10929
__96:
 10975 mov EAX,0
 10978 leave 
 10979 ret 
__94:
 10980 leave 
 10981 ret 
strstr:
// strstr(haystack,needle)
 10982 enter -0
__104:
 10985 rstack ECX,EBP:2
 10989 mov EAX,ECX
 10991 rstack ECX,EBP:3
 10995 mov EBX,ECX
__106:
// if (1
 10997 cmp 0,1
 11001 jz 11083
__108:
 11004 mov ECX,#EBX
 11006 lneg ECX
// if (!*p)
 11008 cmp 0,ECX
 11011 jge 11022
 11014 rstack ECX,EBP:2
 11018 mov EAX,ECX
 11020 leave 
 11021 ret 
__109:
__107:
__111:
 11022 mov ECX,#EAX
 11024 sub ECX,#EBX
 11026 fabs ECX,ECX
 11028 fsgn ECX,ECX
 11030 lneg ECX
// if (*p==*s)
 11032 cmp 0,ECX
 11035 jge 11045
// ++p
 11038 inc EBX
// ++s
 11040 inc EAX
 11042 jmp 11080
__113:
__112:
__115:
 11045 rstack ECX,EBP:3
// p=needle
 11049 mov EBX,ECX
__117:
 11051 mov ECX,#EAX
 11053 lneg ECX
// if (!*s)
 11055 cmp 0,ECX
 11058 jge 11066
 11061 mov EAX,0
 11064 leave 
 11065 ret 
__118:
__116:
 11066 rstack ECX,EBP:2
 11070 inc ECX
 11072 mov EDX,ECX
 11074 sstack EBP:2,ECX
// s=++haystack
 11078 mov EAX,EDX
__114:
__110:
 11080 jmp 10997
__105:
__103:
 11083 leave 
 11084 ret 
va_start:
 11085 rstack EAX,ESP:2
 11089 sub EAX,DS
 11091 add EAX,SS
 11093 ret 
va_start_0:
 11094 mov EAX,EBP:1
 11098 ret 
va_next:
 11099 rstack EBX,ESP:2
 11103 inc #EBX
 11105 rstack EAX,#EBX
 11107 ret 
va_get:
 11108 rstack EAX,ESP:2
 11112 rstack EBX,ESP:3
 11116 add EAX,EBX
 11118 inc EAX
 11120 mov EAX,#EAX
 11122 ret 
va_get_0:
 11123 rstack EAX,ESP:2
 11127 add EAX,EBP:2
 11131 rstack EAX,EAX
 11133 ret 
explode:
// explode(str,del)
 11134 enter 7
__120:
 11137 rstack EAX,EBP:2
 11141 sstack EBP:-1,EAX
 11145 rstack EAX,EBP:2
 11149 sstack EBP:-2,EAX
 11153 sstack EBP:-3,0
 11158 sstack EBP:-4,0
 11163 rstack EAX,EBP:3
// strlen arg #1 (char* str)
 11167 push EAX
 11169 mov ECX,1
// strlen(...)
 11172 call 10743
 11175 add ESP,1
 11178 sstack EBP:-5,EAX
 11182 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 11186 push EAX
 11188 mov ECX,1
// strlen(...)
 11191 call 10743
 11194 add ESP,1
 11197 sstack EBP:-6,EAX
 11201 sstack EBP:-7,0
__122:
 11206 rstack EAX,EBP:-7
 11210 lneg EAX
 11212 mov EBX,EAX
// if (!Finish
 11214 cmp 0,EBX
 11217 jz 11378
 11220 rstack EAX,EBP:-4
// Count++
 11224 inc EAX
 11226 sstack EBP:-4,EAX
 11230 rstack EAX,EBP:3
// strstr arg #2 (char* needle)
 11234 push EAX
 11236 rstack EAX,EBP:-1
// strstr arg #1 (char* haystack)
 11240 push EAX
 11242 mov ECX,2
// strstr(...)
 11245 call 10982
 11248 add ESP,2
// End=strstr(Start,del)
 11251 sstack EBP:-2,EAX
__124:
 11255 rstack EAX,EBP:-2
// if (End)
 11259 cmp 0,EAX
 11262 jge 11370
 11265 rstack EAX,EBP:-2
// *End=0
 11269 mov #EAX,0
 11272 rstack EAX,EBP:-1
 11276 rstack EBX,EBP:-3
 11280 mov ECX,16486
 11283 add ECX,EBX
// *(Array+I)=Start
 11285 mov #ECX,EAX
 11287 rstack EAX,EBP:-3
// I++
 11291 inc EAX
 11293 sstack EBP:-3,EAX
 11297 rstack EAX,EBP:-5
 11301 rstack EBX,EBP:-2
 11305 add EBX,EAX
 11307 mov EAX,EBX
// Start=End+lenD
 11309 sstack EBP:-1,EAX
__127:
 11313 rstack EAX,EBP:-1
 11317 rstack EBX,EBP:-6
 11321 rstack ECX,EBP:2
 11325 add ECX,EBX
 11327 mov EBX,ECX
 11329 sub EBX,EAX
 11331 neg EBX
 11333 fsgn EBX,EBX
 11335 max EBX,0
 11338 rstack EAX,EBP:-3
 11342 mov ECX,13
 11345 sub ECX,EAX
 11347 neg ECX
 11349 fsgn ECX,ECX
 11351 max ECX,0
 11354 bor ECX,EBX
// if ((I>13)|(Start>(str+lenS)))
 11356 cmp 0,ECX
 11359 jge 11367
// Finish=1
 11362 sstack EBP:-7,1
__128:
__126:
 11367 jmp 11375
__129:
__125:
__131:
// Finish=1
 11370 sstack EBP:-7,1
__130:
__123:
 11375 jmp 11206
__121:
 11378 rstack EAX,EBP:-1
 11382 rstack EBX,EBP:-3
 11386 add EBX,16486
 11389 mov ECX,EBX
// Array[I]=Start
 11391 mov #ECX,EAX
 11393 rstack EAX,EBP:-3
// I++
 11397 inc EAX
 11399 sstack EBP:-3,EAX
 11403 rstack EAX,EBP:-3
 11407 add EAX,16486
 11410 mov EBX,EAX
// Array[I]=0
 11412 mov #EBX,0
 11415 mov EAX,16486
 11418 leave 
 11419 ret 
__119:
 11420 leave 
 11421 ret 
str2num:
// str2num(str)
 11422 enter 8
__133:
 11425 sstack EBP:-1,0
 11430 sstack EBP:-2,0
 11435 sstack EBP:-3,0
 11440 sstack EBP:-4,0
 11445 sstack EBP:-5,0
 11450 sstack EBP:-6,0
 11455 sstack EBP:-7,10
 11460 rstack EAX,EBP:-2
 11464 rstack EBX,EBP:2
 11468 add EBX,EAX
 11470 mov EAX,EBX
 11472 sstack EBP:-8,#EAX
__135:
 11476 rstack EAX,EBP:-8
 11480 mov EBX,0
 11483 sub EBX,EAX
 11485 fabs EBX,EBX
 11487 fsgn EBX,EBX
 11489 lneg EBX
// if (C==0)
 11491 cmp 0,EBX
 11494 jge 11505
 11497 mov EAX,0
 11500 leave 
 11501 ret 
 11502 jmp 11702
__137:
__136:
__139:
__141:
 11505 rstack EAX,EBP:-8
 11509 mov EBX,45
 11512 sub EBX,EAX
 11514 fabs EBX,EBX
 11516 fsgn EBX,EBX
 11518 lneg EBX
// if (C=='-')
 11520 cmp 0,EBX
 11523 jge 11531
// Minus=1
 11526 sstack EBP:-4,1
__142:
__140:
__144:
 11531 rstack EAX,EBP:-8
 11535 mov EBX,48
 11538 sub EBX,EAX
 11540 fabs EBX,EBX
 11542 fsgn EBX,EBX
 11544 lneg EBX
// if (C=='0')
 11546 cmp 0,EBX
 11549 jge 11702
__147:
 11552 rstack EAX,EBP:-2
 11556 add EAX,1
 11559 mov EBX,EAX
 11561 rstack EAX,EBP:2
 11565 add EAX,EBX
 11567 mov EBX,EAX
 11569 mov EAX,98
 11572 sub EAX,#EBX
 11574 fabs EAX,EAX
 11576 fsgn EAX,EAX
 11578 lneg EAX
// if (str[I+1]=='b')
 11580 cmp 0,EAX
 11583 jge 11602
// Base=2
 11586 sstack EBP:-7,2
 11591 rstack EAX,EBP:-2
// I+=2
 11595 add EAX,2
 11598 sstack EBP:-2,EAX
__148:
__146:
__150:
 11602 rstack EAX,EBP:-2
 11606 add EAX,1
 11609 mov EBX,EAX
 11611 rstack EAX,EBP:2
 11615 add EAX,EBX
 11617 mov EBX,EAX
 11619 mov EAX,111
 11622 sub EAX,#EBX
 11624 fabs EAX,EAX
 11626 fsgn EAX,EAX
 11628 lneg EAX
// if (str[I+1]=='o')
 11630 cmp 0,EAX
 11633 jge 11652
// Base=8
 11636 sstack EBP:-7,8
 11641 rstack EAX,EBP:-2
// I+=2
 11645 add EAX,2
 11648 sstack EBP:-2,EAX
__151:
__149:
__153:
 11652 rstack EAX,EBP:-2
 11656 add EAX,1
 11659 mov EBX,EAX
 11661 rstack EAX,EBP:2
 11665 add EAX,EBX
 11667 mov EBX,EAX
 11669 mov EAX,120
 11672 sub EAX,#EBX
 11674 fabs EAX,EAX
 11676 fsgn EAX,EAX
 11678 lneg EAX
// if (str[I+1]=='x')
 11680 cmp 0,EAX
 11683 jge 11702
// Base=16
 11686 sstack EBP:-7,16
 11691 rstack EAX,EBP:-2
// I+=2
 11695 add EAX,2
 11698 sstack EBP:-2,EAX
__154:
__152:
__145:
__143:
__138:
__134:
__156:
 11702 rstack EAX,EBP:-1
 11706 lneg EAX
 11708 mov EBX,EAX
// if (!End
 11710 cmp 0,EBX
 11713 jz 12249
 11716 rstack EAX,EBP:-2
 11720 mov EBX,EAX
 11722 inc EAX
 11724 sstack EBP:-2,EAX
 11728 rstack EAX,EBP:2
 11732 add EAX,EBX
 11734 mov EBX,EAX
// C=str[I++]
 11736 sstack EBP:-8,#EBX
__158:
 11740 rstack EAX,EBP:-8
 11744 mov EBX,0
 11747 sub EBX,EAX
 11749 fabs EBX,EBX
 11751 fsgn EBX,EBX
 11753 lneg EBX
// if (C==0)
 11755 cmp 0,EBX
 11758 jge 11769
// End=1
 11761 sstack EBP:-1,1
 11766 jmp 12246
__160:
__159:
__162:
__164:
 11769 rstack EAX,EBP:-8
 11773 mov EBX,46
 11776 sub EBX,EAX
 11778 fabs EBX,EBX
 11780 fsgn EBX,EBX
 11782 lneg EBX
// if (C=='.')
 11784 cmp 0,EBX
 11787 jge 11803
// End=1
 11790 sstack EBP:-1,1
// Frac=1
 11795 sstack EBP:-5,1
 11800 jmp 12246
__166:
__165:
__168:
// N=0
 11803 sstack EBP:-6,0
__170:
 11808 rstack EAX,EBP:-8
 11812 mov EBX,48
 11815 sub EBX,EAX
 11817 fabs EBX,EBX
 11819 fsgn EBX,EBX
 11821 lneg EBX
// if (C=='0')
 11823 cmp 0,EBX
 11826 jge 11834
// N=0
 11829 sstack EBP:-6,0
__171:
__169:
__173:
 11834 rstack EAX,EBP:-8
 11838 mov EBX,49
 11841 sub EBX,EAX
 11843 fabs EBX,EBX
 11845 fsgn EBX,EBX
 11847 lneg EBX
// if (C=='1')
 11849 cmp 0,EBX
 11852 jge 11860
// N=1
 11855 sstack EBP:-6,1
__174:
__172:
__176:
 11860 rstack EAX,EBP:-8
 11864 mov EBX,50
 11867 sub EBX,EAX
 11869 fabs EBX,EBX
 11871 fsgn EBX,EBX
 11873 lneg EBX
// if (C=='2')
 11875 cmp 0,EBX
 11878 jge 11886
// N=2
 11881 sstack EBP:-6,2
__177:
__175:
__179:
 11886 rstack EAX,EBP:-8
 11890 mov EBX,51
 11893 sub EBX,EAX
 11895 fabs EBX,EBX
 11897 fsgn EBX,EBX
 11899 lneg EBX
// if (C=='3')
 11901 cmp 0,EBX
 11904 jge 11912
// N=3
 11907 sstack EBP:-6,3
__180:
__178:
__182:
 11912 rstack EAX,EBP:-8
 11916 mov EBX,52
 11919 sub EBX,EAX
 11921 fabs EBX,EBX
 11923 fsgn EBX,EBX
 11925 lneg EBX
// if (C=='4')
 11927 cmp 0,EBX
 11930 jge 11938
// N=4
 11933 sstack EBP:-6,4
__183:
__181:
__185:
 11938 rstack EAX,EBP:-8
 11942 mov EBX,53
 11945 sub EBX,EAX
 11947 fabs EBX,EBX
 11949 fsgn EBX,EBX
 11951 lneg EBX
// if (C=='5')
 11953 cmp 0,EBX
 11956 jge 11964
// N=5
 11959 sstack EBP:-6,5
__186:
__184:
__188:
 11964 rstack EAX,EBP:-8
 11968 mov EBX,54
 11971 sub EBX,EAX
 11973 fabs EBX,EBX
 11975 fsgn EBX,EBX
 11977 lneg EBX
// if (C=='6')
 11979 cmp 0,EBX
 11982 jge 11990
// N=6
 11985 sstack EBP:-6,6
__189:
__187:
__191:
 11990 rstack EAX,EBP:-8
 11994 mov EBX,55
 11997 sub EBX,EAX
 11999 fabs EBX,EBX
 12001 fsgn EBX,EBX
 12003 lneg EBX
// if (C=='7')
 12005 cmp 0,EBX
 12008 jge 12016
// N=7
 12011 sstack EBP:-6,7
__192:
__190:
__194:
 12016 rstack EAX,EBP:-8
 12020 mov EBX,56
 12023 sub EBX,EAX
 12025 fabs EBX,EBX
 12027 fsgn EBX,EBX
 12029 lneg EBX
// if (C=='8')
 12031 cmp 0,EBX
 12034 jge 12042
// N=8
 12037 sstack EBP:-6,8
__195:
__193:
__197:
 12042 rstack EAX,EBP:-8
 12046 mov EBX,57
 12049 sub EBX,EAX
 12051 fabs EBX,EBX
 12053 fsgn EBX,EBX
 12055 lneg EBX
// if (C=='9')
 12057 cmp 0,EBX
 12060 jge 12068
// N=9
 12063 sstack EBP:-6,9
__198:
__196:
__200:
 12068 rstack EAX,EBP:-8
 12072 mov EBX,65
 12075 sub EBX,EAX
 12077 fabs EBX,EBX
 12079 fsgn EBX,EBX
 12081 lneg EBX
// if (C=='A')
 12083 cmp 0,EBX
 12086 jge 12094
// N=10
 12089 sstack EBP:-6,10
__201:
__199:
__203:
 12094 rstack EAX,EBP:-8
 12098 mov EBX,66
 12101 sub EBX,EAX
 12103 fabs EBX,EBX
 12105 fsgn EBX,EBX
 12107 lneg EBX
// if (C=='B')
 12109 cmp 0,EBX
 12112 jge 12120
// N=11
 12115 sstack EBP:-6,11
__204:
__202:
__206:
 12120 rstack EAX,EBP:-8
 12124 mov EBX,67
 12127 sub EBX,EAX
 12129 fabs EBX,EBX
 12131 fsgn EBX,EBX
 12133 lneg EBX
// if (C=='C')
 12135 cmp 0,EBX
 12138 jge 12146
// N=12
 12141 sstack EBP:-6,12
__207:
__205:
__209:
 12146 rstack EAX,EBP:-8
 12150 mov EBX,68
 12153 sub EBX,EAX
 12155 fabs EBX,EBX
 12157 fsgn EBX,EBX
 12159 lneg EBX
// if (C=='D')
 12161 cmp 0,EBX
 12164 jge 12172
// N=13
 12167 sstack EBP:-6,13
__210:
__208:
__212:
 12172 rstack EAX,EBP:-8
 12176 mov EBX,69
 12179 sub EBX,EAX
 12181 fabs EBX,EBX
 12183 fsgn EBX,EBX
 12185 lneg EBX
// if (C=='E')
 12187 cmp 0,EBX
 12190 jge 12198
// N=14
 12193 sstack EBP:-6,14
__213:
__211:
__215:
 12198 rstack EAX,EBP:-8
 12202 mov EBX,70
 12205 sub EBX,EAX
 12207 fabs EBX,EBX
 12209 fsgn EBX,EBX
 12211 lneg EBX
// if (C=='F')
 12213 cmp 0,EBX
 12216 jge 12224
// N=15
 12219 sstack EBP:-6,15
__216:
__214:
 12224 rstack EAX,EBP:-6
 12228 rstack EBX,EBP:-7
 12232 rstack ECX,EBP:-3
 12236 mul ECX,EBX
 12238 mov EBX,ECX
 12240 add EBX,EAX
// Num=Num*Base+N
 12242 sstack EBP:-3,EBX
__167:
__163:
__161:
__157:
 12246 jmp 11702
__155:
__218:
 12249 rstack EAX,EBP:-5
 12253 mov EBX,1
 12256 sub EBX,EAX
 12258 fabs EBX,EBX
 12260 fsgn EBX,EBX
 12262 lneg EBX
// if (Frac==1)
 12264 cmp 0,EBX
 12267 jge 12798
// End=0
 12270 sstack EBP:-1,0
__221:
 12275 rstack EAX,EBP:-1
 12279 lneg EAX
 12281 mov EBX,EAX
// if (!End
 12283 cmp 0,EBX
 12286 jz 12798
 12289 rstack EAX,EBP:-2
 12293 mov EBX,EAX
 12295 inc EAX
 12297 sstack EBP:-2,EAX
 12301 rstack EAX,EBP:2
 12305 add EAX,EBX
 12307 mov EBX,EAX
// C=str[I++]
 12309 sstack EBP:-8,#EBX
__223:
 12313 rstack EAX,EBP:-8
 12317 mov EBX,0
 12320 sub EBX,EAX
 12322 fabs EBX,EBX
 12324 fsgn EBX,EBX
 12326 lneg EBX
// if (C==0)
 12328 cmp 0,EBX
 12331 jge 12342
// End=1
 12334 sstack EBP:-1,1
 12339 jmp 12795
__225:
__224:
__227:
// N=0
 12342 sstack EBP:-6,0
__229:
 12347 rstack EAX,EBP:-8
 12351 mov EBX,48
 12354 sub EBX,EAX
 12356 fabs EBX,EBX
 12358 fsgn EBX,EBX
 12360 lneg EBX
// if (C=='0')
 12362 cmp 0,EBX
 12365 jge 12373
// N=0
 12368 sstack EBP:-6,0
__230:
__228:
__232:
 12373 rstack EAX,EBP:-8
 12377 mov EBX,49
 12380 sub EBX,EAX
 12382 fabs EBX,EBX
 12384 fsgn EBX,EBX
 12386 lneg EBX
// if (C=='1')
 12388 cmp 0,EBX
 12391 jge 12399
// N=1
 12394 sstack EBP:-6,1
__233:
__231:
__235:
 12399 rstack EAX,EBP:-8
 12403 mov EBX,50
 12406 sub EBX,EAX
 12408 fabs EBX,EBX
 12410 fsgn EBX,EBX
 12412 lneg EBX
// if (C=='2')
 12414 cmp 0,EBX
 12417 jge 12425
// N=2
 12420 sstack EBP:-6,2
__236:
__234:
__238:
 12425 rstack EAX,EBP:-8
 12429 mov EBX,51
 12432 sub EBX,EAX
 12434 fabs EBX,EBX
 12436 fsgn EBX,EBX
 12438 lneg EBX
// if (C=='3')
 12440 cmp 0,EBX
 12443 jge 12451
// N=3
 12446 sstack EBP:-6,3
__239:
__237:
__241:
 12451 rstack EAX,EBP:-8
 12455 mov EBX,52
 12458 sub EBX,EAX
 12460 fabs EBX,EBX
 12462 fsgn EBX,EBX
 12464 lneg EBX
// if (C=='4')
 12466 cmp 0,EBX
 12469 jge 12477
// N=4
 12472 sstack EBP:-6,4
__242:
__240:
__244:
 12477 rstack EAX,EBP:-8
 12481 mov EBX,53
 12484 sub EBX,EAX
 12486 fabs EBX,EBX
 12488 fsgn EBX,EBX
 12490 lneg EBX
// if (C=='5')
 12492 cmp 0,EBX
 12495 jge 12503
// N=5
 12498 sstack EBP:-6,5
__245:
__243:
__247:
 12503 rstack EAX,EBP:-8
 12507 mov EBX,54
 12510 sub EBX,EAX
 12512 fabs EBX,EBX
 12514 fsgn EBX,EBX
 12516 lneg EBX
// if (C=='6')
 12518 cmp 0,EBX
 12521 jge 12529
// N=6
 12524 sstack EBP:-6,6
__248:
__246:
__250:
 12529 rstack EAX,EBP:-8
 12533 mov EBX,55
 12536 sub EBX,EAX
 12538 fabs EBX,EBX
 12540 fsgn EBX,EBX
 12542 lneg EBX
// if (C=='7')
 12544 cmp 0,EBX
 12547 jge 12555
// N=7
 12550 sstack EBP:-6,7
__251:
__249:
__253:
 12555 rstack EAX,EBP:-8
 12559 mov EBX,56
 12562 sub EBX,EAX
 12564 fabs EBX,EBX
 12566 fsgn EBX,EBX
 12568 lneg EBX
// if (C=='8')
 12570 cmp 0,EBX
 12573 jge 12581
// N=8
 12576 sstack EBP:-6,8
__254:
__252:
__256:
 12581 rstack EAX,EBP:-8
 12585 mov EBX,57
 12588 sub EBX,EAX
 12590 fabs EBX,EBX
 12592 fsgn EBX,EBX
 12594 lneg EBX
// if (C=='9')
 12596 cmp 0,EBX
 12599 jge 12607
// N=9
 12602 sstack EBP:-6,9
__257:
__255:
__259:
 12607 rstack EAX,EBP:-8
 12611 mov EBX,65
 12614 sub EBX,EAX
 12616 fabs EBX,EBX
 12618 fsgn EBX,EBX
 12620 lneg EBX
// if (C=='A')
 12622 cmp 0,EBX
 12625 jge 12633
// N=10
 12628 sstack EBP:-6,10
__260:
__258:
__262:
 12633 rstack EAX,EBP:-8
 12637 mov EBX,66
 12640 sub EBX,EAX
 12642 fabs EBX,EBX
 12644 fsgn EBX,EBX
 12646 lneg EBX
// if (C=='B')
 12648 cmp 0,EBX
 12651 jge 12659
// N=11
 12654 sstack EBP:-6,11
__263:
__261:
__265:
 12659 rstack EAX,EBP:-8
 12663 mov EBX,67
 12666 sub EBX,EAX
 12668 fabs EBX,EBX
 12670 fsgn EBX,EBX
 12672 lneg EBX
// if (C=='C')
 12674 cmp 0,EBX
 12677 jge 12685
// N=12
 12680 sstack EBP:-6,12
__266:
__264:
__268:
 12685 rstack EAX,EBP:-8
 12689 mov EBX,68
 12692 sub EBX,EAX
 12694 fabs EBX,EBX
 12696 fsgn EBX,EBX
 12698 lneg EBX
// if (C=='D')
 12700 cmp 0,EBX
 12703 jge 12711
// N=13
 12706 sstack EBP:-6,13
__269:
__267:
__271:
 12711 rstack EAX,EBP:-8
 12715 mov EBX,69
 12718 sub EBX,EAX
 12720 fabs EBX,EBX
 12722 fsgn EBX,EBX
 12724 lneg EBX
// if (C=='E')
 12726 cmp 0,EBX
 12729 jge 12737
// N=14
 12732 sstack EBP:-6,14
__272:
__270:
__274:
 12737 rstack EAX,EBP:-8
 12741 mov EBX,70
 12744 sub EBX,EAX
 12746 fabs EBX,EBX
 12748 fsgn EBX,EBX
 12750 lneg EBX
// if (C=='F')
 12752 cmp 0,EBX
 12755 jge 12763
// N=15
 12758 sstack EBP:-6,15
__275:
__273:
 12763 rstack EAX,EBP:-6
 12767 rstack EBX,EBP:-7
 12771 rstack ECX,EBP:-3
 12775 mul ECX,EBX
 12777 mov EBX,ECX
 12779 add EBX,EAX
// Num=Num*Base+N
 12781 sstack EBP:-3,EBX
 12785 rstack EAX,EBP:-5
// Frac++
 12789 inc EAX
 12791 sstack EBP:-5,EAX
__226:
__222:
 12795 jmp 12275
__220:
__219:
__217:
__277:
 12798 rstack EAX,EBP:-5
// if (Frac)
 12802 cmp 0,EAX
 12805 jge 12835
 12808 rstack EAX,EBP:-5
 12812 add EAX,-1
 12815 mov EBX,EAX
 12817 rstack EAX,EBP:-7
 12821 fpwr EAX,EBX
 12823 mov EBX,EAX
 12825 rstack EAX,EBP:-3
// Num/=(Base^^(Frac-1))
 12829 div EAX,EBX
 12831 sstack EBP:-3,EAX
__278:
__276:
__280:
 12835 rstack EAX,EBP:-4
// if (Minus)
 12839 cmp 0,EAX
 12842 jge 12857
 12845 rstack EAX,EBP:-3
 12849 neg EAX
 12851 mov EBX,EAX
// Num=-Num
 12853 sstack EBP:-3,EBX
__281:
__279:
 12857 rstack EAX,EBP:-3
 12861 leave 
 12862 ret 
__132:
 12863 leave 
 12864 ret 
getNdigit:
// getNdigit(num,digit,Base)
 12865 enter -0
__283:
 12868 rstack EBX,EBP:4
 12872 push EBX
 12874 rstack EBX,EBP:2
 12878 push EBX
 12880 mov ECX,2
// Nlog(...)
 12883 call 14455
 12886 add ESP,2
 12889 push EAX
 12891 mov EBX,EAX
 12893 pop EAX
// EAX=Nlog(num,Base)
 12895 mov EAX,EBX
 12897 fint EAX
 12899 inc EAX
 12901 rstack EBX,EBP:3
 12905 sub EAX,EBX
 12907 rstack EBX,EBP:4
 12911 mov EDX,EBX
 12913 fpwr EDX,EAX
 12915 rstack EBX,EBP:2
 12919 mov EAX,EBX
 12921 div EAX,EDX
 12923 fint EAX
 12925 rstack EBX,EBP:4
 12929 mod EAX,EBX
 12931 leave 
 12932 ret 
__282:
 12933 leave 
 12934 ret 
num2strSet:
// num2strSet(base,precision)
 12935 enter -0
__285:
 12938 rstack EAX,EBP:2
// Nbase=base
 12942 mov #16468,EAX
 12945 rstack EAX,EBP:3
// Nprec=precision
 12949 mov #16469,EAX
 12952 out 5,#16468
__284:
 12956 leave 
 12957 ret 
num2str:
// num2str(num)
 12958 enter 10
__287:
 12961 sstack EBP:-1,0
 12966 sstack EBP:-2,0
 12971 rstack EBX,EBP:2
 12975 sstack EBP:-3,EBX
 12979 sstack EBP:-4,10
 12984 sstack EBP:-5,3
// Base=Nbase
 12989 sstack EBP:-4,#16468
 12994 rstack EBX,EBP:-4
 12998 out 1,EBX
// Prec=Nprec
 13001 sstack EBP:-5,#16469
 13006 rstack EBX,EBP:-5
 13010 out 2,EBX
__289:
 13013 rstack EBX,EBP:-3
 13017 mov ECX,0
 13020 sub ECX,EBX
 13022 fsgn ECX,ECX
 13024 max ECX,0
// if (NM<0)
 13027 cmp 0,ECX
 13030 jge 13063
 13033 rstack EBX,EBP:-3
 13037 neg EBX
 13039 mov ECX,EBX
// NM=-NM
 13041 sstack EBP:-3,ECX
 13045 rstack EBX,EBP:-1
 13049 mov ECX,EBX
 13051 inc EBX
 13053 sstack EBP:-1,EBX
 13057 add ECX,16470
// Nstack[NI++]='-'
 13060 mov #ECX,45
__290:
__288:
__292:
 13063 rstack EBX,EBP:-4
 13067 mov ECX,2
 13070 sub ECX,EBX
 13072 fabs ECX,ECX
 13074 fsgn ECX,ECX
 13076 lneg ECX
// if (Base==2)
 13078 cmp 0,ECX
 13081 jge 13120
 13084 rstack EBX,EBP:-1
 13088 mov ECX,EBX
 13090 inc EBX
 13092 sstack EBP:-1,EBX
 13096 add ECX,16470
// Nstack[NI++]='0'
 13099 mov #ECX,48
 13102 rstack EBX,EBP:-1
 13106 mov ECX,EBX
 13108 inc EBX
 13110 sstack EBP:-1,EBX
 13114 add ECX,16470
// Nstack[NI++]='b'
 13117 mov #ECX,98
__293:
__291:
__295:
 13120 rstack EBX,EBP:-4
 13124 mov ECX,8
 13127 sub ECX,EBX
 13129 fabs ECX,ECX
 13131 fsgn ECX,ECX
 13133 lneg ECX
// if (Base==8)
 13135 cmp 0,ECX
 13138 jge 13177
 13141 rstack EBX,EBP:-1
 13145 mov ECX,EBX
 13147 inc EBX
 13149 sstack EBP:-1,EBX
 13153 add ECX,16470
// Nstack[NI++]='0'
 13156 mov #ECX,48
 13159 rstack EBX,EBP:-1
 13163 mov ECX,EBX
 13165 inc EBX
 13167 sstack EBP:-1,EBX
 13171 add ECX,16470
// Nstack[NI++]='o'
 13174 mov #ECX,111
__296:
__294:
__298:
 13177 rstack EBX,EBP:-4
 13181 mov ECX,16
 13184 sub ECX,EBX
 13186 fabs ECX,ECX
 13188 fsgn ECX,ECX
 13190 lneg ECX
// if (Base==16)
 13192 cmp 0,ECX
 13195 jge 13234
 13198 rstack EBX,EBP:-1
 13202 mov ECX,EBX
 13204 inc EBX
 13206 sstack EBP:-1,EBX
 13210 add ECX,16470
// Nstack[NI++]='0'
 13213 mov #ECX,48
 13216 rstack EBX,EBP:-1
 13220 mov ECX,EBX
 13222 inc EBX
 13224 sstack EBP:-1,EBX
 13228 add ECX,16470
// Nstack[NI++]='x'
 13231 mov #ECX,120
__299:
__297:
__301:
 13234 rstack EBX,EBP:-3
 13238 mov ECX,1
 13241 sub ECX,EBX
 13243 fsgn ECX,ECX
 13245 max ECX,0
// if (NM<1)
 13248 cmp 0,ECX
 13251 jge 13272
 13254 rstack EBX,EBP:-1
 13258 mov ECX,EBX
 13260 inc EBX
 13262 sstack EBP:-1,EBX
 13266 add ECX,16470
// Nstack[NI++]='0'
 13269 mov #ECX,48
__302:
__300:
 13272 rstack EBX,EBP:-4
 13276 push EBX
 13278 rstack EBX,EBP:-3
 13282 push EBX
 13284 mov ECX,2
// Nlog(...)
 13287 call 14455
 13290 add ESP,2
 13293 push EAX
 13295 mov EBX,EAX
 13297 pop EAX
// EAX=Nlog(NM,Base)
 13299 mov EAX,EBX
 13301 out 3,EAX
 13304 mov EBX,EAX
 13306 add EBX,1
 13309 sstack EBP:-6,EBX
 13313 sstack EBP:-9,0
// init loop
 13318 sstack EBP:-9,1
__304:
 13323 rstack EBX,EBP:-9
 13327 rstack ECX,EBP:-6
 13331 sub ECX,EBX
 13333 mov EBX,ECX
 13335 fsgn EBX,EBX
 13337 inc EBX
// condition
 13339 max EBX,0
 13342 cmp 0,EBX
 13345 jz 13840
// C='F'
 13348 sstack EBP:-8,70
 13353 rstack EBX,EBP:-4
// getNdigit arg #3 (float Base)
 13357 push EBX
 13359 rstack EBX,EBP:-9
// getNdigit arg #2 (float digit)
 13363 push EBX
 13365 rstack EBX,EBP:-3
// getNdigit arg #1 (float num)
 13369 push EBX
 13371 mov ECX,3
// getNdigit(...)
 13374 call 12865
 13377 add ESP,3
 13380 push EAX
 13382 mov EBX,EAX
 13384 pop EAX
// N=getNdigit(NM,I,Base)
 13386 sstack EBP:-7,EBX
__306:
 13390 rstack EBX,EBP:-7
 13394 mov ECX,0
 13397 sub ECX,EBX
 13399 fabs ECX,ECX
 13401 fsgn ECX,ECX
 13403 lneg ECX
// if (N==0)
 13405 cmp 0,ECX
 13408 jge 13416
// C='0'
 13411 sstack EBP:-8,48
__307:
__305:
__309:
 13416 rstack EBX,EBP:-7
 13420 mov ECX,1
 13423 sub ECX,EBX
 13425 fabs ECX,ECX
 13427 fsgn ECX,ECX
 13429 lneg ECX
// if (N==1)
 13431 cmp 0,ECX
 13434 jge 13442
// C='1'
 13437 sstack EBP:-8,49
__310:
__308:
__312:
 13442 rstack EBX,EBP:-7
 13446 mov ECX,2
 13449 sub ECX,EBX
 13451 fabs ECX,ECX
 13453 fsgn ECX,ECX
 13455 lneg ECX
// if (N==2)
 13457 cmp 0,ECX
 13460 jge 13468
// C='2'
 13463 sstack EBP:-8,50
__313:
__311:
__315:
 13468 rstack EBX,EBP:-7
 13472 mov ECX,3
 13475 sub ECX,EBX
 13477 fabs ECX,ECX
 13479 fsgn ECX,ECX
 13481 lneg ECX
// if (N==3)
 13483 cmp 0,ECX
 13486 jge 13494
// C='3'
 13489 sstack EBP:-8,51
__316:
__314:
__318:
 13494 rstack EBX,EBP:-7
 13498 mov ECX,4
 13501 sub ECX,EBX
 13503 fabs ECX,ECX
 13505 fsgn ECX,ECX
 13507 lneg ECX
// if (N==4)
 13509 cmp 0,ECX
 13512 jge 13520
// C='4'
 13515 sstack EBP:-8,52
__319:
__317:
__321:
 13520 rstack EBX,EBP:-7
 13524 mov ECX,5
 13527 sub ECX,EBX
 13529 fabs ECX,ECX
 13531 fsgn ECX,ECX
 13533 lneg ECX
// if (N==5)
 13535 cmp 0,ECX
 13538 jge 13546
// C='5'
 13541 sstack EBP:-8,53
__322:
__320:
__324:
 13546 rstack EBX,EBP:-7
 13550 mov ECX,6
 13553 sub ECX,EBX
 13555 fabs ECX,ECX
 13557 fsgn ECX,ECX
 13559 lneg ECX
// if (N==6)
 13561 cmp 0,ECX
 13564 jge 13572
// C='6'
 13567 sstack EBP:-8,54
__325:
__323:
__327:
 13572 rstack EBX,EBP:-7
 13576 mov ECX,7
 13579 sub ECX,EBX
 13581 fabs ECX,ECX
 13583 fsgn ECX,ECX
 13585 lneg ECX
// if (N==7)
 13587 cmp 0,ECX
 13590 jge 13598
// C='7'
 13593 sstack EBP:-8,55
__328:
__326:
__330:
 13598 rstack EBX,EBP:-7
 13602 mov ECX,8
 13605 sub ECX,EBX
 13607 fabs ECX,ECX
 13609 fsgn ECX,ECX
 13611 lneg ECX
// if (N==8)
 13613 cmp 0,ECX
 13616 jge 13624
// C='8'
 13619 sstack EBP:-8,56
__331:
__329:
__333:
 13624 rstack EBX,EBP:-7
 13628 mov ECX,9
 13631 sub ECX,EBX
 13633 fabs ECX,ECX
 13635 fsgn ECX,ECX
 13637 lneg ECX
// if (N==9)
 13639 cmp 0,ECX
 13642 jge 13650
// C='9'
 13645 sstack EBP:-8,57
__334:
__332:
__336:
 13650 rstack EBX,EBP:-7
 13654 mov ECX,10
 13657 sub ECX,EBX
 13659 fabs ECX,ECX
 13661 fsgn ECX,ECX
 13663 lneg ECX
// if (N==10)
 13665 cmp 0,ECX
 13668 jge 13676
// C='A'
 13671 sstack EBP:-8,65
__337:
__335:
__339:
 13676 rstack EBX,EBP:-7
 13680 mov ECX,11
 13683 sub ECX,EBX
 13685 fabs ECX,ECX
 13687 fsgn ECX,ECX
 13689 lneg ECX
// if (N==11)
 13691 cmp 0,ECX
 13694 jge 13702
// C='B'
 13697 sstack EBP:-8,66
__340:
__338:
__342:
 13702 rstack EBX,EBP:-7
 13706 mov ECX,12
 13709 sub ECX,EBX
 13711 fabs ECX,ECX
 13713 fsgn ECX,ECX
 13715 lneg ECX
// if (N==12)
 13717 cmp 0,ECX
 13720 jge 13728
// C='C'
 13723 sstack EBP:-8,67
__343:
__341:
__345:
 13728 rstack EBX,EBP:-7
 13732 mov ECX,13
 13735 sub ECX,EBX
 13737 fabs ECX,ECX
 13739 fsgn ECX,ECX
 13741 lneg ECX
// if (N==13)
 13743 cmp 0,ECX
 13746 jge 13754
// C='D'
 13749 sstack EBP:-8,68
__346:
__344:
__348:
 13754 rstack EBX,EBP:-7
 13758 mov ECX,14
 13761 sub ECX,EBX
 13763 fabs ECX,ECX
 13765 fsgn ECX,ECX
 13767 lneg ECX
// if (N==14)
 13769 cmp 0,ECX
 13772 jge 13780
// C='E'
 13775 sstack EBP:-8,69
__349:
__347:
__351:
 13780 rstack EBX,EBP:-7
 13784 mov ECX,15
 13787 sub ECX,EBX
 13789 fabs ECX,ECX
 13791 fsgn ECX,ECX
 13793 lneg ECX
// if (N==15)
 13795 cmp 0,ECX
 13798 jge 13806
// C='F'
 13801 sstack EBP:-8,70
__352:
__350:
 13806 rstack EBX,EBP:-8
 13810 rstack ECX,EBP:-1
 13814 mov EDX,ECX
 13816 inc ECX
 13818 sstack EBP:-1,ECX
 13822 add EDX,16470
// Nstack[NI++]=C
 13825 mov #EDX,EBX
 13827 rstack EBX,EBP:-9
// loop step
 13831 inc EBX
 13833 sstack EBP:-9,EBX
 13837 jmp 13323
__303:
 13840 rstack EBX,EBP:-3
 13844 mov EAX,EBX
 13846 ffrac EAX
__354:
 13848 rstack EBX,EBP:-5
 13852 mov ECX,0
 13855 sub ECX,EBX
 13857 neg ECX
 13859 fsgn ECX,ECX
 13861 max ECX,0
 13864 mov EBX,0
 13867 sub EBX,EAX
 13869 neg EBX
 13871 fsgn EBX,EBX
 13873 max EBX,0
 13876 and EBX,ECX
// if ((EAX>0)&&(Prec>0))
 13878 cmp 0,EBX
 13881 jge 14436
 13884 sstack EBP:-10,0
 13889 rstack EBX,EBP:-1
 13893 mov ECX,EBX
 13895 inc EBX
 13897 sstack EBP:-1,EBX
 13901 add ECX,16470
// Nstack[NI++]='.'
 13904 mov #ECX,46
 13907 rstack EBX,EBP:-9
// init loop
 13911 sstack EBP:-10,EBX
__357:
 13915 rstack EBX,EBP:-10
 13919 rstack ECX,EBP:-5
 13923 rstack EDX,EBP:-9
 13927 add EDX,ECX
 13929 mov ECX,EDX
 13931 sub ECX,EBX
 13933 fsgn ECX,ECX
// condition
 13935 max ECX,0
 13938 cmp 0,ECX
 13941 jz 14436
// C='F'
 13944 sstack EBP:-8,70
 13949 rstack EBX,EBP:-4
// getNdigit arg #3 (float Base)
 13953 push EBX
 13955 rstack EBX,EBP:-10
// getNdigit arg #2 (float digit)
 13959 push EBX
 13961 rstack EBX,EBP:-3
// getNdigit arg #1 (float num)
 13965 push EBX
 13967 mov ECX,3
// getNdigit(...)
 13970 call 12865
 13973 add ESP,3
 13976 push EAX
 13978 mov EBX,EAX
 13980 pop EAX
// N=getNdigit(NM,K,Base)
 13982 sstack EBP:-7,EBX
__359:
 13986 rstack EBX,EBP:-7
 13990 mov ECX,0
 13993 sub ECX,EBX
 13995 fabs ECX,ECX
 13997 fsgn ECX,ECX
 13999 lneg ECX
// if (N==0)
 14001 cmp 0,ECX
 14004 jge 14012
// C='0'
 14007 sstack EBP:-8,48
__360:
__358:
__362:
 14012 rstack EBX,EBP:-7
 14016 mov ECX,1
 14019 sub ECX,EBX
 14021 fabs ECX,ECX
 14023 fsgn ECX,ECX
 14025 lneg ECX
// if (N==1)
 14027 cmp 0,ECX
 14030 jge 14038
// C='1'
 14033 sstack EBP:-8,49
__363:
__361:
__365:
 14038 rstack EBX,EBP:-7
 14042 mov ECX,2
 14045 sub ECX,EBX
 14047 fabs ECX,ECX
 14049 fsgn ECX,ECX
 14051 lneg ECX
// if (N==2)
 14053 cmp 0,ECX
 14056 jge 14064
// C='2'
 14059 sstack EBP:-8,50
__366:
__364:
__368:
 14064 rstack EBX,EBP:-7
 14068 mov ECX,3
 14071 sub ECX,EBX
 14073 fabs ECX,ECX
 14075 fsgn ECX,ECX
 14077 lneg ECX
// if (N==3)
 14079 cmp 0,ECX
 14082 jge 14090
// C='3'
 14085 sstack EBP:-8,51
__369:
__367:
__371:
 14090 rstack EBX,EBP:-7
 14094 mov ECX,4
 14097 sub ECX,EBX
 14099 fabs ECX,ECX
 14101 fsgn ECX,ECX
 14103 lneg ECX
// if (N==4)
 14105 cmp 0,ECX
 14108 jge 14116
// C='4'
 14111 sstack EBP:-8,52
__372:
__370:
__374:
 14116 rstack EBX,EBP:-7
 14120 mov ECX,5
 14123 sub ECX,EBX
 14125 fabs ECX,ECX
 14127 fsgn ECX,ECX
 14129 lneg ECX
// if (N==5)
 14131 cmp 0,ECX
 14134 jge 14142
// C='5'
 14137 sstack EBP:-8,53
__375:
__373:
__377:
 14142 rstack EBX,EBP:-7
 14146 mov ECX,6
 14149 sub ECX,EBX
 14151 fabs ECX,ECX
 14153 fsgn ECX,ECX
 14155 lneg ECX
// if (N==6)
 14157 cmp 0,ECX
 14160 jge 14168
// C='6'
 14163 sstack EBP:-8,54
__378:
__376:
__380:
 14168 rstack EBX,EBP:-7
 14172 mov ECX,7
 14175 sub ECX,EBX
 14177 fabs ECX,ECX
 14179 fsgn ECX,ECX
 14181 lneg ECX
// if (N==7)
 14183 cmp 0,ECX
 14186 jge 14194
// C='7'
 14189 sstack EBP:-8,55
__381:
__379:
__383:
 14194 rstack EBX,EBP:-7
 14198 mov ECX,8
 14201 sub ECX,EBX
 14203 fabs ECX,ECX
 14205 fsgn ECX,ECX
 14207 lneg ECX
// if (N==8)
 14209 cmp 0,ECX
 14212 jge 14220
// C='8'
 14215 sstack EBP:-8,56
__384:
__382:
__386:
 14220 rstack EBX,EBP:-7
 14224 mov ECX,9
 14227 sub ECX,EBX
 14229 fabs ECX,ECX
 14231 fsgn ECX,ECX
 14233 lneg ECX
// if (N==9)
 14235 cmp 0,ECX
 14238 jge 14246
// C='9'
 14241 sstack EBP:-8,57
__387:
__385:
__389:
 14246 rstack EBX,EBP:-7
 14250 mov ECX,10
 14253 sub ECX,EBX
 14255 fabs ECX,ECX
 14257 fsgn ECX,ECX
 14259 lneg ECX
// if (N==10)
 14261 cmp 0,ECX
 14264 jge 14272
// C='A'
 14267 sstack EBP:-8,65
__390:
__388:
__392:
 14272 rstack EBX,EBP:-7
 14276 mov ECX,11
 14279 sub ECX,EBX
 14281 fabs ECX,ECX
 14283 fsgn ECX,ECX
 14285 lneg ECX
// if (N==11)
 14287 cmp 0,ECX
 14290 jge 14298
// C='B'
 14293 sstack EBP:-8,66
__393:
__391:
__395:
 14298 rstack EBX,EBP:-7
 14302 mov ECX,12
 14305 sub ECX,EBX
 14307 fabs ECX,ECX
 14309 fsgn ECX,ECX
 14311 lneg ECX
// if (N==12)
 14313 cmp 0,ECX
 14316 jge 14324
// C='C'
 14319 sstack EBP:-8,67
__396:
__394:
__398:
 14324 rstack EBX,EBP:-7
 14328 mov ECX,13
 14331 sub ECX,EBX
 14333 fabs ECX,ECX
 14335 fsgn ECX,ECX
 14337 lneg ECX
// if (N==13)
 14339 cmp 0,ECX
 14342 jge 14350
// C='D'
 14345 sstack EBP:-8,68
__399:
__397:
__401:
 14350 rstack EBX,EBP:-7
 14354 mov ECX,14
 14357 sub ECX,EBX
 14359 fabs ECX,ECX
 14361 fsgn ECX,ECX
 14363 lneg ECX
// if (N==14)
 14365 cmp 0,ECX
 14368 jge 14376
// C='E'
 14371 sstack EBP:-8,69
__402:
__400:
__404:
 14376 rstack EBX,EBP:-7
 14380 mov ECX,15
 14383 sub ECX,EBX
 14385 fabs ECX,ECX
 14387 fsgn ECX,ECX
 14389 lneg ECX
// if (N==15)
 14391 cmp 0,ECX
 14394 jge 14402
// C='F'
 14397 sstack EBP:-8,70
__405:
__403:
 14402 rstack EBX,EBP:-8
 14406 rstack ECX,EBP:-1
 14410 mov EDX,ECX
 14412 inc ECX
 14414 sstack EBP:-1,ECX
 14418 add EDX,16470
// Nstack[NI++]=C
 14421 mov #EDX,EBX
 14423 rstack EBX,EBP:-10
// loop step
 14427 inc EBX
 14429 sstack EBP:-10,EBX
 14433 jmp 13915
__356:
__355:
__353:
 14436 rstack EBX,EBP:-1
 14440 add EBX,16470
 14443 mov ECX,EBX
// Nstack[NI]=0
 14445 mov #ECX,0
 14448 mov EAX,16470
 14451 leave 
 14452 ret 
__286:
 14453 leave 
 14454 ret 
Nlog:
// Nlog(A,B)
 14455 enter -0
__407:
 14458 rstack ESI,EBP:2
 14462 mov EAX,ESI
 14464 rstack ESI,EBP:3
 14468 mov EBX,ESI
 14470 fln EDX,EAX
 14472 fln ECX,EBX
 14474 div EDX,ECX
 14476 mov EAX,EDX
 14478 leave 
 14479 ret 
__406:
 14480 leave 
 14481 ret 
isPrint:
// isPrint(C)
 14482 enter -0
__409:
 14485 rstack EAX,EBP:2
 14489 mov EBX,127
 14492 sub EBX,EAX
 14494 fsgn EBX,EBX
 14496 max EBX,0
 14499 rstack EAX,EBP:2
 14503 sub EAX,31
 14506 mov ECX,EAX
 14508 fsgn ECX,ECX
 14510 max ECX,0
 14513 and ECX,EBX
 14515 mov EAX,ECX
 14517 leave 
 14518 ret 
__408:
 14519 leave 
 14520 ret 
isNum:
// isNum(C)
 14521 enter -0
__411:
 14524 rstack EAX,EBP:2
 14528 mov EBX,58
 14531 sub EBX,EAX
 14533 fsgn EBX,EBX
 14535 max EBX,0
 14538 rstack EAX,EBP:2
 14542 sub EAX,47
 14545 mov ECX,EAX
 14547 fsgn ECX,ECX
 14549 max ECX,0
 14552 and ECX,EBX
 14554 mov EAX,ECX
 14556 leave 
 14557 ret 
__410:
 14558 leave 
 14559 ret 
isAlpha:
// isAlpha(C)
 14560 enter -0
__413:
 14563 rstack EAX,EBP:2
 14567 mov EBX,123
 14570 sub EBX,EAX
 14572 fsgn EBX,EBX
 14574 max EBX,0
 14577 rstack EAX,EBP:2
 14581 sub EAX,96
 14584 mov ECX,EAX
 14586 fsgn ECX,ECX
 14588 max ECX,0
 14591 and ECX,EBX
 14593 rstack EAX,EBP:2
 14597 mov EBX,91
 14600 sub EBX,EAX
 14602 fsgn EBX,EBX
 14604 max EBX,0
 14607 rstack EAX,EBP:2
 14611 sub EAX,64
 14614 mov EDX,EAX
 14616 fsgn EDX,EDX
 14618 max EDX,0
 14621 and EDX,EBX
 14623 or EDX,ECX
 14625 mov EAX,EDX
 14627 leave 
 14628 ret 
__412:
 14629 leave 
 14630 ret 
toLower:
// toLower(C)
 14631 enter -0
__415:
__417:
 14634 rstack EAX,EBP:2
 14638 mov EBX,91
 14641 sub EBX,EAX
 14643 fsgn EBX,EBX
 14645 max EBX,0
 14648 rstack EAX,EBP:2
 14652 sub EAX,64
 14655 mov ECX,EAX
 14657 fsgn ECX,ECX
 14659 max ECX,0
 14662 and ECX,EBX
// if ((64<C)&&(C<91))
 14664 cmp 0,ECX
 14667 jge 14686
 14670 rstack EAX,EBP:2
 14674 add EAX,32
 14677 mov EBX,EAX
 14679 mov EAX,EBX
 14681 leave 
 14682 ret 
 14683 jmp 14692
__419:
__418:
__421:
 14686 rstack EAX,EBP:2
 14690 leave 
 14691 ret 
__420:
__416:
__414:
 14692 leave 
 14693 ret 
toUpper:
// toUpper(C)
 14694 enter -0
__423:
__425:
 14697 rstack EAX,EBP:2
 14701 mov EBX,123
 14704 sub EBX,EAX
 14706 fsgn EBX,EBX
 14708 max EBX,0
 14711 rstack EAX,EBP:2
 14715 sub EAX,96
 14718 mov ECX,EAX
 14720 fsgn ECX,ECX
 14722 max ECX,0
 14725 and ECX,EBX
// if ((96<C)&&(C<123))
 14727 cmp 0,ECX
 14730 jge 14749
 14733 rstack EAX,EBP:2
 14737 add EAX,-32
 14740 mov EBX,EAX
 14742 mov EAX,EBX
 14744 leave 
 14745 ret 
 14746 jmp 14755
__427:
__426:
__429:
 14749 rstack EAX,EBP:2
 14753 leave 
 14754 ret 
__428:
__424:
__422:
 14755 leave 
 14756 ret 
Con:
// Con(str1,str2,str3,str4,str5)
 14757 enter 3
__431:
 14760 sstack EBP:-1,0
 14765 sstack EBP:-2,0
 14770 rstack EAX,EBP:-1
 14774 mov EBX,EAX
 14776 inc EAX
 14778 sstack EBP:-1,EAX
 14782 rstack EAX,EBP:2
 14786 add EAX,EBX
 14788 mov EBX,EAX
 14790 sstack EBP:-3,#EBX
__433:
 14794 rstack EAX,EBP:-2
 14798 mov EBX,256
 14801 sub EBX,EAX
 14803 fsgn EBX,EBX
 14805 max EBX,0
 14808 rstack EAX,EBP:-3
 14812 mov ECX,0
 14815 sub ECX,EAX
 14817 neg ECX
 14819 fsgn ECX,ECX
 14821 max ECX,0
 14824 band ECX,EBX
// if ((C>0)&(I2<256)
 14826 cmp 0,ECX
 14829 jz 14880
 14832 rstack EAX,EBP:-3
 14836 rstack EBX,EBP:-2
 14840 mov ECX,EBX
 14842 inc EBX
 14844 sstack EBP:-2,EBX
 14848 add ECX,16212
// Constr[I2++]=C
 14851 mov #ECX,EAX
 14853 rstack EAX,EBP:-1
 14857 mov EBX,EAX
 14859 inc EAX
 14861 sstack EBP:-1,EAX
 14865 rstack EAX,EBP:2
 14869 add EAX,EBX
 14871 mov EBX,EAX
// C=str1[I++]
 14873 sstack EBP:-3,#EBX
 14877 jmp 14794
__432:
// I=0
 14880 sstack EBP:-1,0
 14885 rstack EAX,EBP:-1
 14889 mov EBX,EAX
 14891 inc EAX
 14893 sstack EBP:-1,EAX
 14897 rstack EAX,EBP:3
 14901 add EAX,EBX
 14903 mov EBX,EAX
// C=str2[I++]
 14905 sstack EBP:-3,#EBX
__435:
 14909 rstack EAX,EBP:-2
 14913 mov EBX,256
 14916 sub EBX,EAX
 14918 fsgn EBX,EBX
 14920 max EBX,0
 14923 rstack EAX,EBP:-3
 14927 mov ECX,0
 14930 sub ECX,EAX
 14932 neg ECX
 14934 fsgn ECX,ECX
 14936 max ECX,0
 14939 band ECX,EBX
// if ((C>0)&(I2<256)
 14941 cmp 0,ECX
 14944 jz 14995
 14947 rstack EAX,EBP:-3
 14951 rstack EBX,EBP:-2
 14955 mov ECX,EBX
 14957 inc EBX
 14959 sstack EBP:-2,EBX
 14963 add ECX,16212
// Constr[I2++]=C
 14966 mov #ECX,EAX
 14968 rstack EAX,EBP:-1
 14972 mov EBX,EAX
 14974 inc EAX
 14976 sstack EBP:-1,EAX
 14980 rstack EAX,EBP:3
 14984 add EAX,EBX
 14986 mov EBX,EAX
// C=str2[I++]
 14988 sstack EBP:-3,#EBX
 14992 jmp 14909
__434:
// I=0
 14995 sstack EBP:-1,0
 15000 rstack EAX,EBP:-1
 15004 mov EBX,EAX
 15006 inc EAX
 15008 sstack EBP:-1,EAX
 15012 rstack EAX,EBP:4
 15016 add EAX,EBX
 15018 mov EBX,EAX
// C=str3[I++]
 15020 sstack EBP:-3,#EBX
__437:
 15024 rstack EAX,EBP:-2
 15028 mov EBX,256
 15031 sub EBX,EAX
 15033 fsgn EBX,EBX
 15035 max EBX,0
 15038 rstack EAX,EBP:-3
 15042 mov ECX,0
 15045 sub ECX,EAX
 15047 neg ECX
 15049 fsgn ECX,ECX
 15051 max ECX,0
 15054 band ECX,EBX
// if ((C>0)&(I2<256)
 15056 cmp 0,ECX
 15059 jz 15110
 15062 rstack EAX,EBP:-3
 15066 rstack EBX,EBP:-2
 15070 mov ECX,EBX
 15072 inc EBX
 15074 sstack EBP:-2,EBX
 15078 add ECX,16212
// Constr[I2++]=C
 15081 mov #ECX,EAX
 15083 rstack EAX,EBP:-1
 15087 mov EBX,EAX
 15089 inc EAX
 15091 sstack EBP:-1,EAX
 15095 rstack EAX,EBP:4
 15099 add EAX,EBX
 15101 mov EBX,EAX
// C=str3[I++]
 15103 sstack EBP:-3,#EBX
 15107 jmp 15024
__436:
// I=0
 15110 sstack EBP:-1,0
 15115 rstack EAX,EBP:-1
 15119 mov EBX,EAX
 15121 inc EAX
 15123 sstack EBP:-1,EAX
 15127 rstack EAX,EBP:5
 15131 add EAX,EBX
 15133 mov EBX,EAX
// C=str4[I++]
 15135 sstack EBP:-3,#EBX
__439:
 15139 rstack EAX,EBP:-2
 15143 mov EBX,256
 15146 sub EBX,EAX
 15148 fsgn EBX,EBX
 15150 max EBX,0
 15153 rstack EAX,EBP:-3
 15157 mov ECX,0
 15160 sub ECX,EAX
 15162 neg ECX
 15164 fsgn ECX,ECX
 15166 max ECX,0
 15169 band ECX,EBX
// if ((C>0)&(I2<256)
 15171 cmp 0,ECX
 15174 jz 15225
 15177 rstack EAX,EBP:-3
 15181 rstack EBX,EBP:-2
 15185 mov ECX,EBX
 15187 inc EBX
 15189 sstack EBP:-2,EBX
 15193 add ECX,16212
// Constr[I2++]=C
 15196 mov #ECX,EAX
 15198 rstack EAX,EBP:-1
 15202 mov EBX,EAX
 15204 inc EAX
 15206 sstack EBP:-1,EAX
 15210 rstack EAX,EBP:5
 15214 add EAX,EBX
 15216 mov EBX,EAX
// C=str4[I++]
 15218 sstack EBP:-3,#EBX
 15222 jmp 15139
__438:
// I=0
 15225 sstack EBP:-1,0
 15230 rstack EAX,EBP:-1
 15234 mov EBX,EAX
 15236 inc EAX
 15238 sstack EBP:-1,EAX
 15242 rstack EAX,EBP:6
 15246 add EAX,EBX
 15248 mov EBX,EAX
// C=str5[I++]
 15250 sstack EBP:-3,#EBX
__441:
 15254 rstack EAX,EBP:-2
 15258 mov EBX,256
 15261 sub EBX,EAX
 15263 fsgn EBX,EBX
 15265 max EBX,0
 15268 rstack EAX,EBP:-3
 15272 mov ECX,0
 15275 sub ECX,EAX
 15277 neg ECX
 15279 fsgn ECX,ECX
 15281 max ECX,0
 15284 band ECX,EBX
// if ((C>0)&(I2<256)
 15286 cmp 0,ECX
 15289 jz 15340
 15292 rstack EAX,EBP:-3
 15296 rstack EBX,EBP:-2
 15300 mov ECX,EBX
 15302 inc EBX
 15304 sstack EBP:-2,EBX
 15308 add ECX,16212
// Constr[I2++]=C
 15311 mov #ECX,EAX
 15313 rstack EAX,EBP:-1
 15317 mov EBX,EAX
 15319 inc EAX
 15321 sstack EBP:-1,EAX
 15325 rstack EAX,EBP:6
 15329 add EAX,EBX
 15331 mov EBX,EAX
// C=str5[I++]
 15333 sstack EBP:-3,#EBX
 15337 jmp 15254
__440:
 15340 rstack EAX,EBP:-2
 15344 add EAX,16212
 15347 mov EBX,EAX
// Constr[I2]=0
 15349 mov #EBX,0
 15352 mov EAX,16212
 15355 leave 
 15356 ret 
__430:
 15357 leave 
 15358 ret 
concat:
// concat()
 15359 enter 9
__443:
 15362 sstack EBP:-1,ECX
 15366 sstack EBP:-2,0
 15371 mov ECX,0
// va_start_0(...)
 15374 call 11094
 15377 sstack EBP:-3,EAX
 15381 sstack EBP:-4,0
__445:
 15386 rstack EAX,EBP:-2
 15390 rstack EBX,EBP:-1
 15394 sub EBX,EAX
 15396 mov EAX,EBX
 15398 fsgn EAX,EAX
 15400 max EAX,0
// if (I<n
 15403 cmp 0,EAX
 15406 jz 15519
 15409 mov EAX,SS:ESP
 15412 add EAX,-3
 15415 push EAX
 15417 mov ECX,1
// va_next(...)
 15420 call 11099
 15423 add ESP,1
 15426 sstack EBP:-5,EAX
 15430 sstack EBP:-6,0
 15435 rstack EAX,EBP:-6
 15439 mov EBX,EAX
 15441 inc EAX
 15443 sstack EBP:-6,EAX
 15447 rstack EAX,EBP:-5
 15451 add EAX,EBX
 15453 mov EBX,EAX
 15455 sstack EBP:-7,#EBX
__447:
 15459 rstack EAX,EBP:-7
// if (C
 15463 cmp 0,EAX
 15466 jz 15506
 15469 rstack EAX,EBP:-4
// len++
 15473 inc EAX
 15475 sstack EBP:-4,EAX
 15479 rstack EAX,EBP:-6
 15483 mov EBX,EAX
 15485 inc EAX
 15487 sstack EBP:-6,EAX
 15491 rstack EAX,EBP:-5
 15495 add EAX,EBX
 15497 mov EBX,EAX
// C=str[J++]
 15499 sstack EBP:-7,#EBX
 15503 jmp 15459
__446:
 15506 rstack EAX,EBP:-2
// I++
 15510 inc EAX
 15512 sstack EBP:-2,EAX
 15516 jmp 15386
__444:
 15519 rstack EAX,EBP:-4
 15523 add EAX,1
 15526 mov EBX,EAX
 15528 push EBX
 15530 mov ECX,1
// stack_alloc(...)
 15533 call 61596
 15536 add ESP,1
 15539 sstack EBP:-8,EAX
// I=0
 15543 sstack EBP:-2,0
 15548 mov ECX,0
// va_start_0(...)
 15551 call 11094
// va=va_start_0()
 15554 sstack EBP:-3,EAX
 15558 sstack EBP:-9,0
__449:
 15563 rstack EAX,EBP:-2
 15567 rstack EBX,EBP:-1
 15571 sub EBX,EAX
 15573 mov EAX,EBX
 15575 fsgn EAX,EAX
 15577 max EAX,0
// if (I<n
 15580 cmp 0,EAX
 15583 jz 15712
 15586 mov EAX,SS:ESP
 15589 add EAX,-3
 15592 push EAX
 15594 mov ECX,1
// va_next(...)
 15597 call 11099
 15600 add ESP,1
// str=va_next(&va)
 15603 sstack EBP:-5,EAX
// J=0
 15607 sstack EBP:-6,0
 15612 rstack EAX,EBP:-6
 15616 mov EBX,EAX
 15618 inc EAX
 15620 sstack EBP:-6,EAX
 15624 rstack EAX,EBP:-5
 15628 add EAX,EBX
 15630 mov EBX,EAX
// C=str[J++]
 15632 sstack EBP:-7,#EBX
__451:
 15636 rstack EAX,EBP:-7
// if (C
 15640 cmp 0,EAX
 15643 jz 15699
 15646 rstack EAX,EBP:-7
 15650 rstack EBX,EBP:-9
 15654 mov ECX,EBX
 15656 inc EBX
 15658 sstack EBP:-9,EBX
 15662 rstack EBX,EBP:-8
 15666 add EBX,ECX
 15668 mov ECX,EBX
// newstr[J2++]=C
 15670 mov #ECX,EAX
 15672 rstack EAX,EBP:-6
 15676 mov EBX,EAX
 15678 inc EAX
 15680 sstack EBP:-6,EAX
 15684 rstack EAX,EBP:-5
 15688 add EAX,EBX
 15690 mov EBX,EAX
// C=str[J++]
 15692 sstack EBP:-7,#EBX
 15696 jmp 15636
__450:
 15699 rstack EAX,EBP:-2
// I++
 15703 inc EAX
 15705 sstack EBP:-2,EAX
 15709 jmp 15563
__448:
 15712 rstack EAX,EBP:-9
 15716 rstack EBX,EBP:-8
 15720 add EBX,EAX
 15722 mov EAX,EBX
// newstr[J2]=0
 15724 mov #EAX,0
 15727 rstack EAX,EBP:-1
 15731 push EAX
 15733 rstack EAX,EBP:-4
 15737 add EAX,1
 15740 mov EBX,EAX
 15742 push EBX
 15744 rstack EAX,EBP:-8
 15748 push EAX
 15750 mov ECX,3
// stack_return(...)
 15753 call 61637
 15756 add ESP,3
 15759 leave 
 15760 ret 
__442:
 15761 leave 
 15762 ret 
c2str:
// c2str(C)
 15763 enter -0
__453:
__455:
 15766 rstack EAX,EBP:2
 15770 mov EBX,10
 15773 sub EBX,EAX
 15775 fabs EBX,EBX
 15777 fsgn EBX,EBX
 15779 lneg EBX
// if (C=='\10')
 15781 cmp 0,EBX
 15784 jge 15805
 15787 push 1
 15790 push 3
 15793 push 16206
 15796 mov ECX,3
// stack_return(...)
 15799 call 61637
 15802 add ESP,3
__456:
__454:
__458:
 15805 rstack EAX,EBP:2
 15809 mov EBX,0
 15812 sub EBX,EAX
 15814 fabs EBX,EBX
 15816 fsgn EBX,EBX
 15818 lneg EBX
// if (C==0)
 15820 cmp 0,EBX
 15823 jge 15844
 15826 push 1
 15829 push 3
 15832 push 16208
 15835 mov ECX,3
// stack_return(...)
 15838 call 61637
 15841 add ESP,3
__459:
__457:
 15844 rstack EAX,EBP:2
 15848 mov EBX,0
 15851 add EBX,16210
// c2str_str[0]=C
 15854 mov #EBX,EAX
 15856 mov EAX,1
 15859 add EAX,16210
// c2str_str[1]=0
 15862 mov #EAX,0
 15865 push 1
 15868 push 2
 15871 push 16210
 15874 mov ECX,3
// stack_return(...)
 15877 call 61637
 15880 add ESP,3
__452:
 15883 leave 
 15884 ret 
str_find_first_of:
// str_find_first_of(S,C)
 15885 enter 2
__461:
 15888 sstack EBP:-1,0
 15893 rstack EAX,EBP:-1
 15897 rstack EBX,EBP:2
 15901 add EBX,EAX
 15903 mov EAX,EBX
 15905 sstack EBP:-2,#EAX
__463:
 15909 rstack EAX,EBP:-2
 15913 mov EBX,0
 15916 sub EBX,EAX
 15918 fabs EBX,EBX
 15920 fsgn EBX,EBX
// if (C1!=0
 15922 cmp 0,EBX
 15925 jz 15987
__465:
 15928 rstack EAX,EBP:-2
 15932 rstack EBX,EBP:3
 15936 sub EBX,EAX
 15938 mov EAX,EBX
 15940 fabs EAX,EAX
 15942 fsgn EAX,EAX
 15944 lneg EAX
// if (C1==C)
 15946 cmp 0,EAX
 15949 jge 15958
 15952 rstack EAX,EBP:-1
 15956 leave 
 15957 ret 
__466:
__464:
 15958 rstack EAX,EBP:-1
// I++
 15962 inc EAX
 15964 sstack EBP:-1,EAX
 15968 rstack EAX,EBP:-1
 15972 rstack EBX,EBP:2
 15976 add EBX,EAX
 15978 mov EAX,EBX
// C1=S[I]
 15980 sstack EBP:-2,#EAX
 15984 jmp 15909
__462:
 15987 mov EAX,-1
 15990 leave 
 15991 ret 
__460:
 15992 leave 
 15993 ret 
str_find_last_of:
// str_find_last_of(S,C)
 15994 enter 2
__468:
 15997 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 16001 push EAX
 16003 mov ECX,1
// strlen(...)
 16006 call 10743
 16009 add ESP,1
 16012 add EAX,-1
 16015 sstack EBP:-1,EAX
 16019 rstack EAX,EBP:-1
 16023 rstack EBX,EBP:2
 16027 add EBX,EAX
 16029 mov EAX,EBX
 16031 sstack EBP:-2,#EAX
__470:
 16035 rstack EAX,EBP:-1
 16039 mov EBX,-1
 16042 sub EBX,EAX
 16044 fabs EBX,EBX
 16046 fsgn EBX,EBX
// if (I!=-1
 16048 cmp 0,EBX
 16051 jz 16113
__472:
 16054 rstack EAX,EBP:-2
 16058 rstack EBX,EBP:3
 16062 sub EBX,EAX
 16064 mov EAX,EBX
 16066 fabs EAX,EAX
 16068 fsgn EAX,EAX
 16070 lneg EAX
// if (C1==C)
 16072 cmp 0,EAX
 16075 jge 16084
 16078 rstack EAX,EBP:-1
 16082 leave 
 16083 ret 
__473:
__471:
 16084 rstack EAX,EBP:-1
// I--
 16088 dec EAX
 16090 sstack EBP:-1,EAX
 16094 rstack EAX,EBP:-1
 16098 rstack EBX,EBP:2
 16102 add EBX,EAX
 16104 mov EAX,EBX
// C1=S[I]
 16106 sstack EBP:-2,#EAX
 16110 jmp 16035
__469:
 16113 mov EAX,-1
 16116 leave 
 16117 ret 
__467:
 16118 leave 
 16119 ret 
stack_copy:
// stack_copy(ptr,size)
 16120 enter -0
__475:
 16123 push 2
 16126 rstack EAX,EBP:3
 16130 push EAX
 16132 rstack EAX,EBP:2
 16136 push EAX
 16138 mov ECX,3
// stack_return(...)
 16141 call 61637
 16144 add ESP,3
 16147 leave 
 16148 ret 
__474:
 16149 leave 
 16150 ret 
str_stack_copy:
// str_stack_copy(str)
 16151 enter 1
__477:
 16154 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 16158 push EAX
 16160 mov ECX,1
// strlen(...)
 16163 call 10743
 16166 add ESP,1
 16169 sstack EBP:-1,EAX
 16173 push 1
 16176 rstack EAX,EBP:-1
 16180 add EAX,1
 16183 mov EBX,EAX
 16185 push EBX
 16187 rstack EAX,EBP:2
 16191 push EAX
 16193 mov ECX,3
// stack_return(...)
 16196 call 61637
 16199 add ESP,3
 16202 leave 
 16203 ret 
__476:
 16204 leave 
 16205 ret 
LIBSTRING_CONSTANTS:
c2str_n:
 16206 db ""
 16206 db 110
 16207 db 0
c2str_0:
 16208 db ""
 16208 db 48
 16209 db 0
LIBSTRING_VARS:
c2str_str:
 16210 alloc 2
Constr:
 16212 alloc 256
Nbase:
 16468 db 10
Nprec:
 16469 db 3
Nstack:
 16470 alloc 16
Array:
 16486 alloc 16
LIBSTRING_END:
LIBNUMBER_CODE:
pow:
// pow(A,B)
 16502 enter -0
__479:
 16505 rstack EAX,EBP:3
 16509 rstack EBX,EBP:2
 16513 fpwr EBX,EAX
 16515 mov EAX,EBX
 16517 leave 
 16518 ret 
__478:
 16519 leave 
 16520 ret 
modulo:
// modulo(A,B)
 16521 enter -0
__481:
 16524 rstack EAX,EBP:3
 16528 rstack EBX,EBP:2
 16532 mod EBX,EAX
 16534 sstack EBP:2,EBX
 16538 rstack EAX,EBP:2
 16542 leave 
 16543 ret 
__480:
 16544 leave 
 16545 ret 
sqrt:
// sqrt(A)
 16546 enter -0
__483:
 16549 rstack EAX,EBP:2
 16553 fpwr EAX,0.5
 16556 mov EBX,EAX
 16558 mov EAX,EBX
 16560 leave 
 16561 ret 
__482:
 16562 leave 
 16563 ret 
cbrt:
// cbrt(A)
 16564 enter -0
__485:
 16567 rstack EAX,EBP:2
 16571 fpwr EAX,0.33333333333333
 16574 mov EBX,EAX
 16576 mov EAX,EBX
 16578 leave 
 16579 ret 
__484:
 16580 leave 
 16581 ret 
root:
// root(A,B)
 16582 enter -0
__487:
 16585 rstack EAX,EBP:3
 16589 mov EBX,1
 16592 div EBX,EAX
 16594 rstack EAX,EBP:2
 16598 fpwr EAX,EBX
 16600 mov EBX,EAX
 16602 mov EAX,EBX
 16604 leave 
 16605 ret 
__486:
 16606 leave 
 16607 ret 
e:
// e()
 16608 enter -0
__489:
 16611 fe EAX
 16613 leave 
 16614 ret 
__488:
 16615 leave 
 16616 ret 
exp:
// exp(A)
 16617 enter -0
__491:
 16620 fpi EAX
 16622 rstack EBX,EBP:2
 16626 fpwr EAX,EBX
 16628 leave 
 16629 ret 
__490:
 16630 leave 
 16631 ret 
ln:
// ln(A)
 16632 enter -0
__493:
 16635 rstack EBX,EBP:2
 16639 mov EAX,EBX
 16641 fln EDX,EAX
 16643 mov EAX,EDX
 16645 leave 
 16646 ret 
__492:
 16647 leave 
 16648 ret 
log2:
// log2(A)
 16649 enter -0
__495:
 16652 rstack EBX,EBP:2
 16656 mov EAX,EBX
 16658 fln EDX,EAX
 16660 fln ECX,2
 16663 mov EBX,EDX
 16665 div EBX,ECX
 16667 mov EAX,EBX
 16669 leave 
 16670 ret 
__494:
 16671 leave 
 16672 ret 
log10:
// log10(A)
 16673 enter -0
__497:
 16676 flog10 EDX,EAX
 16678 mov EAX,EDX
 16680 leave 
 16681 ret 
__496:
 16682 leave 
 16683 ret 
log:
// log(A,B)
 16684 enter -0
__499:
 16687 rstack ESI,EBP:2
 16691 mov EAX,ESI
 16693 rstack ESI,EBP:3
 16697 mov EBX,ESI
 16699 fln EDX,EAX
 16701 fln ECX,EBX
 16703 div EDX,ECX
 16705 mov EAX,EDX
 16707 leave 
 16708 ret 
__498:
 16709 leave 
 16710 ret 
abs:
// abs(A)
 16711 enter -0
__501:
 16714 rstack EBX,EBP:2
 16718 mov EAX,EBX
 16720 fabs EDX,EAX
 16722 mov EAX,EDX
 16724 leave 
 16725 ret 
__500:
 16726 leave 
 16727 ret 
ceil:
// ceil(A)
 16728 enter -0
__503:
 16731 rstack EBX,EBP:2
 16735 mov EAX,EBX
 16737 fceil EAX
 16739 leave 
 16740 ret 
__502:
 16741 leave 
 16742 ret 
floor:
// floor(A)
 16743 enter -0
__505:
 16746 rstack EBX,EBP:2
 16750 mov EAX,EBX
 16752 fint EAX
 16754 leave 
 16755 ret 
__504:
 16756 leave 
 16757 ret 
round:
// round(A)
 16758 enter -0
__507:
 16761 rstack EBX,EBP:2
 16765 mov EAX,EBX
 16767 frnd EAX
 16769 leave 
 16770 ret 
__506:
 16771 leave 
 16772 ret 
integer:
// integer(A)
 16773 enter -0
__509:
 16776 rstack EBX,EBP:2
 16780 mov EAX,EBX
 16782 fint EAX
 16784 leave 
 16785 ret 
__508:
 16786 leave 
 16787 ret 
frac:
// frac(A)
 16788 enter -0
__511:
 16791 rstack EBX,EBP:2
 16795 mov EAX,EBX
 16797 ffrac EAX
 16799 leave 
 16800 ret 
__510:
 16801 leave 
 16802 ret 
clamp:
// clamp(A,MinA,MaxA)
 16803 enter -0
__513:
 16806 rstack EBX,EBP:2
 16810 mov EAX,EBX
 16812 rstack EBX,EBP:3
 16816 max EAX,EBX
 16818 rstack EBX,EBP:4
 16822 min EAX,EBX
 16824 leave 
 16825 ret 
__512:
 16826 leave 
 16827 ret 
inrange:
// inrange(A,MinA,MaxA)
 16828 enter -0
__515:
 16831 rstack EAX,EBP:2
 16835 rstack EBX,EBP:4
 16839 sub EBX,EAX
 16841 mov EAX,EBX
 16843 fsgn EAX,EAX
 16845 max EAX,0
 16848 rstack EBX,EBP:2
 16852 rstack ECX,EBP:3
 16856 sub ECX,EBX
 16858 mov EBX,ECX
 16860 neg EBX
 16862 fsgn EBX,EBX
 16864 max EBX,0
 16867 and EBX,EAX
 16869 mov EAX,EBX
 16871 leave 
 16872 ret 
__514:
 16873 leave 
 16874 ret 
minimal:
// minimal(A,B)
 16875 enter -0
__517:
 16878 rstack ECX,EBP:2
 16882 mov EAX,ECX
 16884 rstack ECX,EBP:3
 16888 mov EBX,ECX
 16890 min EAX,EBX
 16892 leave 
 16893 ret 
__516:
 16894 leave 
 16895 ret 
maximal:
// maximal(A,B)
 16896 enter -0
__519:
 16899 rstack ECX,EBP:2
 16903 mov EAX,ECX
 16905 rstack ECX,EBP:3
 16909 mov EBX,ECX
 16911 max EAX,EBX
 16913 leave 
 16914 ret 
__518:
 16915 leave 
 16916 ret 
random:
// random()
 16917 enter -0
__521:
 16920 rand EAX
 16922 leave 
 16923 ret 
__520:
 16924 leave 
 16925 ret 
random1:
// random1(A)
 16926 enter -0
__523:
 16929 rstack EBX,EBP:2
 16933 mov EAX,EBX
 16935 rand EDX
 16937 mul EDX,EAX
 16939 mov EAX,EDX
 16941 leave 
 16942 ret 
__522:
 16943 leave 
 16944 ret 
random2:
// random2(A,B)
 16945 enter -0
__525:
 16948 rstack ECX,EBP:2
 16952 mov EAX,ECX
 16954 rstack ECX,EBP:3
 16958 mov EBX,ECX
 16960 rand EDX
 16962 sub EBX,EAX
 16964 mul EDX,EBX
 16966 add EDX,EAX
 16968 mov EAX,EDX
 16970 leave 
 16971 ret 
__524:
 16972 leave 
 16973 ret 
randint1:
// randint1(A)
 16974 enter -0
__527:
 16977 rstack EBX,EBP:2
 16981 mov EAX,EBX
 16983 rand EDX
 16985 mul EDX,EAX
 16987 fint EDX
 16989 mov EAX,EDX
 16991 leave 
 16992 ret 
__526:
 16993 leave 
 16994 ret 
randint2:
// randint2(A,B)
 16995 enter -0
__529:
 16998 rstack ECX,EBP:2
 17002 mov EAX,ECX
 17004 rstack ECX,EBP:3
 17008 mov EBX,ECX
 17010 rand EDX
 17012 sub EBX,EAX
 17014 mul EDX,EBX
 17016 add EDX,EAX
 17018 fint EDX
 17020 mov EAX,EDX
 17022 leave 
 17023 ret 
__528:
 17024 leave 
 17025 ret 
pi:
// pi()
 17026 enter -0
__531:
 17029 fpi EAX
 17031 leave 
 17032 ret 
__530:
 17033 leave 
 17034 ret 
toRad:
// toRad(N)
 17035 enter -0
__533:
 17038 rstack ECX,EBP:2
 17042 mov EAX,ECX
 17044 fpi EBX
 17046 mul EAX,EBX
 17048 div EAX,180
 17051 leave 
 17052 ret 
__532:
 17053 leave 
 17054 ret 
toDeg:
// toDeg(N)
 17055 enter -0
__535:
 17058 rstack ECX,EBP:2
 17062 mov EAX,ECX
 17064 fpi EBX
 17066 mul EAX,180
 17069 div EAX,EBX
 17071 leave 
 17072 ret 
__534:
 17073 leave 
 17074 ret 
sin:
// sin(N)
 17075 enter -0
__537:
 17078 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17082 push EBX
 17084 mov ECX,1
// toRad(...)
 17087 call 17035
 17090 add ESP,1
 17093 fsin EAX,EAX
 17095 leave 
 17096 ret 
__536:
 17097 leave 
 17098 ret 
cos:
// cos(N)
 17099 enter -0
__539:
 17102 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17106 push EBX
 17108 mov ECX,1
// toRad(...)
 17111 call 17035
 17114 add ESP,1
 17117 fcos EAX,EAX
 17119 leave 
 17120 ret 
__538:
 17121 leave 
 17122 ret 
tan:
// tan(N)
 17123 enter -0
__541:
 17126 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17130 push EBX
 17132 mov ECX,1
// toRad(...)
 17135 call 17035
 17138 add ESP,1
 17141 ftan EAX,EAX
 17143 leave 
 17144 ret 
__540:
 17145 leave 
 17146 ret 
cot:
// cot(N)
 17147 enter -0
__543:
 17150 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17154 push EBX
 17156 mov ECX,1
// toRad(...)
 17159 call 17035
 17162 add ESP,1
 17165 ftan EAX,EAX
 17167 finv EAX
 17169 leave 
 17170 ret 
__542:
 17171 leave 
 17172 ret 
sec:
// sec(N)
 17173 enter -0
__545:
 17176 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17180 push EBX
 17182 mov ECX,1
// toRad(...)
 17185 call 17035
 17188 add ESP,1
 17191 fcos EAX,EAX
 17193 finv EAX
 17195 leave 
 17196 ret 
__544:
 17197 leave 
 17198 ret 
csc:
// csc(N)
 17199 enter -0
__547:
 17202 rstack EBX,EBP:2
// toRad arg #1 (float N)
 17206 push EBX
 17208 mov ECX,1
// toRad(...)
 17211 call 17035
 17214 add ESP,1
 17217 fsin EAX,EAX
 17219 finv EAX
 17221 leave 
 17222 ret 
__546:
 17223 leave 
 17224 ret 
asin:
// asin(N)
 17225 enter -0
__549:
 17228 rstack EBX,EBP:2
 17232 fasin EAX,EBX
// toDeg arg #1 (float N)
 17234 push EAX
 17236 mov ECX,1
// toDeg(...)
 17239 call 17055
 17242 add ESP,1
 17245 leave 
 17246 ret 
__548:
 17247 leave 
 17248 ret 
acos:
// acos(N)
 17249 enter -0
__551:
 17252 rstack EBX,EBP:2
 17256 facos EAX,EBX
// toDeg arg #1 (float N)
 17258 push EAX
 17260 mov ECX,1
// toDeg(...)
 17263 call 17055
 17266 add ESP,1
 17269 leave 
 17270 ret 
__550:
 17271 leave 
 17272 ret 
atan:
// atan(N)
 17273 enter -0
__553:
 17276 rstack EBX,EBP:2
 17280 fatan EAX,EBX
// toDeg arg #1 (float N)
 17282 push EAX
 17284 mov ECX,1
// toDeg(...)
 17287 call 17055
 17290 add ESP,1
 17293 leave 
 17294 ret 
__552:
 17295 leave 
 17296 ret 
sinh:
// sinh(N)
 17297 enter -0
__555:
 17300 fe EAX
 17302 rstack EBX,EBP:2
 17306 neg EBX
 17308 mov ECX,EBX
 17310 mov EBX,EAX
 17312 neg EBX
 17314 fpwr EBX,ECX
 17316 rstack ECX,EBP:2
 17320 mov EDX,EAX
 17322 fpwr EDX,ECX
 17324 add EDX,EBX
 17326 mov EBX,0.5
 17329 mul EBX,EDX
 17331 mov EAX,EBX
 17333 leave 
 17334 ret 
__554:
 17335 leave 
 17336 ret 
cosh:
// cosh(N)
 17337 enter -0
__557:
 17340 fe EAX
 17342 rstack EBX,EBP:2
 17346 neg EBX
 17348 mov ECX,EBX
 17350 mov EBX,EAX
 17352 fpwr EBX,ECX
 17354 rstack ECX,EBP:2
 17358 mov EDX,EAX
 17360 fpwr EDX,ECX
 17362 add EDX,EBX
 17364 mov EBX,0.5
 17367 mul EBX,EDX
 17369 mov EAX,EBX
 17371 leave 
 17372 ret 
__556:
 17373 leave 
 17374 ret 
tanh:
// tanh(N)
 17375 enter -0
__559:
 17378 fe EAX
 17380 rstack EBX,EBP:2
 17384 mov ECX,2
 17387 mul ECX,EBX
 17389 mov EBX,EAX
 17391 fpwr EBX,ECX
 17393 add EBX,1
 17396 rstack ECX,EBP:2
 17400 mov EDX,2
 17403 mul EDX,ECX
 17405 mov ECX,EAX
 17407 fpwr ECX,EDX
 17409 add ECX,-1
 17412 div ECX,EBX
 17414 mov EAX,ECX
 17416 leave 
 17417 ret 
__558:
 17418 leave 
 17419 ret 
coth:
// coth(N)
 17420 enter -0
__561:
 17423 fe EAX
 17425 rstack EBX,EBP:2
 17429 mov ECX,2
 17432 mul ECX,EBX
 17434 mov EBX,EAX
 17436 fpwr EBX,ECX
 17438 add EBX,-1
 17441 rstack ECX,EBP:2
 17445 mov EDX,2
 17448 mul EDX,ECX
 17450 mov ECX,EAX
 17452 fpwr ECX,EDX
 17454 add ECX,1
 17457 div ECX,EBX
 17459 mov EAX,ECX
 17461 leave 
 17462 ret 
__560:
 17463 leave 
 17464 ret 
sech:
// sech(N)
 17465 enter -0
__563:
 17468 fe EAX
 17470 rstack EBX,EBP:2
 17474 neg EBX
 17476 mov ECX,EBX
 17478 mov EBX,EAX
 17480 fpwr EBX,ECX
 17482 rstack ECX,EBP:2
 17486 mov EDX,EAX
 17488 fpwr EDX,ECX
 17490 add EDX,EBX
 17492 mov EBX,2
 17495 div EBX,EDX
 17497 mov EAX,EBX
 17499 leave 
 17500 ret 
__562:
 17501 leave 
 17502 ret 
csch:
// csch(N)
 17503 enter -0
__565:
 17506 fe EAX
 17508 rstack EBX,EBP:2
 17512 neg EBX
 17514 mov ECX,EBX
 17516 mov EBX,EAX
 17518 neg EBX
 17520 fpwr EBX,ECX
 17522 rstack ECX,EBP:2
 17526 mov EDX,EAX
 17528 fpwr EDX,ECX
 17530 add EDX,EBX
 17532 mov EBX,2
 17535 div EBX,EDX
 17537 mov EAX,EBX
 17539 leave 
 17540 ret 
__564:
 17541 leave 
 17542 ret 
sinr:
// sinr(N)
 17543 enter -0
__567:
 17546 rstack EBX,EBP:2
 17550 fsin EAX,EBX
 17552 leave 
 17553 ret 
__566:
 17554 leave 
 17555 ret 
cosr:
// cosr(N)
 17556 enter -0
__569:
 17559 rstack EBX,EBP:2
 17563 fcos EAX,EBX
 17565 leave 
 17566 ret 
__568:
 17567 leave 
 17568 ret 
tanr:
// tanr(N)
 17569 enter -0
__571:
 17572 rstack EBX,EBP:2
 17576 ftan EAX,EBX
 17578 leave 
 17579 ret 
__570:
 17580 leave 
 17581 ret 
cotr:
// cotr(N)
 17582 enter -0
__573:
 17585 rstack EBX,EBP:2
 17589 ftan EAX,EBX
 17591 finv EAX
 17593 leave 
 17594 ret 
__572:
 17595 leave 
 17596 ret 
secr:
// secr(N)
 17597 enter -0
__575:
 17600 rstack EBX,EBP:2
 17604 fcos EAX,EBX
 17606 finv EAX
 17608 leave 
 17609 ret 
__574:
 17610 leave 
 17611 ret 
cscr:
// cscr(N)
 17612 enter -0
__577:
 17615 rstack EBX,EBP:2
 17619 fsin EAX,EBX
 17621 finv EAX
 17623 leave 
 17624 ret 
__576:
 17625 leave 
 17626 ret 
asinr:
// asinr(N)
 17627 enter -0
__579:
 17630 rstack EBX,EBP:2
 17634 fasin EAX,EBX
 17636 leave 
 17637 ret 
__578:
 17638 leave 
 17639 ret 
acosr:
// acosr(N)
 17640 enter -0
__581:
 17643 rstack EBX,EBP:2
 17647 facos EAX,EBX
 17649 leave 
 17650 ret 
__580:
 17651 leave 
 17652 ret 
atanr:
// atanr(N)
 17653 enter -0
__583:
 17656 rstack EBX,EBP:2
 17660 fatan EAX,EBX
 17662 leave 
 17663 ret 
__582:
 17664 leave 
 17665 ret 
ceil2:
// ceil2(A,B)
 17666 enter -0
__585:
 17669 rstack ECX,EBP:2
 17673 mov EAX,ECX
 17675 rstack ECX,EBP:3
 17679 mov EBX,ECX
 17681 mov EDX,10
 17684 fpwr EBX,EDX
 17686 rstack ECX,EBP:3
 17690 div EAX,ECX
 17692 mov EDX,EAX
 17694 fceil EDX
 17696 mul EDX,EBX
 17698 mov EAX,EDX
 17700 leave 
 17701 ret 
__584:
 17702 leave 
 17703 ret 
floor2:
// floor2(A,B)
 17704 enter -0
__587:
 17707 rstack ECX,EBP:2
 17711 mov EAX,ECX
 17713 rstack ECX,EBP:3
 17717 mov EBX,ECX
 17719 mov EDX,10
 17722 fpwr EBX,EDX
 17724 rstack ECX,EBP:3
 17728 div EAX,ECX
 17730 mov EDX,EAX
 17732 fint EDX
 17734 mul EDX,EBX
 17736 mov EAX,EDX
 17738 leave 
 17739 ret 
__586:
 17740 leave 
 17741 ret 
round2:
// round2(A,B)
 17742 enter -0
__589:
 17745 rstack ECX,EBP:2
 17749 mov EAX,ECX
 17751 rstack ECX,EBP:3
 17755 mov EBX,ECX
 17757 mov EDX,10
 17760 fpwr EBX,EDX
 17762 rstack ECX,EBP:3
 17766 div EAX,ECX
 17768 mov EDX,EAX
 17770 frnd EDX
 17772 mul EDX,EBX
 17774 mov EAX,EDX
 17776 leave 
 17777 ret 
__588:
 17778 leave 
 17779 ret 
LIBNUMBER_CONSTANTS:
LIBNUMBER_VARS:
LIBNUMBER_END:
ZMALLOC_CODE:
allocation_constructor:
// allocation_constructor(A)
 17780 enter -0
__591:
 17783 push 0
 17786 rstack EAX,EBP:2
 17790 push EAX
 17792 mov ECX,2
// allocation_set_size(...)
 17795 call 17857
 17798 add ESP,2
 17801 push 0
 17804 rstack EAX,EBP:2
 17808 push EAX
 17810 mov ECX,2
// allocation_set_owner(...)
 17813 call 17877
 17816 add ESP,2
 17819 push 0
 17822 rstack EAX,EBP:2
 17826 push EAX
 17828 mov ECX,2
// allocation_set_prev(...)
 17831 call 17897
 17834 add ESP,2
 17837 push 0
 17840 rstack EAX,EBP:2
 17844 push EAX
 17846 mov ECX,2
// allocation_set_next(...)
 17849 call 17917
 17852 add ESP,2
__590:
 17855 leave 
 17856 ret 
allocation_set_size:
// allocation_set_size(A,n)
 17857 enter -0
__593:
 17860 rstack EAX,EBP:3
 17864 rstack EBX,EBP:2
 17868 add EBX,0
 17871 mov ECX,EBX
// A[0]=n
 17873 mov #ECX,EAX
__592:
 17875 leave 
 17876 ret 
allocation_set_owner:
// allocation_set_owner(A,n)
 17877 enter -0
__595:
 17880 rstack EAX,EBP:3
 17884 rstack EBX,EBP:2
 17888 add EBX,1
 17891 mov ECX,EBX
// A[1]=n
 17893 mov #ECX,EAX
__594:
 17895 leave 
 17896 ret 
allocation_set_prev:
// allocation_set_prev(A,n)
 17897 enter -0
__597:
 17900 rstack EAX,EBP:3
 17904 rstack EBX,EBP:2
 17908 add EBX,2
 17911 mov ECX,EBX
// A[2]=n
 17913 mov #ECX,EAX
__596:
 17915 leave 
 17916 ret 
allocation_set_next:
// allocation_set_next(A,n)
 17917 enter -0
__599:
 17920 rstack EAX,EBP:3
 17924 rstack EBX,EBP:2
 17928 add EBX,3
 17931 mov ECX,EBX
// A[3]=n
 17933 mov #ECX,EAX
__598:
 17935 leave 
 17936 ret 
allocation_get_size:
// allocation_get_size(A)
 17937 enter -0
__601:
 17940 rstack EAX,EBP:2
 17944 add EAX,0
 17947 mov EBX,EAX
 17949 mov EAX,#EBX
 17951 leave 
 17952 ret 
__600:
 17953 leave 
 17954 ret 
allocation_get_owner:
// allocation_get_owner(A)
 17955 enter -0
__603:
 17958 rstack EAX,EBP:2
 17962 add EAX,1
 17965 mov EBX,EAX
 17967 mov EAX,#EBX
 17969 leave 
 17970 ret 
__602:
 17971 leave 
 17972 ret 
allocation_get_prev:
// allocation_get_prev(A)
 17973 enter -0
__605:
 17976 rstack EAX,EBP:2
 17980 add EAX,2
 17983 mov EBX,EAX
 17985 mov EAX,#EBX
 17987 leave 
 17988 ret 
__604:
 17989 leave 
 17990 ret 
allocation_get_next:
// allocation_get_next(A)
 17991 enter -0
__607:
 17994 rstack EAX,EBP:2
 17998 add EAX,3
 18001 mov EBX,EAX
 18003 mov EAX,#EBX
 18005 leave 
 18006 ret 
__606:
 18007 leave 
 18008 ret 
malloc_getAllocation:
// malloc_getAllocation(I)
 18009 enter -0
__609:
__611:
 18012 rstack EAX,EBP:2
 18016 mov EBX,1
 18019 sub EBX,EAX
 18021 fsgn EBX,EBX
 18023 max EBX,0
// if (I<1)
 18026 cmp 0,EBX
 18029 jge 18094
__614:
// if (malloc_debug)
 18032 cmp 0,#22588
 18036 jge 18089
 18039 push 18252
 18042 mov ECX,1
// malloc_print(...)
 18045 call #22589
 18048 add ESP,1
 18051 rstack EAX,EBP:2
 18055 push EAX
 18057 mov ECX,1
// malloc_num2str(...)
 18060 call #22590
 18063 add ESP,1
 18066 push EAX
 18068 mov ECX,1
// malloc_print(...)
 18071 call #22589
 18074 add ESP,1
 18077 push 18246
 18080 mov ECX,1
// malloc_print(...)
 18083 call #22589
 18086 add ESP,1
__615:
__613:
 18089 mov EAX,0
 18092 leave 
 18093 ret 
__612:
__610:
__619:
 18094 rstack EAX,EBP:2
 18098 mov EBX,#22593
 18101 neg EBX
 18103 mov ECX,#22592
 18106 add ECX,EBX
 18108 sub ECX,EAX
 18110 neg ECX
 18112 fsgn ECX,ECX
 18114 max ECX,0
// if (I>malloc_max_disk-malloc_header)
 18117 cmp 0,ECX
 18120 jge 18229
__622:
// if (malloc_debug)
 18123 cmp 0,#22588
 18127 jge 18224
 18130 push 18252
 18133 mov ECX,1
// malloc_print(...)
 18136 call #22589
 18139 add ESP,1
 18142 rstack EAX,EBP:2
 18146 push EAX
 18148 mov ECX,1
// malloc_num2str(...)
 18151 call #22590
 18154 add ESP,1
 18157 push EAX
 18159 mov ECX,1
// malloc_print(...)
 18162 call #22589
 18165 add ESP,1
 18168 push 18274
 18171 mov ECX,1
// malloc_print(...)
 18174 call #22589
 18177 add ESP,1
 18180 mov EAX,#22593
 18183 neg EAX
 18185 mov EBX,#22592
 18188 add EBX,EAX
 18190 push EBX
 18192 mov ECX,1
// malloc_num2str(...)
 18195 call #22590
 18198 add ESP,1
 18201 push EAX
 18203 mov ECX,1
// malloc_print(...)
 18206 call #22589
 18209 add ESP,1
 18212 push 18244
 18215 mov ECX,1
// malloc_print(...)
 18218 call #22589
 18221 add ESP,1
__623:
__621:
 18224 mov EAX,0
 18227 leave 
 18228 ret 
__620:
__618:
 18229 rstack EAX,EBP:2
 18233 mov EBX,#22591
 18236 add EBX,EAX
 18238 mov EAX,EBX
 18240 leave 
 18241 ret 
__608:
 18242 leave 
 18243 ret 
__625:
 18244 db "
",0
__617:
 18246 db "<= 0
",0
__616:
 18252 db "getAllocation fails: ",0
__624:
 18274 db ">",0
malloc_getDataFromIndex:
// malloc_getDataFromIndex(I)
 18276 enter -0
__627:
 18279 rstack EAX,EBP:2
 18283 add EAX,#22593
 18286 mov EBX,EAX
 18288 mov EAX,#22591
 18291 add EAX,EBX
 18293 leave 
 18294 ret 
__626:
 18295 leave 
 18296 ret 
malloc_getDataFromAllocation:
// malloc_getDataFromAllocation(A)
 18297 enter -0
__629:
 18300 rstack EAX,EBP:2
 18304 add EAX,#22593
 18307 mov EBX,EAX
 18309 mov EAX,EBX
 18311 leave 
 18312 ret 
__628:
 18313 leave 
 18314 ret 
malloc_getIndex:
// malloc_getIndex(ptr)
 18315 enter -0
__631:
 18318 mov EAX,#22591
 18321 neg EAX
 18323 rstack EBX,EBP:2
 18327 add EBX,EAX
 18329 mov EAX,EBX
 18331 leave 
 18332 ret 
__630:
 18333 leave 
 18334 ret 
malloc_trySplit:
// malloc_trySplit(A,returnB,n)
 18335 enter 4
__633:
__635:
// if (malloc_debug)
 18338 cmp 0,#22588
 18342 jge 18433
 18345 push 19085
 18348 mov ECX,1
// malloc_print(...)
 18351 call #22589
 18354 add ESP,1
 18357 rstack EAX,EBP:2
 18361 push EAX
 18363 mov ECX,1
// malloc_num2str(...)
 18366 call #22590
 18369 add ESP,1
 18372 push EAX
 18374 mov ECX,1
// malloc_print(...)
 18377 call #22589
 18380 add ESP,1
 18383 push 18994
 18386 mov ECX,1
// malloc_print(...)
 18389 call #22589
 18392 add ESP,1
 18395 rstack EAX,EBP:4
 18399 push EAX
 18401 mov ECX,1
// malloc_num2str(...)
 18404 call #22590
 18407 add ESP,1
 18410 push EAX
 18412 mov ECX,1
// malloc_print(...)
 18415 call #22589
 18418 add ESP,1
 18421 push 18244
 18424 mov ECX,1
// malloc_print(...)
 18427 call #22589
 18430 add ESP,1
__636:
__634:
__640:
 18433 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 18437 push EAX
 18439 mov ECX,1
// allocation_get_size(...)
 18442 call 17937
 18445 add ESP,1
 18448 mov EBX,#22593
 18451 add EBX,1
 18454 rstack ECX,EBP:4
 18458 add ECX,EBX
 18460 mov EBX,ECX
 18462 sub EBX,EAX
 18464 fsgn EBX,EBX
 18466 max EBX,0
// if (allocation_get_size(A)<n+malloc_header+1)
 18469 cmp 0,EBX
 18472 jge 18499
__643:
// if (malloc_debug)
 18475 cmp 0,#22588
 18479 jge 18494
 18482 push 19017
 18485 mov ECX,1
// malloc_print(...)
 18488 call #22589
 18491 add ESP,1
__644:
__642:
 18494 mov EAX,0
 18497 leave 
 18498 ret 
__641:
__639:
 18499 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 18503 push EAX
 18505 mov ECX,1
// allocation_get_size(...)
 18508 call 17937
 18511 add ESP,1
 18514 sstack EBP:-1,EAX
 18518 rstack EAX,EBP:4
// allocation_set_size arg #2 (float n)
 18522 push EAX
 18524 rstack EAX,EBP:2
// allocation_set_size arg #1 (float* A)
 18528 push EAX
 18530 mov ECX,2
// allocation_set_size(...)
 18533 call 17857
 18536 add ESP,2
 18539 rstack EAX,EBP:2
// malloc_getDataFromAllocation arg #1 (float* A)
 18543 push EAX
 18545 mov ECX,1
// malloc_getDataFromAllocation(...)
 18548 call 18297
 18551 add ESP,1
 18554 sstack EBP:-2,EAX
 18558 rstack EAX,EBP:4
 18562 rstack EBX,EBP:-2
 18566 add EBX,EAX
 18568 mov EAX,EBX
// tmp=tmp+n
 18570 sstack EBP:-2,EAX
 18574 rstack EAX,EBP:-2
// malloc_getIndex arg #1 (float* ptr)
 18578 push EAX
 18580 mov ECX,1
// malloc_getIndex(...)
 18583 call 18315
 18586 add ESP,1
// tmp=malloc_getIndex(tmp)
 18589 sstack EBP:-2,EAX
 18593 rstack EAX,EBP:-2
// malloc_getAllocation arg #1 (float I)
 18597 push EAX
 18599 mov ECX,1
// malloc_getAllocation(...)
 18602 call 18009
 18605 add ESP,1
 18608 sstack EBP:-3,EAX
 18612 rstack EAX,EBP:-3
 18616 sstack EBP:-4,EAX
__647:
// if (malloc_debug)
 18620 cmp 0,#22588
 18624 jge 18715
 18627 push 19041
 18630 mov ECX,1
// malloc_print(...)
 18633 call #22589
 18636 add ESP,1
 18639 rstack EAX,EBP:-4
 18643 push EAX
 18645 mov ECX,1
// malloc_num2str(...)
 18648 call #22590
 18651 add ESP,1
 18654 push EAX
 18656 mov ECX,1
// malloc_print(...)
 18659 call #22589
 18662 add ESP,1
 18665 push 19076
 18668 mov ECX,1
// malloc_print(...)
 18671 call #22589
 18674 add ESP,1
 18677 rstack EAX,EBP:-2
 18681 push EAX
 18683 mov ECX,1
// malloc_num2str(...)
 18686 call #22590
 18689 add ESP,1
 18692 push EAX
 18694 mov ECX,1
// malloc_print(...)
 18697 call #22589
 18700 add ESP,1
 18703 push 19102
 18706 mov ECX,1
// malloc_print(...)
 18709 call #22589
 18712 add ESP,1
__648:
__646:
 18715 mov EAX,#22593
 18718 neg EAX
 18720 rstack EBX,EBP:4
 18724 neg EBX
 18726 mov ECX,EBX
 18728 add ECX,EAX
 18730 rstack EAX,EBP:-1
 18734 add EAX,ECX
 18736 mov EBX,EAX
// allocation_set_size arg #2 (float n)
 18738 push EBX
 18740 rstack EAX,EBP:-4
// allocation_set_size arg #1 (float* A)
 18744 push EAX
 18746 mov ECX,2
// allocation_set_size(...)
 18749 call 17857
 18752 add ESP,2
 18755 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 18759 push EAX
 18761 mov ECX,1
// allocation_get_owner(...)
 18764 call 17955
 18767 add ESP,1
// allocation_set_owner arg #2 (float n)
 18770 push EAX
 18772 rstack EAX,EBP:-4
// allocation_set_owner arg #1 (float* A)
 18776 push EAX
 18778 mov ECX,2
// allocation_set_owner(...)
 18781 call 17877
 18784 add ESP,2
 18787 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 18791 push EAX
 18793 mov ECX,1
// malloc_getIndex(...)
 18796 call 18315
 18799 add ESP,1
// allocation_set_prev arg #2 (float n)
 18802 push EAX
 18804 rstack EAX,EBP:-4
// allocation_set_prev arg #1 (float* A)
 18808 push EAX
 18810 mov ECX,2
// allocation_set_prev(...)
 18813 call 17897
 18816 add ESP,2
 18819 rstack EAX,EBP:2
// allocation_get_next arg #1 (float* A)
 18823 push EAX
 18825 mov ECX,1
// allocation_get_next(...)
 18828 call 17991
 18831 add ESP,1
// allocation_set_next arg #2 (float n)
 18834 push EAX
 18836 rstack EAX,EBP:-4
// allocation_set_next arg #1 (float* A)
 18840 push EAX
 18842 mov ECX,2
// allocation_set_next(...)
 18845 call 17917
 18848 add ESP,2
 18851 rstack EAX,EBP:-4
// malloc_getIndex arg #1 (float* ptr)
 18855 push EAX
 18857 mov ECX,1
// malloc_getIndex(...)
 18860 call 18315
 18863 add ESP,1
// allocation_set_next arg #2 (float n)
 18866 push EAX
 18868 rstack EAX,EBP:2
// allocation_set_next arg #1 (float* A)
 18872 push EAX
 18874 mov ECX,2
// allocation_set_next(...)
 18877 call 17917
 18880 add ESP,2
__653:
 18883 rstack EAX,EBP:-4
// allocation_get_next arg #1 (float* A)
 18887 push EAX
 18889 mov ECX,1
// allocation_get_next(...)
 18892 call 17991
 18895 add ESP,1
// if (allocation_get_next(B))
 18898 cmp 0,EAX
 18901 jge 18958
 18904 rstack EAX,EBP:-4
// malloc_getIndex arg #1 (float* ptr)
 18908 push EAX
 18910 mov ECX,1
// malloc_getIndex(...)
 18913 call 18315
 18916 add ESP,1
// allocation_set_prev arg #2 (float n)
 18919 push EAX
 18921 rstack EAX,EBP:-4
// allocation_get_next arg #1 (float* A)
 18925 push EAX
 18927 mov ECX,1
// allocation_get_next(...)
 18930 call 17991
 18933 add ESP,1
// malloc_getAllocation arg #1 (float I)
 18936 push EAX
 18938 mov ECX,1
// malloc_getAllocation(...)
 18941 call 18009
 18944 add ESP,1
// allocation_set_prev arg #1 (float* A)
 18947 push EAX
 18949 mov ECX,2
// allocation_set_prev(...)
 18952 call 17897
 18955 add ESP,2
__654:
__652:
 18958 rstack EAX,EBP:-4
 18962 rstack EBX,EBP:3
// *returnB=B
 18966 mov #EBX,EAX
__656:
// if (malloc_debug)
 18968 cmp 0,#22588
 18972 jge 18987
 18975 push 19001
 18978 mov ECX,1
// malloc_print(...)
 18981 call #22589
 18984 add ESP,1
__657:
__655:
 18987 mov EAX,1
 18990 leave 
 18991 ret 
__632:
 18992 leave 
 18993 ret 
__638:
 18994 db " into ",0
__658:
 19001 db "done splitting
",0
__645:
 19017 db "too small, can't split
",0
__649:
 19041 db "splitting: make new allocation at ",0
__650:
 19076 db " (index ",0
__637:
 19085 db "trying to split ",0
__651:
 19102 db ")
",0
malloc_join:
// malloc_join(A,B)
 19105 enter 2
__660:
 19108 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 19112 push EAX
 19114 mov ECX,1
// allocation_get_size(...)
 19117 call 17937
 19120 add ESP,1
 19123 sstack EBP:-1,EAX
 19127 rstack EAX,EBP:3
// allocation_get_size arg #1 (float* A)
 19131 push EAX
 19133 mov ECX,1
// allocation_get_size(...)
 19136 call 17937
 19139 add ESP,1
 19142 rstack EBX,EBP:-1
 19146 add EBX,EAX
 19148 mov EAX,EBX
// tmp=tmp+allocation_get_size(B)
 19150 sstack EBP:-1,EAX
 19154 rstack EAX,EBP:-1
 19158 add EAX,#22593
 19161 mov EBX,EAX
// tmp=tmp+malloc_header
 19163 sstack EBP:-1,EBX
 19167 rstack EAX,EBP:-1
// allocation_set_size arg #2 (float n)
 19171 push EAX
 19173 rstack EAX,EBP:2
// allocation_set_size arg #1 (float* A)
 19177 push EAX
 19179 mov ECX,2
// allocation_set_size(...)
 19182 call 17857
 19185 add ESP,2
 19188 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 19192 push EAX
 19194 mov ECX,1
// allocation_get_next(...)
 19197 call 17991
 19200 add ESP,1
// tmp=allocation_get_next(B)
 19203 sstack EBP:-1,EAX
 19207 rstack EAX,EBP:-1
// allocation_set_next arg #2 (float n)
 19211 push EAX
 19213 rstack EAX,EBP:2
// allocation_set_next arg #1 (float* A)
 19217 push EAX
 19219 mov ECX,2
// allocation_set_next(...)
 19222 call 17917
 19225 add ESP,2
__662:
 19228 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 19232 push EAX
 19234 mov ECX,1
// allocation_get_next(...)
 19237 call 17991
 19240 add ESP,1
// if (allocation_get_next(B))
 19243 cmp 0,EAX
 19246 jge 19327
 19249 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 19253 push EAX
 19255 mov ECX,1
// allocation_get_next(...)
 19258 call 17991
 19261 add ESP,1
// tmp=allocation_get_next(B)
 19264 sstack EBP:-1,EAX
 19268 rstack EAX,EBP:-1
// malloc_getAllocation arg #1 (float I)
 19272 push EAX
 19274 mov ECX,1
// malloc_getAllocation(...)
 19277 call 18009
 19280 add ESP,1
// tmp=malloc_getAllocation(tmp)
 19283 sstack EBP:-1,EAX
 19287 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 19291 push EAX
 19293 mov ECX,1
// malloc_getIndex(...)
 19296 call 18315
 19299 add ESP,1
 19302 sstack EBP:-2,EAX
 19306 rstack EAX,EBP:-2
// allocation_set_prev arg #2 (float n)
 19310 push EAX
 19312 rstack EAX,EBP:-1
// allocation_set_prev arg #1 (float* A)
 19316 push EAX
 19318 mov ECX,2
// allocation_set_prev(...)
 19321 call 17897
 19324 add ESP,2
__663:
__661:
__659:
 19327 leave 
 19328 ret 
malloc_set_disk:
// malloc_set_disk(disk,disk_size)
 19329 enter -0
__665:
 19332 rstack EAX,EBP:2
// malloc_disk=disk
 19336 mov #22591,EAX
 19339 rstack EAX,EBP:3
// malloc_max_disk=disk_size
 19343 mov #22592,EAX
// malloc_header=4
 19346 mov #22593,4
// malloc_user=1
 19350 mov #22594,1
// malloc_debug=0
 19354 mov #22588,0
__664:
 19358 leave 
 19359 ret 
malloc_init:
// malloc_init()
 19360 enter 1
__667:
__669:
// if (malloc_debug)
 19363 cmp 0,#22588
 19367 jge 19417
 19370 push 19632
 19373 mov ECX,1
// malloc_print(...)
 19376 call #22589
 19379 add ESP,1
 19382 push #22591
 19385 mov ECX,1
// malloc_num2str(...)
 19388 call #22590
 19391 add ESP,1
 19394 push EAX
 19396 mov ECX,1
// malloc_print(...)
 19399 call #22589
 19402 add ESP,1
 19405 push 18244
 19408 mov ECX,1
// malloc_print(...)
 19411 call #22589
 19414 add ESP,1
__670:
__668:
// malloc_getAllocation arg #1 (float I)
 19417 push 1
 19420 mov ECX,1
// malloc_getAllocation(...)
 19423 call 18009
 19426 add ESP,1
 19429 sstack EBP:-1,EAX
__673:
// if (malloc_debug)
 19433 cmp 0,#22588
 19437 jge 19490
 19440 push 19595
 19443 mov ECX,1
// malloc_print(...)
 19446 call #22589
 19449 add ESP,1
 19452 rstack EAX,EBP:-1
 19456 push EAX
 19458 mov ECX,1
// malloc_num2str(...)
 19461 call #22590
 19464 add ESP,1
 19467 push EAX
 19469 mov ECX,1
// malloc_print(...)
 19472 call #22589
 19475 add ESP,1
 19478 push 18244
 19481 mov ECX,1
// malloc_print(...)
 19484 call #22589
 19487 add ESP,1
__674:
__672:
 19490 mov EAX,#22593
 19493 neg EAX
 19495 add EAX,-1
 19498 mov EBX,#22592
 19501 add EBX,EAX
// allocation_set_size arg #2 (float n)
 19503 push EBX
 19505 rstack EAX,EBP:-1
// allocation_set_size arg #1 (float* A)
 19509 push EAX
 19511 mov ECX,2
// allocation_set_size(...)
 19514 call 17857
 19517 add ESP,2
// allocation_set_owner arg #2 (float n)
 19520 push 0
 19523 rstack EAX,EBP:-1
// allocation_set_owner arg #1 (float* A)
 19527 push EAX
 19529 mov ECX,2
// allocation_set_owner(...)
 19532 call 17877
 19535 add ESP,2
// allocation_set_prev arg #2 (float n)
 19538 push 0
 19541 rstack EAX,EBP:-1
// allocation_set_prev arg #1 (float* A)
 19545 push EAX
 19547 mov ECX,2
// allocation_set_prev(...)
 19550 call 17897
 19553 add ESP,2
// allocation_set_next arg #2 (float n)
 19556 push 0
 19559 rstack EAX,EBP:-1
// allocation_set_next arg #1 (float* A)
 19563 push EAX
 19565 mov ECX,2
// allocation_set_next(...)
 19568 call 17917
 19571 add ESP,2
__677:
// if (malloc_debug)
 19574 cmp 0,#22588
 19578 jge 19593
 19581 push 19609
 19584 mov ECX,1
// malloc_print(...)
 19587 call #22589
 19590 add ESP,1
__678:
__676:
__666:
 19593 leave 
 19594 ret 
__675:
 19595 db "allocation = ",0
__679:
 19609 db "malloc_init returning
",0
__671:
 19632 db "disk = ",0
malloc_test:
// malloc_test()
 19640 enter 5
__681:
 19643 mov EAX,SS:ESP
 19646 add EAX,-4
 19649 push EAX
 19651 mov EAX,SS:ESP
 19654 add EAX,-3
 19657 push EAX
 19659 mov EAX,SS:ESP
 19662 add EAX,-2
 19665 push EAX
 19667 mov EAX,SS:ESP
 19670 add EAX,-1
 19673 push EAX
 19675 mov ECX,4
// malloc_count(...)
 19678 call 19977
 19681 add ESP,4
__683:
 19684 rstack EAX,EBP:-4
 19688 rstack EBX,EBP:-3
 19692 add EBX,EAX
 19694 mov EAX,EBX
 19696 mov EBX,#22593
 19699 mul EBX,EAX
 19701 add EBX,1
 19704 rstack EAX,EBP:-2
 19708 add EAX,EBX
 19710 mov EBX,EAX
 19712 rstack EAX,EBP:-1
 19716 add EAX,EBX
 19718 mov EBX,EAX
 19720 sstack EBP:-5,EBX
__685:
 19724 rstack EAX,EBP:-5
 19728 mov EBX,#22592
 19731 sub EBX,EAX
 19733 fabs EBX,EBX
 19735 fsgn EBX,EBX
// if (calcsize!=malloc_max_disk)
 19737 cmp 0,EBX
 19740 jge 19840
__688:
// if (malloc_print)
 19743 cmp 0,#22589
 19747 jge 19835
 19750 push 19851
 19753 mov ECX,1
// malloc_print(...)
 19756 call #22589
 19759 add ESP,1
 19762 rstack EAX,EBP:-5
 19766 push EAX
 19768 mov ECX,1
// malloc_num2str(...)
 19771 call #22590
 19774 add ESP,1
 19777 push EAX
 19779 mov ECX,1
// malloc_print(...)
 19782 call #22589
 19785 add ESP,1
 19788 push 19847
 19791 mov ECX,1
// malloc_print(...)
 19794 call #22589
 19797 add ESP,1
 19800 push #22592
 19803 mov ECX,1
// malloc_num2str(...)
 19806 call #22590
 19809 add ESP,1
 19812 push EAX
 19814 mov ECX,1
// malloc_print(...)
 19817 call #22589
 19820 add ESP,1
 19823 push 19102
 19826 mov ECX,1
// malloc_print(...)
 19829 call #22589
 19832 add ESP,1
__689:
__687:
 19835 mov EAX,1
 19838 leave 
 19839 ret 
__686:
__684:
__682:
 19840 mov EAX,0
 19843 leave 
 19844 ret 
__680:
 19845 leave 
 19846 ret 
__691:
 19847 db " / ",0
__690:
 19851 db "ERROR: HEAP CORRUPTED
(",0
malloc_print_count:
// malloc_print_count()
 19875 enter 1
__693:
// malloc_getAllocation arg #1 (float I)
 19878 push 1
 19881 mov ECX,1
// malloc_getAllocation(...)
 19884 call 18009
 19887 add ESP,1
 19890 sstack EBP:-1,EAX
__695:
// if (1
 19894 cmp 0,1
 19898 jz 19975
 19901 rstack EAX,EBP:-1
 19905 push EAX
 19907 mov ECX,1
// printAllocationSimple(...)
 19910 call 20215
 19913 add ESP,1
__697:
 19916 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 19920 push EAX
 19922 mov ECX,1
// allocation_get_next(...)
 19925 call 17991
 19928 add ESP,1
// if (allocation_get_next(A))
 19931 cmp 0,EAX
 19934 jge 19970
 19937 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 19941 push EAX
 19943 mov ECX,1
// allocation_get_next(...)
 19946 call 17991
 19949 add ESP,1
// malloc_getAllocation arg #1 (float I)
 19952 push EAX
 19954 mov ECX,1
// malloc_getAllocation(...)
 19957 call 18009
 19960 add ESP,1
// A=malloc_getAllocation(allocation_get_next(A))
 19963 sstack EBP:-1,EAX
 19967 jmp 19972
__699:
__698:
__701:
 19970 leave 
 19971 ret 
__700:
__696:
 19972 jmp 19894
__694:
__692:
 19975 leave 
 19976 ret 
malloc_count:
// malloc_count(freesize,usedsize,freecount,usedcount)
 19977 enter 1
__703:
 19980 rstack EAX,EBP:2
// *freesize=0
 19984 mov #EAX,0
 19987 rstack EAX,EBP:3
// *usedsize=0
 19991 mov #EAX,0
 19994 rstack EAX,EBP:4
// *freecount=0
 19998 mov #EAX,0
 20001 rstack EAX,EBP:5
// *usedcount=0
 20005 mov #EAX,0
// malloc_getAllocation arg #1 (float I)
 20008 push 1
 20011 mov ECX,1
// malloc_getAllocation(...)
 20014 call 18009
 20017 add ESP,1
 20020 sstack EBP:-1,EAX
__705:
// if (1
 20024 cmp 0,1
 20028 jz 20213
__707:
 20031 rstack EAX,EBP:-1
// allocation_get_owner arg #1 (float* A)
 20035 push EAX
 20037 mov ECX,1
// allocation_get_owner(...)
 20040 call 17955
 20043 add ESP,1
 20046 mov EBX,0
 20049 sub EBX,EAX
 20051 fabs EBX,EBX
 20053 fsgn EBX,EBX
 20055 lneg EBX
// if (allocation_get_owner(A)==0)
 20057 cmp 0,EBX
 20060 jge 20110
 20063 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 20067 push EAX
 20069 mov ECX,1
// allocation_get_size(...)
 20072 call 17937
 20075 add ESP,1
 20078 rstack EBX,EBP:2
 20082 mov ECX,#EBX
 20084 add ECX,EAX
 20086 rstack EAX,EBP:2
// *freesize=*freesize+allocation_get_size(A)
 20090 mov #EAX,ECX
 20092 rstack EAX,EBP:4
 20096 mov EBX,#EAX
 20098 add EBX,1
 20101 rstack EAX,EBP:4
// *freecount=*freecount+1
 20105 mov #EAX,EBX
 20107 jmp 20154
__709:
__708:
__711:
 20110 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 20114 push EAX
 20116 mov ECX,1
// allocation_get_size(...)
 20119 call 17937
 20122 add ESP,1
 20125 rstack EBX,EBP:3
 20129 mov ECX,#EBX
 20131 add ECX,EAX
 20133 rstack EAX,EBP:3
// *usedsize=*usedsize+allocation_get_size(A)
 20137 mov #EAX,ECX
 20139 rstack EAX,EBP:5
 20143 mov EBX,#EAX
 20145 add EBX,1
 20148 rstack EAX,EBP:5
// *usedcount=*usedcount+1
 20152 mov #EAX,EBX
__710:
__706:
__713:
 20154 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 20158 push EAX
 20160 mov ECX,1
// allocation_get_next(...)
 20163 call 17991
 20166 add ESP,1
// if (allocation_get_next(A))
 20169 cmp 0,EAX
 20172 jge 20208
 20175 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 20179 push EAX
 20181 mov ECX,1
// allocation_get_next(...)
 20184 call 17991
 20187 add ESP,1
// malloc_getAllocation arg #1 (float I)
 20190 push EAX
 20192 mov ECX,1
// malloc_getAllocation(...)
 20195 call 18009
 20198 add ESP,1
// A=malloc_getAllocation(allocation_get_next(A))
 20201 sstack EBP:-1,EAX
 20205 jmp 20210
__715:
__714:
__717:
 20208 leave 
 20209 ret 
__716:
__712:
 20210 jmp 20024
__704:
__702:
 20213 leave 
 20214 ret 
printAllocationSimple:
// printAllocationSimple(A)
 20215 enter -0
__719:
__721:
 20218 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 20222 push EAX
 20224 mov ECX,1
// allocation_get_owner(...)
 20227 call 17955
 20230 add ESP,1
// if (allocation_get_owner(A))
 20233 cmp 0,EAX
 20236 jge 20254
 20239 push 20358
 20242 mov ECX,1
// malloc_print(...)
 20245 call #22589
 20248 add ESP,1
 20251 jmp 20266
__724:
__722:
__726:
 20254 push 20355
 20257 mov ECX,1
// malloc_print(...)
 20260 call #22589
 20263 add ESP,1
__725:
__720:
 20266 rstack EAX,EBP:2
 20270 push EAX
 20272 mov ECX,1
// malloc_num2str(...)
 20275 call #22590
 20278 add ESP,1
 20281 push EAX
 20283 mov ECX,1
// malloc_print(...)
 20286 call #22589
 20289 add ESP,1
 20292 push 20361
 20295 mov ECX,1
// malloc_print(...)
 20298 call #22589
 20301 add ESP,1
 20304 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 20308 push EAX
 20310 mov ECX,1
// allocation_get_size(...)
 20313 call 17937
 20316 add ESP,1
 20319 push EAX
 20321 mov ECX,1
// malloc_num2str(...)
 20324 call #22590
 20327 add ESP,1
 20330 push EAX
 20332 mov ECX,1
// malloc_print(...)
 20335 call #22589
 20338 add ESP,1
 20341 push 18244
 20344 mov ECX,1
// malloc_print(...)
 20347 call #22589
 20350 add ESP,1
__718:
 20353 leave 
 20354 ret 
__727:
 20355 db "O ",0
__723:
 20358 db "X ",0
__728:
 20361 db " ",0
printAllocation:
// printAllocation(A)
 20363 enter -0
__730:
 20366 push 20687
 20369 mov ECX,1
// malloc_print(...)
 20372 call #22589
 20375 add ESP,1
 20378 rstack EAX,EBP:2
 20382 push EAX
 20384 mov ECX,1
// malloc_num2str(...)
 20387 call #22590
 20390 add ESP,1
 20393 push EAX
 20395 mov ECX,1
// malloc_print(...)
 20398 call #22589
 20401 add ESP,1
 20404 push 20663
 20407 mov ECX,1
// malloc_print(...)
 20410 call #22589
 20413 add ESP,1
 20416 rstack EAX,EBP:2
// malloc_getDataFromAllocation arg #1 (float* A)
 20420 push EAX
 20422 mov ECX,1
// malloc_getDataFromAllocation(...)
 20425 call 18297
 20428 add ESP,1
 20431 push EAX
 20433 mov ECX,1
// malloc_num2str(...)
 20436 call #22590
 20439 add ESP,1
 20442 push EAX
 20444 mov ECX,1
// malloc_print(...)
 20447 call #22589
 20450 add ESP,1
 20453 push 20679
 20456 mov ECX,1
// malloc_print(...)
 20459 call #22589
 20462 add ESP,1
 20465 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 20469 push EAX
 20471 mov ECX,1
// allocation_get_size(...)
 20474 call 17937
 20477 add ESP,1
 20480 push EAX
 20482 mov ECX,1
// malloc_num2str(...)
 20485 call #22590
 20488 add ESP,1
 20491 push EAX
 20493 mov ECX,1
// malloc_print(...)
 20496 call #22589
 20499 add ESP,1
 20502 push 20700
 20505 mov ECX,1
// malloc_print(...)
 20508 call #22589
 20511 add ESP,1
 20514 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 20518 push EAX
 20520 mov ECX,1
// allocation_get_owner(...)
 20523 call 17955
 20526 add ESP,1
 20529 push EAX
 20531 mov ECX,1
// malloc_num2str(...)
 20534 call #22590
 20537 add ESP,1
 20540 push EAX
 20542 mov ECX,1
// malloc_print(...)
 20545 call #22589
 20548 add ESP,1
 20551 push 20671
 20554 mov ECX,1
// malloc_print(...)
 20557 call #22589
 20560 add ESP,1
 20563 rstack EAX,EBP:2
// allocation_get_prev arg #1 (float* A)
 20567 push EAX
 20569 mov ECX,1
// allocation_get_prev(...)
 20572 call 17973
 20575 add ESP,1
 20578 push EAX
 20580 mov ECX,1
// malloc_num2str(...)
 20583 call #22590
 20586 add ESP,1
 20589 push EAX
 20591 mov ECX,1
// malloc_print(...)
 20594 call #22589
 20597 add ESP,1
 20600 push 20692
 20603 mov ECX,1
// malloc_print(...)
 20606 call #22589
 20609 add ESP,1
 20612 rstack EAX,EBP:2
// allocation_get_next arg #1 (float* A)
 20616 push EAX
 20618 mov ECX,1
// allocation_get_next(...)
 20621 call 17991
 20624 add ESP,1
 20627 push EAX
 20629 mov ECX,1
// malloc_num2str(...)
 20632 call #22590
 20635 add ESP,1
 20638 push EAX
 20640 mov ECX,1
// malloc_print(...)
 20643 call #22589
 20646 add ESP,1
 20649 push 18244
 20652 mov ECX,1
// malloc_print(...)
 20655 call #22589
 20658 add ESP,1
__729:
 20661 leave 
 20662 ret 
__732:
 20663 db ", data ",0
__735:
 20671 db ", prev ",0
__733:
 20679 db ", size ",0
__731:
 20687 db "Alc ",0
__736:
 20692 db ", next ",0
__734:
 20700 db ", owner ",0
malloc:
// malloc(n)
 20709 enter 5
__738:
__740:
// if (malloc_debug)
 20712 cmp 0,#22588
 20716 jge 20769
 20719 push 21223
 20722 mov ECX,1
// malloc_print(...)
 20725 call #22589
 20728 add ESP,1
 20731 rstack EAX,EBP:2
 20735 push EAX
 20737 mov ECX,1
// malloc_num2str(...)
 20740 call #22590
 20743 add ESP,1
 20746 push EAX
 20748 mov ECX,1
// malloc_print(...)
 20751 call #22589
 20754 add ESP,1
 20757 push 19102
 20760 mov ECX,1
// malloc_print(...)
 20763 call #22589
 20766 add ESP,1
__741:
__739:
// malloc_getAllocation arg #1 (float I)
 20769 push 1
 20772 mov ECX,1
// malloc_getAllocation(...)
 20775 call 18009
 20778 add ESP,1
 20781 sstack EBP:-1,EAX
__744:
// if (1
 20785 cmp 0,1
 20789 jz 21137
__746:
// if (malloc_debug)
 20792 cmp 0,#22588
 20796 jge 20814
 20799 rstack EAX,EBP:-1
// printAllocation arg #1 (float* A)
 20803 push EAX
 20805 mov ECX,1
// printAllocation(...)
 20808 call 20363
 20811 add ESP,1
__747:
__745:
 20814 rstack EAX,EBP:-1
// allocation_get_owner arg #1 (float* A)
 20818 push EAX
 20820 mov ECX,1
// allocation_get_owner(...)
 20823 call 17955
 20826 add ESP,1
 20829 sstack EBP:-2,EAX
 20833 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 20837 push EAX
 20839 mov ECX,1
// allocation_get_size(...)
 20842 call 17937
 20845 add ESP,1
 20848 sstack EBP:-3,EAX
 20852 rstack EAX,EBP:-2
 20856 mov EBX,0
 20859 sub EBX,EAX
 20861 fabs EBX,EBX
 20863 fsgn EBX,EBX
 20865 lneg EBX
// cond1=(cond1==0)
 20867 sstack EBP:-2,EBX
 20871 rstack EAX,EBP:-3
 20875 rstack EBX,EBP:2
 20879 add EBX,-1
 20882 mov ECX,EBX
 20884 sub ECX,EAX
 20886 neg ECX
 20888 fsgn ECX,ECX
 20890 max ECX,0
// cond2=(cond2>(n-1))
 20893 sstack EBP:-3,ECX
 20897 rstack EAX,EBP:-3
 20901 rstack EBX,EBP:-2
 20905 and EBX,EAX
 20907 mov EAX,EBX
// cond1=cond1&&cond2
 20909 sstack EBP:-2,EAX
__749:
 20913 rstack EAX,EBP:-2
// if (cond1)
 20917 cmp 0,EAX
 20920 jge 21027
__752:
// if (malloc_debug)
 20923 cmp 0,#22588
 20927 jge 20942
 20930 push 21198
 20933 mov ECX,1
// malloc_print(...)
 20936 call #22589
 20939 add ESP,1
__753:
__751:
 20942 rstack EAX,EBP:2
// malloc_trySplit arg #3 (float n)
 20946 push EAX
 20948 mov EAX,SS:ESP
 20951 add EAX,-4
// malloc_trySplit arg #2 (float** returnB)
 20954 push EAX
 20956 rstack EAX,EBP:-1
// malloc_trySplit arg #1 (float* A)
 20960 push EAX
 20962 mov ECX,3
// malloc_trySplit(...)
 20965 call 18335
 20968 add ESP,3
// allocation_set_owner arg #2 (float n)
 20971 push #22594
 20974 rstack EAX,EBP:-1
// allocation_set_owner arg #1 (float* A)
 20978 push EAX
 20980 mov ECX,2
// allocation_set_owner(...)
 20983 call 17877
 20986 add ESP,2
__756:
 20989 mov ECX,0
// malloc_test(...)
 20992 call 19640
// if (malloc_test())
 20995 cmp 0,EAX
 20998 jge 21007
 21001 mov ECX,0
// shell_panic(...)
 21004 call 38246
__757:
__755:
 21007 rstack EAX,EBP:-1
// malloc_getDataFromAllocation arg #1 (float* A)
 21011 push EAX
 21013 mov ECX,1
// malloc_getDataFromAllocation(...)
 21016 call 18297
 21019 add ESP,1
 21022 leave 
 21023 ret 
 21024 jmp 21134
__758:
__750:
__760:
__762:
 21027 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 21031 push EAX
 21033 mov ECX,1
// allocation_get_next(...)
 21036 call 17991
 21039 add ESP,1
// if (allocation_get_next(A))
 21042 cmp 0,EAX
 21045 jge 21089
 21048 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 21052 push EAX
 21054 mov ECX,1
// allocation_get_next(...)
 21057 call 17991
 21060 add ESP,1
 21063 sstack EBP:-5,EAX
 21067 rstack EAX,EBP:-5
// malloc_getAllocation arg #1 (float I)
 21071 push EAX
 21073 mov ECX,1
// malloc_getAllocation(...)
 21076 call 18009
 21079 add ESP,1
// A=malloc_getAllocation(tmp)
 21082 sstack EBP:-1,EAX
 21086 jmp 21134
__764:
__763:
__766:
__768:
// if (malloc_debug)
 21089 cmp 0,#22588
 21093 jge 21108
 21096 push 21139
 21099 mov ECX,1
// malloc_print(...)
 21102 call #22589
 21105 add ESP,1
__769:
__767:
 21108 push 900
 21111 push 21171
 21114 mov ECX,2
// Print(...)
 21117 call 40786
 21120 add ESP,2
 21123 mov ECX,0
// shell_panic(...)
 21126 call 38246
 21129 mov EAX,0
 21132 leave 
 21133 ret 
__765:
__761:
__759:
__748:
 21134 jmp 20785
__743:
__737:
 21137 leave 
 21138 ret 
__770:
 21139 db "malloc: no memory, returning 0
",0
__771:
 21171 db "ERROR MALLOC FAILED PANIC
",0
__754:
 21198 db "malloc: found something
",0
__742:
 21223 db "malloc(",0
free:
// free(ptr)
 21231 enter 6
__773:
__775:
// if (malloc_debug)
 21234 cmp 0,#22588
 21238 jge 21291
 21241 push 21880
 21244 mov ECX,1
// malloc_print(...)
 21247 call #22589
 21250 add ESP,1
 21253 rstack EAX,EBP:2
 21257 push EAX
 21259 mov ECX,1
// malloc_num2str(...)
 21262 call #22590
 21265 add ESP,1
 21268 push EAX
 21270 mov ECX,1
// malloc_print(...)
 21273 call #22589
 21276 add ESP,1
 21279 push 18244
 21282 mov ECX,1
// malloc_print(...)
 21285 call #22589
 21288 add ESP,1
__776:
__774:
__779:
 21291 rstack EAX,EBP:2
 21295 mov EBX,1
 21298 add EBX,#22593
 21301 mov ECX,#22591
 21304 add ECX,EBX
 21306 sub ECX,EAX
 21308 fsgn ECX,ECX
 21310 max ECX,0
// if (ptr<malloc_disk+1+malloc_header)
 21313 cmp 0,ECX
 21316 jge 21389
__782:
// if (malloc_debug)
 21319 cmp 0,#22588
 21323 jge 21387
 21326 push 21811
 21329 mov ECX,1
// malloc_print(...)
 21332 call #22589
 21335 add ESP,1
 21338 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 21342 push EAX
 21344 mov ECX,1
// malloc_getIndex(...)
 21347 call 18315
 21350 add ESP,1
 21353 push EAX
 21355 mov ECX,1
// malloc_num2str(...)
 21358 call #22590
 21361 add ESP,1
 21364 push EAX
 21366 mov ECX,1
// malloc_print(...)
 21369 call #22589
 21372 add ESP,1
 21375 push 19102
 21378 mov ECX,1
// malloc_print(...)
 21381 call #22589
 21384 add ESP,1
__783:
__781:
 21387 leave 
 21388 ret 
__780:
__778:
 21389 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 21393 push EAX
 21395 mov ECX,1
// malloc_getIndex(...)
 21398 call 18315
 21401 add ESP,1
 21404 sstack EBP:-1,EAX
__786:
// if (malloc_debug)
 21408 cmp 0,#22588
 21412 jge 21465
 21415 push 21802
 21418 mov ECX,1
// malloc_print(...)
 21421 call #22589
 21424 add ESP,1
 21427 rstack EAX,EBP:-1
 21431 push EAX
 21433 mov ECX,1
// malloc_num2str(...)
 21436 call #22590
 21439 add ESP,1
 21442 push EAX
 21444 mov ECX,1
// malloc_print(...)
 21447 call #22589
 21450 add ESP,1
 21453 push 18244
 21456 mov ECX,1
// malloc_print(...)
 21459 call #22589
 21462 add ESP,1
__787:
__785:
 21465 mov EAX,#22593
 21468 neg EAX
 21470 rstack EBX,EBP:-1
 21474 add EBX,EAX
 21476 mov EAX,EBX
// tmp=tmp-malloc_header
 21478 sstack EBP:-1,EAX
 21482 rstack EAX,EBP:-1
// malloc_getAllocation arg #1 (float I)
 21486 push EAX
 21488 mov ECX,1
// malloc_getAllocation(...)
 21491 call 18009
 21494 add ESP,1
// tmp=malloc_getAllocation(tmp)
 21497 sstack EBP:-1,EAX
 21501 rstack EAX,EBP:-1
 21505 sstack EBP:-2,EAX
// allocation_set_owner arg #2 (float n)
 21509 push 0
 21512 rstack EAX,EBP:-2
// allocation_set_owner arg #1 (float* A)
 21516 push EAX
 21518 mov ECX,2
// allocation_set_owner(...)
 21521 call 17877
 21524 add ESP,2
__790:
// if (malloc_debug)
 21527 cmp 0,#22588
 21531 jge 21546
 21534 push 21838
 21537 mov ECX,1
// malloc_print(...)
 21540 call #22589
 21543 add ESP,1
__791:
__789:
free_loop1:
 21546 rstack EAX,EBP:-2
// allocation_get_prev arg #1 (float* A)
 21550 push EAX
 21552 mov ECX,1
// allocation_get_prev(...)
 21555 call 17973
 21558 add ESP,1
// prev=allocation_get_prev(A)
 21561 sstack EBP:-3,EAX
__794:
 21565 rstack EAX,EBP:-3
// if (prev)
 21569 cmp 0,EAX
 21572 jge 21658
 21575 rstack EAX,EBP:-3
// malloc_getAllocation arg #1 (float I)
 21579 push EAX
 21581 mov ECX,1
// malloc_getAllocation(...)
 21584 call 18009
 21587 add ESP,1
// prevA=malloc_getAllocation(prev)
 21590 sstack EBP:-4,EAX
__797:
 21594 rstack EAX,EBP:-4
// allocation_get_owner arg #1 (float* A)
 21598 push EAX
 21600 mov ECX,1
// allocation_get_owner(...)
 21603 call 17955
 21606 add ESP,1
 21609 mov EBX,0
 21612 sub EBX,EAX
 21614 fabs EBX,EBX
 21616 fsgn EBX,EBX
 21618 lneg EBX
// if (allocation_get_owner(prevA)==0)
 21620 cmp 0,EBX
 21623 jge 21658
 21626 rstack EAX,EBP:-2
// malloc_join arg #2 (float* B)
 21630 push EAX
 21632 rstack EAX,EBP:-4
// malloc_join arg #1 (float* A)
 21636 push EAX
 21638 mov ECX,2
// malloc_join(...)
 21641 call 19105
 21644 add ESP,2
 21647 rstack EAX,EBP:-4
// A=prevA
 21651 sstack EBP:-2,EAX
 21655 jmp 21546
__798:
__796:
__795:
__793:
__800:
// if (malloc_debug)
 21658 cmp 0,#22588
 21662 jge 21677
 21665 push 21861
 21668 mov ECX,1
// malloc_print(...)
 21671 call #22589
 21674 add ESP,1
__801:
__799:
free_loop2:
 21677 rstack EAX,EBP:-2
// allocation_get_next arg #1 (float* A)
 21681 push EAX
 21683 mov ECX,1
// allocation_get_next(...)
 21686 call 17991
 21689 add ESP,1
// next=allocation_get_next(A)
 21692 sstack EBP:-5,EAX
__804:
 21696 rstack EAX,EBP:-5
// if (next)
 21700 cmp 0,EAX
 21703 jge 21781
 21706 rstack EAX,EBP:-5
// malloc_getAllocation arg #1 (float I)
 21710 push EAX
 21712 mov ECX,1
// malloc_getAllocation(...)
 21715 call 18009
 21718 add ESP,1
// nextA=malloc_getAllocation(next)
 21721 sstack EBP:-6,EAX
__807:
 21725 rstack EAX,EBP:-6
// allocation_get_owner arg #1 (float* A)
 21729 push EAX
 21731 mov ECX,1
// allocation_get_owner(...)
 21734 call 17955
 21737 add ESP,1
 21740 mov EBX,0
 21743 sub EBX,EAX
 21745 fabs EBX,EBX
 21747 fsgn EBX,EBX
 21749 lneg EBX
// if (allocation_get_owner(nextA)==0)
 21751 cmp 0,EBX
 21754 jge 21781
 21757 rstack EAX,EBP:-6
// malloc_join arg #2 (float* B)
 21761 push EAX
 21763 rstack EAX,EBP:-2
// malloc_join arg #1 (float* A)
 21767 push EAX
 21769 mov ECX,2
// malloc_join(...)
 21772 call 19105
 21775 add ESP,2
 21778 jmp 21677
__808:
__806:
__805:
__803:
__810:
// if (malloc_debug)
 21781 cmp 0,#22588
 21785 jge 21800
 21788 push 21889
 21791 mov ECX,1
// malloc_print(...)
 21794 call #22589
 21797 add ESP,1
__811:
__809:
__772:
 21800 leave 
 21801 ret 
__788:
 21802 db "index = ",0
__784:
 21811 db "free: null pointer (index ",0
__792:
 21838 db "free, trying previous
",0
__802:
 21861 db "free, trying next
",0
__777:
 21880 db "freeing ",0
__812:
 21889 db "done freeing
",0
realloc:
// realloc(ptr,n)
 21903 enter 4
__814:
__816:
// if (malloc_debug)
 21906 cmp 0,#22588
 21910 jge 22001
 21913 push 22475
 21916 mov ECX,1
// malloc_print(...)
 21919 call #22589
 21922 add ESP,1
 21925 rstack EAX,EBP:2
 21929 push EAX
 21931 mov ECX,1
// malloc_num2str(...)
 21934 call #22590
 21937 add ESP,1
 21940 push EAX
 21942 mov ECX,1
// malloc_print(...)
 21945 call #22589
 21948 add ESP,1
 21951 push 20361
 21954 mov ECX,1
// malloc_print(...)
 21957 call #22589
 21960 add ESP,1
 21963 rstack EAX,EBP:3
 21967 push EAX
 21969 mov ECX,1
// malloc_num2str(...)
 21972 call #22590
 21975 add ESP,1
 21978 push EAX
 21980 mov ECX,1
// malloc_print(...)
 21983 call #22589
 21986 add ESP,1
 21989 push 18244
 21992 mov ECX,1
// malloc_print(...)
 21995 call #22589
 21998 add ESP,1
__817:
__815:
 22001 rstack EAX,EBP:3
// malloc arg #1 (float n)
 22005 push EAX
 22007 mov ECX,1
// malloc(...)
 22010 call 20709
 22013 add ESP,1
 22016 sstack EBP:-1,EAX
__820:
// if (malloc_debug)
 22020 cmp 0,#22588
 22024 jge 22077
 22027 push 22462
 22030 mov ECX,1
// malloc_print(...)
 22033 call #22589
 22036 add ESP,1
 22039 rstack EAX,EBP:-1
 22043 push EAX
 22045 mov ECX,1
// malloc_num2str(...)
 22048 call #22590
 22051 add ESP,1
 22054 push EAX
 22056 mov ECX,1
// malloc_print(...)
 22059 call #22589
 22062 add ESP,1
 22065 push 18244
 22068 mov ECX,1
// malloc_print(...)
 22071 call #22589
 22074 add ESP,1
__821:
__819:
__824:
 22077 rstack EAX,EBP:-1
// if (newp)
 22081 cmp 0,EAX
 22084 jge 22455
__827:
 22087 rstack EAX,EBP:2
// if (ptr)
 22091 cmp 0,EAX
 22094 jge 22446
 22097 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 22101 push EAX
 22103 mov ECX,1
// malloc_getIndex(...)
 22106 call 18315
 22109 add ESP,1
 22112 sstack EBP:-2,EAX
 22116 mov EAX,#22593
 22119 neg EAX
 22121 rstack EBX,EBP:-2
 22125 add EBX,EAX
 22127 mov EAX,EBX
// tmp=tmp-malloc_header
 22129 sstack EBP:-2,EAX
 22133 rstack EAX,EBP:-2
// malloc_getAllocation arg #1 (float I)
 22137 push EAX
 22139 mov ECX,1
// malloc_getAllocation(...)
 22142 call 18009
 22145 add ESP,1
// tmp=malloc_getAllocation(tmp)
 22148 sstack EBP:-2,EAX
 22152 rstack EAX,EBP:-2
 22156 sstack EBP:-3,EAX
 22160 rstack EAX,EBP:-3
// allocation_get_size arg #1 (float* A)
 22164 push EAX
 22166 mov ECX,1
// allocation_get_size(...)
 22169 call 17937
 22172 add ESP,1
 22175 sstack EBP:-4,EAX
__830:
 22179 rstack EAX,EBP:3
 22183 rstack EBX,EBP:-4
 22187 sub EBX,EAX
 22189 mov EAX,EBX
 22191 fsgn EAX,EAX
 22193 max EAX,0
// if (n<size)
 22196 cmp 0,EAX
 22199 jge 22210
 22202 rstack EAX,EBP:3
// size=n
 22206 sstack EBP:-4,EAX
__831:
__829:
__833:
// if (malloc_debug)
 22210 cmp 0,#22588
 22214 jge 22376
 22217 push 22497
 22220 mov ECX,1
// malloc_print(...)
 22223 call #22589
 22226 add ESP,1
 22229 rstack EAX,EBP:-4
 22233 push EAX
 22235 mov ECX,1
// malloc_num2str(...)
 22238 call #22590
 22241 add ESP,1
 22244 push EAX
 22246 mov ECX,1
// malloc_print(...)
 22249 call #22589
 22252 add ESP,1
 22255 push 22484
 22258 mov ECX,1
// malloc_print(...)
 22261 call #22589
 22264 add ESP,1
 22267 rstack EAX,EBP:-3
// malloc_getDataFromAllocation arg #1 (float* A)
 22271 push EAX
 22273 mov ECX,1
// malloc_getDataFromAllocation(...)
 22276 call 18297
 22279 add ESP,1
// malloc_getIndex arg #1 (float* ptr)
 22282 push EAX
 22284 mov ECX,1
// malloc_getIndex(...)
 22287 call 18315
 22290 add ESP,1
 22293 push EAX
 22295 mov ECX,1
// malloc_num2str(...)
 22298 call #22590
 22301 add ESP,1
 22304 push EAX
 22306 mov ECX,1
// malloc_print(...)
 22309 call #22589
 22312 add ESP,1
 22315 push 22470
 22318 mov ECX,1
// malloc_print(...)
 22321 call #22589
 22324 add ESP,1
 22327 rstack EAX,EBP:-1
// malloc_getIndex arg #1 (float* ptr)
 22331 push EAX
 22333 mov ECX,1
// malloc_getIndex(...)
 22336 call 18315
 22339 add ESP,1
 22342 push EAX
 22344 mov ECX,1
// malloc_num2str(...)
 22347 call #22590
 22350 add ESP,1
 22353 push EAX
 22355 mov ECX,1
// malloc_print(...)
 22358 call #22589
 22361 add ESP,1
 22364 push 18244
 22367 mov ECX,1
// malloc_print(...)
 22370 call #22589
 22373 add ESP,1
__834:
__832:
 22376 rstack EAX,EBP:-3
// malloc_getDataFromAllocation arg #1 (float* A)
 22380 push EAX
 22382 mov ECX,1
// malloc_getDataFromAllocation(...)
 22385 call 18297
 22388 add ESP,1
// tmp=malloc_getDataFromAllocation(A)
 22391 sstack EBP:-2,EAX
 22395 rstack EAX,EBP:-4
 22399 push EAX
 22401 rstack EAX,EBP:-1
 22405 push EAX
 22407 rstack EAX,EBP:-2
 22411 push EAX
 22413 mov ECX,3
// malloc_memcopy(...)
 22416 call 22506
 22419 add ESP,3
 22422 rstack EAX,EBP:2
// free arg #1 (float* ptr)
 22426 push EAX
 22428 mov ECX,1
// free(...)
 22431 call 21231
 22434 add ESP,1
 22437 rstack EAX,EBP:-1
 22441 leave 
 22442 ret 
 22443 jmp 22452
__838:
__828:
__840:
 22446 rstack EAX,EBP:-1
 22450 leave 
 22451 ret 
__839:
__826:
 22452 jmp 22460
__841:
__825:
__843:
 22455 mov EAX,0
 22458 leave 
 22459 ret 
__842:
__823:
__813:
 22460 leave 
 22461 ret 
__822:
 22462 db "newp = ",0
__837:
 22470 db " to ",0
__818:
 22475 db "realloc ",0
__836:
 22484 db " bytes from ",0
__835:
 22497 db "copying ",0
malloc_memcopy:
// malloc_memcopy(from,to,n)
 22506 enter 1
__845:
// init loop
 22509 sstack EBP:-1,0
__847:
 22514 rstack EAX,EBP:-1
 22518 rstack EBX,EBP:4
 22522 sub EBX,EAX
 22524 mov EAX,EBX
 22526 fsgn EAX,EAX
// condition
 22528 max EAX,0
 22531 cmp 0,EAX
 22534 jz 22586
 22537 rstack EAX,EBP:2
 22541 rstack EBX,EBP:3
// *to=*from
 22545 mov #EBX,#EAX
 22547 rstack EAX,EBP:3
 22551 add EAX,1
 22554 mov EBX,EAX
// to=to+1
 22556 sstack EBP:3,EBX
 22560 rstack EAX,EBP:2
 22564 add EAX,1
 22567 mov EBX,EAX
// from=from+1
 22569 sstack EBP:2,EBX
 22573 rstack EAX,EBP:-1
// loop step
 22577 inc EAX
 22579 sstack EBP:-1,EAX
 22583 jmp 22514
__846:
__844:
 22586 leave 
 22587 ret 
ZMALLOC_CONSTANTS:
ZMALLOC_VARS:
malloc_debug:
 22588 db 0
malloc_print:
 22589 db 0
malloc_num2str:
 22590 db 0
malloc_disk:
 22591 alloc 1
malloc_max_disk:
 22592 alloc 1
malloc_header:
 22593 alloc 1
malloc_user:
 22594 alloc 1
ZMALLOC_END:
ZVECTOR_CODE:
memcpy2:
// memcpy2(dest,src,n)
 22595 enter 1
__849:
__851:
 22598 rstack EAX,EBP:2
 22602 rstack EBX,EBP:3
 22606 sub EBX,EAX
 22608 mov EAX,EBX
 22610 fsgn EAX,EAX
 22612 max EAX,0
// if (dest<src)
 22615 cmp 0,EAX
 22618 jge 22691
// init loop
 22621 sstack EBP:-1,0
__854:
 22626 rstack EAX,EBP:-1
 22630 rstack EBX,EBP:4
 22634 sub EBX,EAX
 22636 mov EAX,EBX
 22638 fsgn EAX,EAX
// condition
 22640 max EAX,0
 22643 cmp 0,EAX
 22646 jz 22688
 22649 rstack EAX,EBP:-1
 22653 rstack EBX,EBP:3
 22657 add EBX,EAX
 22659 mov EAX,EBX
 22661 rstack EBX,EBP:-1
 22665 rstack ECX,EBP:2
 22669 add ECX,EBX
 22671 mov EBX,ECX
// dest[I]=src[I]
 22673 mov #EBX,#EAX
 22675 rstack EAX,EBP:-1
// loop step
 22679 inc EAX
 22681 sstack EBP:-1,EAX
 22685 jmp 22626
__853:
 22688 jmp 22765
__855:
__852:
__857:
 22691 rstack EAX,EBP:4
 22695 add EAX,-1
 22698 mov EBX,EAX
// init loop
 22700 sstack EBP:-1,EBX
__859:
 22704 rstack EAX,EBP:-1
 22708 mov EBX,-1
 22711 sub EBX,EAX
 22713 neg EBX
 22715 fsgn EBX,EBX
// condition
 22717 max EBX,0
 22720 cmp 0,EBX
 22723 jz 22765
 22726 rstack EAX,EBP:-1
 22730 rstack EBX,EBP:3
 22734 add EBX,EAX
 22736 mov EAX,EBX
 22738 rstack EBX,EBP:-1
 22742 rstack ECX,EBP:2
 22746 add ECX,EBX
 22748 mov EBX,ECX
// dest[I]=src[I]
 22750 mov #EBX,#EAX
 22752 rstack EAX,EBP:-1
// loop step
 22756 dec EAX
 22758 sstack EBP:-1,EAX
 22762 jmp 22704
__858:
__856:
__850:
__848:
 22765 leave 
 22766 ret 
error:
// error(errno)
 22767 enter -0
__861:
 22770 push 22828
 22773 mov ECX,1
// Perr(...)
 22776 call 40763
 22779 add ESP,1
 22782 rstack EAX,EBP:2
// num2str arg #1 (float num)
 22786 push EAX
 22788 mov ECX,1
// num2str(...)
 22791 call 12958
 22794 add ESP,1
 22797 push EAX
 22799 mov ECX,1
// Perr(...)
 22802 call 40763
 22805 add ESP,1
 22808 push 18244
 22811 mov ECX,1
// Perr(...)
 22814 call 40763
 22817 add ESP,1
 22820 mov ECX,0
// shell_panic(...)
 22823 call 38246
__860:
 22826 leave 
 22827 ret 
__862:
 22828 db "Vector error ",0
sizeof_vector:
 22842 db 5
vector_constructor:
// vector_constructor(self,element_size)
 22843 enter -0
__864:
 22846 rstack EAX,EBP:2
 22850 add EAX,0
 22853 mov EBX,EAX
// self[0]=typeof_vector
 22855 mov #EBX,25691
 22858 rstack EAX,EBP:3
 22862 mov EBX,10
 22865 mul EBX,EAX
// malloc arg #1 (float n)
 22867 push EBX
 22869 mov ECX,1
// malloc(...)
 22872 call 20709
 22875 add ESP,1
 22878 rstack EBX,EBP:2
 22882 add EBX,1
 22885 mov ECX,EBX
// self[1]=malloc(10*element_size)
 22887 mov #ECX,EAX
 22889 rstack EAX,EBP:2
 22893 add EAX,2
 22896 mov EBX,EAX
// self[2]=0
 22898 mov #EBX,0
 22901 rstack EAX,EBP:2
 22905 add EAX,3
 22908 mov EBX,EAX
// self[3]=10
 22910 mov #EBX,10
 22913 rstack EAX,EBP:3
 22917 rstack EBX,EBP:2
 22921 add EBX,4
 22924 mov ECX,EBX
// self[4]=element_size
 22926 mov #ECX,EAX
__863:
 22928 leave 
 22929 ret 
vector_copy_constructor:
// vector_copy_constructor(self,other)
 22930 enter 3
__866:
 22933 push 25691
 22936 rstack EAX,EBP:3
 22940 push EAX
 22942 mov ECX,2
// assert_type(...)
 22945 call 37630
 22948 add ESP,2
 22951 rstack EAX,EBP:3
 22955 add EAX,0
 22958 mov EBX,EAX
 22960 rstack EAX,EBP:2
 22964 add EAX,0
 22967 mov ECX,EAX
// self[0]=other[0]
 22969 mov #ECX,#EBX
 22971 rstack EAX,EBP:3
 22975 add EAX,1
 22978 mov EBX,EAX
 22980 rstack EAX,EBP:2
 22984 add EAX,1
 22987 mov ECX,EAX
// self[1]=other[1]
 22989 mov #ECX,#EBX
 22991 rstack EAX,EBP:3
 22995 add EAX,2
 22998 mov EBX,EAX
 23000 rstack EAX,EBP:2
 23004 add EAX,2
 23007 mov ECX,EAX
// self[2]=other[2]
 23009 mov #ECX,#EBX
 23011 rstack EAX,EBP:3
 23015 add EAX,3
 23018 mov EBX,EAX
 23020 rstack EAX,EBP:2
 23024 add EAX,3
 23027 mov ECX,EAX
// self[3]=other[3]
 23029 mov #ECX,#EBX
 23031 rstack EAX,EBP:3
 23035 add EAX,4
 23038 mov EBX,EAX
 23040 rstack EAX,EBP:2
 23044 add EAX,4
 23047 mov ECX,EAX
// self[4]=other[4]
 23049 mov #ECX,#EBX
 23051 rstack EAX,EBP:2
 23055 add EAX,4
 23058 mov EBX,EAX
 23060 rstack EAX,EBP:2
 23064 add EAX,2
 23067 mov ECX,EAX
 23069 mov EAX,#ECX
 23071 mul EAX,#EBX
 23073 sstack EBP:-1,EAX
 23077 rstack EAX,EBP:-1
// malloc arg #1 (float n)
 23081 push EAX
 23083 mov ECX,1
// malloc(...)
 23086 call 20709
 23089 add ESP,1
 23092 sstack EBP:-2,EAX
 23096 rstack EAX,EBP:2
 23100 add EAX,1
 23103 mov EBX,EAX
 23105 sstack EBP:-3,#EBX
 23109 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 23113 push EAX
 23115 rstack EAX,EBP:-3
// memcpy arg #2 (void* src)
 23119 push EAX
 23121 rstack EAX,EBP:-2
// memcpy arg #1 (void* dest)
 23125 push EAX
 23127 mov ECX,3
// memcpy(...)
 23130 call 10006
 23133 add ESP,3
 23136 rstack EAX,EBP:-2
 23140 rstack EBX,EBP:2
 23144 add EBX,1
 23147 mov ECX,EBX
// self[1]=newarray
 23149 mov #ECX,EAX
__865:
 23151 leave 
 23152 ret 
vector_get_array:
// vector_get_array(self)
 23153 enter -0
__868:
 23156 push 25691
 23159 rstack EAX,EBP:2
 23163 push EAX
 23165 mov ECX,2
// assert_type(...)
 23168 call 37630
 23171 add ESP,2
 23174 rstack EAX,EBP:2
 23178 add EAX,1
 23181 mov EBX,EAX
 23183 mov EAX,#EBX
 23185 leave 
 23186 ret 
__867:
 23187 leave 
 23188 ret 
vector_get_size:
// vector_get_size(self)
 23189 enter -0
__870:
 23192 push 25691
 23195 rstack EAX,EBP:2
 23199 push EAX
 23201 mov ECX,2
// assert_type(...)
 23204 call 37630
 23207 add ESP,2
 23210 rstack EAX,EBP:2
 23214 add EAX,2
 23217 mov EBX,EAX
 23219 mov EAX,#EBX
 23221 leave 
 23222 ret 
__869:
 23223 leave 
 23224 ret 
vector_get_capacity:
// vector_get_capacity(self)
 23225 enter -0
__872:
 23228 push 25691
 23231 rstack EAX,EBP:2
 23235 push EAX
 23237 mov ECX,2
// assert_type(...)
 23240 call 37630
 23243 add ESP,2
 23246 rstack EAX,EBP:2
 23250 add EAX,3
 23253 mov EBX,EAX
 23255 mov EAX,#EBX
 23257 leave 
 23258 ret 
__871:
 23259 leave 
 23260 ret 
vector_get_element_size:
// vector_get_element_size(self)
 23261 enter -0
__874:
 23264 push 25691
 23267 rstack EAX,EBP:2
 23271 push EAX
 23273 mov ECX,2
// assert_type(...)
 23276 call 37630
 23279 add ESP,2
 23282 rstack EAX,EBP:2
 23286 add EAX,4
 23289 mov EBX,EAX
 23291 mov EAX,#EBX
 23293 leave 
 23294 ret 
__873:
 23295 leave 
 23296 ret 
vector_set_array:
// vector_set_array(self,n)
 23297 enter -0
__876:
 23300 push 25691
 23303 rstack EAX,EBP:2
 23307 push EAX
 23309 mov ECX,2
// assert_type(...)
 23312 call 37630
 23315 add ESP,2
 23318 rstack EAX,EBP:3
 23322 rstack EBX,EBP:2
 23326 add EBX,1
 23329 mov ECX,EBX
// self[1]=n
 23331 mov #ECX,EAX
__875:
 23333 leave 
 23334 ret 
vector_set_size:
// vector_set_size(self,n)
 23335 enter -0
__878:
 23338 push 25691
 23341 rstack EAX,EBP:2
 23345 push EAX
 23347 mov ECX,2
// assert_type(...)
 23350 call 37630
 23353 add ESP,2
 23356 rstack EAX,EBP:3
 23360 rstack EBX,EBP:2
 23364 add EBX,2
 23367 mov ECX,EBX
// self[2]=n
 23369 mov #ECX,EAX
__877:
 23371 leave 
 23372 ret 
vector_set_capacity:
// vector_set_capacity(self,n)
 23373 enter -0
__880:
 23376 push 25691
 23379 rstack EAX,EBP:2
 23383 push EAX
 23385 mov ECX,2
// assert_type(...)
 23388 call 37630
 23391 add ESP,2
 23394 rstack EAX,EBP:3
 23398 rstack EBX,EBP:2
 23402 add EBX,3
 23405 mov ECX,EBX
// self[3]=n
 23407 mov #ECX,EAX
__879:
 23409 leave 
 23410 ret 
vector_set_element_size:
// vector_set_element_size(self,n)
 23411 enter -0
__882:
 23414 push 25691
 23417 rstack EAX,EBP:2
 23421 push EAX
 23423 mov ECX,2
// assert_type(...)
 23426 call 37630
 23429 add ESP,2
 23432 rstack EAX,EBP:3
 23436 rstack EBX,EBP:2
 23440 add EBX,4
 23443 mov ECX,EBX
// self[4]=n
 23445 mov #ECX,EAX
__881:
 23447 leave 
 23448 ret 
vector_destructor:
// vector_destructor(self)
 23449 enter -0
__884:
 23452 push 25691
 23455 rstack EAX,EBP:2
 23459 push EAX
 23461 mov ECX,2
// assert_type(...)
 23464 call 37630
 23467 add ESP,2
 23470 rstack EAX,EBP:2
 23474 add EAX,1
 23477 mov EBX,EAX
// free arg #1 (float* ptr)
 23479 push #EBX
 23481 mov ECX,1
// free(...)
 23484 call 21231
 23487 add ESP,1
__883:
 23490 leave 
 23491 ret 
vector_clear:
// vector_clear(self)
 23492 enter 1
__886:
 23495 push 25691
 23498 rstack EAX,EBP:2
 23502 push EAX
 23504 mov ECX,2
// assert_type(...)
 23507 call 37630
 23510 add ESP,2
 23513 rstack EAX,EBP:2
 23517 add EAX,2
 23520 mov EBX,EAX
 23522 sstack EBP:-1,#EBX
// self_size=0
 23526 sstack EBP:-1,0
 23531 rstack EAX,EBP:-1
 23535 rstack EBX,EBP:2
 23539 add EBX,2
 23542 mov ECX,EBX
// self[2]=self_size
 23544 mov #ECX,EAX
__885:
 23546 leave 
 23547 ret 
vector_push:
// vector_push(self,element)
 23548 enter 5
__888:
 23551 push 25691
 23554 rstack EAX,EBP:2
 23558 push EAX
 23560 mov ECX,2
// assert_type(...)
 23563 call 37630
 23566 add ESP,2
 23569 rstack EAX,EBP:2
 23573 add EAX,1
 23576 mov EBX,EAX
 23578 sstack EBP:-1,#EBX
 23582 rstack EAX,EBP:2
 23586 add EAX,2
 23589 mov EBX,EAX
 23591 sstack EBP:-2,#EBX
 23595 rstack EAX,EBP:2
 23599 add EAX,3
 23602 mov EBX,EAX
 23604 sstack EBP:-3,#EBX
 23608 rstack EAX,EBP:2
 23612 add EAX,4
 23615 mov EBX,EAX
 23617 sstack EBP:-4,#EBX
 23621 rstack EAX,EBP:-2
// self_size++
 23625 inc EAX
 23627 sstack EBP:-2,EAX
__890:
 23631 rstack EAX,EBP:-2
 23635 rstack EBX,EBP:-3
 23639 sub EBX,EAX
 23641 mov EAX,EBX
 23643 neg EAX
 23645 fsgn EAX,EAX
 23647 max EAX,0
// if (self_size>self_capacity)
 23650 cmp 0,EAX
 23653 jge 23761
 23656 rstack EAX,EBP:-3
 23660 add EAX,1
 23663 mov EBX,EAX
 23665 sstack EBP:-5,EBX
 23669 rstack EAX,EBP:-5
 23673 mul EAX,1.5
 23676 mov EBX,EAX
// newsize=newsize*1.5
 23678 sstack EBP:-5,EBX
 23682 rstack EAX,EBP:-5
// ceil arg #1 (float A)
 23686 push EAX
 23688 mov ECX,1
// ceil(...)
 23691 call 16728
 23694 add ESP,1
// newsize=ceil(newsize)
 23697 sstack EBP:-5,EAX
 23701 rstack EAX,EBP:-5
 23705 push EAX
 23707 rstack EAX,EBP:2
 23711 push EAX
 23713 mov ECX,2
// vector_resize(...)
 23716 call 25454
 23719 add ESP,2
// array=vector_resize(self,newsize)
 23722 sstack EBP:-1,EAX
__893:
 23726 rstack EAX,EBP:-1
 23730 mov EBX,0
 23733 sub EBX,EAX
 23735 fabs EBX,EBX
 23737 fsgn EBX,EBX
 23739 lneg EBX
// if (array==0)
 23741 cmp 0,EBX
 23744 jge 23761
 23747 push 23871
 23750 mov ECX,1
// Perr(...)
 23753 call 40763
 23756 add ESP,1
 23759 leave 
 23760 ret 
__894:
__892:
__891:
__889:
__897:
 23761 rstack EAX,EBP:-4
 23765 mov EBX,1
 23768 sub EBX,EAX
 23770 fabs EBX,EBX
 23772 fsgn EBX,EBX
 23774 lneg EBX
// if (element_size==1)
 23776 cmp 0,EBX
 23779 jge 23808
 23782 rstack EAX,EBP:3
 23786 rstack EBX,EBP:-2
 23790 add EBX,-1
 23793 mov ECX,EBX
 23795 rstack EBX,EBP:-1
 23799 add EBX,ECX
 23801 mov ECX,EBX
// array[self_size-1]=element
 23803 mov #ECX,EAX
 23805 jmp 23854
__899:
__898:
__901:
 23808 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 23812 push EAX
 23814 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 23818 push EAX
 23820 rstack EAX,EBP:-4
 23824 rstack EBX,EBP:-2
 23828 add EBX,-1
 23831 mov ECX,EBX
 23833 mul ECX,EAX
 23835 rstack EAX,EBP:-1
 23839 add EAX,ECX
 23841 mov EBX,EAX
// memcpy2 arg #1 (void* dest)
 23843 push EBX
 23845 mov ECX,3
// memcpy2(...)
 23848 call 22595
 23851 add ESP,3
__900:
__896:
 23854 rstack EAX,EBP:-2
 23858 rstack EBX,EBP:2
 23862 add EBX,2
 23865 mov ECX,EBX
// self[2]=self_size
 23867 mov #ECX,EAX
__887:
 23869 leave 
 23870 ret 
__895:
 23871 db "vector: can't resize
",0
vector_pop:
// vector_pop(self,element)
 23893 enter 5
__903:
 23896 push 25691
 23899 rstack EAX,EBP:2
 23903 push EAX
 23905 mov ECX,2
// assert_type(...)
 23908 call 37630
 23911 add ESP,2
 23914 rstack EAX,EBP:2
 23918 add EAX,1
 23921 mov EBX,EAX
 23923 sstack EBP:-1,#EBX
 23927 rstack EAX,EBP:2
 23931 add EAX,2
 23934 mov EBX,EAX
 23936 sstack EBP:-2,#EBX
 23940 rstack EAX,EBP:2
 23944 add EAX,3
 23947 mov EBX,EAX
 23949 sstack EBP:-3,#EBX
 23953 rstack EAX,EBP:2
 23957 add EAX,4
 23960 mov EBX,EAX
 23962 sstack EBP:-4,#EBX
__905:
 23966 rstack EAX,EBP:-2
 23970 mov EBX,0
 23973 sub EBX,EAX
 23975 fsgn EBX,EBX
 23977 inc EBX
 23979 max EBX,0
// if (self_size<=0)
 23982 cmp 0,EBX
 23985 jge 24000
// error arg #1 (float errno)
 23988 push 0
 23991 mov ECX,1
// error(...)
 23994 call 22767
 23997 add ESP,1
__906:
__904:
__908:
 24000 rstack EAX,EBP:3
 24004 mov EBX,0
 24007 sub EBX,EAX
 24009 fabs EBX,EBX
 24011 fsgn EBX,EBX
// if (element!=0)
 24013 cmp 0,EBX
 24016 jge 24062
 24019 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 24023 push EAX
 24025 rstack EAX,EBP:-4
 24029 rstack EBX,EBP:-2
 24033 mul EBX,EAX
 24035 mov EAX,EBX
 24037 rstack EBX,EBP:-1
 24041 add EBX,EAX
 24043 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 24045 push EAX
 24047 rstack EAX,EBP:3
// memcpy2 arg #1 (void* dest)
 24051 push EAX
 24053 mov ECX,3
// memcpy2(...)
 24056 call 22595
 24059 add ESP,3
__909:
__907:
 24062 rstack EAX,EBP:-4
 24066 rstack EBX,EBP:-2
 24070 add EBX,-1
 24073 mov ECX,EBX
 24075 mul ECX,EAX
 24077 rstack EAX,EBP:-1
 24081 add EAX,ECX
 24083 mov EBX,EAX
 24085 sstack EBP:-5,#EBX
 24089 rstack EAX,EBP:-2
// self_size--
 24093 dec EAX
 24095 sstack EBP:-2,EAX
 24099 rstack EAX,EBP:-2
 24103 rstack EBX,EBP:2
 24107 add EBX,2
 24110 mov ECX,EBX
// self[2]=self_size
 24112 mov #ECX,EAX
 24114 rstack EAX,EBP:-5
 24118 leave 
 24119 ret 
__902:
 24120 leave 
 24121 ret 
vector_size:
// vector_size(self)
 24122 enter -0
__911:
 24125 push 25691
 24128 rstack EAX,EBP:2
 24132 push EAX
 24134 mov ECX,2
// assert_type(...)
 24137 call 37630
 24140 add ESP,2
 24143 rstack EAX,EBP:2
 24147 add EAX,2
 24150 mov EBX,EAX
 24152 mov EAX,#EBX
 24154 leave 
 24155 ret 
__910:
 24156 leave 
 24157 ret 
vector_disk_size:
// vector_disk_size(self)
 24158 enter -0
__913:
 24161 push 25691
 24164 rstack EAX,EBP:2
 24168 push EAX
 24170 mov ECX,2
// assert_type(...)
 24173 call 37630
 24176 add ESP,2
 24179 rstack EAX,EBP:2
 24183 add EAX,4
 24186 mov EBX,EAX
 24188 rstack EAX,EBP:2
 24192 add EAX,2
 24195 mov ECX,EAX
 24197 mov EAX,#ECX
 24199 mul EAX,#EBX
 24201 leave 
 24202 ret 
__912:
 24203 leave 
 24204 ret 
vector_get:
// vector_get(self,element,pos)
 24205 enter 5
__915:
 24208 push 25691
 24211 rstack EAX,EBP:2
 24215 push EAX
 24217 mov ECX,2
// assert_type(...)
 24220 call 37630
 24223 add ESP,2
 24226 rstack EAX,EBP:2
 24230 add EAX,1
 24233 mov EBX,EAX
 24235 sstack EBP:-1,#EBX
 24239 rstack EAX,EBP:2
 24243 add EAX,2
 24246 mov EBX,EAX
 24248 sstack EBP:-2,#EBX
 24252 rstack EAX,EBP:2
 24256 add EAX,3
 24259 mov EBX,EAX
 24261 sstack EBP:-3,#EBX
 24265 rstack EAX,EBP:2
 24269 add EAX,4
 24272 mov EBX,EAX
 24274 sstack EBP:-4,#EBX
__917:
 24278 rstack EAX,EBP:4
 24282 rstack EBX,EBP:-2
 24286 sub EBX,EAX
 24288 mov EAX,EBX
 24290 neg EAX
 24292 fsgn EAX,EAX
 24294 inc EAX
 24296 max EAX,0
 24299 rstack EBX,EBP:4
 24303 mov ECX,0
 24306 sub ECX,EBX
 24308 fsgn ECX,ECX
 24310 max ECX,0
 24313 or ECX,EAX
// if ((pos<0)||(pos>=self_size))
 24315 cmp 0,ECX
 24318 jge 24333
// error arg #1 (float errno)
 24321 push 0
 24324 mov ECX,1
// error(...)
 24327 call 22767
 24330 add ESP,1
__918:
__916:
__920:
 24333 rstack EAX,EBP:3
 24337 mov EBX,0
 24340 sub EBX,EAX
 24342 fabs EBX,EBX
 24344 fsgn EBX,EBX
// if (element!=0)
 24346 cmp 0,EBX
 24349 jge 24395
 24352 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 24356 push EAX
 24358 rstack EAX,EBP:-4
 24362 rstack EBX,EBP:4
 24366 mul EBX,EAX
 24368 mov EAX,EBX
 24370 rstack EBX,EBP:-1
 24374 add EBX,EAX
 24376 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 24378 push EAX
 24380 rstack EAX,EBP:3
// memcpy2 arg #1 (void* dest)
 24384 push EAX
 24386 mov ECX,3
// memcpy2(...)
 24389 call 22595
 24392 add ESP,3
__921:
__919:
 24395 rstack EAX,EBP:-4
 24399 rstack EBX,EBP:4
 24403 mul EBX,EAX
 24405 mov EAX,EBX
 24407 rstack EBX,EBP:-1
 24411 add EBX,EAX
 24413 mov EAX,EBX
 24415 sstack EBP:-5,#EAX
 24419 rstack EAX,EBP:-5
 24423 leave 
 24424 ret 
__914:
 24425 leave 
 24426 ret 
vector_set:
// vector_set(self,element,pos)
 24427 enter 4
__923:
 24430 push 25691
 24433 rstack EAX,EBP:2
 24437 push EAX
 24439 mov ECX,2
// assert_type(...)
 24442 call 37630
 24445 add ESP,2
 24448 rstack EAX,EBP:2
 24452 add EAX,1
 24455 mov EBX,EAX
 24457 sstack EBP:-1,#EBX
 24461 rstack EAX,EBP:2
 24465 add EAX,2
 24468 mov EBX,EAX
 24470 sstack EBP:-2,#EBX
 24474 rstack EAX,EBP:2
 24478 add EAX,3
 24481 mov EBX,EAX
 24483 sstack EBP:-3,#EBX
 24487 rstack EAX,EBP:2
 24491 add EAX,4
 24494 mov EBX,EAX
 24496 sstack EBP:-4,#EBX
__925:
 24500 rstack EAX,EBP:4
 24504 rstack EBX,EBP:-2
 24508 sub EBX,EAX
 24510 mov EAX,EBX
 24512 fabs EAX,EAX
 24514 fsgn EAX,EAX
 24516 lneg EAX
// if (pos==self_size)
 24518 cmp 0,EAX
 24521 jge 24547
 24524 rstack EAX,EBP:3
// vector_push arg #2 (void* element)
 24528 push EAX
 24530 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 24534 push EAX
 24536 mov ECX,2
// vector_push(...)
 24539 call 23548
 24542 add ESP,2
 24545 leave 
 24546 ret 
__926:
__924:
__928:
 24547 rstack EAX,EBP:4
 24551 rstack EBX,EBP:-2
 24555 sub EBX,EAX
 24557 mov EAX,EBX
 24559 neg EAX
 24561 fsgn EAX,EAX
 24563 inc EAX
 24565 max EAX,0
 24568 rstack EBX,EBP:4
 24572 mov ECX,0
 24575 sub ECX,EBX
 24577 fsgn ECX,ECX
 24579 max ECX,0
 24582 or ECX,EAX
// if ((pos<0)||(pos>=self_size))
 24584 cmp 0,ECX
 24587 jge 24602
// error arg #1 (float errno)
 24590 push 0
 24593 mov ECX,1
// error(...)
 24596 call 22767
 24599 add ESP,1
__929:
__927:
__931:
 24602 rstack EAX,EBP:-4
 24606 mov EBX,1
 24609 sub EBX,EAX
 24611 fabs EBX,EBX
 24613 fsgn EBX,EBX
 24615 lneg EBX
// if (element_size==1)
 24617 cmp 0,EBX
 24620 jge 24644
 24623 rstack EAX,EBP:3
 24627 rstack EBX,EBP:4
 24631 rstack ECX,EBP:-1
 24635 add ECX,EBX
 24637 mov EBX,ECX
// array[pos]=element
 24639 mov #EBX,EAX
 24641 jmp 24687
__933:
__932:
__935:
 24644 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 24648 push EAX
 24650 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 24654 push EAX
 24656 rstack EAX,EBP:-4
 24660 rstack EBX,EBP:4
 24664 mul EBX,EAX
 24666 mov EAX,EBX
 24668 rstack EBX,EBP:-1
 24672 add EBX,EAX
 24674 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 24676 push EAX
 24678 mov ECX,3
// memcpy2(...)
 24681 call 22595
 24684 add ESP,3
__934:
__930:
__922:
 24687 leave 
 24688 ret 
vector_insert:
// vector_insert(self,element,pos)
 24689 enter 5
__937:
 24692 push 25691
 24695 rstack EAX,EBP:2
 24699 push EAX
 24701 mov ECX,2
// assert_type(...)
 24704 call 37630
 24707 add ESP,2
 24710 rstack EAX,EBP:2
 24714 add EAX,2
 24717 mov EBX,EAX
 24719 sstack EBP:-1,#EBX
 24723 rstack EAX,EBP:2
 24727 add EAX,3
 24730 mov EBX,EAX
 24732 sstack EBP:-2,#EBX
 24736 rstack EAX,EBP:2
 24740 add EAX,4
 24743 mov EBX,EAX
 24745 sstack EBP:-3,#EBX
__939:
 24749 rstack EAX,EBP:4
 24753 rstack EBX,EBP:-1
 24757 sub EBX,EAX
 24759 mov EAX,EBX
 24761 neg EAX
 24763 fsgn EAX,EAX
 24765 max EAX,0
 24768 rstack EBX,EBP:4
 24772 mov ECX,0
 24775 sub ECX,EBX
 24777 fsgn ECX,ECX
 24779 max ECX,0
 24782 or ECX,EAX
// if ((pos<0)||(pos>self_size))
 24784 cmp 0,ECX
 24787 jge 24802
// error arg #1 (float errno)
 24790 push 0
 24793 mov ECX,1
// error(...)
 24796 call 22767
 24799 add ESP,1
__940:
__938:
__942:
 24802 rstack EAX,EBP:4
 24806 rstack EBX,EBP:-1
 24810 sub EBX,EAX
 24812 mov EAX,EBX
 24814 fabs EAX,EAX
 24816 fsgn EAX,EAX
 24818 lneg EAX
// if (pos==self_size)
 24820 cmp 0,EAX
 24823 jge 24847
 24826 rstack EAX,EBP:3
// vector_push arg #2 (void* element)
 24830 push EAX
 24832 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 24836 push EAX
 24838 mov ECX,2
// vector_push(...)
 24841 call 23548
 24844 add ESP,2
__943:
__941:
 24847 rstack EAX,EBP:-1
// self_size++
 24851 inc EAX
 24853 sstack EBP:-1,EAX
__945:
 24857 rstack EAX,EBP:-1
 24861 rstack EBX,EBP:-2
 24865 sub EBX,EAX
 24867 mov EAX,EBX
 24869 neg EAX
 24871 fsgn EAX,EAX
 24873 max EAX,0
// if (self_size>self_capacity)
 24876 cmp 0,EAX
 24879 jge 24991
 24882 rstack EAX,EBP:-2
 24886 add EAX,1
 24889 mov EBX,EAX
 24891 sstack EBP:-4,EBX
 24895 rstack EAX,EBP:-4
 24899 mul EAX,1.5
 24902 mov EBX,EAX
// newsize=newsize*1.5
 24904 sstack EBP:-4,EBX
 24908 rstack EAX,EBP:-4
// ceil arg #1 (float A)
 24912 push EAX
 24914 mov ECX,1
// ceil(...)
 24917 call 16728
 24920 add ESP,1
// newsize=ceil(newsize)
 24923 sstack EBP:-4,EAX
 24927 rstack EAX,EBP:-4
 24931 push EAX
 24933 rstack EAX,EBP:2
 24937 push EAX
 24939 mov ECX,2
// vector_resize(...)
 24942 call 25454
 24945 add ESP,2
// array=vector_resize(self,newsize)
 24948 mov 16486,EAX
__948:
 24951 rstack EAX,EBP:-4
 24955 push EAX
 24957 rstack EAX,EBP:2
 24961 push EAX
 24963 mov ECX,2
// vector_resize(...)
 24966 call 25454
 24969 add ESP,2
 24972 mov EBX,0
 24975 sub EBX,EAX
 24977 fabs EBX,EBX
 24979 fsgn EBX,EBX
 24981 lneg EBX
// if (vector_resize(self,newsize)==0)
 24983 cmp 0,EBX
 24986 jge 24991
 24989 leave 
 24990 ret 
__949:
__947:
__946:
__944:
 24991 rstack EAX,EBP:2
 24995 add EAX,1
 24998 mov EBX,EAX
 25000 sstack EBP:-5,#EBX
 25004 rstack EAX,EBP:4
 25008 neg EAX
 25010 mov EBX,EAX
 25012 add EBX,-1
 25015 rstack EAX,EBP:-1
 25019 add EAX,EBX
 25021 mov EBX,EAX
// memcpy2 arg #3 (float n)
 25023 push EBX
 25025 rstack EAX,EBP:-3
 25029 rstack EBX,EBP:4
 25033 mul EBX,EAX
 25035 mov EAX,EBX
 25037 rstack EBX,EBP:-5
 25041 add EBX,EAX
 25043 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 25045 push EAX
 25047 rstack EAX,EBP:-3
 25051 rstack EBX,EBP:4
 25055 add EBX,1
 25058 mov ECX,EBX
 25060 mul ECX,EAX
 25062 rstack EAX,EBP:-5
 25066 add EAX,ECX
 25068 mov EBX,EAX
// memcpy2 arg #1 (void* dest)
 25070 push EBX
 25072 mov ECX,3
// memcpy2(...)
 25075 call 22595
 25078 add ESP,3
__951:
 25081 rstack EAX,EBP:-3
 25085 mov EBX,1
 25088 sub EBX,EAX
 25090 fabs EBX,EBX
 25092 fsgn EBX,EBX
 25094 lneg EBX
// if (element_size==1)
 25096 cmp 0,EBX
 25099 jge 25123
 25102 rstack EAX,EBP:3
 25106 rstack EBX,EBP:4
 25110 rstack ECX,EBP:-5
 25114 add ECX,EBX
 25116 mov EBX,ECX
// array[pos]=element
 25118 mov #EBX,EAX
 25120 jmp 25166
__953:
__952:
__955:
 25123 rstack EAX,EBP:-3
// memcpy2 arg #3 (float n)
 25127 push EAX
 25129 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 25133 push EAX
 25135 rstack EAX,EBP:-3
 25139 rstack EBX,EBP:4
 25143 mul EBX,EAX
 25145 mov EAX,EBX
 25147 rstack EBX,EBP:-5
 25151 add EBX,EAX
 25153 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 25155 push EAX
 25157 mov ECX,3
// memcpy2(...)
 25160 call 22595
 25163 add ESP,3
__954:
__950:
 25166 rstack EAX,EBP:-1
 25170 rstack EBX,EBP:2
 25174 add EBX,2
 25177 mov ECX,EBX
// self[2]=self_size
 25179 mov #ECX,EAX
__936:
 25181 leave 
 25182 ret 
vector_remove:
// vector_remove(self,pos)
 25183 enter 4
__957:
 25186 push 25691
 25189 rstack EAX,EBP:2
 25193 push EAX
 25195 mov ECX,2
// assert_type(...)
 25198 call 37630
 25201 add ESP,2
 25204 rstack EAX,EBP:2
 25208 add EAX,1
 25211 mov EBX,EAX
 25213 sstack EBP:-1,#EBX
 25217 rstack EAX,EBP:2
 25221 add EAX,2
 25224 mov EBX,EAX
 25226 sstack EBP:-2,#EBX
 25230 rstack EAX,EBP:2
 25234 add EAX,3
 25237 mov EBX,EAX
 25239 sstack EBP:-3,#EBX
 25243 rstack EAX,EBP:2
 25247 add EAX,4
 25250 mov EBX,EAX
 25252 sstack EBP:-4,#EBX
__959:
 25256 rstack EAX,EBP:3
 25260 rstack EBX,EBP:-2
 25264 sub EBX,EAX
 25266 mov EAX,EBX
 25268 neg EAX
 25270 fsgn EAX,EAX
 25272 max EAX,0
 25275 rstack EBX,EBP:3
 25279 mov ECX,0
 25282 sub ECX,EBX
 25284 fsgn ECX,ECX
 25286 max ECX,0
 25289 or ECX,EAX
// if ((pos<0)||(pos>self_size))
 25291 cmp 0,ECX
 25294 jge 25309
// error arg #1 (float errno)
 25297 push 0
 25300 mov ECX,1
// error(...)
 25303 call 22767
 25306 add ESP,1
__960:
__958:
__962:
 25309 rstack EAX,EBP:3
 25313 rstack EBX,EBP:-2
 25317 sub EBX,EAX
 25319 mov EAX,EBX
 25321 fabs EAX,EAX
 25323 fsgn EAX,EAX
 25325 lneg EAX
// if (pos==self_size)
 25327 cmp 0,EAX
 25330 jge 25353
// vector_pop arg #2 (void* element)
 25333 push 0
 25336 rstack EAX,EBP:2
// vector_pop arg #1 (void* self)
 25340 push EAX
 25342 mov ECX,2
// vector_pop(...)
 25345 call 23893
 25348 add ESP,2
 25351 leave 
 25352 ret 
__963:
__961:
 25353 rstack EAX,EBP:3
 25357 neg EAX
 25359 mov EBX,EAX
 25361 rstack EAX,EBP:-2
 25365 add EAX,EBX
 25367 mov EBX,EAX
// memcpy2 arg #3 (float n)
 25369 push EBX
 25371 rstack EAX,EBP:-4
 25375 rstack EBX,EBP:3
 25379 add EBX,1
 25382 mov ECX,EBX
 25384 mul ECX,EAX
 25386 rstack EAX,EBP:-1
 25390 add EAX,ECX
 25392 mov EBX,EAX
// memcpy2 arg #2 (void* src)
 25394 push EBX
 25396 rstack EAX,EBP:-4
 25400 rstack EBX,EBP:3
 25404 mul EBX,EAX
 25406 mov EAX,EBX
 25408 rstack EBX,EBP:-1
 25412 add EBX,EAX
 25414 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 25416 push EAX
 25418 mov ECX,3
// memcpy2(...)
 25421 call 22595
 25424 add ESP,3
 25427 rstack EAX,EBP:-2
// self_size--
 25431 dec EAX
 25433 sstack EBP:-2,EAX
 25437 rstack EAX,EBP:-2
 25441 rstack EBX,EBP:2
 25445 add EBX,2
 25448 mov ECX,EBX
// self[2]=self_size
 25450 mov #ECX,EAX
__956:
 25452 leave 
 25453 ret 
vector_resize:
// vector_resize(self,newcap)
 25454 enter 5
__965:
 25457 push 25691
 25460 rstack EAX,EBP:2
 25464 push EAX
 25466 mov ECX,2
// assert_type(...)
 25469 call 37630
 25472 add ESP,2
 25475 rstack EAX,EBP:2
 25479 add EAX,1
 25482 mov EBX,EAX
 25484 sstack EBP:-1,#EBX
 25488 rstack EAX,EBP:2
 25492 add EAX,2
 25495 mov EBX,EAX
 25497 sstack EBP:-2,#EBX
 25501 rstack EAX,EBP:2
 25505 add EAX,3
 25508 mov EBX,EAX
 25510 sstack EBP:-3,#EBX
 25514 rstack EAX,EBP:2
 25518 add EAX,4
 25521 mov EBX,EAX
 25523 sstack EBP:-4,#EBX
 25527 rstack EAX,EBP:-1
 25531 sstack EBP:-5,EAX
 25535 rstack EAX,EBP:3
 25539 rstack EBX,EBP:-4
 25543 mul EBX,EAX
 25545 mov EAX,EBX
// realloc arg #2 (float n)
 25547 push EAX
 25549 rstack EAX,EBP:-1
// realloc arg #1 (float* ptr)
 25553 push EAX
 25555 mov ECX,2
// realloc(...)
 25558 call 21903
 25561 add ESP,2
// array=realloc(array,element_size*newcap)
 25564 sstack EBP:-1,EAX
__967:
 25568 rstack EAX,EBP:-1
 25572 mov EBX,0
 25575 sub EBX,EAX
 25577 fabs EBX,EBX
 25579 fsgn EBX,EBX
 25581 lneg EBX
// if (array==0)
 25583 cmp 0,EBX
 25586 jge 25594
 25589 mov EAX,0
 25592 leave 
 25593 ret 
__968:
__966:
 25594 rstack EAX,EBP:3
// self_capacity=newcap
 25598 sstack EBP:-3,EAX
 25602 rstack EAX,EBP:-1
 25606 rstack EBX,EBP:2
 25610 add EBX,1
 25613 mov ECX,EBX
// self[1]=array
 25615 mov #ECX,EAX
 25617 rstack EAX,EBP:-2
 25621 rstack EBX,EBP:2
 25625 add EBX,2
 25628 mov ECX,EBX
// self[2]=self_size
 25630 mov #ECX,EAX
 25632 rstack EAX,EBP:-3
 25636 rstack EBX,EBP:2
 25640 add EBX,3
 25643 mov ECX,EBX
// self[3]=self_capacity
 25645 mov #ECX,EAX
 25647 rstack EAX,EBP:-1
 25651 leave 
 25652 ret 
__964:
 25653 leave 
 25654 ret 
vector_array:
// vector_array(self)
 25655 enter -0
__970:
 25658 push 25691
 25661 rstack EAX,EBP:2
 25665 push EAX
 25667 mov ECX,2
// assert_type(...)
 25670 call 37630
 25673 add ESP,2
 25676 rstack EAX,EBP:2
 25680 add EAX,1
 25683 mov EBX,EAX
 25685 mov EAX,#EBX
 25687 leave 
 25688 ret 
__969:
 25689 leave 
 25690 ret 
ZVECTOR_CONSTANTS:
typeof_vector:
 25691 db "vector"
 25697 db 0
ZVECTOR_VARS:
ZVECTOR_END:
ZSTRING_CODE:
string_constructor:
// string_constructor(self,str)
 25698 enter 1
__972:
// vector_constructor arg #2 (float element_size)
 25701 push 1
 25704 rstack EAX,EBP:2
// vector_constructor arg #1 (void* self)
 25708 push EAX
 25710 mov ECX,2
// vector_constructor(...)
 25713 call 22843
 25716 add ESP,2
 25719 rstack EAX,EBP:3
// strlen arg #1 (char* str)
 25723 push EAX
 25725 mov ECX,1
// strlen(...)
 25728 call 10743
 25731 add ESP,1
 25734 sstack EBP:-1,EAX
 25738 rstack EAX,EBP:-1
 25742 add EAX,1
 25745 mov EBX,EAX
// vector_resize arg #2 (float newcap)
 25747 push EBX
 25749 rstack EAX,EBP:2
// vector_resize arg #1 (void* self)
 25753 push EAX
 25755 mov ECX,2
// vector_resize(...)
 25758 call 25454
 25761 add ESP,2
// vector_push arg #2 (void* element)
 25764 push 0
 25767 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 25771 push EAX
 25773 mov ECX,2
// vector_push(...)
 25776 call 23548
 25779 add ESP,2
 25782 rstack EAX,EBP:3
 25786 push EAX
 25788 rstack EAX,EBP:2
 25792 push EAX
 25794 mov ECX,2
// string_addcs(...)
 25797 call 26168
 25800 add ESP,2
__971:
 25803 leave 
 25804 ret 
string_destructor:
// string_destructor(self)
 25805 enter -0
__974:
 25808 rstack EAX,EBP:2
// vector_destructor arg #1 (void* self)
 25812 push EAX
 25814 mov ECX,1
// vector_destructor(...)
 25817 call 23449
 25820 add ESP,1
__973:
 25823 leave 
 25824 ret 
string_c_str:
// string_c_str(self)
 25825 enter -0
__976:
 25828 rstack EAX,EBP:2
// vector_array arg #1 (void* self)
 25832 push EAX
 25834 mov ECX,1
// vector_array(...)
 25837 call 25655
 25840 add ESP,1
 25843 leave 
 25844 ret 
__975:
 25845 leave 
 25846 ret 
string_clear:
// string_clear(self)
 25847 enter -0
__978:
 25850 rstack EAX,EBP:2
// vector_clear arg #1 (void* self)
 25854 push EAX
 25856 mov ECX,1
// vector_clear(...)
 25859 call 23492
 25862 add ESP,1
// vector_push arg #2 (void* element)
 25865 push 0
 25868 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 25872 push EAX
 25874 mov ECX,2
// vector_push(...)
 25877 call 23548
 25880 add ESP,2
__977:
 25883 leave 
 25884 ret 
string_adds:
// string_adds(self,str)
 25885 enter -0
__980:
 25888 rstack EAX,EBP:3
// vector_array arg #1 (void* self)
 25892 push EAX
 25894 mov ECX,1
// vector_array(...)
 25897 call 25655
 25900 add ESP,1
 25903 push EAX
 25905 rstack EAX,EBP:2
 25909 push EAX
 25911 mov ECX,2
// string_addcs(...)
 25914 call 26168
 25917 add ESP,2
__979:
 25920 leave 
 25921 ret 
string_addc:
// string_addc(self,C)
 25922 enter 1
__982:
// vector_pop arg #2 (void* element)
 25925 push 0
 25928 rstack EAX,EBP:2
// vector_pop arg #1 (void* self)
 25932 push EAX
 25934 mov ECX,2
// vector_pop(...)
 25937 call 23893
 25940 add ESP,2
 25943 sstack EBP:-1,EAX
 25947 rstack EAX,EBP:3
// vector_push arg #2 (void* element)
 25951 push EAX
 25953 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 25957 push EAX
 25959 mov ECX,2
// vector_push(...)
 25962 call 23548
 25965 add ESP,2
 25968 rstack EAX,EBP:-1
// vector_push arg #2 (void* element)
 25972 push EAX
 25974 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 25978 push EAX
 25980 mov ECX,2
// vector_push(...)
 25983 call 23548
 25986 add ESP,2
__981:
 25989 leave 
 25990 ret 
string_addn:
// string_addn(self,N)
 25991 enter -0
__984:
 25994 rstack EAX,EBP:3
// num2str arg #1 (float num)
 25998 push EAX
 26000 mov ECX,1
// num2str(...)
 26003 call 12958
 26006 add ESP,1
 26009 push EAX
 26011 rstack EAX,EBP:2
 26015 push EAX
 26017 mov ECX,2
// string_addcs(...)
 26020 call 26168
 26023 add ESP,2
__983:
 26026 leave 
 26027 ret 
string_equals:
// string_equals(self,str)
 26028 enter -0
__986:
 26031 rstack EAX,EBP:3
// string_c_str arg #1 (void* self)
 26035 push EAX
 26037 mov ECX,1
// string_c_str(...)
 26040 call 25825
 26043 add ESP,1
// strcmp arg #2 (char* dest)
 26046 push EAX
 26048 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 26052 push EAX
 26054 mov ECX,1
// string_c_str(...)
 26057 call 25825
 26060 add ESP,1
// strcmp arg #1 (char* src)
 26063 push EAX
 26065 mov ECX,2
// strcmp(...)
 26068 call 10414
 26071 add ESP,2
 26074 mov EBX,0
 26077 sub EBX,EAX
 26079 fabs EBX,EBX
 26081 fsgn EBX,EBX
 26083 lneg EBX
 26085 mov EAX,EBX
 26087 leave 
 26088 ret 
__985:
 26089 leave 
 26090 ret 
string_equals_cs:
// string_equals_cs(self,str)
 26091 enter -0
__988:
 26094 rstack EAX,EBP:3
// strcmp arg #2 (char* dest)
 26098 push EAX
 26100 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 26104 push EAX
 26106 mov ECX,1
// string_c_str(...)
 26109 call 25825
 26112 add ESP,1
// strcmp arg #1 (char* src)
 26115 push EAX
 26117 mov ECX,2
// strcmp(...)
 26120 call 10414
 26123 add ESP,2
 26126 mov EBX,0
 26129 sub EBX,EAX
 26131 fabs EBX,EBX
 26133 fsgn EBX,EBX
 26135 lneg EBX
 26137 mov EAX,EBX
 26139 leave 
 26140 ret 
__987:
 26141 leave 
 26142 ret 
string_length:
// string_length(self)
 26143 enter -0
__990:
 26146 rstack EAX,EBP:2
// vector_size arg #1 (void* self)
 26150 push EAX
 26152 mov ECX,1
// vector_size(...)
 26155 call 24122
 26158 add ESP,1
 26161 add EAX,-1
 26164 leave 
 26165 ret 
__989:
 26166 leave 
 26167 ret 
string_addcs:
// string_addcs(self,c_str)
 26168 enter 3
__992:
 26171 sstack EBP:-1,0
 26176 sstack EBP:-2,0
 26181 sstack EBP:-3,0
string_addcs_loop:
 26186 rstack EAX,EBP:-1
 26190 rstack EBX,EBP:3
 26194 add EBX,EAX
 26196 mov EAX,EBX
// C=c_str[I]
 26198 sstack EBP:-2,#EAX
__994:
 26202 rstack EAX,EBP:-2
 26206 mov EBX,0
 26209 sub EBX,EAX
 26211 fabs EBX,EBX
 26213 fsgn EBX,EBX
// if (C!=0)
 26215 cmp 0,EBX
 26218 jge 26298
// vector_pop arg #2 (void* element)
 26221 push 0
 26224 rstack EAX,EBP:2
// vector_pop arg #1 (void* self)
 26228 push EAX
 26230 mov ECX,2
// vector_pop(...)
 26233 call 23893
 26236 add ESP,2
// CEOF=vector_pop(self,0)
 26239 sstack EBP:-3,EAX
 26243 rstack EAX,EBP:-2
// vector_push arg #2 (void* element)
 26247 push EAX
 26249 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 26253 push EAX
 26255 mov ECX,2
// vector_push(...)
 26258 call 23548
 26261 add ESP,2
 26264 rstack EAX,EBP:-3
// vector_push arg #2 (void* element)
 26268 push EAX
 26270 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 26274 push EAX
 26276 mov ECX,2
// vector_push(...)
 26279 call 23548
 26282 add ESP,2
 26285 rstack EAX,EBP:-1
// I++
 26289 inc EAX
 26291 sstack EBP:-1,EAX
 26295 jmp 26186
__995:
__993:
__991:
 26298 leave 
 26299 ret 
string_find_first_of:
// string_find_first_of(self,C)
 26300 enter 3
__997:
 26303 sstack EBP:-1,0
 26308 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 26312 push EAX
 26314 mov ECX,1
// string_c_str(...)
 26317 call 25825
 26320 add ESP,1
 26323 sstack EBP:-2,EAX
 26327 rstack EAX,EBP:-1
 26331 rstack EBX,EBP:-2
 26335 add EBX,EAX
 26337 mov EAX,EBX
 26339 sstack EBP:-3,#EAX
__999:
 26343 rstack EAX,EBP:-3
 26347 mov EBX,0
 26350 sub EBX,EAX
 26352 fabs EBX,EBX
 26354 fsgn EBX,EBX
// if (C1!=0
 26356 cmp 0,EBX
 26359 jz 26421
__1001:
 26362 rstack EAX,EBP:-3
 26366 rstack EBX,EBP:3
 26370 sub EBX,EAX
 26372 mov EAX,EBX
 26374 fabs EAX,EAX
 26376 fsgn EAX,EAX
 26378 lneg EAX
// if (C1==C)
 26380 cmp 0,EAX
 26383 jge 26392
 26386 rstack EAX,EBP:-1
 26390 leave 
 26391 ret 
__1002:
__1000:
 26392 rstack EAX,EBP:-1
// I++
 26396 inc EAX
 26398 sstack EBP:-1,EAX
 26402 rstack EAX,EBP:-1
 26406 rstack EBX,EBP:-2
 26410 add EBX,EAX
 26412 mov EAX,EBX
// C1=S[I]
 26414 sstack EBP:-3,#EAX
 26418 jmp 26343
__998:
 26421 mov EAX,-1
 26424 leave 
 26425 ret 
__996:
 26426 leave 
 26427 ret 
string_find_last_of:
// string_find_last_of(self,C)
 26428 enter 3
__1004:
 26431 rstack EAX,EBP:2
// string_length arg #1 (void* self)
 26435 push EAX
 26437 mov ECX,1
// string_length(...)
 26440 call 26143
 26443 add ESP,1
 26446 add EAX,-1
 26449 sstack EBP:-1,EAX
 26453 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 26457 push EAX
 26459 mov ECX,1
// string_c_str(...)
 26462 call 25825
 26465 add ESP,1
 26468 sstack EBP:-2,EAX
 26472 rstack EAX,EBP:-1
 26476 rstack EBX,EBP:-2
 26480 add EBX,EAX
 26482 mov EAX,EBX
 26484 sstack EBP:-3,#EAX
__1006:
 26488 rstack EAX,EBP:-1
 26492 mov EBX,-1
 26495 sub EBX,EAX
 26497 fabs EBX,EBX
 26499 fsgn EBX,EBX
// if (I!=-1
 26501 cmp 0,EBX
 26504 jz 26566
__1008:
 26507 rstack EAX,EBP:-3
 26511 rstack EBX,EBP:3
 26515 sub EBX,EAX
 26517 mov EAX,EBX
 26519 fabs EAX,EAX
 26521 fsgn EAX,EAX
 26523 lneg EAX
// if (C1==C)
 26525 cmp 0,EAX
 26528 jge 26537
 26531 rstack EAX,EBP:-1
 26535 leave 
 26536 ret 
__1009:
__1007:
 26537 rstack EAX,EBP:-1
// I--
 26541 dec EAX
 26543 sstack EBP:-1,EAX
 26547 rstack EAX,EBP:-1
 26551 rstack EBX,EBP:-2
 26555 add EBX,EAX
 26557 mov EAX,EBX
// C1=S[I]
 26559 sstack EBP:-3,#EAX
 26563 jmp 26488
__1005:
 26566 mov EAX,-1
 26569 leave 
 26570 ret 
__1003:
 26571 leave 
 26572 ret 
string_substr:
// string_substr(self,start1,count)
 26573 enter 3
__1011:
// malloc arg #1 (float n)
 26576 push #22842
 26579 mov ECX,1
// malloc(...)
 26582 call 20709
 26585 add ESP,1
 26588 sstack EBP:-1,EAX
 26592 rstack EAX,EBP:2
// string_length arg #1 (void* self)
 26596 push EAX
 26598 mov ECX,1
// string_length(...)
 26601 call 26143
 26604 add ESP,1
 26607 sstack EBP:-2,EAX
// string_constructor arg #2 (char* str)
 26611 push 26784
 26614 rstack EAX,EBP:-1
// string_constructor arg #1 (void* self)
 26618 push EAX
 26620 mov ECX,2
// string_constructor(...)
 26623 call 25698
 26626 add ESP,2
__1014:
 26629 rstack EAX,EBP:4
 26633 mov EBX,0
 26636 sub EBX,EAX
 26638 fsgn EBX,EBX
 26640 max EBX,0
// if (count<0)
 26643 cmp 0,EBX
 26646 jge 26657
 26649 rstack EAX,EBP:-2
// count=maxlen
 26653 sstack EBP:4,EAX
__1015:
__1013:
__1017:
 26657 rstack EAX,EBP:4
 26661 mov EBX,0
 26664 sub EBX,EAX
 26666 fabs EBX,EBX
 26668 fsgn EBX,EBX
 26670 lneg EBX
// if (count==0)
 26672 cmp 0,EBX
 26675 jge 26684
 26678 rstack EAX,EBP:-1
 26682 leave 
 26683 ret 
__1018:
__1016:
 26684 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 26688 push EAX
 26690 mov ECX,1
// string_c_str(...)
 26693 call 25825
 26696 add ESP,1
 26699 sstack EBP:-3,EAX
string_substr_loop:
 26703 rstack EAX,EBP:3
 26707 rstack EBX,EBP:-3
 26711 add EBX,EAX
 26713 mov EAX,EBX
// string_addc arg #2 (char C)
 26715 push #EAX
 26717 rstack EAX,EBP:-1
// string_addc arg #1 (void* self)
 26721 push EAX
 26723 mov ECX,2
// string_addc(...)
 26726 call 25922
 26729 add ESP,2
 26732 rstack EAX,EBP:3
// start1++
 26736 inc EAX
 26738 sstack EBP:3,EAX
 26742 rstack EAX,EBP:4
// count--
 26746 dec EAX
 26748 sstack EBP:4,EAX
__1020:
 26752 rstack EAX,EBP:4
 26756 mov EBX,0
 26759 sub EBX,EAX
 26761 fabs EBX,EBX
 26763 fsgn EBX,EBX
 26765 lneg EBX
// if (count==0)
 26767 cmp 0,EBX
 26770 jge 26779
 26773 rstack EAX,EBP:-1
 26777 leave 
 26778 ret 
__1021:
__1019:
 26779 jmp 26703
__1010:
 26782 leave 
 26783 ret 
__1012:
 26784 db "",0
ZSTRING_CONSTANTS:
ZSTRING_VARS:
ZSTRING_END:
ZLIST_CODE:
sizeof_listnode:
 26785 db 3
sizeof_list:
 26786 db 2
list_constructor:
// list_constructor(list,new_element_size)
 26787 enter 2
__1023:
 26790 rstack EAX,EBP:2
 26794 add EAX,0
 26797 mov EBX,EAX
 26799 sstack EBP:-1,#EBX
 26803 rstack EAX,EBP:2
 26807 add EAX,1
 26810 mov EBX,EAX
 26812 sstack EBP:-2,#EBX
 26816 rstack EAX,EBP:3
// element_size=new_element_size
 26820 sstack EBP:-1,EAX
// first=0
 26824 sstack EBP:-2,0
 26829 rstack EAX,EBP:-1
 26833 rstack EBX,EBP:2
 26837 add EBX,0
 26840 mov ECX,EBX
// list[0]=element_size
 26842 mov #ECX,EAX
 26844 rstack EAX,EBP:-2
 26848 rstack EBX,EBP:2
 26852 add EBX,1
 26855 mov ECX,EBX
// list[1]=first
 26857 mov #ECX,EAX
__1022:
 26859 leave 
 26860 ret 
listnode_constructor:
// listnode_constructor(node)
 26861 enter 3
__1025:
 26864 rstack EAX,EBP:2
 26868 add EAX,0
 26871 mov EBX,EAX
 26873 sstack EBP:-1,#EBX
 26877 rstack EAX,EBP:2
 26881 add EAX,1
 26884 mov EBX,EAX
 26886 sstack EBP:-2,#EBX
 26890 rstack EAX,EBP:2
 26894 add EAX,2
 26897 mov EBX,EAX
 26899 sstack EBP:-3,#EBX
// prev=0
 26903 sstack EBP:-1,0
// next=0
 26908 sstack EBP:-2,0
// datas=0
 26913 sstack EBP:-3,0
 26918 rstack EAX,EBP:-1
 26922 rstack EBX,EBP:2
 26926 add EBX,0
 26929 mov ECX,EBX
// node[0]=prev
 26931 mov #ECX,EAX
 26933 rstack EAX,EBP:-2
 26937 rstack EBX,EBP:2
 26941 add EBX,1
 26944 mov ECX,EBX
// node[1]=next
 26946 mov #ECX,EAX
 26948 rstack EAX,EBP:-3
 26952 rstack EBX,EBP:2
 26956 add EBX,2
 26959 mov ECX,EBX
// node[2]=datas
 26961 mov #ECX,EAX
__1024:
 26963 leave 
 26964 ret 
listnode_destructor:
// listnode_destructor(node)
 26965 enter 3
__1027:
 26968 rstack EAX,EBP:2
 26972 add EAX,0
 26975 mov EBX,EAX
 26977 sstack EBP:-1,#EBX
 26981 rstack EAX,EBP:2
 26985 add EAX,1
 26988 mov EBX,EAX
 26990 sstack EBP:-2,#EBX
 26994 rstack EAX,EBP:2
 26998 add EAX,2
 27001 mov EBX,EAX
 27003 sstack EBP:-3,#EBX
__1029:
 27007 rstack EAX,EBP:-2
// if (next)
 27011 cmp 0,EAX
 27014 jge 27047
 27017 rstack EAX,EBP:-2
// listnode_destructor arg #1 (void* node)
 27021 push EAX
 27023 mov ECX,1
// listnode_destructor(...)
 27026 call 26965
 27029 add ESP,1
 27032 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 27036 push EAX
 27038 mov ECX,1
// free(...)
 27041 call 21231
 27044 add ESP,1
__1030:
__1028:
 27047 rstack EAX,EBP:-3
// free arg #1 (float* ptr)
 27051 push EAX
 27053 mov ECX,1
// free(...)
 27056 call 21231
 27059 add ESP,1
 27062 rstack EAX,EBP:-1
 27066 rstack EBX,EBP:2
 27070 add EBX,0
 27073 mov ECX,EBX
// node[0]=prev
 27075 mov #ECX,EAX
 27077 rstack EAX,EBP:-2
 27081 rstack EBX,EBP:2
 27085 add EBX,1
 27088 mov ECX,EBX
// node[1]=next
 27090 mov #ECX,EAX
 27092 rstack EAX,EBP:-3
 27096 rstack EBX,EBP:2
 27100 add EBX,2
 27103 mov ECX,EBX
// node[2]=datas
 27105 mov #ECX,EAX
__1026:
 27107 leave 
 27108 ret 
list_size:
// list_size(list)
 27109 enter 2
__1032:
 27112 rstack EAX,EBP:2
 27116 add EAX,0
 27119 mov EBX,EAX
 27121 sstack EBP:-1,#EBX
 27125 rstack EAX,EBP:2
 27129 add EAX,1
 27132 mov EBX,EAX
 27134 sstack EBP:-2,#EBX
__1034:
 27138 rstack EAX,EBP:-2
// if (first)
 27142 cmp 0,EAX
 27145 jge 27168
 27148 rstack EAX,EBP:-2
 27152 push EAX
 27154 mov ECX,1
// list_size_helper(...)
 27157 call 27205
 27160 add ESP,1
 27163 leave 
 27164 ret 
 27165 jmp 27173
__1036:
__1035:
__1038:
 27168 mov EAX,0
 27171 leave 
 27172 ret 
__1037:
__1033:
 27173 rstack EAX,EBP:-1
 27177 rstack EBX,EBP:2
 27181 add EBX,0
 27184 mov ECX,EBX
// list[0]=element_size
 27186 mov #ECX,EAX
 27188 rstack EAX,EBP:-2
 27192 rstack EBX,EBP:2
 27196 add EBX,1
 27199 mov ECX,EBX
// list[1]=first
 27201 mov #ECX,EAX
__1031:
 27203 leave 
 27204 ret 
list_size_helper:
// list_size_helper(node)
 27205 enter 3
__1040:
 27208 rstack EAX,EBP:2
 27212 add EAX,0
 27215 mov EBX,EAX
 27217 sstack EBP:-1,#EBX
 27221 rstack EAX,EBP:2
 27225 add EAX,1
 27228 mov EBX,EAX
 27230 sstack EBP:-2,#EBX
 27234 rstack EAX,EBP:2
 27238 add EAX,2
 27241 mov EBX,EAX
 27243 sstack EBP:-3,#EBX
__1042:
 27247 rstack EAX,EBP:-2
// if (next)
 27251 cmp 0,EAX
 27254 jge 27280
 27257 rstack EAX,EBP:2
// list_size_helper arg #1 (void* node)
 27261 push EAX
 27263 mov ECX,1
// list_size_helper(...)
 27266 call 27205
 27269 add ESP,1
 27272 add EAX,1
 27275 leave 
 27276 ret 
 27277 jmp 27285
__1044:
__1043:
__1046:
 27280 mov EAX,1
 27283 leave 
 27284 ret 
__1045:
__1041:
 27285 rstack EAX,EBP:-1
 27289 rstack EBX,EBP:2
 27293 add EBX,0
 27296 mov ECX,EBX
// node[0]=prev
 27298 mov #ECX,EAX
 27300 rstack EAX,EBP:-2
 27304 rstack EBX,EBP:2
 27308 add EBX,1
 27311 mov ECX,EBX
// node[1]=next
 27313 mov #ECX,EAX
 27315 rstack EAX,EBP:-3
 27319 rstack EBX,EBP:2
 27323 add EBX,2
 27326 mov ECX,EBX
// node[2]=datas
 27328 mov #ECX,EAX
__1039:
 27330 leave 
 27331 ret 
list_empty:
// list_empty(list)
 27332 enter -0
__1048:
 27335 rstack EAX,EBP:2
// list_size arg #1 (void* list)
 27339 push EAX
 27341 mov ECX,1
// list_size(...)
 27344 call 27109
 27347 add ESP,1
 27350 mov EBX,0
 27353 sub EBX,EAX
 27355 fabs EBX,EBX
 27357 fsgn EBX,EBX
 27359 lneg EBX
 27361 mov EAX,EBX
 27363 leave 
 27364 ret 
__1047:
 27365 leave 
 27366 ret 
list_clear:
// list_clear(list)
 27367 enter 2
__1050:
 27370 rstack EAX,EBP:2
 27374 add EAX,0
 27377 mov EBX,EAX
 27379 sstack EBP:-1,#EBX
 27383 rstack EAX,EBP:2
 27387 add EAX,1
 27390 mov EBX,EAX
 27392 sstack EBP:-2,#EBX
__1052:
 27396 rstack EAX,EBP:-2
// if (first)
 27400 cmp 0,EAX
 27403 jge 27441
 27406 rstack EAX,EBP:-2
// listnode_destructor arg #1 (void* node)
 27410 push EAX
 27412 mov ECX,1
// listnode_destructor(...)
 27415 call 26965
 27418 add ESP,1
 27421 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 27425 push EAX
 27427 mov ECX,1
// free(...)
 27430 call 21231
 27433 add ESP,1
// first=0
 27436 sstack EBP:-2,0
__1053:
__1051:
 27441 rstack EAX,EBP:-1
 27445 rstack EBX,EBP:2
 27449 add EBX,0
 27452 mov ECX,EBX
// list[0]=element_size
 27454 mov #ECX,EAX
 27456 rstack EAX,EBP:-2
 27460 rstack EBX,EBP:2
 27464 add EBX,1
 27467 mov ECX,EBX
// list[1]=first
 27469 mov #ECX,EAX
__1049:
 27471 leave 
 27472 ret 
list_push:
// list_push(list,element)
 27473 enter 2
__1055:
 27476 rstack EAX,EBP:2
 27480 add EAX,0
 27483 mov EBX,EAX
 27485 sstack EBP:-1,#EBX
 27489 rstack EAX,EBP:2
 27493 add EAX,1
 27496 mov EBX,EAX
 27498 sstack EBP:-2,#EBX
__1057:
 27502 rstack EAX,EBP:-2
// if (first)
 27506 cmp 0,EAX
 27509 jge 27542
 27512 rstack EAX,EBP:3
 27516 push EAX
 27518 rstack EAX,EBP:-2
 27522 push EAX
 27524 rstack EAX,EBP:2
 27528 push EAX
 27530 mov ECX,3
// list_push_helper(...)
 27533 call 27632
 27536 add ESP,3
 27539 jmp 27600
__1059:
__1058:
__1061:
// malloc arg #1 (float n)
 27542 push #26785
 27545 mov ECX,1
// malloc(...)
 27548 call 20709
 27551 add ESP,1
// first=malloc(sizeof_listnode)
 27554 sstack EBP:-2,EAX
 27558 rstack EAX,EBP:-2
// listnode_constructor arg #1 (void* node)
 27562 push EAX
 27564 mov ECX,1
// listnode_constructor(...)
 27567 call 26861
 27570 add ESP,1
 27573 rstack EAX,EBP:3
 27577 push EAX
 27579 rstack EAX,EBP:-2
 27583 push EAX
 27585 rstack EAX,EBP:2
 27589 push EAX
 27591 mov ECX,3
// list_push_helper(...)
 27594 call 27632
 27597 add ESP,3
__1060:
__1056:
 27600 rstack EAX,EBP:-1
 27604 rstack EBX,EBP:2
 27608 add EBX,0
 27611 mov ECX,EBX
// list[0]=element_size
 27613 mov #ECX,EAX
 27615 rstack EAX,EBP:-2
 27619 rstack EBX,EBP:2
 27623 add EBX,1
 27626 mov ECX,EBX
// list[1]=first
 27628 mov #ECX,EAX
__1054:
 27630 leave 
 27631 ret 
list_push_helper:
// list_push_helper(list,node,element)
 27632 enter 5
__1063:
 27635 rstack EAX,EBP:3
 27639 add EAX,0
 27642 mov EBX,EAX
 27644 sstack EBP:-1,#EBX
 27648 rstack EAX,EBP:3
 27652 add EAX,1
 27655 mov EBX,EAX
 27657 sstack EBP:-2,#EBX
 27661 rstack EAX,EBP:3
 27665 add EAX,2
 27668 mov EBX,EAX
 27670 sstack EBP:-3,#EBX
 27674 rstack EAX,EBP:2
 27678 add EAX,0
 27681 mov EBX,EAX
 27683 sstack EBP:-4,#EBX
 27687 rstack EAX,EBP:2
 27691 add EAX,1
 27694 mov EBX,EAX
 27696 sstack EBP:-5,#EBX
__1065:
 27700 rstack EAX,EBP:-3
 27704 mov EBX,0
 27707 sub EBX,EAX
 27709 fabs EBX,EBX
 27711 fsgn EBX,EBX
 27713 lneg EBX
// if (datas==0)
 27715 cmp 0,EBX
 27718 jge 27770
 27721 rstack EAX,EBP:-4
// malloc arg #1 (float n)
 27725 push EAX
 27727 mov ECX,1
// malloc(...)
 27730 call 20709
 27733 add ESP,1
// datas=malloc(element_size)
 27736 sstack EBP:-3,EAX
 27740 rstack EAX,EBP:-4
// memcpy arg #3 (float n)
 27744 push EAX
 27746 rstack EAX,EBP:4
// memcpy arg #2 (void* src)
 27750 push EAX
 27752 rstack EAX,EBP:-3
// memcpy arg #1 (void* dest)
 27756 push EAX
 27758 mov ECX,3
// memcpy(...)
 27761 call 10006
 27764 add ESP,3
 27767 jmp 27834
__1067:
__1066:
__1069:
// malloc arg #1 (float n)
 27770 push #26785
 27773 mov ECX,1
// malloc(...)
 27776 call 20709
 27779 add ESP,1
// next=malloc(sizeof_listnode)
 27782 sstack EBP:-2,EAX
 27786 rstack EAX,EBP:-4
// listnode_constructor arg #2 (unknown)
 27790 push EAX
 27792 rstack EAX,EBP:-2
// listnode_constructor arg #1 (void* node)
 27796 push EAX
 27798 mov ECX,2
// listnode_constructor(...)
 27801 call 26861
 27804 add ESP,2
 27807 rstack EAX,EBP:4
// list_push_helper arg #3 (float* element)
 27811 push EAX
 27813 rstack EAX,EBP:-2
// list_push_helper arg #2 (void* node)
 27817 push EAX
 27819 rstack EAX,EBP:2
// list_push_helper arg #1 (void* list)
 27823 push EAX
 27825 mov ECX,3
// list_push_helper(...)
 27828 call 27632
 27831 add ESP,3
__1068:
__1064:
 27834 rstack EAX,EBP:-1
 27838 rstack EBX,EBP:3
 27842 add EBX,0
 27845 mov ECX,EBX
// node[0]=prev
 27847 mov #ECX,EAX
 27849 rstack EAX,EBP:-2
 27853 rstack EBX,EBP:3
 27857 add EBX,1
 27860 mov ECX,EBX
// node[1]=next
 27862 mov #ECX,EAX
 27864 rstack EAX,EBP:-3
 27868 rstack EBX,EBP:3
 27872 add EBX,2
 27875 mov ECX,EBX
// node[2]=datas
 27877 mov #ECX,EAX
 27879 rstack EAX,EBP:-4
 27883 rstack EBX,EBP:2
 27887 add EBX,0
 27890 mov ECX,EBX
// list[0]=element_size
 27892 mov #ECX,EAX
 27894 rstack EAX,EBP:-5
 27898 rstack EBX,EBP:2
 27902 add EBX,1
 27905 mov ECX,EBX
// list[1]=first
 27907 mov #ECX,EAX
__1062:
 27909 leave 
 27910 ret 
list_pop:
// list_pop(list,element)
 27911 enter 2
__1071:
 27914 rstack EAX,EBP:2
 27918 add EAX,0
 27921 mov EBX,EAX
 27923 sstack EBP:-1,#EBX
 27927 rstack EAX,EBP:2
 27931 add EAX,1
 27934 mov EBX,EAX
 27936 sstack EBP:-2,#EBX
__1073:
 27940 rstack EAX,EBP:-2
// if (first)
 27944 cmp 0,EAX
 27947 jge 27980
 27950 rstack EAX,EBP:3
 27954 push EAX
 27956 rstack EAX,EBP:-2
 27960 push EAX
 27962 rstack EAX,EBP:2
 27966 push EAX
 27968 mov ECX,3
// list_pop_helper(...)
 27971 call 28169
 27974 add ESP,3
 27977 jmp 27992
__1075:
__1074:
__1077:
// error arg #1 (float errno)
 27980 push 0
 27983 mov ECX,1
// error(...)
 27986 call 22767
 27989 add ESP,1
__1076:
__1072:
 27992 rstack EAX,EBP:-1
 27996 rstack EBX,EBP:2
 28000 add EBX,0
 28003 mov ECX,EBX
// list[0]=element_size
 28005 mov #ECX,EAX
 28007 rstack EAX,EBP:-2
 28011 rstack EBX,EBP:2
 28015 add EBX,1
 28018 mov ECX,EBX
// list[1]=first
 28020 mov #ECX,EAX
__1070:
 28022 leave 
 28023 ret 
node_selfdestruct:
// node_selfdestruct(node)
 28024 enter 5
__1079:
 28027 rstack EAX,EBP:2
 28031 add EAX,0
 28034 mov EBX,EAX
 28036 sstack EBP:-1,#EBX
 28040 rstack EAX,EBP:2
 28044 add EAX,1
 28047 mov EBX,EAX
 28049 sstack EBP:-2,#EBX
 28053 rstack EAX,EBP:2
 28057 add EAX,2
 28060 mov EBX,EAX
 28062 sstack EBP:-3,#EBX
 28066 rstack EAX,EBP:-1
 28070 sstack EBP:-4,EAX
 28074 rstack EAX,EBP:-4
 28078 add EAX,1
 28081 mov EBX,EAX
 28083 sstack EBP:-5,#EBX
 28087 rstack EAX,EBP:2
// listnode_destructor arg #1 (void* node)
 28091 push EAX
 28093 mov ECX,1
// listnode_destructor(...)
 28096 call 26965
 28099 add ESP,1
 28102 rstack EAX,EBP:-5
// free arg #1 (float* ptr)
 28106 push EAX
 28108 mov ECX,1
// free(...)
 28111 call 21231
 28114 add ESP,1
// P_next=0
 28117 sstack EBP:-5,0
 28122 rstack EAX,EBP:-1
 28126 rstack EBX,EBP:2
 28130 add EBX,0
 28133 mov ECX,EBX
// node[0]=prev
 28135 mov #ECX,EAX
 28137 rstack EAX,EBP:-2
 28141 rstack EBX,EBP:2
 28145 add EBX,1
 28148 mov ECX,EBX
// node[1]=next
 28150 mov #ECX,EAX
 28152 rstack EAX,EBP:-3
 28156 rstack EBX,EBP:2
 28160 add EBX,2
 28163 mov ECX,EBX
// node[2]=datas
 28165 mov #ECX,EAX
__1078:
 28167 leave 
 28168 ret 
list_pop_helper:
// list_pop_helper(list,node,element)
 28169 enter 6
__1081:
 28172 rstack EAX,EBP:2
 28176 add EAX,0
 28179 mov EBX,EAX
 28181 sstack EBP:-1,#EBX
 28185 rstack EAX,EBP:2
 28189 add EAX,1
 28192 mov EBX,EAX
 28194 sstack EBP:-2,#EBX
 28198 rstack EAX,EBP:3
 28202 add EAX,0
 28205 mov EBX,EAX
 28207 sstack EBP:-3,#EBX
 28211 rstack EAX,EBP:3
 28215 add EAX,1
 28218 mov EBX,EAX
 28220 sstack EBP:-4,#EBX
 28224 rstack EAX,EBP:3
 28228 add EAX,2
 28231 mov EBX,EAX
 28233 sstack EBP:-5,#EBX
__1083:
 28237 rstack EAX,EBP:-4
// if (next)
 28241 cmp 0,EAX
 28244 jge 28277
 28247 rstack EAX,EBP:4
// list_pop_helper arg #3 (float* element)
 28251 push EAX
 28253 rstack EAX,EBP:-4
// list_pop_helper arg #2 (void* node)
 28257 push EAX
 28259 rstack EAX,EBP:2
// list_pop_helper arg #1 (void* list)
 28263 push EAX
 28265 mov ECX,3
// list_pop_helper(...)
 28268 call 28169
 28271 add ESP,3
 28274 jmp 28378
__1085:
__1084:
__1087:
__1089:
 28277 rstack EAX,EBP:-5
// if (datas)
 28281 cmp 0,EAX
 28284 jge 28366
 28287 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 28291 push EAX
 28293 rstack EAX,EBP:-5
// memcpy arg #2 (void* src)
 28297 push EAX
 28299 rstack EAX,EBP:4
// memcpy arg #1 (void* dest)
 28303 push EAX
 28305 mov ECX,3
// memcpy(...)
 28308 call 10006
 28311 add ESP,3
 28314 rstack EAX,EBP:-5
 28318 add EAX,0
 28321 mov EBX,EAX
 28323 sstack EBP:-6,#EBX
 28327 rstack EAX,EBP:3
// listnode_destructor arg #1 (void* node)
 28331 push EAX
 28333 mov ECX,1
// listnode_destructor(...)
 28336 call 26965
 28339 add ESP,1
 28342 rstack EAX,EBP:3
// free arg #1 (float* ptr)
 28346 push EAX
 28348 mov ECX,1
// free(...)
 28351 call 21231
 28354 add ESP,1
 28357 rstack EAX,EBP:-6
 28361 leave 
 28362 ret 
 28363 jmp 28378
__1091:
__1090:
__1093:
// error arg #1 (float errno)
 28366 push 0
 28369 mov ECX,1
// error(...)
 28372 call 22767
 28375 add ESP,1
__1092:
__1088:
__1086:
__1082:
 28378 rstack EAX,EBP:-3
 28382 rstack EBX,EBP:3
 28386 add EBX,0
 28389 mov ECX,EBX
// node[0]=prev
 28391 mov #ECX,EAX
 28393 rstack EAX,EBP:-4
 28397 rstack EBX,EBP:3
 28401 add EBX,1
 28404 mov ECX,EBX
// node[1]=next
 28406 mov #ECX,EAX
 28408 rstack EAX,EBP:-5
 28412 rstack EBX,EBP:3
 28416 add EBX,2
 28419 mov ECX,EBX
// node[2]=datas
 28421 mov #ECX,EAX
 28423 rstack EAX,EBP:-1
 28427 rstack EBX,EBP:2
 28431 add EBX,0
 28434 mov ECX,EBX
// list[0]=element_size
 28436 mov #ECX,EAX
 28438 rstack EAX,EBP:-2
 28442 rstack EBX,EBP:2
 28446 add EBX,1
 28449 mov ECX,EBX
// list[1]=first
 28451 mov #ECX,EAX
__1080:
 28453 leave 
 28454 ret 
list_get:
// list_get(list,element,pos)
 28455 enter 2
__1095:
 28458 rstack EAX,EBP:2
 28462 add EAX,0
 28465 mov EBX,EAX
 28467 sstack EBP:-1,#EBX
 28471 rstack EAX,EBP:2
 28475 add EAX,1
 28478 mov EBX,EAX
 28480 sstack EBP:-2,#EBX
__1097:
 28484 rstack EAX,EBP:-2
// if (first)
 28488 cmp 0,EAX
 28491 jge 28532
 28494 rstack EAX,EBP:4
 28498 push EAX
 28500 rstack EAX,EBP:3
 28504 push EAX
 28506 rstack EAX,EBP:-2
 28510 push EAX
 28512 rstack EAX,EBP:2
 28516 push EAX
 28518 mov ECX,4
// list_get_helper(...)
 28521 call 28576
 28524 add ESP,4
 28527 leave 
 28528 ret 
 28529 jmp 28544
__1099:
__1098:
__1101:
// error arg #1 (float errno)
 28532 push 0
 28535 mov ECX,1
// error(...)
 28538 call 22767
 28541 add ESP,1
__1100:
__1096:
 28544 rstack EAX,EBP:-1
 28548 rstack EBX,EBP:2
 28552 add EBX,0
 28555 mov ECX,EBX
// list[0]=element_size
 28557 mov #ECX,EAX
 28559 rstack EAX,EBP:-2
 28563 rstack EBX,EBP:2
 28567 add EBX,1
 28570 mov ECX,EBX
// list[1]=first
 28572 mov #ECX,EAX
__1094:
 28574 leave 
 28575 ret 
list_get_helper:
// list_get_helper(list,node,element,pos)
 28576 enter 5
__1103:
 28579 rstack EAX,EBP:2
 28583 add EAX,0
 28586 mov EBX,EAX
 28588 sstack EBP:-1,#EBX
 28592 rstack EAX,EBP:2
 28596 add EAX,1
 28599 mov EBX,EAX
 28601 sstack EBP:-2,#EBX
 28605 rstack EAX,EBP:3
 28609 add EAX,0
 28612 mov EBX,EAX
 28614 sstack EBP:-3,#EBX
 28618 rstack EAX,EBP:3
 28622 add EAX,1
 28625 mov EBX,EAX
 28627 sstack EBP:-4,#EBX
 28631 rstack EAX,EBP:3
 28635 add EAX,2
 28638 mov EBX,EAX
 28640 sstack EBP:-5,#EBX
__1105:
 28644 rstack EAX,EBP:5
 28648 mov EBX,0
 28651 sub EBX,EAX
 28653 fabs EBX,EBX
 28655 fsgn EBX,EBX
 28657 lneg EBX
// if (pos==0)
 28659 cmp 0,EBX
 28662 jge 28760
__1108:
 28665 rstack EAX,EBP:-1
 28669 mov EBX,1
 28672 sub EBX,EAX
 28674 neg EBX
 28676 fsgn EBX,EBX
 28678 max EBX,0
// if (element_size>1)
 28681 cmp 0,EBX
 28684 jge 28751
__1111:
 28687 rstack EAX,EBP:-5
 28691 mov EBX,0
 28694 sub EBX,EAX
 28696 fabs EBX,EBX
 28698 fsgn EBX,EBX
// if (datas!=0)
 28700 cmp 0,EBX
 28703 jge 28736
 28706 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 28710 push EAX
 28712 rstack EAX,EBP:-5
// memcpy arg #2 (void* src)
 28716 push EAX
 28718 rstack EAX,EBP:4
// memcpy arg #1 (void* dest)
 28722 push EAX
 28724 mov ECX,3
// memcpy(...)
 28727 call 10006
 28730 add ESP,3
 28733 jmp 28748
__1113:
__1112:
__1115:
// error arg #1 (float errno)
 28736 push 0
 28739 mov ECX,1
// error(...)
 28742 call 22767
 28745 add ESP,1
__1114:
__1110:
 28748 jmp 28757
__1116:
__1109:
__1118:
 28751 rstack EAX,EBP:-5
 28755 leave 
 28756 ret 
__1117:
__1107:
 28757 jmp 28832
__1119:
__1106:
__1121:
__1123:
 28760 rstack EAX,EBP:-4
 28764 mov EBX,0
 28767 sub EBX,EAX
 28769 fabs EBX,EBX
 28771 fsgn EBX,EBX
// if (next!=0)
 28773 cmp 0,EBX
 28776 jge 28820
 28779 rstack EAX,EBP:5
 28783 add EAX,-1
 28786 mov EBX,EAX
// list_get_helper arg #4 (float pos)
 28788 push EBX
 28790 rstack EAX,EBP:4
// list_get_helper arg #3 (void* element)
 28794 push EAX
 28796 rstack EAX,EBP:-4
// list_get_helper arg #2 (void* node)
 28800 push EAX
 28802 rstack EAX,EBP:2
// list_get_helper arg #1 (void* list)
 28806 push EAX
 28808 mov ECX,4
// list_get_helper(...)
 28811 call 28576
 28814 add ESP,4
 28817 jmp 28832
__1125:
__1124:
__1127:
// error arg #1 (float errno)
 28820 push 0
 28823 mov ECX,1
// error(...)
 28826 call 22767
 28829 add ESP,1
__1126:
__1122:
__1120:
__1104:
 28832 rstack EAX,EBP:-3
 28836 rstack EBX,EBP:3
 28840 add EBX,0
 28843 mov ECX,EBX
// node[0]=prev
 28845 mov #ECX,EAX
 28847 rstack EAX,EBP:-4
 28851 rstack EBX,EBP:3
 28855 add EBX,1
 28858 mov ECX,EBX
// node[1]=next
 28860 mov #ECX,EAX
 28862 rstack EAX,EBP:-5
 28866 rstack EBX,EBP:3
 28870 add EBX,2
 28873 mov ECX,EBX
// node[2]=datas
 28875 mov #ECX,EAX
 28877 rstack EAX,EBP:-1
 28881 rstack EBX,EBP:2
 28885 add EBX,0
 28888 mov ECX,EBX
// list[0]=element_size
 28890 mov #ECX,EAX
 28892 rstack EAX,EBP:-2
 28896 rstack EBX,EBP:2
 28900 add EBX,1
 28903 mov ECX,EBX
// list[1]=first
 28905 mov #ECX,EAX
__1102:
 28907 leave 
 28908 ret 
list_set:
// list_set(list,element,pos)
 28909 enter 2
__1129:
 28912 rstack EAX,EBP:2
 28916 add EAX,0
 28919 mov EBX,EAX
 28921 sstack EBP:-1,#EBX
 28925 rstack EAX,EBP:2
 28929 add EAX,1
 28932 mov EBX,EAX
 28934 sstack EBP:-2,#EBX
__1131:
 28938 rstack EAX,EBP:-2
// if (first)
 28942 cmp 0,EAX
 28945 jge 28984
 28948 rstack EAX,EBP:4
 28952 push EAX
 28954 rstack EAX,EBP:3
 28958 push EAX
 28960 rstack EAX,EBP:-2
 28964 push EAX
 28966 rstack EAX,EBP:2
 28970 push EAX
 28972 mov ECX,4
// list_set_helper(...)
 28975 call 29028
 28978 add ESP,4
 28981 jmp 28996
__1133:
__1132:
__1135:
// error arg #1 (float errno)
 28984 push 0
 28987 mov ECX,1
// error(...)
 28990 call 22767
 28993 add ESP,1
__1134:
__1130:
 28996 rstack EAX,EBP:-1
 29000 rstack EBX,EBP:2
 29004 add EBX,0
 29007 mov ECX,EBX
// list[0]=element_size
 29009 mov #ECX,EAX
 29011 rstack EAX,EBP:-2
 29015 rstack EBX,EBP:2
 29019 add EBX,1
 29022 mov ECX,EBX
// list[1]=first
 29024 mov #ECX,EAX
__1128:
 29026 leave 
 29027 ret 
list_set_helper:
// list_set_helper(list,node,element,pos)
 29028 enter 5
__1137:
 29031 rstack EAX,EBP:2
 29035 add EAX,0
 29038 mov EBX,EAX
 29040 sstack EBP:-1,#EBX
 29044 rstack EAX,EBP:2
 29048 add EAX,1
 29051 mov EBX,EAX
 29053 sstack EBP:-2,#EBX
 29057 rstack EAX,EBP:3
 29061 add EAX,0
 29064 mov EBX,EAX
 29066 sstack EBP:-3,#EBX
 29070 rstack EAX,EBP:3
 29074 add EAX,1
 29077 mov EBX,EAX
 29079 sstack EBP:-4,#EBX
 29083 rstack EAX,EBP:3
 29087 add EAX,2
 29090 mov EBX,EAX
 29092 sstack EBP:-5,#EBX
__1139:
 29096 rstack EAX,EBP:5
 29100 mov EBX,0
 29103 sub EBX,EAX
 29105 fabs EBX,EBX
 29107 fsgn EBX,EBX
 29109 lneg EBX
// if (pos==0)
 29111 cmp 0,EBX
 29114 jge 29214
__1142:
 29117 rstack EAX,EBP:-1
 29121 mov EBX,1
 29124 sub EBX,EAX
 29126 neg EBX
 29128 fsgn EBX,EBX
 29130 max EBX,0
// if (element_size>1)
 29133 cmp 0,EBX
 29136 jge 29203
__1145:
 29139 rstack EAX,EBP:-5
 29143 mov EBX,0
 29146 sub EBX,EAX
 29148 fabs EBX,EBX
 29150 fsgn EBX,EBX
// if (datas!=0)
 29152 cmp 0,EBX
 29155 jge 29188
 29158 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 29162 push EAX
 29164 rstack EAX,EBP:4
// memcpy arg #2 (void* src)
 29168 push EAX
 29170 rstack EAX,EBP:-5
// memcpy arg #1 (void* dest)
 29174 push EAX
 29176 mov ECX,3
// memcpy(...)
 29179 call 10006
 29182 add ESP,3
 29185 jmp 29200
__1147:
__1146:
__1149:
// error arg #1 (float errno)
 29188 push 0
 29191 mov ECX,1
// error(...)
 29194 call 22767
 29197 add ESP,1
__1148:
__1144:
 29200 jmp 29211
__1150:
__1143:
__1152:
 29203 rstack EAX,EBP:4
// datas=element
 29207 sstack EBP:-5,EAX
__1151:
__1141:
 29211 jmp 29286
__1153:
__1140:
__1155:
__1157:
 29214 rstack EAX,EBP:-4
 29218 mov EBX,0
 29221 sub EBX,EAX
 29223 fabs EBX,EBX
 29225 fsgn EBX,EBX
// if (next!=0)
 29227 cmp 0,EBX
 29230 jge 29274
 29233 rstack EAX,EBP:5
 29237 add EAX,-1
 29240 mov EBX,EAX
// list_set_helper arg #4 (float pos)
 29242 push EBX
 29244 rstack EAX,EBP:4
// list_set_helper arg #3 (float* element)
 29248 push EAX
 29250 rstack EAX,EBP:-4
// list_set_helper arg #2 (void* node)
 29254 push EAX
 29256 rstack EAX,EBP:2
// list_set_helper arg #1 (void* list)
 29260 push EAX
 29262 mov ECX,4
// list_set_helper(...)
 29265 call 29028
 29268 add ESP,4
 29271 jmp 29286
__1159:
__1158:
__1161:
// error arg #1 (float errno)
 29274 push 0
 29277 mov ECX,1
// error(...)
 29280 call 22767
 29283 add ESP,1
__1160:
__1156:
__1154:
__1138:
 29286 rstack EAX,EBP:-3
 29290 rstack EBX,EBP:3
 29294 add EBX,0
 29297 mov ECX,EBX
// node[0]=prev
 29299 mov #ECX,EAX
 29301 rstack EAX,EBP:-4
 29305 rstack EBX,EBP:3
 29309 add EBX,1
 29312 mov ECX,EBX
// node[1]=next
 29314 mov #ECX,EAX
 29316 rstack EAX,EBP:-5
 29320 rstack EBX,EBP:3
 29324 add EBX,2
 29327 mov ECX,EBX
// node[2]=datas
 29329 mov #ECX,EAX
 29331 rstack EAX,EBP:-1
 29335 rstack EBX,EBP:2
 29339 add EBX,0
 29342 mov ECX,EBX
// list[0]=element_size
 29344 mov #ECX,EAX
 29346 rstack EAX,EBP:-2
 29350 rstack EBX,EBP:2
 29354 add EBX,1
 29357 mov ECX,EBX
// list[1]=first
 29359 mov #ECX,EAX
__1136:
 29361 leave 
 29362 ret 
list_insert:
// list_insert(list,element,pos)
 29363 enter 2
__1163:
 29366 rstack EAX,EBP:2
 29370 add EAX,0
 29373 mov EBX,EAX
 29375 sstack EBP:-1,#EBX
 29379 rstack EAX,EBP:2
 29383 add EAX,1
 29386 mov EBX,EAX
 29388 sstack EBP:-2,#EBX
__1165:
 29392 rstack EAX,EBP:-2
 29396 mov EBX,0
 29399 sub EBX,EAX
 29401 fabs EBX,EBX
 29403 fsgn EBX,EBX
// if (first!=0)
 29405 cmp 0,EBX
 29408 jge 29447
 29411 rstack EAX,EBP:4
 29415 push EAX
 29417 rstack EAX,EBP:3
 29421 push EAX
 29423 rstack EAX,EBP:-2
 29427 push EAX
 29429 rstack EAX,EBP:2
 29433 push EAX
 29435 mov ECX,4
// list_insert_helper(...)
 29438 call 29491
 29441 add ESP,4
 29444 jmp 29459
__1167:
__1166:
__1169:
// error arg #1 (float errno)
 29447 push 0
 29450 mov ECX,1
// error(...)
 29453 call 22767
 29456 add ESP,1
__1168:
__1164:
 29459 rstack EAX,EBP:-1
 29463 rstack EBX,EBP:2
 29467 add EBX,0
 29470 mov ECX,EBX
// list[0]=element_size
 29472 mov #ECX,EAX
 29474 rstack EAX,EBP:-2
 29478 rstack EBX,EBP:2
 29482 add EBX,1
 29485 mov ECX,EBX
// list[1]=first
 29487 mov #ECX,EAX
__1162:
 29489 leave 
 29490 ret 
list_insert_helper:
// list_insert_helper(list,node,element,pos)
 29491 enter 9
__1171:
 29494 rstack EAX,EBP:3
 29498 add EAX,0
 29501 mov EBX,EAX
 29503 sstack EBP:-1,#EBX
 29507 rstack EAX,EBP:3
 29511 add EAX,1
 29514 mov EBX,EAX
 29516 sstack EBP:-2,#EBX
 29520 rstack EAX,EBP:3
 29524 add EAX,2
 29527 mov EBX,EAX
 29529 sstack EBP:-3,#EBX
 29533 rstack EAX,EBP:2
 29537 add EAX,0
 29540 mov EBX,EAX
 29542 sstack EBP:-4,#EBX
 29546 rstack EAX,EBP:2
 29550 add EAX,1
 29553 mov EBX,EAX
 29555 sstack EBP:-5,#EBX
__1173:
 29559 rstack EAX,EBP:5
 29563 mov EBX,0
 29566 sub EBX,EAX
 29568 fabs EBX,EBX
 29570 fsgn EBX,EBX
 29572 lneg EBX
// if (pos==0)
 29574 cmp 0,EBX
 29577 jge 29756
__1176:
 29580 rstack EAX,EBP:-1
 29584 mov EBX,0
 29587 sub EBX,EAX
 29589 fabs EBX,EBX
 29591 fsgn EBX,EBX
// if (prev!=0)
 29593 cmp 0,EBX
 29596 jge 29741
 29599 rstack EAX,EBP:-1
 29603 add EAX,1
 29606 mov EBX,EAX
 29608 sstack EBP:-6,#EBX
 29612 rstack EAX,EBP:-6
 29616 sstack EBP:-7,EAX
// malloc arg #1 (float n)
 29620 push #26785
 29623 mov ECX,1
// malloc(...)
 29626 call 20709
 29629 add ESP,1
// P_next=malloc(sizeof_listnode)
 29632 sstack EBP:-6,EAX
 29636 rstack EAX,EBP:-6
// listnode_constructor arg #1 (void* node)
 29640 push EAX
 29642 mov ECX,1
// listnode_constructor(...)
 29645 call 26861
 29648 add ESP,1
 29651 rstack EAX,EBP:-6
 29655 rstack EBX,EBP:-1
 29659 add EBX,1
 29662 mov ECX,EBX
// prev[1]=P_next
 29664 mov #ECX,EAX
 29666 rstack EAX,EBP:-6
 29670 add EAX,0
 29673 mov EBX,EAX
 29675 sstack EBP:-8,#EBX
 29679 rstack EAX,EBP:-6
 29683 add EAX,1
 29686 mov EBX,EAX
 29688 sstack EBP:-9,#EBX
 29692 rstack EAX,EBP:-1
// P_next_prev=prev
 29696 sstack EBP:-8,EAX
 29700 rstack EAX,EBP:-7
// P_next_next=P_next_old
 29704 sstack EBP:-9,EAX
 29708 rstack EAX,EBP:-8
 29712 rstack EBX,EBP:-6
 29716 add EBX,0
 29719 mov ECX,EBX
// P_next[0]=P_next_prev
 29721 mov #ECX,EAX
 29723 rstack EAX,EBP:-9
 29727 rstack EBX,EBP:-6
 29731 add EBX,1
 29734 mov ECX,EBX
// P_next[1]=P_next_next
 29736 mov #ECX,EAX
 29738 jmp 29753
__1178:
__1177:
__1180:
// error arg #1 (float errno)
 29741 push 0
 29744 mov ECX,1
// error(...)
 29747 call 22767
 29750 add ESP,1
__1179:
__1175:
 29753 jmp 29873
__1181:
__1174:
__1183:
__1185:
 29756 rstack EAX,EBP:-2
 29760 mov EBX,0
 29763 sub EBX,EAX
 29765 fabs EBX,EBX
 29767 fsgn EBX,EBX
// if (next!=0)
 29769 cmp 0,EBX
 29772 jge 29816
 29775 rstack EAX,EBP:5
 29779 add EAX,-1
 29782 mov EBX,EAX
// list_insert_helper arg #4 (float pos)
 29784 push EBX
 29786 rstack EAX,EBP:4
// list_insert_helper arg #3 (float* element)
 29790 push EAX
 29792 rstack EAX,EBP:-2
// list_insert_helper arg #2 (void* node)
 29796 push EAX
 29798 rstack EAX,EBP:2
// list_insert_helper arg #1 (void* list)
 29802 push EAX
 29804 mov ECX,4
// list_insert_helper(...)
 29807 call 29491
 29810 add ESP,4
 29813 jmp 29873
__1187:
__1186:
__1189:
__1191:
 29816 rstack EAX,EBP:5
 29820 mov EBX,1
 29823 sub EBX,EAX
 29825 fabs EBX,EBX
 29827 fsgn EBX,EBX
 29829 lneg EBX
// if (pos==1)
 29831 cmp 0,EBX
 29834 jge 29861
 29837 rstack EAX,EBP:4
// list_push arg #2 (float* element)
 29841 push EAX
 29843 rstack EAX,EBP:2
// list_push arg #1 (void* list)
 29847 push EAX
 29849 mov ECX,2
// list_push(...)
 29852 call 27473
 29855 add ESP,2
 29858 jmp 29873
__1193:
__1192:
__1195:
// error arg #1 (float errno)
 29861 push 0
 29864 mov ECX,1
// error(...)
 29867 call 22767
 29870 add ESP,1
__1194:
__1190:
__1188:
__1184:
__1182:
__1172:
 29873 rstack EAX,EBP:-1
 29877 rstack EBX,EBP:3
 29881 add EBX,0
 29884 mov ECX,EBX
// node[0]=prev
 29886 mov #ECX,EAX
 29888 rstack EAX,EBP:-2
 29892 rstack EBX,EBP:3
 29896 add EBX,1
 29899 mov ECX,EBX
// node[1]=next
 29901 mov #ECX,EAX
 29903 rstack EAX,EBP:-3
 29907 rstack EBX,EBP:3
 29911 add EBX,2
 29914 mov ECX,EBX
// node[2]=datas
 29916 mov #ECX,EAX
 29918 rstack EAX,EBP:-4
 29922 rstack EBX,EBP:2
 29926 add EBX,0
 29929 mov ECX,EBX
// list[0]=element_size
 29931 mov #ECX,EAX
 29933 rstack EAX,EBP:-5
 29937 rstack EBX,EBP:2
 29941 add EBX,1
 29944 mov ECX,EBX
// list[1]=first
 29946 mov #ECX,EAX
__1170:
 29948 leave 
 29949 ret 
list_remove:
// list_remove(list,element,pos)
 29950 enter 2
__1197:
 29953 rstack EAX,EBP:2
 29957 add EAX,0
 29960 mov EBX,EAX
 29962 sstack EBP:-1,#EBX
 29966 rstack EAX,EBP:2
 29970 add EAX,1
 29973 mov EBX,EAX
 29975 sstack EBP:-2,#EBX
__1199:
 29979 rstack EAX,EBP:-2
 29983 mov EBX,0
 29986 sub EBX,EAX
 29988 fabs EBX,EBX
 29990 fsgn EBX,EBX
// if (first!=0)
 29992 cmp 0,EBX
 29995 jge 30034
 29998 rstack EAX,EBP:4
 30002 push EAX
 30004 rstack EAX,EBP:3
 30008 push EAX
 30010 rstack EAX,EBP:-2
 30014 push EAX
 30016 rstack EAX,EBP:2
 30020 push EAX
 30022 mov ECX,4
// list_remove_helper(...)
 30025 call 30078
 30028 add ESP,4
 30031 jmp 30046
__1201:
__1200:
__1203:
// error arg #1 (float errno)
 30034 push 0
 30037 mov ECX,1
// error(...)
 30040 call 22767
 30043 add ESP,1
__1202:
__1198:
 30046 rstack EAX,EBP:-1
 30050 rstack EBX,EBP:2
 30054 add EBX,0
 30057 mov ECX,EBX
// list[0]=element_size
 30059 mov #ECX,EAX
 30061 rstack EAX,EBP:-2
 30065 rstack EBX,EBP:2
 30069 add EBX,1
 30072 mov ECX,EBX
// list[1]=first
 30074 mov #ECX,EAX
__1196:
 30076 leave 
 30077 ret 
list_remove_helper:
// list_remove_helper(list,node,element,pos)
 30078 enter 9
__1205:
 30081 rstack EAX,EBP:3
 30085 add EAX,0
 30088 mov EBX,EAX
 30090 sstack EBP:-1,#EBX
 30094 rstack EAX,EBP:3
 30098 add EAX,1
 30101 mov EBX,EAX
 30103 sstack EBP:-2,#EBX
 30107 rstack EAX,EBP:3
 30111 add EAX,2
 30114 mov EBX,EAX
 30116 sstack EBP:-3,#EBX
 30120 rstack EAX,EBP:2
 30124 add EAX,0
 30127 mov EBX,EAX
 30129 sstack EBP:-4,#EBX
 30133 rstack EAX,EBP:2
 30137 add EAX,1
 30140 mov EBX,EAX
 30142 sstack EBP:-5,#EBX
__1207:
 30146 rstack EAX,EBP:5
 30150 mov EBX,0
 30153 sub EBX,EAX
 30155 fabs EBX,EBX
 30157 fsgn EBX,EBX
 30159 lneg EBX
// if (pos==0)
 30161 cmp 0,EBX
 30164 jge 30365
__1210:
 30167 rstack EAX,EBP:-1
 30171 mov EBX,0
 30174 sub EBX,EAX
 30176 fabs EBX,EBX
 30178 fsgn EBX,EBX
// if (prev!=0)
 30180 cmp 0,EBX
 30183 jge 30350
 30186 rstack EAX,EBP:-3
// free arg #1 (float* ptr)
 30190 push EAX
 30192 mov ECX,1
// free(...)
 30195 call 21231
 30198 add ESP,1
 30201 rstack EAX,EBP:-1
 30205 sstack EBP:-6,EAX
 30209 rstack EAX,EBP:-2
 30213 sstack EBP:-7,EAX
 30217 rstack EAX,EBP:3
// free arg #1 (float* ptr)
 30221 push EAX
 30223 mov ECX,1
// free(...)
 30226 call 21231
 30229 add ESP,1
 30232 rstack EAX,EBP:-6
 30236 add EAX,1
 30239 mov EBX,EAX
 30241 sstack EBP:-8,#EBX
 30245 sstack EBP:-9,0
__1213:
 30250 rstack EAX,EBP:-7
 30254 mov EBX,0
 30257 sub EBX,EAX
 30259 fabs EBX,EBX
 30261 fsgn EBX,EBX
// if (oldnext!=0)
 30263 cmp 0,EBX
 30266 jge 30282
 30269 rstack EAX,EBP:-7
 30273 add EAX,0
 30276 mov EBX,EAX
// oldnext_prev=oldnext[0]
 30278 sstack EBP:-9,#EBX
__1214:
__1212:
 30282 rstack EAX,EBP:-7
// oldprev_next=oldnext
 30286 sstack EBP:-8,EAX
 30290 rstack EAX,EBP:-6
// oldnext_prev=oldprev
 30294 sstack EBP:-9,EAX
 30298 rstack EAX,EBP:-8
 30302 rstack EBX,EBP:-6
 30306 add EBX,1
 30309 mov ECX,EBX
// oldprev[1]=oldprev_next
 30311 mov #ECX,EAX
__1216:
 30313 rstack EAX,EBP:-7
 30317 mov EBX,0
 30320 sub EBX,EAX
 30322 fabs EBX,EBX
 30324 fsgn EBX,EBX
// if (oldnext!=0)
 30326 cmp 0,EBX
 30329 jge 30347
 30332 rstack EAX,EBP:-9
 30336 rstack EBX,EBP:-7
 30340 add EBX,0
 30343 mov ECX,EBX
// oldnext[0]=oldnext_prev
 30345 mov #ECX,EAX
__1217:
__1215:
 30347 jmp 30362
__1218:
__1211:
__1220:
// error arg #1 (float errno)
 30350 push 0
 30353 mov ECX,1
// error(...)
 30356 call 22767
 30359 add ESP,1
__1219:
__1209:
 30362 jmp 30482
__1221:
__1208:
__1223:
__1225:
 30365 rstack EAX,EBP:-2
 30369 mov EBX,0
 30372 sub EBX,EAX
 30374 fabs EBX,EBX
 30376 fsgn EBX,EBX
// if (next!=0)
 30378 cmp 0,EBX
 30381 jge 30425
 30384 rstack EAX,EBP:5
 30388 add EAX,-1
 30391 mov EBX,EAX
// list_remove_helper arg #4 (float pos)
 30393 push EBX
 30395 rstack EAX,EBP:4
// list_remove_helper arg #3 (float* element)
 30399 push EAX
 30401 rstack EAX,EBP:-2
// list_remove_helper arg #2 (void* node)
 30405 push EAX
 30407 rstack EAX,EBP:2
// list_remove_helper arg #1 (void* list)
 30411 push EAX
 30413 mov ECX,4
// list_remove_helper(...)
 30416 call 30078
 30419 add ESP,4
 30422 jmp 30482
__1227:
__1226:
__1229:
__1231:
 30425 rstack EAX,EBP:5
 30429 mov EBX,1
 30432 sub EBX,EAX
 30434 fabs EBX,EBX
 30436 fsgn EBX,EBX
 30438 lneg EBX
// if (pos==1)
 30440 cmp 0,EBX
 30443 jge 30470
 30446 rstack EAX,EBP:4
// list_pop arg #2 (float* element)
 30450 push EAX
 30452 rstack EAX,EBP:2
// list_pop arg #1 (void* list)
 30456 push EAX
 30458 mov ECX,2
// list_pop(...)
 30461 call 27911
 30464 add ESP,2
 30467 jmp 30482
__1233:
__1232:
__1235:
// error arg #1 (float errno)
 30470 push 0
 30473 mov ECX,1
// error(...)
 30476 call 22767
 30479 add ESP,1
__1234:
__1230:
__1228:
__1224:
__1222:
__1206:
 30482 rstack EAX,EBP:-1
 30486 rstack EBX,EBP:3
 30490 add EBX,0
 30493 mov ECX,EBX
// node[0]=prev
 30495 mov #ECX,EAX
 30497 rstack EAX,EBP:-2
 30501 rstack EBX,EBP:3
 30505 add EBX,1
 30508 mov ECX,EBX
// node[1]=next
 30510 mov #ECX,EAX
 30512 rstack EAX,EBP:-3
 30516 rstack EBX,EBP:3
 30520 add EBX,2
 30523 mov ECX,EBX
// node[2]=datas
 30525 mov #ECX,EAX
 30527 rstack EAX,EBP:-4
 30531 rstack EBX,EBP:2
 30535 add EBX,0
 30538 mov ECX,EBX
// list[0]=element_size
 30540 mov #ECX,EAX
 30542 rstack EAX,EBP:-5
 30546 rstack EBX,EBP:2
 30550 add EBX,1
 30553 mov ECX,EBX
// list[1]=first
 30555 mov #ECX,EAX
__1204:
 30557 leave 
 30558 ret 
list_getnode:
// list_getnode(list,pos)
 30559 enter 4
__1237:
 30562 rstack EAX,EBP:2
 30566 add EAX,0
 30569 mov EBX,EAX
 30571 sstack EBP:-1,#EBX
 30575 rstack EAX,EBP:2
 30579 add EAX,1
 30582 mov EBX,EAX
 30584 sstack EBP:-2,#EBX
 30588 rstack EAX,EBP:-2
 30592 sstack EBP:-3,EAX
__1239:
 30596 rstack EAX,EBP:3
 30600 mov EBX,0
 30603 sub EBX,EAX
 30605 fabs EBX,EBX
 30607 fsgn EBX,EBX
// if (pos!=0
 30609 cmp 0,EBX
 30612 jz 30685
 30615 rstack EAX,EBP:-3
 30619 add EAX,1
 30622 mov EBX,EAX
 30624 sstack EBP:-4,#EBX
__1241:
 30628 rstack EAX,EBP:-4
 30632 mov EBX,0
 30635 sub EBX,EAX
 30637 fabs EBX,EBX
 30639 fsgn EBX,EBX
 30641 lneg EBX
// if (next==0)
 30643 cmp 0,EBX
 30646 jge 30661
// error arg #1 (float errno)
 30649 push 0
 30652 mov ECX,1
// error(...)
 30655 call 22767
 30658 add ESP,1
__1242:
__1240:
 30661 rstack EAX,EBP:-4
// node=next
 30665 sstack EBP:-3,EAX
 30669 rstack EAX,EBP:3
 30673 add EAX,-1
 30676 mov EBX,EAX
// pos=pos-1
 30678 sstack EBP:3,EBX
 30682 jmp 30596
__1238:
 30685 rstack EAX,EBP:-3
 30689 leave 
 30690 ret 
__1236:
 30691 leave 
 30692 ret 
list_splice:
// list_splice(listfrom,listto,posfrom,posto)
 30693 enter 13
__1244:
 30696 rstack EAX,EBP:2
 30700 add EAX,0
 30703 mov EBX,EAX
 30705 sstack EBP:-1,#EBX
 30709 rstack EAX,EBP:2
 30713 add EAX,1
 30716 mov EBX,EAX
 30718 sstack EBP:-2,#EBX
 30722 rstack EAX,EBP:3
 30726 add EAX,0
 30729 mov EBX,EAX
 30731 sstack EBP:-3,#EBX
 30735 rstack EAX,EBP:3
 30739 add EAX,1
 30742 mov EBX,EAX
 30744 sstack EBP:-4,#EBX
__1246:
 30748 rstack EAX,EBP:-1
 30752 rstack EBX,EBP:-3
 30756 sub EBX,EAX
 30758 mov EAX,EBX
 30760 fabs EAX,EAX
 30762 fsgn EAX,EAX
// if (element_size1!=element_size2)
 30764 cmp 0,EAX
 30767 jge 30782
// error arg #1 (float errno)
 30770 push 0
 30773 mov ECX,1
// error(...)
 30776 call 22767
 30779 add ESP,1
__1247:
__1245:
 30782 rstack EAX,EBP:4
// list_getnode arg #2 (float pos)
 30786 push EAX
 30788 rstack EAX,EBP:2
// list_getnode arg #1 (void* list)
 30792 push EAX
 30794 mov ECX,2
// list_getnode(...)
 30797 call 30559
 30800 add ESP,2
 30803 sstack EBP:-5,EAX
 30807 rstack EAX,EBP:5
// list_getnode arg #2 (float pos)
 30811 push EAX
 30813 rstack EAX,EBP:3
// list_getnode arg #1 (void* list)
 30817 push EAX
 30819 mov ECX,2
// list_getnode(...)
 30822 call 30559
 30825 add ESP,2
 30828 sstack EBP:-6,EAX
 30832 rstack EAX,EBP:-5
 30836 add EAX,0
 30839 mov EBX,EAX
 30841 sstack EBP:-7,#EBX
 30845 rstack EAX,EBP:-5
 30849 add EAX,1
 30852 mov EBX,EAX
 30854 sstack EBP:-8,#EBX
 30858 rstack EAX,EBP:-6
 30862 add EAX,1
 30865 mov EBX,EAX
 30867 sstack EBP:-9,#EBX
 30871 rstack EAX,EBP:-9
 30875 add EAX,1
 30878 mov EBX,EAX
 30880 sstack EBP:-10,#EBX
 30884 rstack EAX,EBP:-7
 30888 add EAX,1
 30891 mov EBX,EAX
 30893 sstack EBP:-11,#EBX
__1249:
 30897 rstack EAX,EBP:-8
 30901 mov EBX,0
 30904 sub EBX,EAX
 30906 fabs EBX,EBX
 30908 fsgn EBX,EBX
// if (N1!=0)
 30910 cmp 0,EBX
 30913 jge 30978
 30916 rstack EAX,EBP:-8
// P1N=N1
 30920 sstack EBP:-11,EAX
 30924 rstack EAX,EBP:-11
 30928 rstack EBX,EBP:-7
 30932 add EBX,1
 30935 mov ECX,EBX
// P1[1]=P1N
 30937 mov #ECX,EAX
 30939 rstack EAX,EBP:-8
 30943 add EAX,0
 30946 mov EBX,EAX
 30948 sstack EBP:-12,#EBX
 30952 rstack EAX,EBP:-7
// N1P=P1
 30956 sstack EBP:-12,EAX
 30960 rstack EAX,EBP:-12
 30964 rstack EBX,EBP:-8
 30968 add EBX,0
 30971 mov ECX,EBX
// N1[0]=N1P
 30973 mov #ECX,EAX
 30975 jmp 31001
__1251:
__1250:
__1253:
 30978 rstack EAX,EBP:-8
// P1N=N1
 30982 sstack EBP:-11,EAX
 30986 rstack EAX,EBP:-11
 30990 rstack EBX,EBP:-7
 30994 add EBX,1
 30997 mov ECX,EBX
// P1[1]=P1N
 30999 mov #ECX,EAX
__1252:
__1248:
 31001 rstack EAX,EBP:-6
// P1=nodeto
 31005 sstack EBP:-7,EAX
 31009 rstack EAX,EBP:-7
 31013 rstack EBX,EBP:-5
 31017 add EBX,0
 31020 mov ECX,EBX
// nodefrom[0]=P1
 31022 mov #ECX,EAX
 31024 rstack EAX,EBP:-9
// N1=N2
 31028 sstack EBP:-8,EAX
 31032 rstack EAX,EBP:-8
 31036 rstack EBX,EBP:-5
 31040 add EBX,1
 31043 mov ECX,EBX
// nodefrom[1]=N1
 31045 mov #ECX,EAX
__1255:
 31047 rstack EAX,EBP:-10
 31051 mov EBX,0
 31054 sub EBX,EAX
 31056 fabs EBX,EBX
 31058 fsgn EBX,EBX
// if (N2N!=0)
 31060 cmp 0,EBX
 31063 jge 31128
 31066 rstack EAX,EBP:-5
// N2=nodefrom
 31070 sstack EBP:-9,EAX
 31074 rstack EAX,EBP:-9
 31078 rstack EBX,EBP:-6
 31082 add EBX,1
 31085 mov ECX,EBX
// nodeto[1]=N2
 31087 mov #ECX,EAX
 31089 rstack EAX,EBP:-10
 31093 add EAX,0
 31096 mov EBX,EAX
 31098 sstack EBP:-13,#EBX
 31102 rstack EAX,EBP:-5
// N2NP=nodefrom
 31106 sstack EBP:-13,EAX
 31110 rstack EAX,EBP:-13
 31114 rstack EBX,EBP:-10
 31118 add EBX,0
 31121 mov ECX,EBX
// N2N[0]=N2NP
 31123 mov #ECX,EAX
 31125 jmp 31151
__1257:
__1256:
__1259:
 31128 rstack EAX,EBP:-5
// N2=nodefrom
 31132 sstack EBP:-9,EAX
 31136 rstack EAX,EBP:-9
 31140 rstack EBX,EBP:-6
 31144 add EBX,1
 31147 mov ECX,EBX
// nodeto[1]=N2
 31149 mov #ECX,EAX
__1258:
__1254:
__1243:
 31151 leave 
 31152 ret 
list_move:
// list_move(list,pos,newnode,newdatas)
 31153 enter 3
__1261:
 31156 rstack EAX,EBP:3
// list_getnode arg #2 (float pos)
 31160 push EAX
 31162 rstack EAX,EBP:2
// list_getnode arg #1 (void* list)
 31166 push EAX
 31168 mov ECX,2
// list_getnode(...)
 31171 call 30559
 31174 add ESP,2
 31177 sstack EBP:-1,EAX
 31181 rstack EAX,EBP:2
 31185 add EAX,0
 31188 mov EBX,EAX
 31190 sstack EBP:-2,#EBX
 31194 rstack EAX,EBP:-1
 31198 add EAX,2
 31201 mov EBX,EAX
 31203 sstack EBP:-3,#EBX
__1263:
 31207 rstack EAX,EBP:4
 31211 mov EBX,0
 31214 sub EBX,EAX
 31216 fabs EBX,EBX
 31218 fsgn EBX,EBX
// if (newnode!=0)
 31220 cmp 0,EBX
 31223 jge 31258
// memcpy arg #3 (float n)
 31226 push #26785
 31229 rstack EAX,EBP:-1
// memcpy arg #2 (void* src)
 31233 push EAX
 31235 rstack EAX,EBP:4
// memcpy arg #1 (void* dest)
 31239 push EAX
 31241 mov ECX,3
// memcpy(...)
 31244 call 10006
 31247 add ESP,3
 31250 rstack EAX,EBP:4
// node=newnode
 31254 sstack EBP:-1,EAX
__1264:
__1262:
__1266:
 31258 rstack EAX,EBP:5
 31262 mov EBX,0
 31265 sub EBX,EAX
 31267 fabs EBX,EBX
 31269 fsgn EBX,EBX
// if (newdatas!=0)
 31271 cmp 0,EBX
 31274 jge 31312
 31277 rstack EAX,EBP:-2
// memcpy arg #3 (float n)
 31281 push EAX
 31283 rstack EAX,EBP:5
// memcpy arg #2 (void* src)
 31287 push EAX
 31289 rstack EAX,EBP:-3
// memcpy arg #1 (void* dest)
 31293 push EAX
 31295 mov ECX,3
// memcpy(...)
 31298 call 10006
 31301 add ESP,3
 31304 rstack EAX,EBP:5
// datas=newdatas
 31308 sstack EBP:-3,EAX
__1267:
__1265:
 31312 rstack EAX,EBP:-3
 31316 rstack EBX,EBP:-1
 31320 add EBX,2
 31323 mov ECX,EBX
// node[2]=datas
 31325 mov #ECX,EAX
__1260:
 31327 leave 
 31328 ret 
list_destructor:
// list_destructor(list)
 31329 enter 2
__1269:
 31332 rstack EAX,EBP:2
 31336 add EAX,0
 31339 mov EBX,EAX
 31341 sstack EBP:-1,#EBX
 31345 rstack EAX,EBP:2
 31349 add EAX,1
 31352 mov EBX,EAX
 31354 sstack EBP:-2,#EBX
__1271:
 31358 rstack EAX,EBP:-2
 31362 mov EBX,0
 31365 sub EBX,EAX
 31367 fabs EBX,EBX
 31369 fsgn EBX,EBX
// if (first!=0)
 31371 cmp 0,EBX
 31374 jge 31392
 31377 rstack EAX,EBP:-2
// listnode_destructor arg #1 (void* node)
 31381 push EAX
 31383 mov ECX,1
// listnode_destructor(...)
 31386 call 26965
 31389 add ESP,1
__1272:
__1270:
 31392 rstack EAX,EBP:-1
 31396 rstack EBX,EBP:2
 31400 add EBX,0
 31403 mov ECX,EBX
// list[0]=element_size
 31405 mov #ECX,EAX
 31407 rstack EAX,EBP:-2
 31411 rstack EBX,EBP:2
 31415 add EBX,1
 31418 mov ECX,EBX
// list[1]=first
 31420 mov #ECX,EAX
__1268:
 31422 leave 
 31423 ret 
ZLIST_CONSTANTS:
ZLIST_VARS:
ZLIST_END:
STRINGTRACKER_CODE:
sizeof_stringtracker:
 31424 db 8
stringtracker_ok:
 31425 db 0
stringtracker_end_of_string:
 31426 db 1
stringtracker_beginning_of_string:
 31427 db 2
stringtracker_end_of_line:
 31428 db 3
stringtracker_beginning_of_line:
 31429 db 4
stringtracker_box_x_min:
 31430 db 5
stringtracker_box_x_max:
 31431 db 6
stringtracker_box_y_min:
 31432 db 7
stringtracker_box_y_max:
 31433 db 8
stringtracker_constructor:
// stringtracker_constructor(self,str)
 31434 enter -0
__1274:
 31437 rstack EAX,EBP:3
 31441 rstack EBX,EBP:2
 31445 add EBX,0
 31448 mov ECX,EBX
// self[0]=str
 31450 mov #ECX,EAX
 31452 rstack EAX,EBP:2
 31456 add EAX,1
 31459 mov EBX,EAX
// self[1]=0
 31461 mov #EBX,0
 31464 rstack EAX,EBP:2
 31468 add EAX,2
 31471 mov EBX,EAX
// self[2]=0
 31473 mov #EBX,0
 31476 rstack EAX,EBP:2
 31480 add EAX,3
 31483 mov EBX,EAX
// self[3]=0
 31485 mov #EBX,0
 31488 rstack EAX,EBP:2
 31492 add EAX,4
 31495 mov EBX,EAX
// self[4]=0
 31497 mov #EBX,0
 31500 rstack EAX,EBP:2
 31504 add EAX,5
 31507 mov EBX,EAX
// self[5]=29
 31509 mov #EBX,29
 31512 rstack EAX,EBP:2
 31516 add EAX,6
 31519 mov EBX,EAX
// self[6]=0
 31521 mov #EBX,0
 31524 rstack EAX,EBP:2
 31528 add EAX,7
 31531 mov EBX,EAX
// self[7]=17
 31533 mov #EBX,17
__1273:
 31536 leave 
 31537 ret 
stringtracker_copy_constructor:
// stringtracker_copy_constructor(self,other)
 31538 enter -0
__1276:
 31541 rstack EAX,EBP:3
 31545 add EAX,0
 31548 mov EBX,EAX
 31550 rstack EAX,EBP:2
 31554 add EAX,0
 31557 mov ECX,EAX
// self[0]=other[0]
 31559 mov #ECX,#EBX
 31561 rstack EAX,EBP:3
 31565 add EAX,1
 31568 mov EBX,EAX
 31570 rstack EAX,EBP:2
 31574 add EAX,1
 31577 mov ECX,EAX
// self[1]=other[1]
 31579 mov #ECX,#EBX
 31581 rstack EAX,EBP:3
 31585 add EAX,2
 31588 mov EBX,EAX
 31590 rstack EAX,EBP:2
 31594 add EAX,2
 31597 mov ECX,EAX
// self[2]=other[2]
 31599 mov #ECX,#EBX
 31601 rstack EAX,EBP:3
 31605 add EAX,3
 31608 mov EBX,EAX
 31610 rstack EAX,EBP:2
 31614 add EAX,3
 31617 mov ECX,EAX
// self[3]=other[3]
 31619 mov #ECX,#EBX
 31621 rstack EAX,EBP:3
 31625 add EAX,4
 31628 mov EBX,EAX
 31630 rstack EAX,EBP:2
 31634 add EAX,4
 31637 mov ECX,EAX
// self[4]=other[4]
 31639 mov #ECX,#EBX
 31641 rstack EAX,EBP:3
 31645 add EAX,5
 31648 mov EBX,EAX
 31650 rstack EAX,EBP:2
 31654 add EAX,5
 31657 mov ECX,EAX
// self[5]=other[5]
 31659 mov #ECX,#EBX
 31661 rstack EAX,EBP:3
 31665 add EAX,6
 31668 mov EBX,EAX
 31670 rstack EAX,EBP:2
 31674 add EAX,6
 31677 mov ECX,EAX
// self[6]=other[6]
 31679 mov #ECX,#EBX
 31681 rstack EAX,EBP:3
 31685 add EAX,7
 31688 mov EBX,EAX
 31690 rstack EAX,EBP:2
 31694 add EAX,7
 31697 mov ECX,EAX
// self[7]=other[7]
 31699 mov #ECX,#EBX
__1275:
 31701 leave 
 31702 ret 
stringtracker_destructor:
// stringtracker_destructor(self)
 31703 enter -0
__1278:
__1277:
 31706 leave 
 31707 ret 
stringtracker_get_str:
// stringtracker_get_str(self)
 31708 enter -0
__1280:
 31711 rstack EAX,EBP:2
 31715 add EAX,0
 31718 mov EBX,EAX
 31720 mov EAX,#EBX
 31722 leave 
 31723 ret 
__1279:
 31724 leave 
 31725 ret 
stringtracker_get_I:
// stringtracker_get_I(self)
 31726 enter -0
__1282:
 31729 rstack EAX,EBP:2
 31733 add EAX,1
 31736 mov EBX,EAX
 31738 mov EAX,#EBX
 31740 leave 
 31741 ret 
__1281:
 31742 leave 
 31743 ret 
stringtracker_get_x:
// stringtracker_get_x(self)
 31744 enter -0
__1284:
 31747 rstack EAX,EBP:2
 31751 add EAX,2
 31754 mov EBX,EAX
 31756 mov EAX,#EBX
 31758 leave 
 31759 ret 
__1283:
 31760 leave 
 31761 ret 
stringtracker_get_y:
// stringtracker_get_y(self)
 31762 enter -0
__1286:
 31765 rstack EAX,EBP:2
 31769 add EAX,3
 31772 mov EBX,EAX
 31774 mov EAX,#EBX
 31776 leave 
 31777 ret 
__1285:
 31778 leave 
 31779 ret 
stringtracker_get_box:
// stringtracker_get_box(self,return_x_min,return_x_max,return_y_min,return_y_max)
 31780 enter -0
__1288:
 31783 rstack EAX,EBP:2
 31787 add EAX,4
 31790 mov EBX,EAX
 31792 rstack EAX,EBP:3
// *return_x_min=self[4]
 31796 mov #EAX,#EBX
 31798 rstack EAX,EBP:2
 31802 add EAX,5
 31805 mov EBX,EAX
 31807 rstack EAX,EBP:4
// *return_x_max=self[5]
 31811 mov #EAX,#EBX
 31813 rstack EAX,EBP:2
 31817 add EAX,6
 31820 mov EBX,EAX
 31822 rstack EAX,EBP:5
// *return_y_min=self[6]
 31826 mov #EAX,#EBX
 31828 rstack EAX,EBP:2
 31832 add EAX,7
 31835 mov EBX,EAX
 31837 rstack EAX,EBP:6
// *return_y_max=self[7]
 31841 mov #EAX,#EBX
__1287:
 31843 leave 
 31844 ret 
stringtracker_get_c:
// stringtracker_get_c(self)
 31845 enter 2
__1290:
 31848 rstack EAX,EBP:2
 31852 add EAX,1
 31855 mov EBX,EAX
 31857 sstack EBP:-1,#EBX
 31861 rstack EAX,EBP:2
 31865 add EAX,0
 31868 mov EBX,EAX
 31870 sstack EBP:-2,#EBX
 31874 rstack EAX,EBP:-1
 31878 rstack EBX,EBP:-2
 31882 add EBX,EAX
 31884 mov EAX,EBX
 31886 mov EAX,#EAX
 31888 leave 
 31889 ret 
__1289:
 31890 leave 
 31891 ret 
stringtracker_set_str:
// stringtracker_set_str(self,str)
 31892 enter -0
__1292:
 31895 rstack EAX,EBP:3
 31899 rstack EBX,EBP:2
 31903 add EBX,0
 31906 mov ECX,EBX
// self[0]=str
 31908 mov #ECX,EAX
__1291:
 31910 leave 
 31911 ret 
stringtracker_set_I:
// stringtracker_set_I(self,I)
 31912 enter -0
__1294:
 31915 rstack EAX,EBP:3
 31919 rstack EBX,EBP:2
 31923 add EBX,1
 31926 mov ECX,EBX
// self[1]=I
 31928 mov #ECX,EAX
__1293:
 31930 leave 
 31931 ret 
stringtracker_set_x:
// stringtracker_set_x(self,x)
 31932 enter -0
__1296:
 31935 rstack EAX,EBP:3
 31939 rstack EBX,EBP:2
 31943 add EBX,2
 31946 mov ECX,EBX
// self[2]=x
 31948 mov #ECX,EAX
__1295:
 31950 leave 
 31951 ret 
stringtracker_set_y:
// stringtracker_set_y(self,y)
 31952 enter -0
__1298:
 31955 rstack EAX,EBP:3
 31959 rstack EBX,EBP:2
 31963 add EBX,3
 31966 mov ECX,EBX
// self[3]=y
 31968 mov #ECX,EAX
__1297:
 31970 leave 
 31971 ret 
stringtracker_set_box:
// stringtracker_set_box(self,x_min,x_max,y_min,y_max)
 31972 enter -0
__1300:
 31975 rstack EAX,EBP:3
 31979 rstack EBX,EBP:2
 31983 add EBX,4
 31986 mov ECX,EBX
// self[4]=x_min
 31988 mov #ECX,EAX
 31990 rstack EAX,EBP:4
 31994 rstack EBX,EBP:2
 31998 add EBX,5
 32001 mov ECX,EBX
// self[5]=x_max
 32003 mov #ECX,EAX
 32005 rstack EAX,EBP:5
 32009 rstack EBX,EBP:2
 32013 add EBX,6
 32016 mov ECX,EBX
// self[6]=y_min
 32018 mov #ECX,EAX
 32020 rstack EAX,EBP:6
 32024 rstack EBX,EBP:2
 32028 add EBX,7
 32031 mov ECX,EBX
// self[7]=y_max
 32033 mov #ECX,EAX
__1299:
 32035 leave 
 32036 ret 
stringtracker_set_c:
// stringtracker_set_c(self,c)
 32037 enter 2
__1302:
 32040 rstack EAX,EBP:2
 32044 add EAX,1
 32047 mov EBX,EAX
 32049 sstack EBP:-1,#EBX
 32053 rstack EAX,EBP:2
 32057 add EAX,0
 32060 mov EBX,EAX
 32062 sstack EBP:-2,#EBX
 32066 rstack EAX,EBP:3
 32070 rstack EBX,EBP:-1
 32074 rstack ECX,EBP:-2
 32078 add ECX,EBX
 32080 mov EBX,ECX
// str[I]=c
 32082 mov #EBX,EAX
__1301:
 32084 leave 
 32085 ret 
stringtracker_go_I:
// stringtracker_go_I(self,I)
 32086 enter 2
__1304:
 32089 rstack EAX,EBP:2
// stringtracker_get_I arg #1 (float* self)
 32093 push EAX
 32095 mov ECX,1
// stringtracker_get_I(...)
 32098 call 31726
 32101 add ESP,1
 32104 sstack EBP:-1,EAX
 32108 sstack EBP:-2,#31425
__1306:
 32113 rstack EAX,EBP:3
 32117 rstack EBX,EBP:-1
 32121 sub EBX,EAX
 32123 mov EAX,EBX
 32125 fsgn EAX,EAX
 32127 max EAX,0
// if (I<J
 32130 cmp 0,EAX
 32133 jz 32193
 32136 rstack EAX,EBP:2
 32140 push EAX
 32142 mov ECX,1
// stringtracker_go_right(...)
 32145 call 32756
 32148 add ESP,1
// cond=stringtracker_go_right(self)
 32151 sstack EBP:-2,EAX
 32155 rstack EAX,EBP:-1
// J++
 32159 inc EAX
 32161 sstack EBP:-1,EAX
__1308:
 32165 rstack EAX,EBP:-2
 32169 mov EBX,#31425
 32172 sub EBX,EAX
 32174 fabs EBX,EBX
 32176 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32178 cmp 0,EBX
 32181 jge 32190
 32184 rstack EAX,EBP:-2
 32188 leave 
 32189 ret 
__1309:
__1307:
 32190 jmp 32113
__1305:
__1311:
 32193 rstack EAX,EBP:-1
 32197 rstack EBX,EBP:3
 32201 sub EBX,EAX
 32203 mov EAX,EBX
 32205 fsgn EAX,EAX
 32207 max EAX,0
// if (J<I
 32210 cmp 0,EAX
 32213 jz 32273
 32216 rstack EAX,EBP:2
 32220 push EAX
 32222 mov ECX,1
// stringtracker_go_left(...)
 32225 call 33338
 32228 add ESP,1
// cond=stringtracker_go_left(self)
 32231 sstack EBP:-2,EAX
 32235 rstack EAX,EBP:-1
// J--
 32239 dec EAX
 32241 sstack EBP:-1,EAX
__1313:
 32245 rstack EAX,EBP:-2
 32249 mov EBX,#31425
 32252 sub EBX,EAX
 32254 fabs EBX,EBX
 32256 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32258 cmp 0,EBX
 32261 jge 32270
 32264 rstack EAX,EBP:-2
 32268 leave 
 32269 ret 
__1314:
__1312:
 32270 jmp 32193
__1310:
 32273 mov EAX,#31425
 32276 leave 
 32277 ret 
__1303:
 32278 leave 
 32279 ret 
stringtracker_go_x:
// stringtracker_go_x(self,x)
 32280 enter 1
__1316:
 32283 sstack EBP:-1,0
__1318:
// if (1
 32288 cmp 0,1
 32292 jz 32451
__1320:
 32295 rstack EAX,EBP:3
 32299 rstack EBX,EBP:2
 32303 add EBX,2
 32306 mov ECX,EBX
 32308 mov EBX,#ECX
 32310 sub EBX,EAX
 32312 fabs EBX,EBX
 32314 fsgn EBX,EBX
 32316 lneg EBX
// if (x==self[2])
 32318 cmp 0,EBX
 32321 jge 32329
 32324 mov EAX,#31425
 32327 leave 
 32328 ret 
__1321:
__1319:
__1323:
 32329 rstack EAX,EBP:3
 32333 rstack EBX,EBP:2
 32337 add EBX,2
 32340 mov ECX,EBX
 32342 mov EBX,#ECX
 32344 sub EBX,EAX
 32346 fsgn EBX,EBX
 32348 max EBX,0
// if (x<self[2])
 32351 cmp 0,EBX
 32354 jge 32404
 32357 rstack EAX,EBP:2
 32361 push EAX
 32363 mov ECX,1
// stringtracker_go_left_same_line(...)
 32366 call 33966
 32369 add ESP,1
// cond=stringtracker_go_left_same_line(self)
 32372 sstack EBP:-1,EAX
__1326:
 32376 rstack EAX,EBP:-1
 32380 mov EBX,#31425
 32383 sub EBX,EAX
 32385 fabs EBX,EBX
 32387 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32389 cmp 0,EBX
 32392 jge 32401
 32395 rstack EAX,EBP:-1
 32399 leave 
 32400 ret 
__1327:
__1325:
 32401 jmp 32448
__1328:
__1324:
__1330:
 32404 rstack EAX,EBP:2
 32408 push EAX
 32410 mov ECX,1
// stringtracker_go_right_same_line(...)
 32413 call 33119
 32416 add ESP,1
// cond=stringtracker_go_right_same_line(self)
 32419 sstack EBP:-1,EAX
__1332:
 32423 rstack EAX,EBP:-1
 32427 mov EBX,#31425
 32430 sub EBX,EAX
 32432 fabs EBX,EBX
 32434 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32436 cmp 0,EBX
 32439 jge 32448
 32442 rstack EAX,EBP:-1
 32446 leave 
 32447 ret 
__1333:
__1331:
__1329:
__1322:
 32448 jmp 32288
__1317:
 32451 mov EAX,#31425
 32454 leave 
 32455 ret 
__1315:
 32456 leave 
 32457 ret 
stringtracker_go_y:
// stringtracker_go_y(self,y)
 32458 enter 2
__1335:
 32461 rstack EAX,EBP:2
 32465 add EAX,2
 32468 mov EBX,EAX
 32470 sstack EBP:-1,#EBX
 32474 sstack EBP:-2,0
__1337:
// if (1
 32479 cmp 0,1
 32483 jz 32731
__1339:
 32486 rstack EAX,EBP:3
 32490 rstack EBX,EBP:2
 32494 add EBX,3
 32497 mov ECX,EBX
 32499 mov EBX,#ECX
 32501 sub EBX,EAX
 32503 neg EBX
 32505 fsgn EBX,EBX
 32507 max EBX,0
// if (y>self[3])
 32510 cmp 0,EBX
 32513 jge 32592
 32516 rstack EAX,EBP:2
 32520 push EAX
 32522 mov ECX,1
// stringtracker_go_nextline(...)
 32525 call 34235
 32528 add ESP,1
// cond=stringtracker_go_nextline(self)
 32531 sstack EBP:-2,EAX
__1342:
 32535 rstack EAX,EBP:-2
 32539 mov EBX,#31425
 32542 sub EBX,EAX
 32544 fabs EBX,EBX
 32546 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32548 cmp 0,EBX
 32551 jge 32592
__1345:
 32554 rstack EAX,EBP:3
 32558 rstack EBX,EBP:2
 32562 add EBX,3
 32565 mov ECX,EBX
 32567 mov EBX,#ECX
 32569 sub EBX,EAX
 32571 fabs EBX,EBX
 32573 fsgn EBX,EBX
// if (y!=self[3])
 32575 cmp 0,EBX
 32578 jge 32589
 32581 mov EAX,#31425
 32584 leave 
 32585 ret 
 32586 jmp 32592
__1347:
__1346:
__1349:
 32589 jmp 32731
__1348:
__1344:
__1343:
__1341:
__1340:
__1338:
__1351:
 32592 rstack EAX,EBP:3
 32596 rstack EBX,EBP:2
 32600 add EBX,3
 32603 mov ECX,EBX
 32605 mov EBX,#ECX
 32607 sub EBX,EAX
 32609 fsgn EBX,EBX
 32611 max EBX,0
// if (y<self[3])
 32614 cmp 0,EBX
 32617 jge 32696
 32620 rstack EAX,EBP:2
 32624 push EAX
 32626 mov ECX,1
// stringtracker_go_prevline(...)
 32629 call 34347
 32632 add ESP,1
// cond=stringtracker_go_prevline(self)
 32635 sstack EBP:-2,EAX
__1354:
 32639 rstack EAX,EBP:-2
 32643 mov EBX,#31425
 32646 sub EBX,EAX
 32648 fabs EBX,EBX
 32650 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 32652 cmp 0,EBX
 32655 jge 32696
__1357:
 32658 rstack EAX,EBP:3
 32662 rstack EBX,EBP:2
 32666 add EBX,3
 32669 mov ECX,EBX
 32671 mov EBX,#ECX
 32673 sub EBX,EAX
 32675 fabs EBX,EBX
 32677 fsgn EBX,EBX
// if (y!=self[3])
 32679 cmp 0,EBX
 32682 jge 32693
 32685 mov EAX,#31425
 32688 leave 
 32689 ret 
 32690 jmp 32696
__1359:
__1358:
__1361:
 32693 jmp 32731
__1360:
__1356:
__1355:
__1353:
__1352:
__1350:
__1363:
 32696 rstack EAX,EBP:3
 32700 rstack EBX,EBP:2
 32704 add EBX,3
 32707 mov ECX,EBX
 32709 mov EBX,#ECX
 32711 sub EBX,EAX
 32713 fabs EBX,EBX
 32715 fsgn EBX,EBX
 32717 lneg EBX
// if (y==self[3])
 32719 cmp 0,EBX
 32722 jge 32728
 32725 jmp 32731
__1364:
__1362:
 32728 jmp 32479
__1336:
stringtracker_go_y_adjust_x:
 32731 rstack EAX,EBP:-1
// stringtracker_go_x arg #2 (float x)
 32735 push EAX
 32737 rstack EAX,EBP:2
// stringtracker_go_x arg #1 (float* self)
 32741 push EAX
 32743 mov ECX,2
// stringtracker_go_x(...)
 32746 call 32280
 32749 add ESP,2
 32752 leave 
 32753 ret 
__1334:
 32754 leave 
 32755 ret 
stringtracker_go_right:
// stringtracker_go_right(self)
 32756 enter 8
__1366:
 32759 rstack EAX,EBP:2
 32763 add EAX,0
 32766 mov EBX,EAX
 32768 sstack EBP:-1,#EBX
 32772 rstack EAX,EBP:2
 32776 add EAX,1
 32779 mov EBX,EAX
 32781 sstack EBP:-2,#EBX
 32785 rstack EAX,EBP:2
 32789 add EAX,2
 32792 mov EBX,EAX
 32794 sstack EBP:-3,#EBX
 32798 rstack EAX,EBP:2
 32802 add EAX,3
 32805 mov EBX,EAX
 32807 sstack EBP:-4,#EBX
 32811 rstack EAX,EBP:2
 32815 add EAX,4
 32818 mov EBX,EAX
 32820 sstack EBP:-5,#EBX
 32824 rstack EAX,EBP:2
 32828 add EAX,5
 32831 mov EBX,EAX
 32833 sstack EBP:-6,#EBX
 32837 rstack EAX,EBP:2
 32841 add EAX,7
 32844 mov EBX,EAX
 32846 sstack EBP:-7,#EBX
 32850 rstack EAX,EBP:-2
 32854 rstack EBX,EBP:-1
 32858 add EBX,EAX
 32860 mov EAX,EBX
 32862 sstack EBP:-8,#EAX
__1368:
 32866 rstack EAX,EBP:-8
 32870 mov EBX,0
 32873 sub EBX,EAX
 32875 fabs EBX,EBX
 32877 fsgn EBX,EBX
 32879 lneg EBX
// if (C==0)
 32881 cmp 0,EBX
 32884 jge 32892
 32887 mov EAX,#31426
 32890 leave 
 32891 ret 
__1369:
__1367:
__1371:
 32892 rstack EAX,EBP:-3
 32896 rstack EBX,EBP:-6
 32900 sub EBX,EAX
 32902 mov EAX,EBX
 32904 fabs EAX,EAX
 32906 fsgn EAX,EAX
 32908 lneg EAX
 32910 rstack EBX,EBP:-6
 32914 mov ECX,-1
 32917 sub ECX,EBX
 32919 fabs ECX,ECX
 32921 fsgn ECX,ECX
 32923 and ECX,EAX
// if ((x_max!=-1)&&(x==x_max))
 32925 cmp 0,ECX
 32928 jge 32934
 32931 jmp 33008
__1372:
__1370:
__1374:
 32934 rstack EAX,EBP:-8
 32938 mov EBX,10
 32941 sub EBX,EAX
 32943 fabs EBX,EBX
 32945 fsgn EBX,EBX
 32947 lneg EBX
// if (C=='\10')
 32949 cmp 0,EBX
 32952 jge 32958
 32955 jmp 33008
__1375:
__1373:
 32958 rstack EAX,EBP:2
 32962 add EAX,2
 32965 mov EBX,EAX
 32967 mov EAX,#EBX
 32969 add EAX,1
 32972 rstack EBX,EBP:2
 32976 add EBX,2
 32979 mov ECX,EBX
// self[2]=self[2]+1
 32981 mov #ECX,EAX
 32983 rstack EAX,EBP:-2
 32987 add EAX,1
 32990 mov EBX,EAX
 32992 rstack EAX,EBP:2
 32996 add EAX,1
 32999 mov ECX,EAX
// self[1]=I+1
 33001 mov #ECX,EBX
 33003 mov EAX,#31425
 33006 leave 
 33007 ret 
stringtracker_go_right_nextline:
__1377:
 33008 rstack EAX,EBP:-4
 33012 rstack EBX,EBP:-7
 33016 sub EBX,EAX
 33018 mov EAX,EBX
 33020 fabs EAX,EAX
 33022 fsgn EAX,EAX
 33024 lneg EAX
 33026 rstack EBX,EBP:-7
 33030 mov ECX,-1
 33033 sub ECX,EBX
 33035 fabs ECX,ECX
 33037 fsgn ECX,ECX
 33039 and ECX,EAX
// if ((y_max!=-1)&&(y==y_max))
 33041 cmp 0,ECX
 33044 jge 33052
 33047 mov EAX,#31433
 33050 leave 
 33051 ret 
__1378:
__1376:
 33052 rstack EAX,EBP:-2
 33056 add EAX,1
 33059 mov EBX,EAX
 33061 rstack EAX,EBP:2
 33065 add EAX,1
 33068 mov ECX,EAX
// self[1]=I+1
 33070 mov #ECX,EBX
 33072 rstack EAX,EBP:-5
 33076 rstack EBX,EBP:2
 33080 add EBX,2
 33083 mov ECX,EBX
// self[2]=x_min
 33085 mov #ECX,EAX
 33087 rstack EAX,EBP:2
 33091 add EAX,3
 33094 mov EBX,EAX
 33096 mov EAX,#EBX
 33098 add EAX,1
 33101 rstack EBX,EBP:2
 33105 add EBX,3
 33108 mov ECX,EBX
// self[3]=self[3]+1
 33110 mov #ECX,EAX
 33112 mov EAX,#31425
 33115 leave 
 33116 ret 
__1365:
 33117 leave 
 33118 ret 
stringtracker_go_right_same_line:
// stringtracker_go_right_same_line(self)
 33119 enter 5
__1380:
 33122 rstack EAX,EBP:2
 33126 add EAX,0
 33129 mov EBX,EAX
 33131 sstack EBP:-1,#EBX
 33135 rstack EAX,EBP:2
 33139 add EAX,1
 33142 mov EBX,EAX
 33144 sstack EBP:-2,#EBX
 33148 rstack EAX,EBP:-2
 33152 rstack EBX,EBP:-1
 33156 add EBX,EAX
 33158 mov EAX,EBX
 33160 sstack EBP:-3,#EAX
 33164 rstack EAX,EBP:2
 33168 add EAX,2
 33171 mov EBX,EAX
 33173 sstack EBP:-4,#EBX
 33177 rstack EAX,EBP:2
 33181 add EAX,5
 33184 mov EBX,EAX
 33186 sstack EBP:-5,#EBX
__1382:
 33190 rstack EAX,EBP:-3
 33194 mov EBX,0
 33197 sub EBX,EAX
 33199 fabs EBX,EBX
 33201 fsgn EBX,EBX
 33203 lneg EBX
// if (C==0)
 33205 cmp 0,EBX
 33208 jge 33216
 33211 mov EAX,#31426
 33214 leave 
 33215 ret 
__1383:
__1381:
__1385:
 33216 rstack EAX,EBP:-4
 33220 rstack EBX,EBP:-5
 33224 sub EBX,EAX
 33226 mov EAX,EBX
 33228 fabs EAX,EAX
 33230 fsgn EAX,EAX
 33232 lneg EAX
 33234 rstack EBX,EBP:-5
 33238 mov ECX,-1
 33241 sub ECX,EBX
 33243 fabs ECX,ECX
 33245 fsgn ECX,ECX
 33247 and ECX,EAX
// if ((x_max!=-1)&&(x==x_max))
 33249 cmp 0,ECX
 33252 jge 33260
 33255 mov EAX,#31431
 33258 leave 
 33259 ret 
__1386:
__1384:
__1388:
 33260 rstack EAX,EBP:-3
 33264 mov EBX,10
 33267 sub EBX,EAX
 33269 fabs EBX,EBX
 33271 fsgn EBX,EBX
 33273 lneg EBX
// if (C=='\10')
 33275 cmp 0,EBX
 33278 jge 33286
 33281 mov EAX,#31428
 33284 leave 
 33285 ret 
__1389:
__1387:
 33286 rstack EAX,EBP:2
 33290 add EAX,2
 33293 mov EBX,EAX
 33295 mov EAX,#EBX
 33297 add EAX,1
 33300 rstack EBX,EBP:2
 33304 add EBX,2
 33307 mov ECX,EBX
// self[2]=self[2]+1
 33309 mov #ECX,EAX
 33311 rstack EAX,EBP:-2
 33315 add EAX,1
 33318 mov EBX,EAX
 33320 rstack EAX,EBP:2
 33324 add EAX,1
 33327 mov ECX,EAX
// self[1]=I+1
 33329 mov #ECX,EBX
 33331 mov EAX,#31425
 33334 leave 
 33335 ret 
__1379:
 33336 leave 
 33337 ret 
stringtracker_go_left:
// stringtracker_go_left(self)
 33338 enter 11
__1391:
 33341 rstack EAX,EBP:2
 33345 add EAX,0
 33348 mov EBX,EAX
 33350 sstack EBP:-1,#EBX
 33354 rstack EAX,EBP:2
 33358 add EAX,1
 33361 mov EBX,EAX
 33363 sstack EBP:-2,#EBX
 33367 rstack EAX,EBP:-2
 33371 rstack EBX,EBP:-1
 33375 add EBX,EAX
 33377 mov EAX,EBX
 33379 sstack EBP:-3,#EAX
 33383 rstack EAX,EBP:2
 33387 add EAX,2
 33390 mov EBX,EAX
 33392 sstack EBP:-4,#EBX
 33396 rstack EAX,EBP:2
 33400 add EAX,3
 33403 mov EBX,EAX
 33405 sstack EBP:-5,#EBX
 33409 rstack EAX,EBP:2
 33413 add EAX,4
 33416 mov EBX,EAX
 33418 sstack EBP:-6,#EBX
 33422 rstack EAX,EBP:2
 33426 add EAX,6
 33429 mov EBX,EAX
 33431 sstack EBP:-7,#EBX
__1393:
 33435 rstack EAX,EBP:-2
 33439 mov EBX,0
 33442 sub EBX,EAX
 33444 fabs EBX,EBX
 33446 fsgn EBX,EBX
 33448 lneg EBX
// if (I==0)
 33450 cmp 0,EBX
 33453 jge 33461
 33456 mov EAX,#31427
 33459 leave 
 33460 ret 
__1394:
__1392:
__1396:
 33461 rstack EAX,EBP:-4
 33465 rstack EBX,EBP:-6
 33469 sub EBX,EAX
 33471 mov EAX,EBX
 33473 fabs EAX,EAX
 33475 fsgn EAX,EAX
 33477 lneg EAX
 33479 rstack EBX,EBP:-6
 33483 mov ECX,-1
 33486 sub ECX,EBX
 33488 fabs ECX,ECX
 33490 fsgn ECX,ECX
 33492 and ECX,EAX
// if ((x_min!=-1)&&(x==x_min))
 33494 cmp 0,ECX
 33497 jge 33503
 33500 jmp 33576
__1397:
__1395:
 33503 rstack EAX,EBP:-2
 33507 add EAX,-1
 33510 mov EBX,EAX
 33512 rstack EAX,EBP:-1
 33516 add EAX,EBX
 33518 mov EBX,EAX
// C=str[I-1]
 33520 sstack EBP:-3,#EBX
__1399:
 33524 rstack EAX,EBP:-3
 33528 mov EBX,10
 33531 sub EBX,EAX
 33533 fabs EBX,EBX
 33535 fsgn EBX,EBX
 33537 lneg EBX
// if (C=='\10')
 33539 cmp 0,EBX
 33542 jge 33548
 33545 jmp 33576
__1400:
__1398:
 33548 rstack EAX,EBP:2
 33552 add EAX,2
 33555 mov EBX,EAX
 33557 mov EAX,#EBX
 33559 add EAX,-1
 33562 rstack EBX,EBP:2
 33566 add EBX,2
 33569 mov ECX,EBX
// self[2]=self[2]-1
 33571 mov #ECX,EAX
 33573 jmp 33939
stringtracker_go_left_prevline:
__1402:
 33576 rstack EAX,EBP:-5
 33580 rstack EBX,EBP:-7
 33584 sub EBX,EAX
 33586 mov EAX,EBX
 33588 fabs EAX,EAX
 33590 fsgn EAX,EAX
 33592 lneg EAX
 33594 rstack EBX,EBP:-7
 33598 mov ECX,-1
 33601 sub ECX,EBX
 33603 fabs ECX,ECX
 33605 fsgn ECX,ECX
 33607 and ECX,EAX
// if ((y_min!=-1)&&(y==y_min))
 33609 cmp 0,ECX
 33612 jge 33620
 33615 mov EAX,#31432
 33618 leave 
 33619 ret 
__1403:
__1401:
 33620 rstack EAX,EBP:2
 33624 add EAX,3
 33627 mov EBX,EAX
 33629 mov EAX,#EBX
 33631 add EAX,-1
 33634 rstack EBX,EBP:2
 33638 add EBX,3
 33641 mov ECX,EBX
// self[3]=self[3]-1
 33643 mov #ECX,EAX
 33645 rstack EAX,EBP:-6
 33649 rstack EBX,EBP:2
 33653 add EBX,2
 33656 mov ECX,EBX
// self[2]=x_min
 33658 mov #ECX,EAX
 33660 rstack EAX,EBP:-2
 33664 add EAX,-1
 33667 mov EBX,EAX
 33669 sstack EBP:-8,EBX
stringtracker_go_left_loop:
__1405:
 33673 rstack EAX,EBP:-8
 33677 mov EBX,0
 33680 sub EBX,EAX
 33682 fabs EBX,EBX
 33684 fsgn EBX,EBX
 33686 lneg EBX
// if (J==0)
 33688 cmp 0,EBX
 33691 jge 33697
 33694 jmp 33775
__1406:
__1404:
 33697 rstack EAX,EBP:-8
// J--
 33701 dec EAX
 33703 sstack EBP:-8,EAX
 33707 rstack EAX,EBP:-8
 33711 rstack EBX,EBP:-1
 33715 add EBX,EAX
 33717 mov EAX,EBX
// C=str[J]
 33719 sstack EBP:-3,#EAX
__1408:
 33723 rstack EAX,EBP:-3
 33727 mov EBX,10
 33730 sub EBX,EAX
 33732 fabs EBX,EBX
 33734 fsgn EBX,EBX
 33736 lneg EBX
// if (C=='\10')
 33738 cmp 0,EBX
 33741 jge 33747
 33744 jmp 33775
__1409:
__1407:
 33747 rstack EAX,EBP:2
 33751 add EAX,2
 33754 mov EBX,EAX
 33756 mov EAX,#EBX
 33758 add EAX,1
 33761 rstack EBX,EBP:2
 33765 add EBX,2
 33768 mov ECX,EBX
// self[2]=self[2]+1
 33770 mov #ECX,EAX
 33772 jmp 33673
stringtracker_go_left_measured_ok:
 33775 rstack EAX,EBP:2
 33779 add EAX,2
 33782 mov EBX,EAX
// x=self[2]
 33784 sstack EBP:-4,#EBX
 33788 rstack EAX,EBP:2
 33792 add EAX,5
 33795 mov EBX,EAX
 33797 sstack EBP:-9,#EBX
__1411:
 33801 rstack EAX,EBP:-9
 33805 mov EBX,-1
 33808 sub EBX,EAX
 33810 fabs EBX,EBX
 33812 fsgn EBX,EBX
// if (x_max!=-1)
 33814 cmp 0,EBX
 33817 jge 33939
 33820 rstack EAX,EBP:-9
 33824 add EAX,1
 33827 mov EBX,EAX
 33829 sstack EBP:-10,EBX
__1414:
 33833 rstack EAX,EBP:-6
 33837 mov EBX,-1
 33840 sub EBX,EAX
 33842 fabs EBX,EBX
 33844 fsgn EBX,EBX
// if (x_min!=-1)
 33846 cmp 0,EBX
 33849 jge 33872
 33852 rstack EAX,EBP:-6
 33856 neg EAX
 33858 mov EBX,EAX
 33860 rstack EAX,EBP:-10
 33864 add EAX,EBX
 33866 mov EBX,EAX
// len=len-x_min
 33868 sstack EBP:-10,EBX
__1415:
__1413:
 33872 rstack EAX,EBP:-10
 33876 rstack EBX,EBP:-4
 33880 div EBX,EAX
 33882 mov EAX,EBX
// floor arg #1 (float A)
 33884 push EAX
 33886 mov ECX,1
// floor(...)
 33889 call 16743
 33892 add ESP,1
 33895 sstack EBP:-11,EAX
 33899 rstack EAX,EBP:-10
// modulo arg #2 (float B)
 33903 push EAX
 33905 rstack EAX,EBP:-4
// modulo arg #1 (float A)
 33909 push EAX
 33911 mov ECX,2
// modulo(...)
 33914 call 16521
 33917 add ESP,2
// x=modulo(x,len)
 33920 sstack EBP:-4,EAX
 33924 rstack EAX,EBP:-4
 33928 rstack EBX,EBP:2
 33932 add EBX,2
 33935 mov ECX,EBX
// self[2]=x
 33937 mov #ECX,EAX
__1412:
__1410:
stringtracker_go_left_ok:
 33939 rstack EAX,EBP:-2
 33943 add EAX,-1
 33946 mov EBX,EAX
 33948 rstack EAX,EBP:2
 33952 add EAX,1
 33955 mov ECX,EAX
// self[1]=I-1
 33957 mov #ECX,EBX
 33959 mov EAX,#31425
 33962 leave 
 33963 ret 
__1390:
 33964 leave 
 33965 ret 
stringtracker_go_left_same_line:
// stringtracker_go_left_same_line(self)
 33966 enter 7
__1417:
 33969 rstack EAX,EBP:2
 33973 add EAX,0
 33976 mov EBX,EAX
 33978 sstack EBP:-1,#EBX
 33982 rstack EAX,EBP:2
 33986 add EAX,1
 33989 mov EBX,EAX
 33991 sstack EBP:-2,#EBX
 33995 rstack EAX,EBP:-2
 33999 rstack EBX,EBP:-1
 34003 add EBX,EAX
 34005 mov EAX,EBX
 34007 sstack EBP:-3,#EAX
 34011 rstack EAX,EBP:2
 34015 add EAX,2
 34018 mov EBX,EAX
 34020 sstack EBP:-4,#EBX
 34024 rstack EAX,EBP:2
 34028 add EAX,3
 34031 mov EBX,EAX
 34033 sstack EBP:-5,#EBX
 34037 rstack EAX,EBP:2
 34041 add EAX,4
 34044 mov EBX,EAX
 34046 sstack EBP:-6,#EBX
 34050 rstack EAX,EBP:2
 34054 add EAX,6
 34057 mov EBX,EAX
 34059 sstack EBP:-7,#EBX
__1419:
 34063 rstack EAX,EBP:-2
 34067 mov EBX,0
 34070 sub EBX,EAX
 34072 fabs EBX,EBX
 34074 fsgn EBX,EBX
 34076 lneg EBX
// if (I==0)
 34078 cmp 0,EBX
 34081 jge 34089
 34084 mov EAX,#31427
 34087 leave 
 34088 ret 
__1420:
__1418:
 34089 rstack EAX,EBP:-2
 34093 add EAX,-1
 34096 mov EBX,EAX
 34098 rstack EAX,EBP:-1
 34102 add EAX,EBX
 34104 mov EBX,EAX
// C=str[I-1]
 34106 sstack EBP:-3,#EBX
__1422:
 34110 rstack EAX,EBP:-3
 34114 mov EBX,10
 34117 sub EBX,EAX
 34119 fabs EBX,EBX
 34121 fsgn EBX,EBX
 34123 lneg EBX
// if (C=='\10')
 34125 cmp 0,EBX
 34128 jge 34139
 34131 mov EAX,#31429
 34134 leave 
 34135 ret 
 34136 jmp 34233
__1424:
__1423:
__1426:
__1428:
 34139 rstack EAX,EBP:-4
 34143 rstack EBX,EBP:-6
 34147 sub EBX,EAX
 34149 mov EAX,EBX
 34151 fabs EAX,EAX
 34153 fsgn EAX,EAX
 34155 lneg EAX
 34157 rstack EBX,EBP:-6
 34161 mov ECX,-1
 34164 sub ECX,EBX
 34166 fabs ECX,ECX
 34168 fsgn ECX,ECX
 34170 and ECX,EAX
// if ((x_min!=-1)&&(x==x_min))
 34172 cmp 0,ECX
 34175 jge 34183
 34178 mov EAX,#31430
 34181 leave 
 34182 ret 
__1429:
__1427:
 34183 rstack EAX,EBP:-2
 34187 add EAX,-1
 34190 mov EBX,EAX
 34192 rstack EAX,EBP:2
 34196 add EAX,1
 34199 mov ECX,EAX
// self[1]=I-1
 34201 mov #ECX,EBX
 34203 rstack EAX,EBP:2
 34207 add EAX,2
 34210 mov EBX,EAX
 34212 mov EAX,#EBX
 34214 add EAX,-1
 34217 rstack EBX,EBP:2
 34221 add EBX,2
 34224 mov ECX,EBX
// self[2]=self[2]-1
 34226 mov #ECX,EAX
 34228 mov EAX,#31425
 34231 leave 
 34232 ret 
__1425:
__1421:
__1416:
 34233 leave 
 34234 ret 
stringtracker_go_nextline:
// stringtracker_go_nextline(self)
 34235 enter 2
__1431:
 34238 rstack EAX,EBP:2
 34242 add EAX,3
 34245 mov EBX,EAX
 34247 sstack EBP:-1,#EBX
 34251 sstack EBP:-2,0
__1433:
// if (1
 34256 cmp 0,1
 34260 jz 34345
 34263 rstack EAX,EBP:2
// stringtracker_go_right arg #1 (float* self)
 34267 push EAX
 34269 mov ECX,1
// stringtracker_go_right(...)
 34272 call 32756
 34275 add ESP,1
// cond=stringtracker_go_right(self)
 34278 sstack EBP:-2,EAX
__1435:
 34282 rstack EAX,EBP:-2
 34286 mov EBX,#31425
 34289 sub EBX,EAX
 34291 fabs EBX,EBX
 34293 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34295 cmp 0,EBX
 34298 jge 34307
 34301 rstack EAX,EBP:-2
 34305 leave 
 34306 ret 
__1436:
__1434:
__1438:
 34307 rstack EAX,EBP:2
 34311 add EAX,3
 34314 mov EBX,EAX
 34316 rstack EAX,EBP:-1
 34320 sub EAX,#EBX
 34322 mov EBX,EAX
 34324 neg EBX
 34326 fsgn EBX,EBX
 34328 max EBX,0
// if (self[3]>y)
 34331 cmp 0,EBX
 34334 jge 34342
 34337 mov EAX,#31425
 34340 leave 
 34341 ret 
__1439:
__1437:
 34342 jmp 34256
__1432:
__1430:
 34345 leave 
 34346 ret 
stringtracker_go_prevline:
// stringtracker_go_prevline(self)
 34347 enter 2
__1441:
 34350 rstack EAX,EBP:2
 34354 add EAX,3
 34357 mov EBX,EAX
 34359 sstack EBP:-1,#EBX
 34363 sstack EBP:-2,0
__1443:
// if (1
 34368 cmp 0,1
 34372 jz 34455
 34375 rstack EAX,EBP:2
// stringtracker_go_left arg #1 (float* self)
 34379 push EAX
 34381 mov ECX,1
// stringtracker_go_left(...)
 34384 call 33338
 34387 add ESP,1
// cond=stringtracker_go_left(self)
 34390 sstack EBP:-2,EAX
__1445:
 34394 rstack EAX,EBP:-2
 34398 mov EBX,#31425
 34401 sub EBX,EAX
 34403 fabs EBX,EBX
 34405 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34407 cmp 0,EBX
 34410 jge 34419
 34413 rstack EAX,EBP:-2
 34417 leave 
 34418 ret 
__1446:
__1444:
__1448:
 34419 rstack EAX,EBP:2
 34423 add EAX,3
 34426 mov EBX,EAX
 34428 rstack EAX,EBP:-1
 34432 sub EAX,#EBX
 34434 mov EBX,EAX
 34436 fsgn EBX,EBX
 34438 max EBX,0
// if (self[3]<y)
 34441 cmp 0,EBX
 34444 jge 34452
 34447 mov EAX,#31425
 34450 leave 
 34451 ret 
__1449:
__1447:
 34452 jmp 34368
__1442:
__1440:
 34455 leave 
 34456 ret 
stringtracker_go_down:
// stringtracker_go_down(self)
 34457 enter 1
__1451:
 34460 rstack EAX,EBP:2
 34464 add EAX,3
 34467 mov EBX,EAX
 34469 sstack EBP:-1,#EBX
 34473 rstack EAX,EBP:-1
 34477 add EAX,1
 34480 mov EBX,EAX
// stringtracker_go_y arg #2 (float y)
 34482 push EBX
 34484 rstack EAX,EBP:2
// stringtracker_go_y arg #1 (float* self)
 34488 push EAX
 34490 mov ECX,2
// stringtracker_go_y(...)
 34493 call 32458
 34496 add ESP,2
 34499 leave 
 34500 ret 
__1450:
 34501 leave 
 34502 ret 
stringtracker_go_up:
// stringtracker_go_up(self)
 34503 enter 1
__1453:
 34506 rstack EAX,EBP:2
 34510 add EAX,3
 34513 mov EBX,EAX
 34515 sstack EBP:-1,#EBX
 34519 rstack EAX,EBP:-1
 34523 add EAX,-1
 34526 mov EBX,EAX
// stringtracker_go_y arg #2 (float y)
 34528 push EBX
 34530 rstack EAX,EBP:2
// stringtracker_go_y arg #1 (float* self)
 34534 push EAX
 34536 mov ECX,2
// stringtracker_go_y(...)
 34539 call 32458
 34542 add ESP,2
 34545 leave 
 34546 ret 
__1452:
 34547 leave 
 34548 ret 
stringtracker_go_beginning_of_string:
// stringtracker_go_beginning_of_string(self)
 34549 enter 1
__1455:
 34552 sstack EBP:-1,0
__1457:
 34557 rstack EAX,EBP:2
 34561 add EAX,1
 34564 mov EBX,EAX
 34566 mov EAX,0
 34569 sub EAX,#EBX
 34571 fabs EAX,EAX
 34573 fsgn EAX,EAX
// if (self[1]!=0
 34575 cmp 0,EAX
 34578 jz 34628
 34581 rstack EAX,EBP:2
// stringtracker_go_left arg #1 (float* self)
 34585 push EAX
 34587 mov ECX,1
// stringtracker_go_left(...)
 34590 call 33338
 34593 add ESP,1
// cond=stringtracker_go_left(self)
 34596 sstack EBP:-1,EAX
__1459:
 34600 rstack EAX,EBP:-1
 34604 mov EBX,#31425
 34607 sub EBX,EAX
 34609 fabs EBX,EBX
 34611 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34613 cmp 0,EBX
 34616 jge 34625
 34619 rstack EAX,EBP:-1
 34623 leave 
 34624 ret 
__1460:
__1458:
 34625 jmp 34557
__1456:
 34628 mov EAX,#31425
 34631 leave 
 34632 ret 
__1454:
 34633 leave 
 34634 ret 
stringtracker_go_end_of_string:
// stringtracker_go_end_of_string(self)
 34635 enter 1
__1462:
 34638 sstack EBP:-1,0
__1464:
 34643 rstack EAX,EBP:2
// stringtracker_get_c arg #1 (float* self)
 34647 push EAX
 34649 mov ECX,1
// stringtracker_get_c(...)
 34652 call 31845
 34655 add ESP,1
 34658 mov EBX,0
 34661 sub EBX,EAX
 34663 fabs EBX,EBX
 34665 fsgn EBX,EBX
// if (stringtracker_get_c(self)!=0
 34667 cmp 0,EBX
 34670 jz 34720
 34673 rstack EAX,EBP:2
// stringtracker_go_right arg #1 (float* self)
 34677 push EAX
 34679 mov ECX,1
// stringtracker_go_right(...)
 34682 call 32756
 34685 add ESP,1
// cond=stringtracker_go_right(self)
 34688 sstack EBP:-1,EAX
__1466:
 34692 rstack EAX,EBP:-1
 34696 mov EBX,#31425
 34699 sub EBX,EAX
 34701 fabs EBX,EBX
 34703 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34705 cmp 0,EBX
 34708 jge 34717
 34711 rstack EAX,EBP:-1
 34715 leave 
 34716 ret 
__1467:
__1465:
 34717 jmp 34643
__1463:
 34720 mov EAX,#31425
 34723 leave 
 34724 ret 
__1461:
 34725 leave 
 34726 ret 
stringtracker_go_beginning_of_line:
// stringtracker_go_beginning_of_line(self)
 34727 enter 1
__1469:
 34730 sstack EBP:-1,0
__1471:
// if (1
 34735 cmp 0,1
 34739 jz 34788
 34742 rstack EAX,EBP:2
// stringtracker_go_left_same_line arg #1 (float* self)
 34746 push EAX
 34748 mov ECX,1
// stringtracker_go_left_same_line(...)
 34751 call 33966
 34754 add ESP,1
// cond=stringtracker_go_left_same_line(self)
 34757 sstack EBP:-1,EAX
__1473:
 34761 rstack EAX,EBP:-1
 34765 mov EBX,#31425
 34768 sub EBX,EAX
 34770 fabs EBX,EBX
 34772 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34774 cmp 0,EBX
 34777 jge 34785
 34780 mov EAX,#31425
 34783 leave 
 34784 ret 
__1474:
__1472:
 34785 jmp 34735
__1470:
__1468:
 34788 leave 
 34789 ret 
stringtracker_go_end_of_line:
// stringtracker_go_end_of_line(self)
 34790 enter 1
__1476:
 34793 sstack EBP:-1,0
__1478:
// if (1
 34798 cmp 0,1
 34802 jz 34851
 34805 rstack EAX,EBP:2
// stringtracker_go_right_same_line arg #1 (float* self)
 34809 push EAX
 34811 mov ECX,1
// stringtracker_go_right_same_line(...)
 34814 call 33119
 34817 add ESP,1
// cond=stringtracker_go_right_same_line(self)
 34820 sstack EBP:-1,EAX
__1480:
 34824 rstack EAX,EBP:-1
 34828 mov EBX,#31425
 34831 sub EBX,EAX
 34833 fabs EBX,EBX
 34835 fsgn EBX,EBX
// if (cond!=stringtracker_ok)
 34837 cmp 0,EBX
 34840 jge 34848
 34843 mov EAX,#31425
 34846 leave 
 34847 ret 
__1481:
__1479:
 34848 jmp 34798
__1477:
__1475:
 34851 leave 
 34852 ret 
stringtracker_test:
// stringtracker_test()
 34853 enter 2
__1483:
 34856 mov EAX,2041
 34859 add EAX,#37053
// AdrScreen[2041]=1
 34862 mov #EAX,1
// malloc arg #1 (float n)
 34865 push #31424
 34868 mov ECX,1
// malloc(...)
 34871 call 20709
 34874 add ESP,1
// stringtracker_test_tracker=malloc(sizeof_stringtracker)
 34877 mov #36481,EAX
// stringtracker_constructor arg #2 (char* str)
 34880 push 36249
// stringtracker_constructor arg #1 (float* self)
 34883 push #36481
 34886 mov ECX,2
// stringtracker_constructor(...)
 34889 call 31434
 34892 add ESP,2
// stringtracker_set_box arg #5 (float y_max)
 34895 push 17
// stringtracker_set_box arg #4 (float y_min)
 34898 push 0
// stringtracker_set_box arg #3 (float x_max)
 34901 push 29
// stringtracker_set_box arg #2 (float x_min)
 34904 push 0
// stringtracker_set_box arg #1 (float* self)
 34907 push #36481
 34910 mov ECX,5
// stringtracker_set_box(...)
 34913 call 31972
 34916 add ESP,5
 34919 sstack EBP:-1,#36481
__1485:
 34924 mov ECX,0
// malloc_test(...)
 34927 call 19640
// if (malloc_test())
 34930 cmp 0,EAX
 34933 jge 34939
 34936 jmp 35882
__1486:
__1484:
 34939 push 999
 34942 push 36249
 34945 mov ECX,2
// Print(...)
 34948 call 40786
 34951 add ESP,2
 34954 mov EAX,2046
 34957 add EAX,#37053
// AdrScreen[2046]=1
 34960 mov #EAX,1
 34963 mov ECX,0
// stringtracker_test_snap_cursor(...)
 34966 call 35925
 34969 mov EAX,2020
 34972 add EAX,#37053
// AdrScreen[2020]=1
 34975 mov #EAX,1
 34978 push 1
 34981 mov ECX,1
// delay(...)
 34984 call 36681
 34987 add ESP,1
__1488:
// if (1
 34990 cmp 0,1
 34994 jz 35882
 34997 mov ECX,0
// readKey(...)
 35000 call 37108
 35003 sstack EBP:-2,EAX
__1490:
 35007 rstack EAX,EBP:-2
// if (C
 35011 cmp 0,EAX
 35014 jz 35879
__1492:
 35017 rstack EAX,EBP:-2
 35021 mov EBX,17
 35024 sub EBX,EAX
 35026 fabs EBX,EBX
 35028 fsgn EBX,EBX
 35030 lneg EBX
// if (C==17)
 35032 cmp 0,EBX
 35035 jge 35059
 35038 rstack EAX,EBP:-1
// stringtracker_go_up arg #1 (float* self)
 35042 push EAX
 35044 mov ECX,1
// stringtracker_go_up(...)
 35047 call 34503
 35050 add ESP,1
 35053 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35056 call 35925
__1493:
__1491:
__1495:
 35059 rstack EAX,EBP:-2
 35063 mov EBX,18
 35066 sub EBX,EAX
 35068 fabs EBX,EBX
 35070 fsgn EBX,EBX
 35072 lneg EBX
// if (C==18)
 35074 cmp 0,EBX
 35077 jge 35101
 35080 rstack EAX,EBP:-1
// stringtracker_go_down arg #1 (float* self)
 35084 push EAX
 35086 mov ECX,1
// stringtracker_go_down(...)
 35089 call 34457
 35092 add ESP,1
 35095 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35098 call 35925
__1496:
__1494:
__1498:
 35101 rstack EAX,EBP:-2
 35105 mov EBX,19
 35108 sub EBX,EAX
 35110 fabs EBX,EBX
 35112 fsgn EBX,EBX
 35114 lneg EBX
// if (C==19)
 35116 cmp 0,EBX
 35119 jge 35143
 35122 rstack EAX,EBP:-1
// stringtracker_go_left arg #1 (float* self)
 35126 push EAX
 35128 mov ECX,1
// stringtracker_go_left(...)
 35131 call 33338
 35134 add ESP,1
 35137 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35140 call 35925
__1499:
__1497:
__1501:
 35143 rstack EAX,EBP:-2
 35147 mov EBX,20
 35150 sub EBX,EAX
 35152 fabs EBX,EBX
 35154 fsgn EBX,EBX
 35156 lneg EBX
// if (C==20)
 35158 cmp 0,EBX
 35161 jge 35185
 35164 rstack EAX,EBP:-1
// stringtracker_go_right arg #1 (float* self)
 35168 push EAX
 35170 mov ECX,1
// stringtracker_go_right(...)
 35173 call 32756
 35176 add ESP,1
 35179 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35182 call 35925
__1502:
__1500:
__1504:
 35185 rstack EAX,EBP:-2
 35189 mov EBX,129
 35192 sub EBX,EAX
 35194 fabs EBX,EBX
 35196 fsgn EBX,EBX
 35198 lneg EBX
// if (C==129)
 35200 cmp 0,EBX
 35203 jge 35230
// stringtracker_go_x arg #2 (float x)
 35206 push 1
 35209 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35213 push EAX
 35215 mov ECX,2
// stringtracker_go_x(...)
 35218 call 32280
 35221 add ESP,2
 35224 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35227 call 35925
__1505:
__1503:
__1507:
 35230 rstack EAX,EBP:-2
 35234 mov EBX,130
 35237 sub EBX,EAX
 35239 fabs EBX,EBX
 35241 fsgn EBX,EBX
 35243 lneg EBX
// if (C==130)
 35245 cmp 0,EBX
 35248 jge 35275
// stringtracker_go_x arg #2 (float x)
 35251 push 2
 35254 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35258 push EAX
 35260 mov ECX,2
// stringtracker_go_x(...)
 35263 call 32280
 35266 add ESP,2
 35269 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35272 call 35925
__1508:
__1506:
__1510:
 35275 rstack EAX,EBP:-2
 35279 mov EBX,131
 35282 sub EBX,EAX
 35284 fabs EBX,EBX
 35286 fsgn EBX,EBX
 35288 lneg EBX
// if (C==131)
 35290 cmp 0,EBX
 35293 jge 35320
// stringtracker_go_x arg #2 (float x)
 35296 push 3
 35299 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35303 push EAX
 35305 mov ECX,2
// stringtracker_go_x(...)
 35308 call 32280
 35311 add ESP,2
 35314 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35317 call 35925
__1511:
__1509:
__1513:
 35320 rstack EAX,EBP:-2
 35324 mov EBX,132
 35327 sub EBX,EAX
 35329 fabs EBX,EBX
 35331 fsgn EBX,EBX
 35333 lneg EBX
// if (C==132)
 35335 cmp 0,EBX
 35338 jge 35365
// stringtracker_go_x arg #2 (float x)
 35341 push 4
 35344 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35348 push EAX
 35350 mov ECX,2
// stringtracker_go_x(...)
 35353 call 32280
 35356 add ESP,2
 35359 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35362 call 35925
__1514:
__1512:
__1516:
 35365 rstack EAX,EBP:-2
 35369 mov EBX,133
 35372 sub EBX,EAX
 35374 fabs EBX,EBX
 35376 fsgn EBX,EBX
 35378 lneg EBX
// if (C==133)
 35380 cmp 0,EBX
 35383 jge 35410
// stringtracker_go_x arg #2 (float x)
 35386 push 5
 35389 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35393 push EAX
 35395 mov ECX,2
// stringtracker_go_x(...)
 35398 call 32280
 35401 add ESP,2
 35404 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35407 call 35925
__1517:
__1515:
__1519:
 35410 rstack EAX,EBP:-2
 35414 mov EBX,134
 35417 sub EBX,EAX
 35419 fabs EBX,EBX
 35421 fsgn EBX,EBX
 35423 lneg EBX
// if (C==134)
 35425 cmp 0,EBX
 35428 jge 35455
// stringtracker_go_x arg #2 (float x)
 35431 push 6
 35434 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35438 push EAX
 35440 mov ECX,2
// stringtracker_go_x(...)
 35443 call 32280
 35446 add ESP,2
 35449 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35452 call 35925
__1520:
__1518:
__1522:
 35455 rstack EAX,EBP:-2
 35459 mov EBX,135
 35462 sub EBX,EAX
 35464 fabs EBX,EBX
 35466 fsgn EBX,EBX
 35468 lneg EBX
// if (C==135)
 35470 cmp 0,EBX
 35473 jge 35500
// stringtracker_go_x arg #2 (float x)
 35476 push 7
 35479 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35483 push EAX
 35485 mov ECX,2
// stringtracker_go_x(...)
 35488 call 32280
 35491 add ESP,2
 35494 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35497 call 35925
__1523:
__1521:
__1525:
 35500 rstack EAX,EBP:-2
 35504 mov EBX,136
 35507 sub EBX,EAX
 35509 fabs EBX,EBX
 35511 fsgn EBX,EBX
 35513 lneg EBX
// if (C==136)
 35515 cmp 0,EBX
 35518 jge 35545
// stringtracker_go_x arg #2 (float x)
 35521 push 8
 35524 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35528 push EAX
 35530 mov ECX,2
// stringtracker_go_x(...)
 35533 call 32280
 35536 add ESP,2
 35539 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35542 call 35925
__1526:
__1524:
__1528:
 35545 rstack EAX,EBP:-2
 35549 mov EBX,137
 35552 sub EBX,EAX
 35554 fabs EBX,EBX
 35556 fsgn EBX,EBX
 35558 lneg EBX
// if (C==137)
 35560 cmp 0,EBX
 35563 jge 35590
// stringtracker_go_x arg #2 (float x)
 35566 push 9
 35569 rstack EAX,EBP:-1
// stringtracker_go_x arg #1 (float* self)
 35573 push EAX
 35575 mov ECX,2
// stringtracker_go_x(...)
 35578 call 32280
 35581 add ESP,2
 35584 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35587 call 35925
__1529:
__1527:
__1531:
 35590 rstack EAX,EBP:-2
 35594 mov EBX,149
 35597 sub EBX,EAX
 35599 fabs EBX,EBX
 35601 fsgn EBX,EBX
 35603 lneg EBX
// if (C==149)
 35605 cmp 0,EBX
 35608 jge 35632
 35611 rstack EAX,EBP:-1
// stringtracker_go_beginning_of_string arg #1 (float* self)
 35615 push EAX
 35617 mov ECX,1
// stringtracker_go_beginning_of_string(...)
 35620 call 34549
 35623 add ESP,1
 35626 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35629 call 35925
__1532:
__1530:
__1534:
 35632 rstack EAX,EBP:-2
 35636 mov EBX,150
 35639 sub EBX,EAX
 35641 fabs EBX,EBX
 35643 fsgn EBX,EBX
 35645 lneg EBX
// if (C==150)
 35647 cmp 0,EBX
 35650 jge 35674
 35653 rstack EAX,EBP:-1
// stringtracker_go_end_of_string arg #1 (float* self)
 35657 push EAX
 35659 mov ECX,1
// stringtracker_go_end_of_string(...)
 35662 call 34635
 35665 add ESP,1
 35668 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35671 call 35925
__1535:
__1533:
__1537:
 35674 rstack EAX,EBP:-2
 35678 mov EBX,151
 35681 sub EBX,EAX
 35683 fabs EBX,EBX
 35685 fsgn EBX,EBX
 35687 lneg EBX
// if (C==151)
 35689 cmp 0,EBX
 35692 jge 35716
 35695 rstack EAX,EBP:-1
// stringtracker_go_beginning_of_line arg #1 (float* self)
 35699 push EAX
 35701 mov ECX,1
// stringtracker_go_beginning_of_line(...)
 35704 call 34727
 35707 add ESP,1
 35710 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35713 call 35925
__1538:
__1536:
__1540:
 35716 rstack EAX,EBP:-2
 35720 mov EBX,152
 35723 sub EBX,EAX
 35725 fabs EBX,EBX
 35727 fsgn EBX,EBX
 35729 lneg EBX
// if (C==152)
 35731 cmp 0,EBX
 35734 jge 35758
 35737 rstack EAX,EBP:-1
// stringtracker_go_end_of_line arg #1 (float* self)
 35741 push EAX
 35743 mov ECX,1
// stringtracker_go_end_of_line(...)
 35746 call 34790
 35749 add ESP,1
 35752 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35755 call 35925
__1541:
__1539:
__1543:
 35758 rstack EAX,EBP:-2
 35762 mov EBX,166
 35765 sub EBX,EAX
 35767 fabs EBX,EBX
 35769 fsgn EBX,EBX
 35771 lneg EBX
// if (C==166)
 35773 cmp 0,EBX
 35776 jge 35782
 35779 jmp 35882
__1544:
__1542:
__1546:
 35782 rstack EAX,EBP:-2
 35786 mov EBX,127
 35789 sub EBX,EAX
 35791 fabs EBX,EBX
 35793 fsgn EBX,EBX
 35795 lneg EBX
// if (C==127)
 35797 cmp 0,EBX
 35800 jge 35824
 35803 rstack EAX,EBP:-1
// stringtracker_go_prevline arg #1 (float* self)
 35807 push EAX
 35809 mov ECX,1
// stringtracker_go_prevline(...)
 35812 call 34347
 35815 add ESP,1
 35818 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35821 call 35925
__1547:
__1545:
__1549:
 35824 rstack EAX,EBP:-2
 35828 mov EBX,13
 35831 sub EBX,EAX
 35833 fabs EBX,EBX
 35835 fsgn EBX,EBX
 35837 lneg EBX
// if (C==13)
 35839 cmp 0,EBX
 35842 jge 35866
 35845 rstack EAX,EBP:-1
// stringtracker_go_nextline arg #1 (float* self)
 35849 push EAX
 35851 mov ECX,1
// stringtracker_go_nextline(...)
 35854 call 34235
 35857 add ESP,1
 35860 mov ECX,0
// stringtracker_test_snap_cursor(...)
 35863 call 35925
__1550:
__1548:
 35866 mov ECX,0
// readKey(...)
 35869 call 37108
// C=readKey()
 35872 sstack EBP:-2,EAX
 35876 jmp 35007
__1489:
 35879 jmp 34990
__1487:
stringtracker_test_exit:
 35882 mov EAX,2046
 35885 add EAX,#37053
// AdrScreen[2046]=0
 35888 mov #EAX,0
 35891 mov EAX,2020
 35894 add EAX,#37053
// AdrScreen[2020]=1
 35897 mov #EAX,1
 35900 push 1
 35903 mov ECX,1
// delay(...)
 35906 call 36681
 35909 add ESP,1
 35912 mov EAX,2041
 35915 add EAX,#37053
// AdrScreen[2041]=1
 35918 mov #EAX,1
 35921 leave 
 35922 ret 
__1482:
 35923 leave 
 35924 ret 
stringtracker_test_snap_cursor:
// stringtracker_test_snap_cursor()
 35925 enter 4
__1552:
// stringtracker_get_x arg #1 (float* self)
 35928 push #36481
 35931 mov ECX,1
// stringtracker_get_x(...)
 35934 call 31744
 35937 add ESP,1
// x=stringtracker_get_x(stringtracker_test_tracker)
 35940 sstack EBP:-1,EAX
// stringtracker_get_y arg #1 (float* self)
 35944 push #36481
 35947 mov ECX,1
// stringtracker_get_y(...)
 35950 call 31762
 35953 add ESP,1
// y=stringtracker_get_y(stringtracker_test_tracker)
 35956 sstack EBP:-2,EAX
 35960 rstack EAX,EBP:-1
 35964 rstack EBX,EBP:-2
 35968 mov ECX,30
 35971 mul ECX,EBX
 35973 add ECX,EAX
 35975 mov EAX,2
 35978 mul EAX,ECX
 35980 mov EBX,2045
 35983 add EBX,#37053
// AdrScreen[2045]=2*(30*y+x)
 35986 mov #EBX,EAX
// stringtracker_get_I arg #1 (float* self)
 35988 push #36481
 35991 mov ECX,1
// stringtracker_get_I(...)
 35994 call 31726
 35997 add ESP,1
 36000 sstack EBP:-3,EAX
// stringtracker_get_c arg #1 (float* self)
 36004 push #36481
 36007 mov ECX,1
// stringtracker_get_c(...)
 36010 call 31845
 36013 add ESP,1
 36016 sstack EBP:-4,EAX
 36020 push 999
// concat arg #3 (unknown)
 36023 push 36223
 36026 rstack EAX,EBP:-1
// num2str arg #1 (float num)
 36030 push EAX
 36032 mov ECX,1
// num2str(...)
 36035 call 12958
 36038 add ESP,1
// concat arg #2 (unknown)
 36041 push EAX
// concat arg #1 (unknown)
 36043 push 36239
 36046 mov ECX,3
// concat(...)
 36049 call 15359
 36052 add ESP,3
 36055 push EAX
 36057 push 14
 36060 push 0
 36063 mov ECX,4
// PrintStringXY(...)
 36066 call 36482
 36069 add ESP,4
 36072 push 999
// concat arg #3 (unknown)
 36075 push 36223
 36078 rstack EAX,EBP:-2
// num2str arg #1 (float num)
 36082 push EAX
 36084 mov ECX,1
// num2str(...)
 36087 call 12958
 36090 add ESP,1
// concat arg #2 (unknown)
 36093 push EAX
// concat arg #1 (unknown)
 36095 push 36244
 36098 mov ECX,3
// concat(...)
 36101 call 15359
 36104 add ESP,3
 36107 push EAX
 36109 push 15
 36112 push 0
 36115 mov ECX,4
// PrintStringXY(...)
 36118 call 36482
 36121 add ESP,4
 36124 push 999
// concat arg #3 (unknown)
 36127 push 36223
 36130 rstack EAX,EBP:-3
// num2str arg #1 (float num)
 36134 push EAX
 36136 mov ECX,1
// num2str(...)
 36139 call 12958
 36142 add ESP,1
// concat arg #2 (unknown)
 36145 push EAX
// concat arg #1 (unknown)
 36147 push 36227
 36150 mov ECX,3
// concat(...)
 36153 call 15359
 36156 add ESP,3
 36159 push EAX
 36161 push 16
 36164 push 0
 36167 mov ECX,4
// PrintStringXY(...)
 36170 call 36482
 36173 add ESP,4
 36176 push 999
 36179 push 36232
 36182 push 17
 36185 push 0
 36188 mov ECX,4
// PrintStringXY(...)
 36191 call 36482
 36194 add ESP,4
 36197 push 999
 36200 rstack EAX,EBP:-4
 36204 push EAX
 36206 push 17
 36209 push 4
 36212 mov ECX,4
// PrintCharXY(...)
 36215 call 36617
 36218 add ESP,4
__1551:
 36221 leave 
 36222 ret 
__1554:
 36223 db "   ",0
__1556:
 36227 db "I = ",0
__1557:
 36232 db "c =<_>",0
__1553:
 36239 db "x = ",0
__1555:
 36244 db "y = ",0
STRINGTRACKER_CONSTANTS:
stringtracker_test_string:
 36249 db "Lorem ipsum dolor sit amet,
"
 36277 db "consectetur adipiscing elit,
"
 36306 db "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
"
 36373 db "Ut enim ad minim veniam,
"
 36398 db "quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
 36480 db 0
STRINGTRACKER_VARS:
stringtracker_test_tracker:
 36481 alloc 1
STRINGTRACKER_END:
LIBCONSOLESCREEN_CODE:
PrintStringXY:
// PrintStringXY(x,y,str,col)
 36482 enter 3
__1559:
 36485 rstack EAX,EBP:2
 36489 rstack EBX,EBP:3
 36493 mul EBX,30
 36496 mov ECX,EBX
 36498 add ECX,EAX
 36500 mul ECX,2
 36503 sstack EBP:-1,ECX
 36507 sstack EBP:-2,0
 36512 rstack EAX,EBP:-2
 36516 mov EBX,EAX
 36518 inc EAX
 36520 sstack EBP:-2,EAX
 36524 rstack EAX,EBP:4
 36528 add EAX,EBX
 36530 mov EBX,EAX
 36532 sstack EBP:-3,#EBX
__1561:
 36536 rstack EAX,EBP:-3
// if (C
 36540 cmp 0,EAX
 36543 jz 36615
 36546 rstack EAX,EBP:-3
 36550 rstack EBX,EBP:-1
 36554 mov ECX,EBX
 36556 inc EBX
 36558 sstack EBP:-1,EBX
 36562 add ECX,#37053
// AdrScreen[P++]=C
 36565 mov #ECX,EAX
 36567 rstack EAX,EBP:5
 36571 rstack EBX,EBP:-1
 36575 mov ECX,EBX
 36577 inc EBX
 36579 sstack EBP:-1,EBX
 36583 add ECX,#37053
// AdrScreen[P++]=col
 36586 mov #ECX,EAX
 36588 rstack EAX,EBP:-2
 36592 mov EBX,EAX
 36594 inc EAX
 36596 sstack EBP:-2,EAX
 36600 rstack EAX,EBP:4
 36604 add EAX,EBX
 36606 mov EBX,EAX
// C=str[I++]
 36608 sstack EBP:-3,#EBX
 36612 jmp 36536
__1560:
__1558:
 36615 leave 
 36616 ret 
PrintCharXY:
// printCharXY(X,Y,C,col)
 36617 enter 1
__1563:
 36620 rstack EAX,EBP:3
 36624 mul EAX,30
 36627 mov EBX,EAX
 36629 rstack EAX,EBP:2
 36633 add EAX,EBX
 36635 mov EBX,EAX
 36637 mov EAX,2
 36640 mul EAX,EBX
 36642 mov EBX,#37053
 36645 add EBX,EAX
 36647 sstack EBP:-1,EBX
 36651 rstack EAX,EBP:4
 36655 rstack EBX,EBP:-1
 36659 mov ECX,EBX
 36661 inc EBX
 36663 sstack EBP:-1,EBX
// *P++=C
 36667 mov #ECX,EAX
 36669 rstack EAX,EBP:5
 36673 rstack EBX,EBP:-1
// *P=col
 36677 mov #EBX,EAX
__1562:
 36679 leave 
 36680 ret 
delay:
// delay(time)
 36681 enter 1
__1565:
 36684 timer EDX
 36686 sstack EBP:-1,EDX
__1567:
 36690 rstack EAX,EBP:-1
 36694 neg EAX
 36696 mov EBX,EAX
 36698 add EDX,EBX
 36700 rstack EAX,EBP:2
 36704 sub EAX,EDX
 36706 mov EBX,EAX
 36708 fsgn EBX,EBX
 36710 max EBX,0
// if ((EDX-T)<time
 36713 cmp 0,EBX
 36716 jz 36724
 36719 timer EDX
 36721 jmp 36690
__1566:
__1564:
 36724 leave 
 36725 ret 
screen_set:
// screen_set(scr)
 36726 enter -0
__1569:
 36729 rstack EAX,EBP:2
// AdrScreen=scr
 36733 mov #37053,EAX
__1568:
 36736 leave 
 36737 ret 
screen_clear:
// screen_clear()
 36738 enter -0
__1571:
 36741 mov EAX,2041
 36744 add EAX,#37053
// AdrScreen[2041]=1
 36747 mov #EAX,1
__1570:
 36750 leave 
 36751 ret 
screen_cursor_enable:
// screen_cursor_enable()
 36752 enter -0
__1573:
 36755 mov EAX,2046
 36758 add EAX,#37053
// AdrScreen[2046]=1
 36761 mov #EAX,1
__1572:
 36764 leave 
 36765 ret 
screen_cursor_disable:
// screen_cursor_disable()
 36766 enter -0
__1575:
 36769 mov EAX,2046
 36772 add EAX,#37053
// AdrScreen[2046]=0
 36775 mov #EAX,0
__1574:
 36778 leave 
 36779 ret 
screen_set_cursor_pos:
// screen_set_cursor_pos(I)
 36780 enter -0
__1577:
 36783 rstack EAX,EBP:2
 36787 mov EBX,2
 36790 mul EBX,EAX
 36792 mov EAX,2045
 36795 add EAX,#37053
// AdrScreen[2045]=2*I
 36798 mov #EAX,EBX
__1576:
 36800 leave 
 36801 ret 
screen_set_cursor_pos_xy:
// screen_set_cursor_pos_xy(x,y)
 36802 enter -0
__1579:
 36805 rstack EAX,EBP:2
 36809 rstack EBX,EBP:3
 36813 mov ECX,30
 36816 mul ECX,EBX
 36818 add ECX,EAX
 36820 mov EAX,2
 36823 mul EAX,ECX
 36825 mov EBX,2045
 36828 add EBX,#37053
// AdrScreen[2045]=2*(30*y+x)
 36831 mov #EBX,EAX
__1578:
 36833 leave 
 36834 ret 
screen_force_refresh:
// screen_force_refresh()
 36835 enter -0
__1581:
 36838 mov EAX,2020
 36841 add EAX,#37053
// AdrScreen[2020]=1
 36844 mov #EAX,1
// delay arg #1 (float time)
 36847 push 1
 36850 mov ECX,1
// delay(...)
 36853 call 36681
 36856 add ESP,1
__1580:
 36859 leave 
 36860 ret 
screen_set_shift_box_x1:
// screen_set_shift_box_x1(n)
 36861 enter -0
__1583:
 36864 rstack EAX,EBP:2
 36868 mov EBX,2031
 36871 add EBX,#37053
// AdrScreen[2031]=n
 36874 mov #EBX,EAX
__1582:
 36876 leave 
 36877 ret 
screen_set_shift_box_x2:
// screen_set_shift_box_x2(n)
 36878 enter -0
__1585:
 36881 rstack EAX,EBP:2
 36885 mov EBX,2032
 36888 add EBX,#37053
// AdrScreen[2032]=n
 36891 mov #EBX,EAX
__1584:
 36893 leave 
 36894 ret 
screen_set_shift_box_y1:
// screen_set_shift_box_y1(n)
 36895 enter -0
__1587:
 36898 rstack EAX,EBP:2
 36902 mov EBX,2033
 36905 add EBX,#37053
// AdrScreen[2033]=n
 36908 mov #EBX,EAX
__1586:
 36910 leave 
 36911 ret 
screen_set_shift_box_y2:
// screen_set_shift_box_y2(n)
 36912 enter -0
__1589:
 36915 rstack EAX,EBP:2
 36919 mov EBX,2034
 36922 add EBX,#37053
// AdrScreen[2034]=n
 36925 mov #EBX,EAX
__1588:
 36927 leave 
 36928 ret 
screen_set_shift_box:
// screen_set_shift_box(x1,x2,y1,y2)
 36929 enter -0
__1591:
 36932 rstack EAX,EBP:2
 36936 mov EBX,2031
 36939 add EBX,#37053
// AdrScreen[2031]=x1
 36942 mov #EBX,EAX
 36944 rstack EAX,EBP:3
 36948 mov EBX,2032
 36951 add EBX,#37053
// AdrScreen[2032]=x2
 36954 mov #EBX,EAX
 36956 rstack EAX,EBP:4
 36960 mov EBX,2033
 36963 add EBX,#37053
// AdrScreen[2033]=y1
 36966 mov #EBX,EAX
 36968 rstack EAX,EBP:5
 36972 mov EBX,2034
 36975 add EBX,#37053
// AdrScreen[2034]=y2
 36978 mov #EBX,EAX
__1590:
 36980 leave 
 36981 ret 
screen_print_x_min:
 36982 db 0
screen_print_y_min:
 36983 db 0
screen_print_x_max:
 36984 db 0
screen_print_y_max:
 36985 db 0
screen_set_print_box:
// screen_set_print_box(x1,y1,x2,y2)
 36986 enter -0
__1593:
 36989 rstack EAX,EBP:2
// screen_print_x_min=x1
 36993 mov #36982,EAX
 36996 rstack EAX,EBP:3
// screen_print_y_min=y1
 37000 mov #36983,EAX
 37003 rstack EAX,EBP:4
// screen_print_x_max=x2
 37007 mov #36984,EAX
 37010 rstack EAX,EBP:5
// screen_print_y_max=y2
 37014 mov #36985,EAX
__1592:
 37017 leave 
 37018 ret 
screen_shift_vertical:
// screen_shift_vertical(n)
 37019 enter -0
__1595:
 37022 rstack EAX,EBP:2
 37026 mov EBX,2038
 37029 add EBX,#37053
// AdrScreen[2038]=n
 37032 mov #EBX,EAX
__1594:
 37034 leave 
 37035 ret 
screen_shift_horizontal:
// screen_shift_horizontal(n)
 37036 enter -0
__1597:
 37039 rstack EAX,EBP:2
 37043 mov EBX,2037
 37046 add EBX,#37053
// AdrScreen[2037]=n
 37049 mov #EBX,EAX
__1596:
 37051 leave 
 37052 ret 
LIBCONSOLESCREEN_CONSTANTS:
LIBCONSOLESCREEN_VARS:
AdrScreen:
 37053 alloc 1
LIBCONSOLESCREEN_END:
LIBKEYBOARD_CODE:
ptrKB:
 37054 alloc 1
setKeyboard:
// setKeyboard(ptr)
 37055 enter -0
__1599:
 37058 rstack EAX,EBP:2
// ptrKB=ptr
 37062 mov #37054,EAX
__1598:
 37065 leave 
 37066 ret 
isPrint1:
// isPrint1(c)
 37067 enter -0
__1601:
 37070 rstack EAX,EBP:2
 37074 mov EBX,127
 37077 sub EBX,EAX
 37079 fsgn EBX,EBX
 37081 max EBX,0
 37084 rstack EAX,EBP:2
 37088 mov ECX,31
 37091 sub ECX,EAX
 37093 neg ECX
 37095 fsgn ECX,ECX
 37097 max ECX,0
 37100 and ECX,EBX
 37102 mov EAX,ECX
 37104 leave 
 37105 ret 
__1600:
 37106 leave 
 37107 ret 
readKey:
// readKey()
 37108 enter 1
__1603:
 37111 mov EAX,#37054
 37114 add EAX,1
 37117 sstack EBP:-1,#EAX
 37121 mov EAX,#37054
// *ptrKB=0
 37124 mov #EAX,0
 37127 rstack EAX,EBP:-1
 37131 leave 
 37132 ret 
__1602:
 37133 leave 
 37134 ret 
hasKey:
// hasKey()
 37135 enter -0
__1605:
 37138 mov EAX,#37054
 37141 mov EAX,#EAX
 37143 leave 
 37144 ret 
__1604:
 37145 leave 
 37146 ret 
readKB:
// readKB(func)
 37147 enter -0
__1607:
__1609:
 37150 mov ECX,0
// hasKey(...)
 37153 call 37135
// if (hasKey()
 37156 cmp 0,EAX
 37159 jz 37185
 37162 mov ECX,0
// readKey(...)
 37165 call 37108
 37168 push EAX
 37170 mov ECX,1
 37173 rstack EAX,EBP:2
// func(...)
 37177 call EAX
 37179 add ESP,1
 37182 jmp 37150
__1608:
__1606:
 37185 leave 
 37186 ret 
waitKey:
// waitKey()
 37187 enter -0
__1611:
__1613:
 37190 mov ECX,0
// hasKey(...)
 37193 call 37135
 37196 lneg EAX
// if (!hasKey()
 37198 cmp 0,EAX
 37201 jz 37207
 37204 jmp 37190
__1612:
 37207 mov ECX,0
// readKey(...)
 37210 call 37108
 37213 leave 
 37214 ret 
__1610:
 37215 leave 
 37216 ret 
readKeyTimed_delay_time:
 37217 db 0.5
readKeyTimed_repeat_time:
 37218 db 0.1
readKeyTimed_keyState:
 37219 db 0
readKeyTimed_lastSeen:
 37220 db 0
readKeyTimed_lastKey:
 37221 db 0
readKeyTimed:
// readKeyTimed()
 37222 enter 2
__1615:
__1617:
 37225 mov EAX,0
 37228 add EAX,#37054
// if (ptrKB[0])
 37231 cmp 0,#EAX
 37234 jge 37457
 37237 mov EAX,0
 37240 add EAX,#37054
 37243 mov EBX,#EAX
 37245 add EBX,#37054
 37248 sstack EBP:-2,#EBX
__1620:
 37252 rstack EAX,EBP:-2
 37256 mov EBX,#37221
 37259 sub EBX,EAX
 37261 fabs EBX,EBX
 37263 fsgn EBX,EBX
 37265 mov EAX,0
 37268 sub EAX,#37219
 37271 fabs EAX,EAX
 37273 fsgn EAX,EAX
 37275 lneg EAX
 37277 or EAX,EBX
// if ((readKeyTimed_keyState==0)||(C!=readKeyTimed_lastKey))
 37279 cmp 0,EAX
 37282 jge 37307
 37285 timer EAX
// readKeyTimed_lastSeen=EAX
 37287 mov #37220,EAX
 37290 rstack EAX,EBP:-2
// readKeyTimed_lastKey=C
 37294 mov #37221,EAX
// readKeyTimed_keyState=1
 37297 mov #37219,1
 37301 rstack EAX,EBP:-2
 37305 leave 
 37306 ret 
__1621:
__1619:
__1623:
 37307 mov EAX,1
 37310 sub EAX,#37219
 37313 fabs EAX,EAX
 37315 fsgn EAX,EAX
 37317 lneg EAX
// if (readKeyTimed_keyState==1)
 37319 cmp 0,EAX
 37322 jge 37384
 37325 timer EAX
// T=EAX
 37327 sstack EBP:-1,EAX
__1626:
 37331 mov EAX,#37220
 37334 neg EAX
 37336 rstack EBX,EBP:-1
 37340 add EBX,EAX
 37342 mov EAX,EBX
 37344 mov EBX,#37217
 37347 sub EBX,EAX
 37349 neg EBX
 37351 fsgn EBX,EBX
 37353 max EBX,0
// if ((T-readKeyTimed_lastSeen)>readKeyTimed_delay_time)
 37356 cmp 0,EBX
 37359 jge 37379
 37362 rstack EAX,EBP:-1
// readKeyTimed_lastSeen=T
 37366 mov #37220,EAX
// readKeyTimed_keyState=2
 37369 mov #37219,2
 37373 rstack EAX,EBP:-2
 37377 leave 
 37378 ret 
__1627:
__1625:
 37379 mov EAX,0
 37382 leave 
 37383 ret 
__1624:
__1622:
__1629:
 37384 mov EAX,2
 37387 sub EAX,#37219
 37390 fabs EAX,EAX
 37392 fsgn EAX,EAX
 37394 lneg EAX
// if (readKeyTimed_keyState==2)
 37396 cmp 0,EAX
 37399 jge 37457
 37402 timer EAX
// T=EAX
 37404 sstack EBP:-1,EAX
__1632:
 37408 mov EAX,#37220
 37411 neg EAX
 37413 rstack EBX,EBP:-1
 37417 add EBX,EAX
 37419 mov EAX,EBX
 37421 mov EBX,#37218
 37424 sub EBX,EAX
 37426 neg EBX
 37428 fsgn EBX,EBX
 37430 max EBX,0
// if ((T-readKeyTimed_lastSeen)>readKeyTimed_repeat_time)
 37433 cmp 0,EBX
 37436 jge 37452
 37439 rstack EAX,EBP:-1
// readKeyTimed_lastSeen=T
 37443 mov #37220,EAX
 37446 rstack EAX,EBP:-2
 37450 leave 
 37451 ret 
__1633:
__1631:
 37452 mov EAX,0
 37455 leave 
 37456 ret 
__1630:
__1628:
__1618:
__1616:
// readKeyTimed_keyState=0
 37457 mov #37219,0
 37461 mov EAX,0
 37464 leave 
 37465 ret 
__1614:
 37466 leave 
 37467 ret 
strLinebuff:
 37468 alloc 64
readline:
// readline()
 37532 enter 2
__1635:
 37535 mov ECX,0
// waitKey(...)
 37538 call 37187
 37541 sstack EBP:-1,EAX
 37545 sstack EBP:-2,37468
__1637:
 37550 rstack EAX,EBP:-2
 37554 mov EBX,37531
 37557 sub EBX,EAX
 37559 fsgn EBX,EBX
 37561 max EBX,0
 37564 rstack EAX,EBP:-1
 37568 mov ECX,13
 37571 sub ECX,EAX
 37573 fabs ECX,ECX
 37575 fsgn ECX,ECX
 37577 and ECX,EBX
// if ((C!=13)&&(P<strLinebuff+63)
 37579 cmp 0,ECX
 37582 jz 37616
 37585 rstack EAX,EBP:-1
 37589 rstack EBX,EBP:-2
 37593 mov ECX,EBX
 37595 inc EBX
 37597 sstack EBP:-2,EBX
// *P++=C
 37601 mov #ECX,EAX
 37603 mov ECX,0
// waitKey(...)
 37606 call 37187
// C=waitKey()
 37609 sstack EBP:-1,EAX
 37613 jmp 37550
__1636:
 37616 rstack EAX,EBP:-2
// *P=0
 37620 mov #EAX,0
 37623 mov EAX,37468
 37626 leave 
 37627 ret 
__1634:
 37628 leave 
 37629 ret 
LIBKEYBOARD_CONSTANTS:
LIBKEYBOARD_VARS:
LIBKEYBOARD_END:
SHELL_CODE:
assert_type:
// assert_type(self,t)
 37630 enter -0
__1639:
__1641:
 37633 rstack EAX,EBP:2
 37637 add EAX,0
 37640 mov EBX,EAX
 37642 rstack EAX,EBP:3
 37646 sub EAX,#EBX
 37648 mov EBX,EAX
 37650 fabs EBX,EBX
 37652 fsgn EBX,EBX
// if (self[0]!=t)
 37654 cmp 0,EBX
 37657 jge 37743
 37660 push 37745
 37663 mov ECX,1
// Perr(...)
 37666 call 40763
 37669 add ESP,1
 37672 rstack EAX,EBP:2
// num2str arg #1 (float num)
 37676 push EAX
 37678 mov ECX,1
// num2str(...)
 37681 call 12958
 37684 add ESP,1
 37687 push EAX
 37689 mov ECX,1
// Perr(...)
 37692 call 40763
 37695 add ESP,1
 37698 push 37758
 37701 mov ECX,1
// Perr(...)
 37704 call 40763
 37707 add ESP,1
 37710 rstack EAX,EBP:3
 37714 push EAX
 37716 mov ECX,1
// Perr(...)
 37719 call 40763
 37722 add ESP,1
 37725 push 18244
 37728 mov ECX,1
// Perr(...)
 37731 call 40763
 37734 add ESP,1
 37737 mov ECX,0
// shell_panic(...)
 37740 call 38246
__1642:
__1640:
__1638:
 37743 leave 
 37744 ret 
__1643:
 37745 db "type error: ",0
__1644:
 37758 db " is not a
",0
curticks:
// curticks()
 37769 enter 1
__1646:
 37772 cpuget EAX,29
// T=EAX
 37775 sstack EBP:-1,EAX
 37779 rstack EAX,EBP:-1
 37783 leave 
 37784 ret 
__1645:
 37785 leave 
 37786 ret 
curtime:
// curtime()
 37787 enter -0
__1648:
 37790 timer EAX
 37792 leave 
 37793 ret 
__1647:
 37794 leave 
 37795 ret 
shenter:
shell:
// shell()
 37796 enter 1
__1650:
 37799 out 6,1
 37803 push 38085
 37806 mov ECX,1
// P(...)
 37809 call 40570
 37812 add ESP,1
 37815 mov ECX,0
// screen_force_refresh(...)
 37818 call 36835
// screen_set_shift_box arg #4 (float y2)
 37821 push 16
// screen_set_shift_box arg #3 (float y1)
 37824 push 0
// screen_set_shift_box arg #2 (float x2)
 37827 push 28
// screen_set_shift_box arg #1 (float x1)
 37830 push 0
 37833 mov ECX,4
// screen_set_shift_box(...)
 37836 call 36929
 37839 add ESP,4
 37842 mov ECX,0
// screen_force_refresh(...)
 37845 call 36835
 37848 mov ECX,0
// cls(...)
 37851 call 38437
// strcpy arg #2 (char* src)
 37854 push 38083
// strcpy arg #1 (char* dest)
 37857 push 55279
 37860 mov ECX,2
// strcpy(...)
 37863 call 10585
 37866 add ESP,2
// current_path=CurDir
 37869 mov #63727,55279
 37873 sstack EBP:-1,0
// init loop
 37878 sstack EBP:-1,0
__1654:
 37883 rstack EAX,EBP:-1
 37887 mov EBX,7
 37890 sub EBX,EAX
 37892 fsgn EBX,EBX
// condition
 37894 max EBX,0
 37897 cmp 0,EBX
 37900 jz 37957
 37903 rstack EAX,EBP:-1
 37907 mul EAX,10
 37910 mov EBX,EAX
 37912 rstack EAX,EBP:-1
 37916 neg EAX
 37918 mov ECX,EAX
 37920 mov EAX,8
 37923 add EAX,ECX
 37925 mul EAX,100
 37928 add EAX,EBX
 37930 push EAX
 37932 push 38113
 37935 mov ECX,2
// Print(...)
 37938 call 40786
 37941 add ESP,2
 37944 rstack EAX,EBP:-1
// loop step
 37948 inc EAX
 37950 sstack EBP:-1,EAX
 37954 jmp 37883
__1653:
 37957 mov ECX,0
// autorun(...)
 37960 call 38122
__1657:
// if (1
 37963 cmp 0,1
 37967 jz 38060
 37970 out 6,2
 37974 mov ECX,0
// checkKB(...)
 37977 call 42038
// shell_panic_ebp=EBP
 37980 mov #55262,EBP
// shell_panic_esp=ESP
 37983 mov #55263,ESP
shell_panic_exit:
__1659:
 37986 mov ECX,0
// malloc_test(...)
 37989 call 19640
// if (malloc_test())
 37992 cmp 0,EAX
 37995 jge 38034
 37998 push 38099
 38001 mov ECX,1
// P(...)
 38004 call 40570
 38007 add ESP,1
 38010 mov ECX,0
// malloc_print_count(...)
 38013 call 19875
 38016 mov ECX,0
// malloc_init(...)
 38019 call 19360
 38022 push 38062
 38025 mov ECX,1
// P(...)
 38028 call 40570
 38031 add ESP,1
__1660:
__1658:
__1664:
// if (RedrawPending)
 38034 cmp 0,#55267
 38038 jge 38057
// RedrawPending=0
 38041 mov #55267,0
 38045 mov ECX,0
// DrawScrollBar(...)
 38048 call 39054
 38051 mov ECX,0
// DrawStatusBar(...)
 38054 call 38521
__1665:
__1663:
 38057 jmp 37963
__1656:
__1649:
 38060 leave 
 38061 ret 
__1662:
 38062 db "Heap re-initialized
",0
__1652:
 38083 db "/",0
__1651:
 38085 db "Hello World!
",0
__1661:
 38099 db "Heap status:
",0
__1655:
 38113 db "[dance]
",0
autorun:
// autorun()
 38122 enter 1
__1667:
 38125 sstack EBP:-1,0
 38130 rstack EAX,EBP:-1
 38134 in EAX,1
 38137 sstack EBP:-1,EAX
__1669:
 38141 rstack EAX,EBP:-1
// if (run)
 38145 cmp 0,EAX
 38148 jge 38202
 38151 push 929
 38154 push 38237
 38157 mov ECX,2
// Print(...)
 38160 call 40786
 38163 add ESP,2
 38166 push 38204
 38169 mov ECX,1
// ParseString(...)
 38172 call 39387
 38175 add ESP,1
 38178 push 38221
 38181 mov ECX,1
// ParseString(...)
 38184 call 39387
 38187 add ESP,1
 38190 push 38213
 38193 mov ECX,1
// ParseString(...)
 38196 call 39387
 38199 add ESP,1
__1670:
__1668:
__1666:
 38202 leave 
 38203 ret 
__1672:
 38204 db "echo off",0
__1674:
 38213 db "echo on",0
__1673:
 38221 db "exec autorun.sh",0
__1671:
 38237 db "AUTORUN
",0
shell_panic:
// shell_panic()
 38246 enter -0
__1676:
 38249 push 9
 38252 push 38292
 38255 mov ECX,2
// Print(...)
 38258 call 40786
 38261 add ESP,2
// MinStrI=0
 38264 mov #55339,0
 38268 mov EAX,1
 38271 add EAX,55340
// MinStr[1]=0
 38274 mov #EAX,0
// RedrawPending=1
 38277 mov #55267,1
// EBP=shell_panic_ebp
 38281 mov EBP,#55262
// ESP=shell_panic_esp
 38284 mov ESP,#55263
 38287 jmp 37986
__1675:
 38290 leave 
 38291 ret 
__1677:
 38292 db "
SHELL PANIC
",0
shell_panic_help:
 38306 db "Escape from the currently executing program back into the shell and re-initialize heap memory. Used when a critical error occurs.
"
 38436 db 0
cls:
// cls()
 38437 enter -0
__1679:
 38440 mov ECX,0
// screen_clear(...)
 38443 call 36738
// memset arg #3 (float n)
 38446 push 6000
// memset arg #2 (float c)
 38449 push 0
// memset arg #1 (void* ptr)
 38452 push 55596
 38455 mov ECX,3
// memset(...)
 38458 call 10120
 38461 add ESP,3
// printPtrX=0
 38464 mov #55271,0
// printPtrY=0
 38468 mov #55270,0
// printScrY=0
 38472 mov #55272,0
// RedrawPending=1
 38476 mov #55267,1
__1678:
 38480 leave 
 38481 ret 
cls_help:
 38482 db "cleans the screen. Soap will be used.
"
 38520 db 0
DrawStatusBar:
// drawStatusBar()
 38521 enter 8
__1681:
 38524 sstack EBP:-1,39048
 38529 sstack EBP:-2,115
 38534 sstack EBP:-3,999
 38539 sstack EBP:-4,0
 38544 rstack EAX,EBP:-1
 38548 sstack EBP:-5,EAX
__1684:
// if (MinStrI)
 38552 cmp 0,#55339
 38556 jge 38564
// str=MinStr
 38559 sstack EBP:-5,55340
__1685:
__1683:
 38564 rstack EAX,EBP:-5
 38568 add EAX,0
 38571 mov EBX,EAX
 38573 sstack EBP:-6,#EBX
 38577 sstack EBP:-7,0
__1687:
 38582 rstack EAX,EBP:-6
// if (C
 38586 cmp 0,EAX
 38589 jz 38621
 38592 rstack EAX,EBP:-7
// len++
 38596 inc EAX
 38598 sstack EBP:-7,EAX
 38602 rstack EAX,EBP:-7
 38606 rstack EBX,EBP:-5
 38610 add EBX,EAX
 38612 mov EAX,EBX
// C=str[len]
 38614 sstack EBP:-6,#EAX
 38618 jmp 38582
__1686:
__1689:
 38621 rstack EAX,EBP:-7
 38625 mov EBX,27
 38628 sub EBX,EAX
 38630 neg EBX
 38632 fsgn EBX,EBX
 38634 max EBX,0
// if (len>27)
 38637 cmp 0,EBX
 38640 jge 38667
 38643 rstack EAX,EBP:-7
 38647 add EAX,-28
 38650 mov EBX,EAX
 38652 rstack EAX,EBP:-5
 38656 add EAX,EBX
 38658 mov EBX,EAX
// C=str[len-28]
 38660 sstack EBP:-6,#EBX
 38664 jmp 38680
__1691:
__1690:
__1693:
 38667 rstack EAX,EBP:-5
 38671 add EAX,0
 38674 mov EBX,EAX
// C=str[0]
 38676 sstack EBP:-6,#EBX
__1692:
__1688:
 38680 rstack EAX,EBP:-5
 38684 rstack EBX,EBP:-1
 38688 sub EBX,EAX
 38690 mov EAX,EBX
 38692 fabs EAX,EAX
 38694 fsgn EAX,EAX
 38696 sstack EBP:-8,EAX
__1695:
 38700 rstack EAX,EBP:-8
// if (inp)
 38704 cmp 0,EAX
 38707 jge 38718
// statTextCol=999
 38710 sstack EBP:-3,999
 38715 jmp 38723
__1697:
__1696:
__1699:
// statTextCol=90
 38718 sstack EBP:-3,90
__1698:
__1694:
// init loop
 38723 sstack EBP:-4,0
__1701:
 38728 rstack EAX,EBP:-4
 38732 mov EBX,29
 38735 sub EBX,EAX
 38737 fsgn EBX,EBX
// condition
 38739 max EBX,0
 38742 cmp 0,EBX
 38745 jz 39046
__1703:
 38748 rstack EAX,EBP:-6
// if (C)
 38752 cmp 0,EAX
 38755 jge 38982
__1706:
 38758 rstack EAX,EBP:-8
 38762 rstack EBX,EBP:-4
 38766 mov ECX,0
 38769 sub ECX,EBX
 38771 fabs ECX,ECX
 38773 fsgn ECX,ECX
 38775 lneg ECX
 38777 and ECX,EAX
// if ((I==0)&&inp)
 38779 cmp 0,ECX
 38782 jge 38820
 38785 mov EAX,1020
 38788 add EAX,#37053
// AdrScreen[60*17]='>'
 38791 mov #EAX,62
 38794 rstack EAX,EBP:-3
 38798 rstack EBX,EBP:-2
 38802 mul EBX,1000
 38805 mov ECX,EBX
 38807 add ECX,EAX
 38809 mov EAX,1021
 38812 add EAX,#37053
// AdrScreen[60*17+1]=statCol*1000+statTextCol
 38815 mov #EAX,ECX
 38817 jmp 38979
__1708:
__1707:
__1710:
 38820 rstack EAX,EBP:-6
 38824 rstack EBX,EBP:-4
 38828 mov ECX,2
 38831 mul ECX,EBX
 38833 mov EBX,1020
 38836 add EBX,ECX
 38838 add EBX,#37053
// AdrScreen[60*17+2*I]=C
 38841 mov #EBX,EAX
 38843 rstack EAX,EBP:-3
 38847 rstack EBX,EBP:-2
 38851 mul EBX,1000
 38854 mov ECX,EBX
 38856 add ECX,EAX
 38858 rstack EAX,EBP:-4
 38862 mov EBX,2
 38865 mul EBX,EAX
 38867 add EBX,1
 38870 mov EAX,1020
 38873 add EAX,EBX
 38875 add EAX,#37053
// AdrScreen[60*17+2*I+1]=statCol*1000+statTextCol
 38878 mov #EAX,ECX
__1712:
 38880 rstack EAX,EBP:-7
 38884 mov EBX,27
 38887 sub EBX,EAX
 38889 neg EBX
 38891 fsgn EBX,EBX
 38893 max EBX,0
// if (len>27)
 38896 cmp 0,EBX
 38899 jge 38946
 38902 rstack EAX,EBP:-8
 38906 neg EAX
 38908 mov EBX,EAX
 38910 mov EAX,-28
 38913 add EAX,EBX
 38915 rstack EBX,EBP:-7
 38919 add EBX,EAX
 38921 mov EAX,EBX
 38923 rstack EBX,EBP:-4
 38927 add EBX,EAX
 38929 mov EAX,EBX
 38931 rstack EBX,EBP:-5
 38935 add EBX,EAX
 38937 mov EAX,EBX
// C=str[I+len-28-inp]
 38939 sstack EBP:-6,#EAX
 38943 jmp 38979
__1714:
__1713:
__1716:
 38946 rstack EAX,EBP:-8
 38950 neg EAX
 38952 mov EBX,EAX
 38954 mov EAX,1
 38957 add EAX,EBX
 38959 rstack EBX,EBP:-4
 38963 add EBX,EAX
 38965 mov EAX,EBX
 38967 rstack EBX,EBP:-5
 38971 add EBX,EAX
 38973 mov EAX,EBX
// C=str[I+1-inp]
 38975 sstack EBP:-6,#EAX
__1715:
__1711:
__1709:
__1705:
 38979 jmp 39033
__1717:
__1704:
__1719:
 38982 rstack EAX,EBP:-4
 38986 mov EBX,2
 38989 mul EBX,EAX
 38991 mov EAX,1020
 38994 add EAX,EBX
 38996 add EAX,#37053
// AdrScreen[60*17+2*I]=' '
 38999 mov #EAX,32
 39002 rstack EAX,EBP:-2
 39006 mul EAX,1000
 39009 mov EBX,EAX
 39011 rstack EAX,EBP:-4
 39015 mov ECX,2
 39018 mul ECX,EAX
 39020 add ECX,1
 39023 mov EAX,1020
 39026 add EAX,ECX
 39028 add EAX,#37053
// AdrScreen[60*17+2*I+1]=statCol*1000
 39031 mov #EAX,EBX
__1718:
__1702:
 39033 rstack EAX,EBP:-4
// loop step
 39037 inc EAX
 39039 sstack EBP:-4,EAX
 39043 jmp 38728
__1700:
__1680:
 39046 leave 
 39047 ret 
__1682:
 39048 db "Ready",0
DrawScrollBar:
// drawScrollBar()
 39054 enter 2
__1721:
 39057 mov EAX,58
 39060 add EAX,#37053
// AdrScreen[2*29]='^'
 39063 mov #EAX,94
 39066 mov EAX,59
 39069 add EAX,#37053
// AdrScreen[2*29+1]=115999
 39072 mov #EAX,115999
 39075 sstack EBP:-1,0
 39080 sstack EBP:-2,0
 39085 mov EAX,#55272
 39088 neg EAX
 39090 mov EBX,#55270
 39093 add EBX,EAX
// T=printPtrY-printScrY
 39095 sstack EBP:-2,EBX
 39099 rstack EAX,EBP:-2
 39103 div EAX,100
 39106 mov EBX,EAX
 39108 mov EAX,18
 39111 mul EAX,EBX
// round arg #1 (float A)
 39113 push EAX
 39115 mov ECX,1
// round(...)
 39118 call 16758
 39121 add ESP,1
// T=round(18*T/100)
 39124 sstack EBP:-2,EAX
 39128 rstack EAX,EBP:-2
// T++
 39132 inc EAX
 39134 sstack EBP:-2,EAX
// init loop
 39138 sstack EBP:-1,1
__1723:
 39143 rstack EAX,EBP:-1
 39147 mov EBX,17
 39150 sub EBX,EAX
 39152 fsgn EBX,EBX
// condition
 39154 max EBX,0
 39157 cmp 0,EBX
 39160 jz 39247
__1725:
 39163 rstack EAX,EBP:-1
 39167 rstack EBX,EBP:-2
 39171 sub EBX,EAX
 39173 mov EAX,EBX
 39175 fabs EAX,EAX
 39177 fsgn EAX,EAX
// if (I!=T)
 39179 cmp 0,EAX
 39182 jge 39234
 39185 rstack EAX,EBP:-1
 39189 mul EAX,30
 39192 mov EBX,EAX
 39194 add EBX,29
 39197 mov EAX,2
 39200 mul EAX,EBX
 39202 add EAX,#37053
// AdrScreen[2*(I*30+29)]='|'
 39205 mov #EAX,124
 39208 rstack EAX,EBP:-1
 39212 mul EAX,30
 39215 mov EBX,EAX
 39217 add EBX,29
 39220 mov EAX,2
 39223 mul EAX,EBX
 39225 add EAX,1
 39228 add EAX,#37053
// AdrScreen[2*(I*30+29)+1]=115999
 39231 mov #EAX,115999
__1726:
__1724:
 39234 rstack EAX,EBP:-1
// loop step
 39238 inc EAX
 39240 sstack EBP:-1,EAX
 39244 jmp 39143
__1722:
 39247 mov EAX,1078
 39250 add EAX,#37053
// AdrScreen[2*(17*30+29)]='v'
 39253 mov #EAX,118
 39256 mov EAX,1079
 39259 add EAX,#37053
// AdrScreen[2*(17*30+29)+1]=115999
 39262 mov #EAX,115999
 39265 rstack EAX,EBP:-2
 39269 mov EBX,30
 39272 mul EBX,EAX
 39274 add EBX,29
 39277 mov EAX,2
 39280 mul EAX,EBX
 39282 add EAX,#37053
// AdrScreen[2*(30*T+29)]=' '
 39285 mov #EAX,32
 39288 rstack EAX,EBP:-2
 39292 mov EBX,30
 39295 mul EBX,EAX
 39297 add EBX,29
 39300 mov EAX,2
 39303 mul EAX,EBX
 39305 add EAX,1
 39308 add EAX,#37053
// AdrScreen[2*(30*T+29)+1]=999000
 39311 mov #EAX,999000
__1720:
 39314 leave 
 39315 ret 
Console:
// Console(str)
 39316 enter -0
__1728:
 39319 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 39323 push EAX
// strcpy arg #1 (char* dest)
 39325 push 55340
 39328 mov ECX,2
// strcpy(...)
 39331 call 10585
 39334 add ESP,2
 39337 push 55340
 39340 mov ECX,1
// ParseString(...)
 39343 call 39387
 39346 add ESP,1
__1727:
 39349 leave 
 39350 ret 
ParseStringSilent:
// ParseStringSilent(str)
 39351 enter 1
__1730:
 39354 sstack EBP:-1,#55265
// Echo=0
 39359 mov #55265,0
 39363 rstack EAX,EBP:2
 39367 push EAX
 39369 mov ECX,1
// ParseString(...)
 39372 call 39387
 39375 add ESP,1
 39378 rstack EAX,EBP:-1
// Echo=Echo_prev
 39382 mov #55265,EAX
__1729:
 39385 leave 
 39386 ret 
ParseString:
// ParseString(str)
 39387 enter 324
__1732:
__1734:
// if (Echo)
 39390 cmp 0,#55265
 39394 jge 39493
__1737:
// strcmp arg #2 (char* dest)
 39397 push 38204
 39400 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 39404 push EAX
 39406 mov ECX,2
// strcmp(...)
 39409 call 10414
 39412 add ESP,2
 39415 mov EBX,0
 39418 sub EBX,EAX
 39420 fabs EBX,EBX
 39422 fsgn EBX,EBX
// if (strcmp(str,"echo off")!=0)
 39424 cmp 0,EBX
 39427 jge 39493
 39430 push 40380
 39433 mov ECX,1
// P(...)
 39436 call 40570
 39439 add ESP,1
 39442 push 55279
 39445 mov ECX,1
// P(...)
 39448 call 40570
 39451 add ESP,1
 39454 push 40429
 39457 mov ECX,1
// P(...)
 39460 call 40570
 39463 add ESP,1
 39466 rstack EAX,EBP:2
 39470 push EAX
 39472 mov ECX,1
// P(...)
 39475 call 40570
 39478 add ESP,1
 39481 push 18244
 39484 mov ECX,1
// P(...)
 39487 call 40570
 39490 add ESP,1
__1738:
__1736:
__1735:
__1733:
 39493 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 39497 push EAX
 39499 mov EAX,SS:ESP
 39502 add EAX,-120
// strcpy arg #1 (char* dest)
 39505 push EAX
 39507 mov ECX,2
// strcpy(...)
 39510 call 10585
 39513 add ESP,2
// explode arg #2 (char* del)
 39516 push 20361
 39519 mov EAX,SS:ESP
 39522 add EAX,-120
// explode arg #1 (char* str)
 39525 push EAX
 39527 mov ECX,2
// explode(...)
 39530 call 11134
 39533 add ESP,2
// Arr=explode(buff," ")
 39536 mov #55266,EAX
 39539 sstack EBP:-121,54997
 39544 sstack EBP:-122,0
__1742:
 39549 rstack EAX,EBP:-121
 39553 mov EBX,55210
 39556 sub EBX,EAX
 39558 fsgn EBX,EBX
 39560 max EBX,0
// if (I<CommandBuffEnd
 39563 cmp 0,EBX
 39566 jz 39710
__1744:
 39569 rstack EAX,EBP:-121
// strcmp arg #2 (char* dest)
 39573 push EAX
 39575 mov EAX,0
 39578 add EAX,#55266
// strcmp arg #1 (char* src)
 39581 push #EAX
 39583 mov ECX,2
// strcmp(...)
 39586 call 10414
 39589 add ESP,2
 39592 mov EBX,0
 39595 sub EBX,EAX
 39597 fabs EBX,EBX
 39599 fsgn EBX,EBX
 39601 lneg EBX
// if (strcmp(Arr[0],I)==0)
 39603 cmp 0,EBX
 39606 jge 39677
 39609 rstack EAX,EBP:-121
// strlen arg #1 (char* str)
 39613 push EAX
 39615 mov ECX,1
// strlen(...)
 39618 call 10743
 39621 add ESP,1
 39624 add EAX,1
 39627 rstack EBX,EBP:-121
 39631 add EBX,EAX
 39633 mov EAX,EBX
// I=I+strlen(I)+1
 39635 sstack EBP:-121,EAX
// Match=1
 39639 sstack EBP:-122,1
 39644 rstack EAX,EBP:-121
 39648 sstack EBP:-123,#EAX
 39652 mov ECX,0
 39655 rstack EAX,EBP:-123
// Ptr(...)
 39659 call EAX
 39661 jmp 40246
 39664 rstack EAX,EBP:-121
// I++
 39668 inc EAX
 39670 sstack EBP:-121,EAX
 39674 jmp 39707
__1746:
__1745:
__1748:
 39677 rstack EAX,EBP:-121
// strlen arg #1 (char* str)
 39681 push EAX
 39683 mov ECX,1
// strlen(...)
 39686 call 10743
 39689 add ESP,1
 39692 add EAX,3
 39695 rstack EBX,EBP:-121
 39699 add EBX,EAX
 39701 mov EAX,EBX
// I=I+strlen(I)+3
 39703 sstack EBP:-121,EAX
__1747:
__1743:
 39707 jmp 39549
__1741:
__1750:
 39710 rstack EAX,EBP:-122
 39714 lneg EAX
 39716 mov EBX,EAX
// if (!Match)
 39718 cmp 0,EBX
 39721 jge 40246
 39724 mov EAX,0
 39727 add EAX,#55266
 39730 push #EAX
 39732 mov EAX,SS:ESP
 39735 add EAX,-203
 39738 push EAX
 39740 mov ECX,2
// getFullname(...)
 39743 call 43939
 39746 add ESP,2
__1754:
 39749 push 40534
 39752 mov EAX,SS:ESP
 39755 add EAX,-203
 39758 push EAX
 39760 mov ECX,2
// fopen(...)
 39763 call 64589
 39766 add ESP,2
// if (fopen(fullname,"r"))
 39769 cmp 0,EAX
 39772 jge 39857
 39775 sstack EBP:-204,#55265
// Echo=0
 39780 mov #55265,0
// strcpy arg #2 (char* src)
 39784 push 40454
 39787 mov EAX,SS:ESP
 39790 add EAX,-324
// strcpy arg #1 (char* dest)
 39793 push EAX
 39795 mov ECX,2
// strcpy(...)
 39798 call 10585
 39801 add ESP,2
 39804 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 39808 push EAX
 39810 mov EAX,SS:ESP
 39813 add EAX,-324
 39816 add EAX,4
// strcpy arg #1 (char* dest)
 39819 push EAX
 39821 mov ECX,2
// strcpy(...)
 39824 call 10585
 39827 add ESP,2
 39830 mov EAX,SS:ESP
 39833 add EAX,-324
// ParseString arg #1 (char str)
 39836 push EAX
 39838 mov ECX,1
// ParseString(...)
 39841 call 39387
 39844 add ESP,1
 39847 rstack EAX,EBP:-204
// Echo=Echo_prev
 39851 mov #55265,EAX
 39854 jmp 40246
__1757:
__1755:
__1759:
__1761:
 39857 mov EAX,0
 39860 sub EAX,#55264
 39863 fabs EAX,EAX
 39865 fsgn EAX,EAX
 39867 lneg EAX
// if (R==0)
 39869 cmp 0,EAX
 39872 jge 39890
 39875 push 900
 39878 push 40459
 39881 mov ECX,2
// Print(...)
 39884 call 40786
 39887 add ESP,2
__1762:
__1760:
__1765:
 39890 mov EAX,1
 39893 sub EAX,#55264
 39896 fabs EAX,EAX
 39898 fsgn EAX,EAX
 39900 lneg EAX
// if (R==1)
 39902 cmp 0,EAX
 39905 jge 39923
 39908 push 900
 39911 push 40424
 39914 mov ECX,2
// Print(...)
 39917 call 40786
 39920 add ESP,2
__1766:
__1764:
__1769:
 39923 mov EAX,2
 39926 sub EAX,#55264
 39929 fabs EAX,EAX
 39931 fsgn EAX,EAX
 39933 lneg EAX
// if (R==2)
 39935 cmp 0,EAX
 39938 jge 39956
 39941 push 900
 39944 push 40465
 39947 mov ECX,2
// Print(...)
 39950 call 40786
 39953 add ESP,2
__1770:
__1768:
__1773:
 39956 mov EAX,3
 39959 sub EAX,#55264
 39962 fabs EAX,EAX
 39964 fsgn EAX,EAX
 39966 lneg EAX
// if (R==3)
 39968 cmp 0,EAX
 39971 jge 39989
 39974 push 900
 39977 push 40432
 39980 mov ECX,2
// Print(...)
 39983 call 40786
 39986 add ESP,2
__1774:
__1772:
__1777:
 39989 mov EAX,4
 39992 sub EAX,#55264
 39995 fabs EAX,EAX
 39997 fsgn EAX,EAX
 39999 lneg EAX
// if (R==4)
 40001 cmp 0,EAX
 40004 jge 40022
 40007 push 900
 40010 push 40486
 40013 mov ECX,2
// Print(...)
 40016 call 40786
 40019 add ESP,2
__1778:
__1776:
__1781:
 40022 mov EAX,5
 40025 sub EAX,#55264
 40028 fabs EAX,EAX
 40030 fsgn EAX,EAX
 40032 lneg EAX
// if (R==5)
 40034 cmp 0,EAX
 40037 jge 40055
 40040 push 900
 40043 push 40386
 40046 mov ECX,2
// Print(...)
 40049 call 40786
 40052 add ESP,2
__1782:
__1780:
__1785:
 40055 mov EAX,6
 40058 sub EAX,#55264
 40061 fabs EAX,EAX
 40063 fsgn EAX,EAX
 40065 lneg EAX
// if (R==6)
 40067 cmp 0,EAX
 40070 jge 40088
 40073 push 900
 40076 push 40305
 40079 mov ECX,2
// Print(...)
 40082 call 40786
 40085 add ESP,2
__1786:
__1784:
__1789:
 40088 mov EAX,7
 40091 sub EAX,#55264
 40094 fabs EAX,EAX
 40096 fsgn EAX,EAX
 40098 lneg EAX
// if (R==7)
 40100 cmp 0,EAX
 40103 jge 40121
 40106 push 900
 40109 push 40363
 40112 mov ECX,2
// Print(...)
 40115 call 40786
 40118 add ESP,2
__1790:
__1788:
__1793:
 40121 mov EAX,8
 40124 sub EAX,#55264
 40127 fabs EAX,EAX
 40129 fsgn EAX,EAX
 40131 lneg EAX
// if (R==8)
 40133 cmp 0,EAX
 40136 jge 40154
 40139 push 900
 40142 push 40520
 40145 mov ECX,2
// Print(...)
 40148 call 40786
 40151 add ESP,2
__1794:
__1792:
__1797:
 40154 mov EAX,9
 40157 sub EAX,#55264
 40160 fabs EAX,EAX
 40162 fsgn EAX,EAX
 40164 lneg EAX
// if (R==9)
 40166 cmp 0,EAX
 40169 jge 40187
 40172 push 900
 40175 push 40265
 40178 mov ECX,2
// Print(...)
 40181 call 40786
 40184 add ESP,2
__1798:
__1796:
__1801:
 40187 mov EAX,10
 40190 sub EAX,#55264
 40193 fabs EAX,EAX
 40195 fsgn EAX,EAX
 40197 lneg EAX
// if (R==10)
 40199 cmp 0,EAX
 40202 jge 40220
 40205 push 900
 40208 push 40320
 40211 mov ECX,2
// Print(...)
 40214 call 40786
 40217 add ESP,2
__1802:
__1800:
// R++
 40220 inc #55264
__1805:
 40223 mov EAX,10
 40226 sub EAX,#55264
 40229 neg EAX
 40231 fsgn EAX,EAX
 40233 max EAX,0
// if (R>10)
 40236 cmp 0,EAX
 40239 jge 40246
// R=0
 40242 mov #55264,0
__1806:
__1804:
__1758:
__1753:
__1751:
__1749:
shell_cmd_found:
// MinStrI=0
 40246 mov #55339,0
 40250 mov EAX,1
 40253 add EAX,55340
// MinStr[1]=0
 40256 mov #EAX,0
// RedrawPending=1
 40259 mov #55267,1
__1731:
 40263 leave 
 40264 ret 
__1799:
 40265 db "ENGLISH MOTHERFUCKER,
DO YOU SPEAK IT?
",0
__1787:
 40305 db "Who are you?!
",0
__1803:
 40320 db "What you need isnt 
always what you want.
",0
__1791:
 40363 db "Unknown command
",0
__1739:
 40380 db "User:",0
__1783:
 40386 db "I'm afraid I can't 
let you do that.
",0
__1767:
 40424 db "wat
",0
__1740:
 40429 db "> ",0
__1775:
 40432 db "Unrecognised command
",0
__1756:
 40454 db "run ",0
__1763:
 40459 db "huh?
",0
__1771:
 40465 db "No, this is patric.
",0
__1779:
 40486 db "You do talk nonsense 
sometimes.
",0
__1795:
 40520 db "Syntax Error
",0
__1752:
 40534 db "r",0
Ps:
// Ps(str)
 40536 enter -0
__1808:
 40539 push 999
 40542 rstack EAX,EBP:2
// string_c_str arg #1 (void* self)
 40546 push EAX
 40548 mov ECX,1
// string_c_str(...)
 40551 call 25825
 40554 add ESP,1
 40557 push EAX
 40559 mov ECX,2
// Print(...)
 40562 call 40786
 40565 add ESP,2
__1807:
 40568 leave 
 40569 ret 
P:
// P(str)
 40570 enter -0
__1810:
 40573 push 999
 40576 rstack EAX,EBP:2
 40580 push EAX
 40582 mov ECX,2
// Print(...)
 40585 call 40786
 40588 add ESP,2
__1809:
 40591 leave 
 40592 ret 
Pc:
// Pc(c)
 40593 enter 2
__1812:
 40596 sstack EBP:-1,0
 40601 rstack EAX,EBP:2
 40605 sstack EBP:-2,EAX
 40609 mov EAX,SS:ESP
 40612 add EAX,-2
// P arg #1 (char* str)
 40615 push EAX
 40617 mov ECX,1
// P(...)
 40620 call 40570
 40623 add ESP,1
__1811:
 40626 leave 
 40627 ret 
Pn:
// Pn(N)
 40628 enter -0
__1814:
 40631 push 999
 40634 rstack EAX,EBP:2
// num2str arg #1 (float num)
 40638 push EAX
 40640 mov ECX,1
// num2str(...)
 40643 call 12958
 40646 add ESP,1
 40649 push EAX
 40651 mov ECX,2
// Print(...)
 40654 call 40786
 40657 add ESP,2
__1813:
 40660 leave 
 40661 ret 
Pl:
// Pl(str)
 40662 enter -0
__1816:
 40665 push 999
 40668 rstack EAX,EBP:2
 40672 push EAX
 40674 mov ECX,2
// Print(...)
 40677 call 40786
 40680 add ESP,2
 40683 push 999
 40686 push 18244
 40689 mov ECX,2
// Print(...)
 40692 call 40786
 40695 add ESP,2
__1815:
 40698 leave 
 40699 ret 
P2:
// P2(str1,N,str2)
 40700 enter -0
__1818:
 40703 push 999
// Con arg #5 (char* str5)
 40706 push 26784
// Con arg #4 (char* str4)
 40709 push 26784
 40712 rstack EAX,EBP:4
// Con arg #3 (char* str3)
 40716 push EAX
 40718 rstack EAX,EBP:3
// num2str arg #1 (float num)
 40722 push EAX
 40724 mov ECX,1
// num2str(...)
 40727 call 12958
 40730 add ESP,1
// Con arg #2 (char* str2)
 40733 push EAX
 40735 rstack EAX,EBP:2
// Con arg #1 (char* str1)
 40739 push EAX
 40741 mov ECX,5
// Con(...)
 40744 call 14757
 40747 add ESP,5
 40750 push EAX
 40752 mov ECX,2
// Print(...)
 40755 call 40786
 40758 add ESP,2
__1817:
 40761 leave 
 40762 ret 
Perr:
// Perr(str)
 40763 enter -0
__1820:
 40766 push 833
 40769 rstack EAX,EBP:2
 40773 push EAX
 40775 mov ECX,2
// Print(...)
 40778 call 40786
 40781 add ESP,2
__1819:
 40784 leave 
 40785 ret 
Print:
// Print(str,col)
 40786 enter 2
__1822:
 40789 rstack EAX,EBP:2
 40793 add EAX,0
 40796 mov EBX,EAX
 40798 sstack EBP:-1,#EBX
 40802 sstack EBP:-2,1
__1824:
 40807 rstack EAX,EBP:-1
 40811 mov EBX,0
 40814 sub EBX,EAX
 40816 fabs EBX,EBX
 40818 fsgn EBX,EBX
// if (C!=0
 40820 cmp 0,EBX
 40823 jz 41248
__1826:
 40826 mov EAX,#55271
 40829 mul EAX,2
 40832 mov EBX,#55270
 40835 mul EBX,60
 40838 add EBX,EAX
 40840 mov EAX,5999
 40843 sub EAX,EBX
 40845 neg EAX
 40847 fsgn EAX,EAX
 40849 max EAX,0
// if ((printPtrY*60+printPtrX*2)>6000-1)
 40852 cmp 0,EAX
 40855 jge 40907
// memcpy arg #3 (float n)
 40858 push 5940
 40861 mov EAX,55596
 40864 add EAX,60
// memcpy arg #2 (void* src)
 40867 push EAX
// memcpy arg #1 (void* dest)
 40869 push 55596
 40872 mov ECX,3
// memcpy(...)
 40875 call 10006
 40878 add ESP,3
// memset arg #3 (float n)
 40881 push 60
// memset arg #2 (float c)
 40884 push 0
 40887 mov EAX,55596
 40890 add EAX,5940
// memset arg #1 (void* ptr)
 40893 push EAX
 40895 mov ECX,3
// memset(...)
 40898 call 10120
 40901 add ESP,3
// PrintPtrY--
 40904 dec #55270
__1827:
__1825:
__1829:
 40907 mov EAX,17
 40910 sub EAX,#55272
 40913 fabs EAX,EAX
 40915 fsgn EAX,EAX
 40917 lneg EAX
// if (printScrY==17)
 40919 cmp 0,EAX
 40922 jge 40931
 40925 mov ECX,0
// ConsoleShiftUp(...)
 40928 call 41513
__1830:
__1828:
__1832:
 40931 rstack EAX,EBP:-1
 40935 mov EBX,10
 40938 sub EBX,EAX
 40940 fabs EBX,EBX
 40942 fsgn EBX,EBX
 40944 lneg EBX
// if ((C=='\10'))
 40946 cmp 0,EBX
 40949 jge 41063
__1835:
// if (printSpecials)
 40952 cmp 0,#55273
 40956 jge 41057
 40959 rstack EAX,EBP:-1
 40963 mov EBX,#55271
 40966 mul EBX,2
 40969 mov ECX,#55270
 40972 mul ECX,60
 40975 add ECX,EBX
 40977 add ECX,55596
// ConsoleStrBuff[printPtrY*60+printPtrX*2]=C
 40980 mov #ECX,EAX
 40982 rstack EAX,EBP:3
 40986 mov EBX,#55271
 40989 mul EBX,2
 40992 add EBX,1
 40995 mov ECX,#55270
 40998 mul ECX,60
 41001 add ECX,EBX
 41003 add ECX,55596
// ConsoleStrBuff[printPtrY*60+printPtrX*2+1]=col
 41006 mov #ECX,EAX
 41008 rstack EAX,EBP:-1
 41012 mov EBX,#55271
 41015 mul EBX,2
 41018 mov ECX,#55272
 41021 mul ECX,60
 41024 add ECX,EBX
 41026 add ECX,#37053
// AdrScreen[printScrY*60+printPtrX*2]=C
 41029 mov #ECX,EAX
 41031 rstack EAX,EBP:3
 41035 mov EBX,#55271
 41038 mul EBX,2
 41041 add EBX,1
 41044 mov ECX,#55272
 41047 mul ECX,60
 41050 add ECX,EBX
 41052 add ECX,#37053
// AdrScreen[printScrY*60+printPtrX*2+1]=col
 41055 mov #ECX,EAX
__1836:
__1834:
 41057 jmp 41211
 41060 jmp 41192
__1837:
__1833:
__1839:
__1841:
 41063 rstack EAX,EBP:-1
 41067 mov EBX,13
 41070 sub EBX,EAX
 41072 fabs EBX,EBX
 41074 fsgn EBX,EBX
 41076 lneg EBX
// if ((C=='\13'))
 41078 cmp 0,EBX
 41081 jge 41091
// printPtrX=0
 41084 mov #55271,0
 41088 jmp 41192
__1843:
__1842:
__1845:
 41091 rstack EAX,EBP:-1
 41095 mov EBX,#55271
 41098 mul EBX,2
 41101 mov ECX,#55270
 41104 mul ECX,60
 41107 add ECX,EBX
 41109 add ECX,55596
// ConsoleStrBuff[printPtrY*60+printPtrX*2]=C
 41112 mov #ECX,EAX
 41114 rstack EAX,EBP:3
 41118 mov EBX,#55271
 41121 mul EBX,2
 41124 add EBX,1
 41127 mov ECX,#55270
 41130 mul ECX,60
 41133 add ECX,EBX
 41135 add ECX,55596
// ConsoleStrBuff[printPtrY*60+printPtrX*2+1]=col
 41138 mov #ECX,EAX
 41140 rstack EAX,EBP:-1
 41144 mov EBX,#55271
 41147 mul EBX,2
 41150 mov ECX,#55272
 41153 mul ECX,60
 41156 add ECX,EBX
 41158 add ECX,#37053
// AdrScreen[printScrY*60+printPtrX*2]=C
 41161 mov #ECX,EAX
 41163 rstack EAX,EBP:3
 41167 mov EBX,#55271
 41170 mul EBX,2
 41173 add EBX,1
 41176 mov ECX,#55272
 41179 mul ECX,60
 41182 add ECX,EBX
 41184 add ECX,#37053
// AdrScreen[printScrY*60+printPtrX*2+1]=col
 41187 mov #ECX,EAX
// printPtrX++
 41189 inc #55271
__1844:
__1840:
__1838:
__1831:
__1847:
 41192 mov EAX,28
 41195 sub EAX,#55271
 41198 neg EAX
 41200 fsgn EAX,EAX
 41202 max EAX,0
// if (printPtrX>28)
 41205 cmp 0,EAX
 41208 jge 41221
print_nextline:
// printPtrX=0
 41211 mov #55271,0
// printPtrY++
 41215 inc #55270
// printScrY++
 41218 inc #55272
__1848:
__1846:
 41221 rstack EAX,EBP:-2
 41225 mov EBX,EAX
 41227 inc EAX
 41229 sstack EBP:-2,EAX
 41233 rstack EAX,EBP:2
 41237 add EAX,EBX
 41239 mov EBX,EAX
// C=str[I++]
 41241 sstack EBP:-1,#EBX
 41245 jmp 40807
__1823:
__1821:
 41248 leave 
 41249 ret 
redraw_all:
// redraw_all()
 41250 enter -0
__1850:
 41253 mov ECX,0
// cls(...)
 41256 call 38437
__1849:
 41259 leave 
 41260 ret 
PrintProgressBar:
// PrintProgressBar(percent)
 41261 enter 2
__1852:
__1854:
 41264 rstack EAX,EBP:2
 41268 mov EBX,0
 41271 sub EBX,EAX
 41273 fsgn EBX,EBX
 41275 max EBX,0
// if (percent<0)
 41278 cmp 0,EBX
 41281 jge 41289
// percent=0
 41284 sstack EBP:2,0
__1855:
__1853:
__1857:
 41289 rstack EAX,EBP:2
 41293 mov EBX,100
 41296 sub EBX,EAX
 41298 neg EBX
 41300 fsgn EBX,EBX
 41302 max EBX,0
// if (percent>100)
 41305 cmp 0,EBX
 41308 jge 41316
// percent=100
 41311 sstack EBP:2,100
__1858:
__1856:
 41316 rstack EAX,EBP:2
 41320 div EAX,5
 41323 mov EBX,EAX
// round arg #1 (float A)
 41325 push EBX
 41327 mov ECX,1
// round(...)
 41330 call 16758
 41333 add ESP,1
 41336 sstack EBP:-1,EAX
 41340 rstack EAX,EBP:2
// round arg #1 (float A)
 41344 push EAX
 41346 mov ECX,1
// round(...)
 41349 call 16758
 41352 add ESP,1
// percent=round(percent)
 41355 sstack EBP:2,EAX
// P arg #1 (char* str)
 41359 push 41511
 41362 mov ECX,1
// P(...)
 41365 call 40570
 41368 add ESP,1
// init loop
 41371 sstack EBP:-2,0
__1861:
 41376 rstack EAX,EBP:-2
 41380 rstack EBX,EBP:-1
 41384 sub EBX,EAX
 41386 mov EAX,EBX
 41388 fsgn EAX,EAX
// condition
 41390 max EAX,0
 41393 cmp 0,EAX
 41396 jz 41427
// Print arg #2 (float col)
 41399 push 888111
// Print arg #1 (char str)
 41402 push 20361
 41405 mov ECX,2
// Print(...)
 41408 call 40786
 41411 add ESP,2
 41414 rstack EAX,EBP:-2
// loop step
 41418 inc EAX
 41420 sstack EBP:-2,EAX
 41424 jmp 41376
__1860:
 41427 rstack EAX,EBP:-1
// init loop
 41431 sstack EBP:-2,EAX
__1863:
 41435 rstack EAX,EBP:-2
 41439 mov EBX,20
 41442 sub EBX,EAX
 41444 fsgn EBX,EBX
// condition
 41446 max EBX,0
 41449 cmp 0,EBX
 41452 jz 41483
// Print arg #2 (float col)
 41455 push 222111
// Print arg #1 (char str)
 41458 push 20361
 41461 mov ECX,2
// Print(...)
 41464 call 40786
 41467 add ESP,2
 41470 rstack EAX,EBP:-2
// loop step
 41474 inc EAX
 41476 sstack EBP:-2,EAX
 41480 jmp 41435
__1862:
// P2 arg #3 (char* str2)
 41483 push 41506
 41486 rstack EAX,EBP:2
// P2 arg #2 (float N)
 41490 push EAX
// P2 arg #1 (char* str1)
 41492 push 20361
 41495 mov ECX,3
// P2(...)
 41498 call 40700
 41501 add ESP,3
__1851:
 41504 leave 
 41505 ret 
__1864:
 41506 db "%   ",0
__1859:
 41511 db "",0
ConsoleShiftUp:
// ConsoleShiftUp()
 41513 enter 1
__1866:
// screen_shift_vertical arg #1 (float n)
 41516 push 1
 41519 mov ECX,1
// screen_shift_vertical(...)
 41522 call 37019
 41525 add ESP,1
// printScrY--
 41528 dec #55272
 41531 sstack EBP:-1,0
// init loop
 41536 sstack EBP:-1,0
__1868:
 41541 rstack EAX,EBP:-1
 41545 mov EBX,58
 41548 sub EBX,EAX
 41550 fsgn EBX,EBX
// condition
 41552 max EBX,0
 41555 cmp 0,EBX
 41558 jz 41617
 41561 rstack EAX,EBP:-1
 41565 mov EBX,#55272
 41568 neg EBX
 41570 mov ECX,16
 41573 add ECX,EBX
 41575 mov EBX,#55270
 41578 add EBX,ECX
 41580 mov ECX,60
 41583 mul ECX,EBX
 41585 add ECX,EAX
 41587 add ECX,55596
 41590 rstack EAX,EBP:-1
 41594 mov EBX,960
 41597 add EBX,EAX
 41599 add EBX,#37053
// AdrScreen[16*60+I]=ConsoleStrBuff[60*(printPtrY+16-printScrY)+I]
 41602 mov #EBX,#ECX
 41604 rstack EAX,EBP:-1
// loop step
 41608 inc EAX
 41610 sstack EBP:-1,EAX
 41614 jmp 41541
__1867:
// RedrawPending=1
 41617 mov #55267,1
__1865:
 41621 leave 
 41622 ret 
ConsoleShiftDown:
// ConsoleShiftDown()
 41623 enter 1
__1870:
__1872:
 41626 mov EAX,#55272
 41629 neg EAX
 41631 mov EBX,#55270
 41634 add EBX,EAX
 41636 mov EAX,0
 41639 sub EAX,EBX
 41641 neg EAX
 41643 fsgn EAX,EAX
 41645 max EAX,0
// if ((printPtrY-printScrY)>0)
 41648 cmp 0,EAX
 41651 jge 41745
// screen_shift_vertical arg #1 (float n)
 41654 push -1
 41657 mov ECX,1
// screen_shift_vertical(...)
 41660 call 37019
 41663 add ESP,1
// printScrY++
 41666 inc #55272
 41669 sstack EBP:-1,0
// init loop
 41674 sstack EBP:-1,0
__1875:
 41679 rstack EAX,EBP:-1
 41683 mov EBX,60
 41686 sub EBX,EAX
 41688 fsgn EBX,EBX
// condition
 41690 max EBX,0
 41693 cmp 0,EBX
 41696 jz 41745
 41699 rstack EAX,EBP:-1
 41703 mov EBX,#55272
 41706 neg EBX
 41708 mov ECX,#55270
 41711 add ECX,EBX
 41713 mul ECX,60
 41716 add ECX,EAX
 41718 add ECX,55596
 41721 rstack EAX,EBP:-1
 41725 add EAX,#37053
 41728 mov EBX,EAX
// AdrScreen[I]=ConsoleStrBuff[(printPtrY-printScrY)*60+I]
 41730 mov #EBX,#ECX
 41732 rstack EAX,EBP:-1
// loop step
 41736 inc EAX
 41738 sstack EBP:-1,EAX
 41742 jmp 41679
__1874:
__1873:
__1871:
// RedrawPending=1
 41745 mov #55267,1
__1869:
 41749 leave 
 41750 ret 
ParseKey:
// ParseKey(key)
 41751 enter 3
__1877:
 41754 rstack EAX,EBP:2
// isPrint arg #1 (char C)
 41758 push EAX
 41760 mov ECX,1
// isPrint(...)
 41763 call 14482
 41766 add ESP,1
 41769 sstack EBP:-1,EAX
 41773 rstack EAX,EBP:2
// isAlpha arg #1 (char C)
 41777 push EAX
 41779 mov ECX,1
// isAlpha(...)
 41782 call 14560
 41785 add ESP,1
 41788 sstack EBP:-2,EAX
 41792 rstack EAX,EBP:2
// isNum arg #1 (char C)
 41796 push EAX
 41798 mov ECX,1
// isNum(...)
 41801 call 14521
 41804 add ESP,1
 41807 sstack EBP:-3,EAX
__1879:
 41811 rstack EAX,EBP:-1
// if (C)
 41815 cmp 0,EAX
 41818 jge 41869
__1882:
 41821 mov EAX,255
 41824 sub EAX,#55339
 41827 fsgn EAX,EAX
 41829 max EAX,0
// if (MinStrI<255)
 41832 cmp 0,EAX
 41835 jge 41862
 41838 rstack EAX,EBP:2
 41842 mov EBX,#55339
 41845 inc #55339
 41848 add EBX,55340
// MinStr[MinStrI++]=key
 41851 mov #EBX,EAX
 41853 mov EAX,#55339
 41856 add EAX,55340
// MinStr[MinStrI]=0
 41859 mov #EAX,0
__1883:
__1881:
// RedrawPending=1
 41862 mov #55267,1
 41866 jmp 42036
__1884:
__1880:
__1886:
__1888:
 41869 rstack EAX,EBP:2
 41873 mov EBX,10
 41876 sub EBX,EAX
 41878 fabs EBX,EBX
 41880 fsgn EBX,EBX
 41882 lneg EBX
// if (key==10)
 41884 cmp 0,EBX
 41887 jge 41902
// ParseString arg #1 (char str)
 41890 push 55340
 41893 mov ECX,1
// ParseString(...)
 41896 call 39387
 41899 add ESP,1
__1889:
__1887:
__1891:
 41902 rstack EAX,EBP:2
 41906 mov EBX,17
 41909 sub EBX,EAX
 41911 fabs EBX,EBX
 41913 fsgn EBX,EBX
 41915 lneg EBX
// if (key==17)
 41917 cmp 0,EBX
 41920 jge 41941
 41923 mov ECX,0
// ConsoleShiftDown(...)
 41926 call 41623
 41929 mov ECX,0
// ConsoleShiftDown(...)
 41932 call 41623
 41935 mov ECX,0
// ConsoleShiftDown(...)
 41938 call 41623
__1892:
__1890:
__1894:
 41941 rstack EAX,EBP:2
 41945 mov EBX,18
 41948 sub EBX,EAX
 41950 fabs EBX,EBX
 41952 fsgn EBX,EBX
 41954 lneg EBX
// if (key==18)
 41956 cmp 0,EBX
 41959 jge 41980
 41962 mov ECX,0
// ConsoleShiftUp(...)
 41965 call 41513
 41968 mov ECX,0
// ConsoleShiftUp(...)
 41971 call 41513
 41974 mov ECX,0
// ConsoleShiftUp(...)
 41977 call 41513
__1895:
__1893:
__1897:
 41980 rstack EAX,EBP:2
 41984 mov EBX,127
 41987 sub EBX,EAX
 41989 fabs EBX,EBX
 41991 fsgn EBX,EBX
 41993 lneg EBX
// if (key==127)
 41995 cmp 0,EBX
 41998 jge 42036
__1900:
 42001 mov EAX,0
 42004 sub EAX,#55339
 42007 neg EAX
 42009 fsgn EAX,EAX
 42011 max EAX,0
// if (MinStrI>0)
 42014 cmp 0,EAX
 42017 jge 42023
// MinStrI--
 42020 dec #55339
__1901:
__1899:
 42023 mov EAX,#55339
 42026 add EAX,55340
// MinStr[MinStrI]=0
 42029 mov #EAX,0
// RedrawPending=1
 42032 mov #55267,1
__1898:
__1896:
__1885:
__1878:
__1876:
 42036 leave 
 42037 ret 
checkKB:
// checkKB()
 42038 enter 1
__1903:
__1905:
 42041 mov ECX,0
// hasKey(...)
 42044 call 37135
// if (hasKey()
 42047 cmp 0,EAX
 42050 jz 42081
 42053 mov ECX,0
// readKey(...)
 42056 call 37108
 42059 sstack EBP:-1,EAX
 42063 rstack EAX,EBP:-1
// ParseKey arg #1 (char key)
 42067 push EAX
 42069 mov ECX,1
// ParseKey(...)
 42072 call 41751
 42075 add ESP,1
 42078 jmp 42041
__1904:
__1902:
 42081 leave 
 42082 ret 
help:
// help()
 42083 enter 4
__1907:
// strlen arg #1 (char* str)
 42086 push #55266
 42089 mov ECX,1
// strlen(...)
 42092 call 10743
 42095 add ESP,1
 42098 sstack EBP:-1,EAX
__1909:
 42102 rstack EAX,EBP:-1
 42106 mov EBX,1
 42109 sub EBX,EAX
 42111 fabs EBX,EBX
 42113 fsgn EBX,EBX
 42115 lneg EBX
// if (argc==1)
 42117 cmp 0,EBX
 42120 jge 42249
// I=CommandBuff
 42123 sstack EBP:-2,54997
// Match=0
 42128 sstack EBP:-3,0
__1912:
 42133 rstack EAX,EBP:-2
 42137 mov EBX,55210
 42140 sub EBX,EAX
 42142 fsgn EBX,EBX
 42144 max EBX,0
// if (I<CommandBuffEnd
 42147 cmp 0,EBX
 42150 jz 42219
// Print arg #2 (float col)
 42153 push 90
 42156 rstack EAX,EBP:-2
// Print arg #1 (char str)
 42160 push EAX
 42162 mov ECX,2
// Print(...)
 42165 call 40786
 42168 add ESP,2
// Print arg #2 (float col)
 42171 push 90
// Print arg #1 (char str)
 42174 push 20361
 42177 mov ECX,2
// Print(...)
 42180 call 40786
 42183 add ESP,2
 42186 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 42190 push EAX
 42192 mov ECX,1
// strlen(...)
 42195 call 10743
 42198 add ESP,1
 42201 add EAX,3
 42204 rstack EBX,EBP:-2
 42208 add EBX,EAX
 42210 mov EAX,EBX
// I=I+strlen(I)+3
 42212 sstack EBP:-2,EAX
 42216 jmp 42133
__1911:
// Print arg #2 (float col)
 42219 push 90
// Print arg #1 (char str)
 42222 push 18244
 42225 mov ECX,2
// Print(...)
 42228 call 40786
 42231 add ESP,2
// P arg #1 (char* str)
 42234 push 42454
 42237 mov ECX,1
// P(...)
 42240 call 40570
 42243 add ESP,1
 42246 jmp 42452
__1914:
__1910:
__1916:
// I=CommandBuff
 42249 sstack EBP:-2,54997
// Match=0
 42254 sstack EBP:-3,0
__1918:
 42259 rstack EAX,EBP:-2
 42263 mov EBX,55210
 42266 sub EBX,EAX
 42268 fsgn EBX,EBX
 42270 max EBX,0
// if (I<CommandBuffEnd
 42273 cmp 0,EBX
 42276 jz 42440
__1920:
 42279 rstack EAX,EBP:-2
// strcmp arg #2 (char* dest)
 42283 push EAX
 42285 mov EAX,1
 42288 add EAX,#55266
// strcmp arg #1 (char* src)
 42291 push #EAX
 42293 mov ECX,2
// strcmp(...)
 42296 call 10414
 42299 add ESP,2
 42302 mov EBX,0
 42305 sub EBX,EAX
 42307 fabs EBX,EBX
 42309 fsgn EBX,EBX
 42311 lneg EBX
// if (strcmp(Arr[1],I)==0)
 42313 cmp 0,EBX
 42316 jge 42407
 42319 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 42323 push EAX
 42325 mov ECX,1
// strlen(...)
 42328 call 10743
 42331 add ESP,1
 42334 add EAX,2
 42337 rstack EBX,EBP:-2
 42341 add EBX,EAX
 42343 mov EAX,EBX
// I=I+strlen(I)+2
 42345 sstack EBP:-2,EAX
// Match=1
 42349 sstack EBP:-3,1
 42354 rstack EAX,EBP:-2
 42358 sstack EBP:-4,#EAX
__1923:
 42362 rstack EAX,EBP:-4
// if (str)
 42366 cmp 0,EAX
 42369 jge 42390
 42372 rstack EAX,EBP:-4
// P arg #1 (char* str)
 42376 push EAX
 42378 mov ECX,1
// P(...)
 42381 call 40570
 42384 add ESP,1
 42387 jmp 42402
__1925:
__1924:
__1927:
// P arg #1 (char* str)
 42390 push 42499
 42393 mov ECX,1
// P(...)
 42396 call 40570
 42399 add ESP,1
__1926:
__1922:
 42402 leave 
 42403 ret 
 42404 jmp 42437
__1929:
__1921:
__1931:
 42407 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 42411 push EAX
 42413 mov ECX,1
// strlen(...)
 42416 call 10743
 42419 add ESP,1
 42422 add EAX,3
 42425 rstack EBX,EBP:-2
 42429 add EBX,EAX
 42431 mov EAX,EBX
// I=I+strlen(I)+3
 42433 sstack EBP:-2,EAX
__1930:
__1919:
 42437 jmp 42259
__1917:
// P arg #1 (char* str)
 42440 push 42539
 42443 mov ECX,1
// P(...)
 42446 call 40570
 42449 add ESP,1
__1915:
__1908:
__1906:
 42452 leave 
 42453 ret 
__1913:
 42454 db "type help <command> for command description
",0
__1928:
 42499 db "no help for this command is available.
",0
__1932:
 42539 db "unknown command, can't help.
",0
help_help:
 42569 db "helps with console commands. "help" for list of commands or "help <command>" for help with specific command.
"
 42678 db 0
cmdtest:
// cmdtest()
 42679 enter 1
__1934:
 42682 out 6,3
 42686 push 0
 42689 push 37796
 42692 mov ECX,2
// thread_create(...)
 42695 call 78790
 42698 add ESP,2
 42701 sstack EBP:-1,EAX
 42705 rstack EAX,EBP:-1
 42709 push EAX
 42711 mov ECX,1
// thread_enter(...)
 42714 call 77665
 42717 add ESP,1
__1933:
 42720 leave 
 42721 ret 
cmdtest2:
// cmdtest2()
 42722 enter 3
__1936:
 42725 sstack EBP:-1,ESP
 42729 sstack EBP:-2,SS
 42733 sstack EBP:-3,EBP
// P2 arg #3 (char* str2)
 42737 push 18244
 42740 rstack EAX,EBP:-1
// P2 arg #2 (float N)
 42744 push EAX
// P2 arg #1 (char* str1)
 42746 push 42815
 42749 mov ECX,3
// P2(...)
 42752 call 40700
 42755 add ESP,3
// P2 arg #3 (char* str2)
 42758 push 18244
 42761 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 42765 push EAX
// P2 arg #1 (char* str1)
 42767 push 42809
 42770 mov ECX,3
// P2(...)
 42773 call 40700
 42776 add ESP,3
// P2 arg #3 (char* str2)
 42779 push 18244
 42782 rstack EAX,EBP:-3
// P2 arg #2 (float N)
 42786 push EAX
// P2 arg #1 (char* str1)
 42788 push 42802
 42791 mov ECX,3
// P2(...)
 42794 call 40700
 42797 add ESP,3
__1935:
 42800 leave 
 42801 ret 
__1939:
 42802 db "EBP = ",0
__1938:
 42809 db "SS = ",0
__1937:
 42815 db "ESP = ",0
test_help:
 42822 db "runs unspecified test code"
printversion:
// printversion()
 42848 enter -0
__1941:
// P arg #1 (char* str)
 42851 push 83680
 42854 mov ECX,1
// P(...)
 42857 call 40570
 42860 add ESP,1
// P arg #1 (char* str)
 42863 push 18244
 42866 mov ECX,1
// P(...)
 42869 call 40570
 42872 add ESP,1
// P2 arg #3 (char* str2)
 42875 push 43055
 42878 mov EAX,83693
 42881 div EAX,1024
// P2 arg #2 (float N)
 42884 push EAX
// P2 arg #1 (char* str1)
 42886 push 43068
 42889 mov ECX,3
// P2(...)
 42892 call 40700
 42895 add ESP,3
// P2 arg #3 (char* str2)
 42898 push 18244
// P2 arg #2 (float N)
 42901 push #83688
// P2 arg #1 (char* str1)
 42904 push 43047
 42907 mov ECX,3
// P2(...)
 42910 call 40700
 42913 add ESP,3
// P2 arg #3 (char* str2)
 42916 push 18244
// P2 arg #2 (float N)
 42919 push #83689
// P2 arg #1 (char* str1)
 42922 push 43039
 42925 mov ECX,3
// P2(...)
 42928 call 40700
 42931 add ESP,3
// P2 arg #3 (char* str2)
 42934 push 18244
// P2 arg #2 (float N)
 42937 push #83690
// P2 arg #1 (char* str1)
 42940 push 43060
 42943 mov ECX,3
// P2(...)
 42946 call 40700
 42949 add ESP,3
// P2 arg #3 (char* str2)
 42952 push 18244
// P2 arg #2 (float N)
 42955 push #37053
// P2 arg #1 (char* str1)
 42958 push 43027
 42961 mov ECX,3
// P2(...)
 42964 call 40700
 42967 add ESP,3
// P2 arg #3 (char* str2)
 42970 push 18244
// P2 arg #2 (float N)
 42973 push #83691
// P2 arg #1 (char* str1)
 42976 push 43018
 42979 mov ECX,3
// P2(...)
 42982 call 40700
 42985 add ESP,3
// P2 arg #3 (char* str2)
 42988 push 18244
// P2 arg #2 (float N)
 42991 push #83692
// P2 arg #1 (char* str1)
 42994 push 43008
 42997 mov ECX,3
// P2(...)
 43000 call 40700
 43003 add ESP,3
__1940:
 43006 leave 
 43007 ret 
__1949:
 43008 db "AdrPort: ",0
__1948:
 43018 db "AdrHDD: ",0
__1947:
 43027 db "AdrScreen: ",0
__1945:
 43039 db "AdrRAM ",0
__1944:
 43047 db "AdrEB: ",0
__1943:
 43055 db " kB
",0
__1946:
 43060 db "AdrKb: ",0
__1942:
 43068 db "Size: ",0
printversion_help:
 43075 db "prints OS version and configuration
"
 43111 db 0
cmdecho:
// cmdecho()
 43112 enter 2
__1951:
__1954:
// strcmp arg #2 (char* dest)
 43115 push 43309
 43118 mov EAX,1
 43121 add EAX,#55266
// strcmp arg #1 (char* src)
 43124 push #EAX
 43126 mov ECX,2
// strcmp(...)
 43129 call 10414
 43132 add ESP,2
 43135 mov EBX,0
 43138 sub EBX,EAX
 43140 fabs EBX,EBX
 43142 fsgn EBX,EBX
 43144 lneg EBX
// if (strcmp(Arr[1],"off")==0)
 43146 cmp 0,EBX
 43149 jge 43159
// Echo=0
 43152 mov #55265,0
 43156 jmp 43307
__1956:
__1955:
__1958:
__1961:
// strcmp arg #2 (char* dest)
 43159 push 43313
 43162 mov EAX,1
 43165 add EAX,#55266
// strcmp arg #1 (char* src)
 43168 push #EAX
 43170 mov ECX,2
// strcmp(...)
 43173 call 10414
 43176 add ESP,2
 43179 mov EBX,0
 43182 sub EBX,EAX
 43184 fabs EBX,EBX
 43186 fsgn EBX,EBX
 43188 lneg EBX
// if (strcmp(Arr[1],"on")==0)
 43190 cmp 0,EBX
 43193 jge 43203
// Echo=1
 43196 mov #55265,1
 43200 jmp 43307
__1963:
__1962:
__1965:
 43203 sstack EBP:-1,1
 43208 rstack EAX,EBP:-1
 43212 mov EBX,EAX
 43214 inc EAX
 43216 sstack EBP:-1,EAX
 43220 add EBX,#55266
 43223 sstack EBP:-2,#EBX
__1967:
 43227 rstack EAX,EBP:-2
// if (S
 43231 cmp 0,EAX
 43234 jz 43292
// Print arg #2 (float col)
 43237 push 90
 43240 rstack EAX,EBP:-2
// Print arg #1 (char str)
 43244 push EAX
 43246 mov ECX,2
// Print(...)
 43249 call 40786
 43252 add ESP,2
// Print arg #2 (float col)
 43255 push 90
// Print arg #1 (char str)
 43258 push 20361
 43261 mov ECX,2
// Print(...)
 43264 call 40786
 43267 add ESP,2
 43270 rstack EAX,EBP:-1
 43274 mov EBX,EAX
 43276 inc EAX
 43278 sstack EBP:-1,EAX
 43282 add EBX,#55266
// S=Arr[I++]
 43285 sstack EBP:-2,#EBX
 43289 jmp 43227
__1966:
// Print arg #2 (float col)
 43292 push 90
// Print arg #1 (char str)
 43295 push 18244
 43298 mov ECX,2
// Print(...)
 43301 call 40786
 43304 add ESP,2
__1964:
__1960:
__1957:
__1953:
__1950:
 43307 leave 
 43308 ret 
__1952:
 43309 db "off",0
__1959:
 43313 db "on",0
echo_help:
 43316 db "echoes input. "echo off" to turn off and "echo on" to turn on.
"
 43379 db 0
arg_rest:
// arg_rest(buff,n)
 43380 enter 2
__1969:
// strlen arg #1 (char* str)
 43383 push #55266
 43386 mov ECX,1
// strlen(...)
 43389 call 10743
 43392 add ESP,1
 43395 sstack EBP:-1,EAX
 43399 rstack EAX,EBP:3
// init loop
 43403 sstack EBP:-2,EAX
__1971:
 43407 rstack EAX,EBP:-2
 43411 rstack EBX,EBP:-1
 43415 sub EBX,EAX
 43417 mov EAX,EBX
 43419 fsgn EAX,EAX
// condition
 43421 max EAX,0
 43424 cmp 0,EAX
 43427 jz 43542
 43430 rstack EAX,EBP:-2
 43434 add EAX,#55266
 43437 mov EBX,EAX
// strcpy arg #2 (char* src)
 43439 push #EBX
 43441 rstack EAX,EBP:2
// strcpy arg #1 (char* dest)
 43445 push EAX
 43447 mov ECX,2
// strcpy(...)
 43450 call 10585
 43453 add ESP,2
 43456 rstack EAX,EBP:-2
 43460 add EAX,#55266
 43463 mov EBX,EAX
// strlen arg #1 (char* str)
 43465 push #EBX
 43467 mov ECX,1
// strlen(...)
 43470 call 10743
 43473 add ESP,1
 43476 rstack EBX,EBP:2
// buff+=strlen(Arr[I])
 43480 add EBX,EAX
 43482 sstack EBP:2,EBX
__1973:
 43486 rstack EAX,EBP:-1
 43490 sub EAX,1
 43493 mov EBX,EAX
 43495 fsgn EBX,EBX
 43497 max EBX,0
 43500 rstack EAX,EBP:-2
 43504 add EAX,EBX
 43506 mov EBX,EAX
// if (I+1<argc)
 43508 cmp 0,EBX
 43511 jge 43529
 43514 rstack EAX,EBP:2
 43518 mov EBX,EAX
 43520 inc EAX
 43522 sstack EBP:2,EAX
// *buff++=' '
 43526 mov #EBX,32
__1974:
__1972:
 43529 rstack EAX,EBP:-2
// loop step
 43533 inc EAX
 43535 sstack EBP:-2,EAX
 43539 jmp 43407
__1970:
 43542 rstack EAX,EBP:2
// *buff=0
 43546 mov #EAX,0
__1968:
 43549 leave 
 43550 ret 
cmdtime:
// cmdtime()
 43551 enter 88
__1976:
// strlen arg #1 (char* str)
 43554 push #55266
 43557 mov ECX,1
// strlen(...)
 43560 call 10743
 43563 add ESP,1
 43566 sstack EBP:-1,EAX
__1978:
 43570 rstack EAX,EBP:-1
 43574 mov EBX,1
 43577 sub EBX,EAX
 43579 neg EBX
 43581 fsgn EBX,EBX
 43583 max EBX,0
// if (argc>1)
 43586 cmp 0,EBX
 43589 jge 43766
 43592 mov ECX,0
// curticks(...)
 43595 call 37769
 43598 mov ECX,0
// curticks(...)
 43601 call 37769
 43604 mov ECX,0
// curtime(...)
 43607 call 37787
 43610 sstack EBP:-2,EAX
 43614 mov ECX,0
// curticks(...)
 43617 call 37769
 43620 sstack EBP:-3,EAX
// arg_rest arg #2 (float n)
 43624 push 1
 43627 mov EAX,SS:ESP
 43630 add EAX,-83
// arg_rest arg #1 (float buff)
 43633 push EAX
 43635 mov ECX,2
// arg_rest(...)
 43638 call 43380
 43641 add ESP,2
 43644 mov ECX,0
// curticks(...)
 43647 call 37769
 43650 sstack EBP:-84,EAX
 43654 mov EAX,SS:ESP
 43657 add EAX,-83
// ParseStringSilent arg #1 (char str)
 43660 push EAX
 43662 mov ECX,1
// ParseStringSilent(...)
 43665 call 39351
 43668 add ESP,1
 43671 mov ECX,0
// curtime(...)
 43674 call 37787
 43677 sstack EBP:-85,EAX
 43681 rstack EAX,EBP:-2
 43685 neg EAX
 43687 mov EBX,EAX
 43689 rstack EAX,EBP:-85
 43693 add EAX,EBX
 43695 mov EBX,EAX
 43697 sstack EBP:-86,EBX
 43701 rstack EAX,EBP:-3
 43705 neg EAX
 43707 mov EBX,EAX
 43709 rstack EAX,EBP:-84
 43713 add EAX,EBX
 43715 mov EBX,EAX
 43717 sstack EBP:-87,EBX
// P2 arg #3 (char* str2)
 43721 push 43803
 43724 rstack EAX,EBP:-86
// P2 arg #2 (float N)
 43728 push EAX
// P2 arg #1 (char* str1)
 43730 push 43824
 43733 mov ECX,3
// P2(...)
 43736 call 40700
 43739 add ESP,3
// P2 arg #3 (char* str2)
 43742 push 43806
 43745 rstack EAX,EBP:-87
// P2 arg #2 (float N)
 43749 push EAX
// P2 arg #1 (char* str1)
 43751 push 43847
 43754 mov ECX,3
// P2(...)
 43757 call 40700
 43760 add ESP,3
 43763 jmp 43801
__1984:
__1979:
__1986:
 43766 mov ECX,0
// curtime(...)
 43769 call 37787
 43772 sstack EBP:-88,EAX
// time=EAX
 43776 sstack EBP:-88,EAX
// P2 arg #3 (char* str2)
 43780 push 43814
 43783 rstack EAX,EBP:-88
// P2 arg #2 (float N)
 43787 push EAX
// P2 arg #1 (char* str1)
 43789 push 43828
 43792 mov ECX,3
// P2(...)
 43795 call 40700
 43798 add ESP,3
__1985:
__1977:
__1975:
 43801 leave 
 43802 ret 
__1981:
 43803 db "s ",0
__1983:
 43806 db " ticks
",0
__1988:
 43814 db " seconds
",0
__1980:
 43824 db "T: ",0
__1987:
 43828 db "Time since start: ",0
__1982:
 43847 db "/ ",0
time_help:
 43850 db "tells the current time in seconds since CPU start, or times the execution of a command.
"
 43938 db 0
getFullname:
// getFullName(buff,str)
 43939 enter 1
__1990:
 43942 rstack EAX,EBP:2
 43946 sstack EBP:-1,EAX
// strcpy arg #2 (char* src)
 43950 push 55279
 43953 rstack EAX,EBP:-1
// strcpy arg #1 (char* dest)
 43957 push EAX
 43959 mov ECX,2
// strcpy(...)
 43962 call 10585
 43965 add ESP,2
// strlen arg #1 (char* str)
 43968 push 55279
 43971 mov ECX,1
// strlen(...)
 43974 call 10743
 43977 add ESP,1
 43980 rstack EBX,EBP:-1
 43984 add EBX,EAX
 43986 mov EAX,EBX
// strI=strI+strlen(CurDir)
 43988 sstack EBP:-1,EAX
 43992 rstack EAX,EBP:3
// strcpy arg #2 (char* src)
 43996 push EAX
 43998 rstack EAX,EBP:-1
// strcpy arg #1 (char* dest)
 44002 push EAX
 44004 mov ECX,2
// strcpy(...)
 44007 call 10585
 44010 add ESP,2
__1989:
 44013 leave 
 44014 ret 
heap_status:
// heap_status()
 44015 enter 4
__1992:
 44018 mov EAX,SS:ESP
 44021 add EAX,-4
// malloc_count arg #4 (float* usedcount)
 44024 push EAX
 44026 mov EAX,SS:ESP
 44029 add EAX,-3
// malloc_count arg #3 (float* freecount)
 44032 push EAX
 44034 mov EAX,SS:ESP
 44037 add EAX,-2
// malloc_count arg #2 (float* usedsize)
 44040 push EAX
 44042 mov EAX,SS:ESP
 44045 add EAX,-1
// malloc_count arg #1 (float* freesize)
 44048 push EAX
 44050 mov ECX,4
// malloc_count(...)
 44053 call 19977
 44056 add ESP,4
// P2 arg #3 (char* str2)
 44059 push 18244
// P2 arg #2 (float N)
 44062 push #22591
// P2 arg #1 (char* str1)
 44065 push 44304
 44068 mov ECX,3
// P2(...)
 44071 call 40700
 44074 add ESP,3
// P2 arg #3 (char* str2)
 44077 push 43055
 44080 rstack EAX,EBP:-1
 44084 div EAX,1024
 44087 mov EBX,EAX
// P2 arg #2 (float N)
 44089 push EBX
// P2 arg #1 (char* str1)
 44091 push 44248
 44094 mov ECX,3
// P2(...)
 44097 call 40700
 44100 add ESP,3
// P2 arg #3 (char* str2)
 44103 push 43055
 44106 rstack EAX,EBP:-2
 44110 div EAX,1024
 44113 mov EBX,EAX
// P2 arg #2 (float N)
 44115 push EBX
// P2 arg #1 (char* str1)
 44117 push 44261
 44120 mov ECX,3
// P2(...)
 44123 call 40700
 44126 add ESP,3
// P2 arg #3 (char* str2)
 44129 push 18244
 44132 rstack EAX,EBP:-3
// P2 arg #2 (float N)
 44136 push EAX
// P2 arg #1 (char* str1)
 44138 push 44234
 44141 mov ECX,3
// P2(...)
 44144 call 40700
 44147 add ESP,3
// P2 arg #3 (char* str2)
 44150 push 18244
 44153 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 44157 push EAX
// P2 arg #1 (char* str1)
 44159 push 44290
 44162 mov ECX,3
// P2(...)
 44165 call 40700
 44168 add ESP,3
__1999:
 44171 mov ECX,0
// malloc_test(...)
 44174 call 19640
 44177 lneg EAX
// if (!malloc_test())
 44179 cmp 0,EAX
 44182 jge 44200
// P arg #1 (char* str)
 44185 push 44217
 44188 mov ECX,1
// P(...)
 44191 call 40570
 44194 add ESP,1
 44197 jmp 44215
__2002:
__2000:
__2004:
// Print arg #2 (float col)
 44200 push 900
// Print arg #1 (char str)
 44203 push 44274
 44206 mov ECX,2
// Print(...)
 44209 call 40786
 44212 add ESP,2
__2003:
__1998:
__1991:
 44215 leave 
 44216 ret 
__2001:
 44217 db "heap is healthy
",0
__1996:
 44234 db "free blocks: ",0
__1994:
 44248 db "free space: ",0
__1995:
 44261 db "used space: ",0
__2005:
 44274 db "HEAP CORRUPTED
",0
__1997:
 44290 db "used blocks: ",0
__1993:
 44304 db "heap at ",0
heap_status_help:
 44313 db "reports RAM / malloc status.
"
 44342 db 0
cmd_rpncalc:
// cmd_rpncalc()
 44343 enter 10
__2007:
// strlen arg #1 (char* str)
 44346 push #55266
 44349 mov ECX,1
// strlen(...)
 44352 call 10743
 44355 add ESP,1
 44358 sstack EBP:-1,EAX
__2009:
 44362 rstack EAX,EBP:-1
 44366 mov EBX,1
 44369 sub EBX,EAX
 44371 fabs EBX,EBX
 44373 fsgn EBX,EBX
 44375 lneg EBX
// if (argc==1)
 44377 cmp 0,EBX
 44380 jge 44395
// P arg #1 (char* str)
 44383 push 45396
 44386 mov ECX,1
// P(...)
 44389 call 40570
 44392 add ESP,1
__2010:
__2008:
// malloc arg #1 (float n)
 44395 push 50
 44398 mov ECX,1
// malloc(...)
 44401 call 20709
 44404 add ESP,1
 44407 sstack EBP:-2,EAX
 44411 sstack EBP:-3,0
// init loop
 44416 sstack EBP:-4,1
__2013:
 44421 rstack EAX,EBP:-4
 44425 rstack EBX,EBP:-1
 44429 sub EBX,EAX
 44431 mov EAX,EBX
 44433 fsgn EAX,EAX
// condition
 44435 max EAX,0
 44438 cmp 0,EAX
 44441 jz 45221
 44444 rstack EAX,EBP:-4
 44448 add EAX,#55266
 44451 mov EBX,EAX
 44453 sstack EBP:-5,#EBX
 44457 rstack EAX,EBP:-5
 44461 add EAX,0
 44464 mov EBX,EAX
 44466 sstack EBP:-6,#EBX
__2015:
 44470 rstack EAX,EBP:-6
// isNum arg #1 (char C)
 44474 push EAX
 44476 mov ECX,1
// isNum(...)
 44479 call 14521
 44482 add ESP,1
// if (isNum(C))
 44485 cmp 0,EAX
 44488 jge 44541
 44491 rstack EAX,EBP:-5
// str2num arg #1 (char* str)
 44495 push EAX
 44497 mov ECX,1
// str2num(...)
 44500 call 11422
 44503 add ESP,1
 44506 sstack EBP:-7,EAX
 44510 rstack EAX,EBP:-7
 44514 rstack EBX,EBP:-3
 44518 rstack ECX,EBP:-2
 44522 add ECX,EBX
 44524 mov EBX,ECX
// argstack[argstackI]=num
 44526 mov #EBX,EAX
 44528 rstack EAX,EBP:-3
// argstackI++
 44532 inc EAX
 44534 sstack EBP:-3,EAX
 44538 jmp 45208
__2017:
__2016:
__2019:
__2021:
 44541 rstack EAX,EBP:-3
 44545 mov EBX,2
 44548 sub EBX,EAX
 44550 fsgn EBX,EBX
 44552 max EBX,0
// if (argstackI<2)
 44555 cmp 0,EBX
 44558 jge 44575
// P arg #1 (char* str)
 44561 push 45321
 44564 mov ECX,1
// P(...)
 44567 call 40570
 44570 add ESP,1
 44573 leave 
 44574 ret 
__2022:
__2020:
 44575 rstack EAX,EBP:-3
// argstackI--
 44579 dec EAX
 44581 sstack EBP:-3,EAX
 44585 rstack EAX,EBP:-3
 44589 rstack EBX,EBP:-2
 44593 add EBX,EAX
 44595 mov EAX,EBX
 44597 sstack EBP:-8,#EAX
 44601 rstack EAX,EBP:-3
// argstackI--
 44605 dec EAX
 44607 sstack EBP:-3,EAX
 44611 rstack EAX,EBP:-3
 44615 rstack EBX,EBP:-2
 44619 add EBX,EAX
 44621 mov EAX,EBX
 44623 sstack EBP:-9,#EAX
 44627 sstack EBP:-10,0
__2025:
 44632 rstack EAX,EBP:-6
 44636 mov EBX,43
 44639 sub EBX,EAX
 44641 fabs EBX,EBX
 44643 fsgn EBX,EBX
 44645 lneg EBX
// if (C=='+')
 44647 cmp 0,EBX
 44650 jge 44735
 44653 rstack EAX,EBP:-8
 44657 rstack EBX,EBP:-9
 44661 add EBX,EAX
 44663 mov EAX,EBX
// arg3=arg1+arg2
 44665 sstack EBP:-10,EAX
// P2 arg #3 (char* str2)
 44669 push 45422
 44672 rstack EAX,EBP:-9
// P2 arg #2 (float N)
 44676 push EAX
// P2 arg #1 (char* str1)
 44678 push 26784
 44681 mov ECX,3
// P2(...)
 44684 call 40700
 44687 add ESP,3
// P2 arg #3 (char* str2)
 44690 push 45317
 44693 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 44697 push EAX
// P2 arg #1 (char* str1)
 44699 push 26784
 44702 mov ECX,3
// P2(...)
 44705 call 40700
 44708 add ESP,3
// P2 arg #3 (char* str2)
 44711 push 18244
 44714 rstack EAX,EBP:-10
// P2 arg #2 (float N)
 44718 push EAX
// P2 arg #1 (char* str1)
 44720 push 26784
 44723 mov ECX,3
// P2(...)
 44726 call 40700
 44729 add ESP,3
 44732 jmp 45180
__2026:
__2024:
__2030:
 44735 rstack EAX,EBP:-6
 44739 mov EBX,45
 44742 sub EBX,EAX
 44744 fabs EBX,EBX
 44746 fsgn EBX,EBX
 44748 lneg EBX
// if (C=='-')
 44750 cmp 0,EBX
 44753 jge 44842
 44756 rstack EAX,EBP:-8
 44760 neg EAX
 44762 mov EBX,EAX
 44764 rstack EAX,EBP:-9
 44768 add EAX,EBX
 44770 mov EBX,EAX
// arg3=arg1-arg2
 44772 sstack EBP:-10,EBX
// P2 arg #3 (char* str2)
 44776 push 45418
 44779 rstack EAX,EBP:-9
// P2 arg #2 (float N)
 44783 push EAX
// P2 arg #1 (char* str1)
 44785 push 26784
 44788 mov ECX,3
// P2(...)
 44791 call 40700
 44794 add ESP,3
// P2 arg #3 (char* str2)
 44797 push 45317
 44800 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 44804 push EAX
// P2 arg #1 (char* str1)
 44806 push 26784
 44809 mov ECX,3
// P2(...)
 44812 call 40700
 44815 add ESP,3
// P2 arg #3 (char* str2)
 44818 push 18244
 44821 rstack EAX,EBP:-10
// P2 arg #2 (float N)
 44825 push EAX
// P2 arg #1 (char* str1)
 44827 push 26784
 44830 mov ECX,3
// P2(...)
 44833 call 40700
 44836 add ESP,3
 44839 jmp 45180
__2031:
__2029:
__2034:
 44842 rstack EAX,EBP:-6
 44846 mov EBX,42
 44849 sub EBX,EAX
 44851 fabs EBX,EBX
 44853 fsgn EBX,EBX
 44855 lneg EBX
// if (C=='*')
 44857 cmp 0,EBX
 44860 jge 44945
 44863 rstack EAX,EBP:-8
 44867 rstack EBX,EBP:-9
 44871 mul EBX,EAX
 44873 mov EAX,EBX
// arg3=arg1*arg2
 44875 sstack EBP:-10,EAX
// P2 arg #3 (char* str2)
 44879 push 45426
 44882 rstack EAX,EBP:-9
// P2 arg #2 (float N)
 44886 push EAX
// P2 arg #1 (char* str1)
 44888 push 26784
 44891 mov ECX,3
// P2(...)
 44894 call 40700
 44897 add ESP,3
// P2 arg #3 (char* str2)
 44900 push 45317
 44903 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 44907 push EAX
// P2 arg #1 (char* str1)
 44909 push 26784
 44912 mov ECX,3
// P2(...)
 44915 call 40700
 44918 add ESP,3
// P2 arg #3 (char* str2)
 44921 push 18244
 44924 rstack EAX,EBP:-10
// P2 arg #2 (float N)
 44928 push EAX
// P2 arg #1 (char* str1)
 44930 push 26784
 44933 mov ECX,3
// P2(...)
 44936 call 40700
 44939 add ESP,3
 44942 jmp 45180
__2035:
__2033:
__2038:
 44945 rstack EAX,EBP:-6
 44949 mov EBX,47
 44952 sub EBX,EAX
 44954 fabs EBX,EBX
 44956 fsgn EBX,EBX
 44958 lneg EBX
// if (C=='/')
 44960 cmp 0,EBX
 44963 jge 45048
 44966 rstack EAX,EBP:-8
 44970 rstack EBX,EBP:-9
 44974 div EBX,EAX
 44976 mov EAX,EBX
// arg3=arg1/arg2
 44978 sstack EBP:-10,EAX
// P2 arg #3 (char* str2)
 44982 push 19847
 44985 rstack EAX,EBP:-9
// P2 arg #2 (float N)
 44989 push EAX
// P2 arg #1 (char* str1)
 44991 push 26784
 44994 mov ECX,3
// P2(...)
 44997 call 40700
 45000 add ESP,3
// P2 arg #3 (char* str2)
 45003 push 45317
 45006 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 45010 push EAX
// P2 arg #1 (char* str1)
 45012 push 26784
 45015 mov ECX,3
// P2(...)
 45018 call 40700
 45021 add ESP,3
// P2 arg #3 (char* str2)
 45024 push 18244
 45027 rstack EAX,EBP:-10
// P2 arg #2 (float N)
 45031 push EAX
// P2 arg #1 (char* str1)
 45033 push 26784
 45036 mov ECX,3
// P2(...)
 45039 call 40700
 45042 add ESP,3
 45045 jmp 45180
__2039:
__2037:
__2041:
 45048 rstack EAX,EBP:-6
 45052 mov EBX,94
 45055 sub EBX,EAX
 45057 fabs EBX,EBX
 45059 fsgn EBX,EBX
 45061 lneg EBX
// if (C=='^')
 45063 cmp 0,EBX
 45066 jge 45151
 45069 rstack EAX,EBP:-8
 45073 rstack EBX,EBP:-9
 45077 fpwr EBX,EAX
 45079 mov EAX,EBX
// arg3=arg1^^arg2
 45081 sstack EBP:-10,EAX
// P2 arg #3 (char* str2)
 45085 push 45430
 45088 rstack EAX,EBP:-9
// P2 arg #2 (float N)
 45092 push EAX
// P2 arg #1 (char* str1)
 45094 push 26784
 45097 mov ECX,3
// P2(...)
 45100 call 40700
 45103 add ESP,3
// P2 arg #3 (char* str2)
 45106 push 45317
 45109 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 45113 push EAX
// P2 arg #1 (char* str1)
 45115 push 26784
 45118 mov ECX,3
// P2(...)
 45121 call 40700
 45124 add ESP,3
// P2 arg #3 (char* str2)
 45127 push 18244
 45130 rstack EAX,EBP:-10
// P2 arg #2 (float N)
 45134 push EAX
// P2 arg #1 (char* str1)
 45136 push 26784
 45139 mov ECX,3
// P2(...)
 45142 call 40700
 45145 add ESP,3
 45148 jmp 45180
__2042:
__2040:
// P arg #1 (char* str)
 45151 push 45368
 45154 mov ECX,1
// P(...)
 45157 call 40570
 45160 add ESP,1
 45163 rstack EAX,EBP:-5
// P arg #1 (char* str)
 45167 push EAX
 45169 mov ECX,1
// P(...)
 45172 call 40570
 45175 add ESP,1
 45178 leave 
 45179 ret 
rpncalc_good:
 45180 rstack EAX,EBP:-10
 45184 rstack EBX,EBP:-3
 45188 rstack ECX,EBP:-2
 45192 add ECX,EBX
 45194 mov EBX,ECX
// argstack[argstackI]=arg3
 45196 mov #EBX,EAX
 45198 rstack EAX,EBP:-3
// argstackI++
 45202 inc EAX
 45204 sstack EBP:-3,EAX
__2018:
__2014:
 45208 rstack EAX,EBP:-4
// loop step
 45212 inc EAX
 45214 sstack EBP:-4,EAX
 45218 jmp 44421
__2012:
// P arg #1 (char* str)
 45221 push 45387
 45224 mov ECX,1
// P(...)
 45227 call 40570
 45230 add ESP,1
// init loop
 45233 sstack EBP:-4,0
__2047:
 45238 rstack EAX,EBP:-4
 45242 rstack EBX,EBP:-3
 45246 sub EBX,EAX
 45248 mov EAX,EBX
 45250 fsgn EAX,EAX
// condition
 45252 max EAX,0
 45255 cmp 0,EAX
 45258 jz 45303
// P2 arg #3 (char* str2)
 45261 push 20361
 45264 rstack EAX,EBP:-4
 45268 rstack EBX,EBP:-2
 45272 add EBX,EAX
 45274 mov EAX,EBX
// P2 arg #2 (float N)
 45276 push #EAX
// P2 arg #1 (char* str1)
 45278 push 26784
 45281 mov ECX,3
// P2(...)
 45284 call 40700
 45287 add ESP,3
 45290 rstack EAX,EBP:-4
// loop step
 45294 inc EAX
 45296 sstack EBP:-4,EAX
 45300 jmp 45238
__2046:
// P arg #1 (char* str)
 45303 push 18244
 45306 mov ECX,1
// P(...)
 45309 call 40570
 45312 add ESP,1
__2006:
 45315 leave 
 45316 ret 
__2028:
 45317 db " = ",0
__2023:
 45321 db "stack underflow. Remember to use RPN notation
",0
__2044:
 45368 db "unknown operator:
",0
__2045:
 45387 db "result:
",0
__2011:
 45396 db "Usage: rpncalc 1 2 +
",0
__2032:
 45418 db " - ",0
__2027:
 45422 db " + ",0
__2036:
 45426 db " * ",0
__2043:
 45430 db " ^ ",0
rpncalc_help:
 45434 db "reverse polish notation calculator. "rpncalc 2 3 * 4 +" to calculate (2 * 3) + 4.
"
 45516 db 0
cmd_cd:
// cmd_cd()
 45517 enter 4
__2049:
// strlen arg #1 (char* str)
 45520 push #55266
 45523 mov ECX,1
// strlen(...)
 45526 call 10743
 45529 add ESP,1
 45532 sstack EBP:-1,EAX
__2051:
 45536 rstack EAX,EBP:-1
 45540 mov EBX,1
 45543 sub EBX,EAX
 45545 neg EBX
 45547 fsgn EBX,EBX
 45549 max EBX,0
// if (argc>1)
 45552 cmp 0,EBX
 45555 jge 45844
// malloc arg #1 (float n)
 45558 push #22842
 45561 mov ECX,1
// malloc(...)
 45564 call 20709
 45567 add ESP,1
 45570 sstack EBP:-2,EAX
// string_constructor arg #2 (char* str)
 45574 push 26784
 45577 rstack EAX,EBP:-2
// string_constructor arg #1 (void* self)
 45581 push EAX
 45583 mov ECX,2
// string_constructor(...)
 45586 call 25698
 45589 add ESP,2
 45592 mov EAX,1
 45595 add EAX,#55266
 45598 sstack EBP:-3,#EAX
 45602 rstack EAX,EBP:-3
// strlen arg #1 (char* str)
 45606 push EAX
 45608 mov ECX,1
// strlen(...)
 45611 call 10743
 45614 add ESP,1
 45617 sstack EBP:-4,EAX
__2054:
 45621 rstack EAX,EBP:-3
 45625 add EAX,0
 45628 mov EBX,EAX
 45630 mov EAX,47
 45633 sub EAX,#EBX
 45635 fabs EAX,EAX
 45637 fsgn EAX,EAX
 45639 lneg EAX
// if (str[0]=='/')
 45641 cmp 0,EAX
 45644 jge 45650
 45647 jmp 45668
__2056:
__2055:
__2058:
// string_addcs arg #2 (char* c_str)
 45650 push 55279
 45653 rstack EAX,EBP:-2
// string_addcs arg #1 (void* self)
 45657 push EAX
 45659 mov ECX,2
// string_addcs(...)
 45662 call 26168
 45665 add ESP,2
__2057:
__2053:
__2060:
 45668 rstack EAX,EBP:-4
 45672 add EAX,-1
 45675 mov EBX,EAX
 45677 rstack EAX,EBP:-3
 45681 add EAX,EBX
 45683 mov EBX,EAX
 45685 mov EAX,47
 45688 sub EAX,#EBX
 45690 fabs EAX,EAX
 45692 fsgn EAX,EAX
 45694 lneg EAX
// if (str[len-1]=='/')
 45696 cmp 0,EAX
 45699 jge 45722
 45702 rstack EAX,EBP:-4
 45706 add EAX,-1
 45709 mov EBX,EAX
 45711 rstack EAX,EBP:-3
 45715 add EAX,EBX
 45717 mov EBX,EAX
// str[len-1]=0
 45719 mov #EBX,0
__2061:
__2059:
 45722 rstack EAX,EBP:-3
// string_addcs arg #2 (char* c_str)
 45726 push EAX
 45728 rstack EAX,EBP:-2
// string_addcs arg #1 (void* self)
 45732 push EAX
 45734 mov ECX,2
// string_addcs(...)
 45737 call 26168
 45740 add ESP,2
// string_addcs arg #2 (char* c_str)
 45743 push 38083
 45746 rstack EAX,EBP:-2
// string_addcs arg #1 (void* self)
 45750 push EAX
 45752 mov ECX,2
// string_addcs(...)
 45755 call 26168
 45758 add ESP,2
 45761 rstack EAX,EBP:-2
// string_c_str arg #1 (void* self)
 45765 push EAX
 45767 mov ECX,1
// string_c_str(...)
 45770 call 25825
 45773 add ESP,1
// str=string_c_str(str2)
 45776 sstack EBP:-3,EAX
 45780 rstack EAX,EBP:-3
// strcpy arg #2 (char* src)
 45784 push EAX
// strcpy arg #1 (char* dest)
 45786 push 55279
 45789 mov ECX,2
// strcpy(...)
 45792 call 10585
 45795 add ESP,2
// current_path=CurDir
 45798 mov #63727,55279
// P arg #1 (char* str)
 45802 push 45902
 45805 mov ECX,1
// P(...)
 45808 call 40570
 45811 add ESP,1
 45814 rstack EAX,EBP:-3
// P arg #1 (char* str)
 45818 push EAX
 45820 mov ECX,1
// P(...)
 45823 call 40570
 45826 add ESP,1
// P arg #1 (char* str)
 45829 push 18244
 45832 mov ECX,1
// P(...)
 45835 call 40570
 45838 add ESP,1
 45841 jmp 45880
__2063:
__2052:
__2065:
// P arg #1 (char* str)
 45844 push 45882
 45847 mov ECX,1
// P(...)
 45850 call 40570
 45853 add ESP,1
// P arg #1 (char* str)
 45856 push 55279
 45859 mov ECX,1
// P(...)
 45862 call 40570
 45865 add ESP,1
// P arg #1 (char* str)
 45868 push 18244
 45871 mov ECX,1
// P(...)
 45874 call 40570
 45877 add ESP,1
__2064:
__2050:
__2048:
 45880 leave 
 45881 ret 
__2066:
 45882 db "Current directory: ",0
__2062:
 45902 db "Changing dir to ",0
cd_help:
 45919 db ""cd" to report current directory.
"cd <path>" to change dir to <current dir>/<path>
"cd /<path>" to change dir to <path>
"
 46040 db 0
cmd_dir:
// cmd_dir()
 46041 enter 4
__2068:
 46044 push 55279
 46047 mov ECX,1
// flist(...)
 46050 call 66223
 46053 add ESP,1
 46056 sstack EBP:-1,EAX
 46060 rstack EAX,EBP:-1
// vector_get_size arg #1 (void* self)
 46064 push EAX
 46066 mov ECX,1
// vector_get_size(...)
 46069 call 23189
 46072 add ESP,1
 46075 sstack EBP:-2,EAX
// init loop
 46079 sstack EBP:-3,0
__2070:
 46084 rstack EAX,EBP:-3
 46088 rstack EBX,EBP:-2
 46092 sub EBX,EAX
 46094 mov EAX,EBX
 46096 fsgn EAX,EAX
// condition
 46098 max EAX,0
 46101 cmp 0,EAX
 46104 jz 46175
 46107 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 46111 push EAX
// vector_get arg #2 (void* element)
 46113 push 0
 46116 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 46120 push EAX
 46122 mov ECX,3
// vector_get(...)
 46125 call 24205
 46128 add ESP,3
 46131 sstack EBP:-4,EAX
 46135 rstack EAX,EBP:-4
// P arg #1 (char* str)
 46139 push EAX
 46141 mov ECX,1
// P(...)
 46144 call 40570
 46147 add ESP,1
// P arg #1 (char* str)
 46150 push 20361
 46153 mov ECX,1
// P(...)
 46156 call 40570
 46159 add ESP,1
 46162 rstack EAX,EBP:-3
// loop step
 46166 inc EAX
 46168 sstack EBP:-3,EAX
 46172 jmp 46084
__2069:
// P arg #1 (char* str)
 46175 push 18244
 46178 mov ECX,1
// P(...)
 46181 call 40570
 46184 add ESP,1
__2067:
 46187 leave 
 46188 ret 
dir_help:
 46189 db "list the files in the current directory.
"
cmd_mkdir:
// cmd_mkdir()
 46230 enter 81
__2072:
// strlen arg #1 (char* str)
 46233 push #55266
 46236 mov ECX,1
// strlen(...)
 46239 call 10743
 46242 add ESP,1
 46245 sstack EBP:-1,EAX
__2074:
 46249 rstack EAX,EBP:-1
 46253 mov EBX,1
 46256 sub EBX,EAX
 46258 neg EBX
 46260 fsgn EBX,EBX
 46262 max EBX,0
// if (argc>1)
 46265 cmp 0,EBX
 46268 jge 46314
// Print arg #2 (float col)
 46271 push 990
// Print arg #1 (char str)
 46274 push 46350
 46277 mov ECX,2
// Print(...)
 46280 call 40786
 46283 add ESP,2
 46286 mov EAX,1
 46289 add EAX,#55266
 46292 push #EAX
 46294 mov EAX,SS:ESP
 46297 add EAX,-81
 46300 push EAX
 46302 mov ECX,2
// getFullname(...)
 46305 call 43939
 46308 add ESP,2
 46311 jmp 46326
__2077:
__2075:
__2079:
// P arg #1 (char* str)
 46314 push 46328
 46317 mov ECX,1
// P(...)
 46320 call 40570
 46323 add ESP,1
__2078:
__2073:
__2071:
 46326 leave 
 46327 ret 
__2080:
 46328 db "usage: mkdir dirname
",0
__2076:
 46350 db "Making Dir...
",0
mkdir_help:
 46365 db ""mkdir <name>" to make a new directory "name".
"
 46412 db 0
cmd_write:
// cmd_write()
 46413 enter 86
__2082:
// strlen arg #1 (char* str)
 46416 push #55266
 46419 mov ECX,1
// strlen(...)
 46422 call 10743
 46425 add ESP,1
 46428 sstack EBP:-1,EAX
__2084:
 46432 rstack EAX,EBP:-1
 46436 mov EBX,2
 46439 sub EBX,EAX
 46441 neg EBX
 46443 fsgn EBX,EBX
 46445 max EBX,0
// if (argc>2)
 46448 cmp 0,EBX
 46451 jge 46729
 46454 mov EAX,1
 46457 add EAX,#55266
 46460 push #EAX
 46462 mov EAX,SS:ESP
 46465 add EAX,-81
 46468 push EAX
 46470 mov ECX,2
// getFullname(...)
 46473 call 43939
 46476 add ESP,2
 46479 push 46800
 46482 mov EAX,SS:ESP
 46485 add EAX,-81
 46488 push EAX
 46490 mov ECX,2
// fopen(...)
 46493 call 64589
 46496 add ESP,2
 46499 sstack EBP:-82,EAX
 46503 sstack EBP:-84,0
__2088:
 46508 rstack EAX,EBP:-82
 46512 lneg EAX
 46514 mov EBX,EAX
// if (!F)
 46516 cmp 0,EBX
 46519 jge 46574
// Print arg #2 (float col)
 46522 push 900
// Print arg #1 (char str)
 46525 push 46743
 46528 mov ECX,2
// Print(...)
 46531 call 40786
 46534 add ESP,2
// Print arg #2 (float col)
 46537 push 900
 46540 mov EAX,SS:ESP
 46543 add EAX,-81
// Print arg #1 (char str)
 46546 push EAX
 46548 mov ECX,2
// Print(...)
 46551 call 40786
 46554 add ESP,2
// Print arg #2 (float col)
 46557 push 900
// Print arg #1 (char str)
 46560 push 18244
 46563 mov ECX,2
// Print(...)
 46566 call 40786
 46569 add ESP,2
 46572 leave 
 46573 ret 
__2089:
__2087:
// init loop
 46574 sstack EBP:-83,2
__2092:
 46579 rstack EAX,EBP:-83
 46583 rstack EBX,EBP:-1
 46587 sub EBX,EAX
 46589 mov EAX,EBX
 46591 fsgn EAX,EAX
// condition
 46593 max EAX,0
 46596 cmp 0,EAX
 46599 jz 46726
 46602 rstack EAX,EBP:-83
 46606 add EAX,#55266
 46609 mov EBX,EAX
 46611 sstack EBP:-85,#EBX
 46615 rstack EAX,EBP:-85
// strlen arg #1 (char* str)
 46619 push EAX
 46621 mov ECX,1
// strlen(...)
 46624 call 10743
 46627 add ESP,1
 46630 sstack EBP:-86,EAX
 46634 rstack EAX,EBP:-82
 46638 push EAX
 46640 rstack EAX,EBP:-86
 46644 push EAX
 46646 rstack EAX,EBP:-85
 46650 push EAX
 46652 mov ECX,3
// fwrite(...)
 46655 call 65070
 46658 add ESP,3
 46661 lneg EAX
// err=!fwrite(str,len,F)
 46663 sstack EBP:-84,EAX
__2094:
 46667 rstack EAX,EBP:-84
// if (err)
 46671 cmp 0,EAX
 46674 jge 46692
// Print arg #2 (float col)
 46677 push 900
// Print arg #1 (char str)
 46680 push 46786
 46683 mov ECX,2
// Print(...)
 46686 call 40786
 46689 add ESP,2
__2095:
__2093:
 46692 rstack EAX,EBP:-82
 46696 push EAX
 46698 push 1
 46701 push 20361
 46704 mov ECX,3
// fwrite(...)
 46707 call 65070
 46710 add ESP,3
 46713 rstack EAX,EBP:-83
// loop step
 46717 inc EAX
 46719 sstack EBP:-83,EAX
 46723 jmp 46579
__2091:
 46726 jmp 46741
__2097:
__2085:
__2099:
// P arg #1 (char* str)
 46729 push 46755
 46732 mov ECX,1
// P(...)
 46735 call 40570
 46738 add ESP,1
__2098:
__2083:
__2081:
 46741 leave 
 46742 ret 
__2090:
 46743 db "Can't open ",0
__2100:
 46755 db "usage: write filename content
",0
__2096:
 46786 db "fwrite error
",0
__2086:
 46800 db "w",0
write_help:
 46802 db ""write <filename> <content>" to write <content> to a file <filename>, creating it if it doesn't exist.
"
 46905 db 0
cmd_read:
// cmd_read()
 46906 enter 87
__2102:
// strlen arg #1 (char* str)
 46909 push #55266
 46912 mov ECX,1
// strlen(...)
 46915 call 10743
 46918 add ESP,1
 46921 sstack EBP:-1,EAX
__2104:
 46925 rstack EAX,EBP:-1
 46929 mov EBX,1
 46932 sub EBX,EAX
 46934 neg EBX
 46936 fsgn EBX,EBX
 46938 max EBX,0
// if (argc>1)
 46941 cmp 0,EBX
 46944 jge 47382
 46947 sstack EBP:-2,0
__2107:
 46952 rstack EAX,EBP:-1
 46956 mov EBX,2
 46959 sub EBX,EAX
 46961 neg EBX
 46963 fsgn EBX,EBX
 46965 max EBX,0
// if (argc>2)
 46968 cmp 0,EBX
 46971 jge 47007
__2111:
// strcmp arg #2 (char* dest)
 46974 push 47399
 46977 mov EAX,2
 46980 add EAX,#55266
// strcmp arg #1 (char* src)
 46983 push #EAX
 46985 mov ECX,2
// strcmp(...)
 46988 call 10414
 46991 add ESP,2
 46994 lneg EAX
// if (!strcmp(Arr[2],"-b"))
 46996 cmp 0,EAX
 46999 jge 47007
// binary=1
 47002 sstack EBP:-2,1
__2112:
__2110:
__2108:
__2106:
 47007 mov EAX,1
 47010 add EAX,#55266
 47013 push #EAX
 47015 mov EAX,SS:ESP
 47018 add EAX,-82
 47021 push EAX
 47023 mov ECX,2
// getFullname(...)
 47026 call 43939
 47029 add ESP,2
 47032 push 40534
 47035 mov EAX,SS:ESP
 47038 add EAX,-82
 47041 push EAX
 47043 mov ECX,2
// fopen(...)
 47046 call 64589
 47049 add ESP,2
 47052 sstack EBP:-83,EAX
__2114:
 47056 rstack EAX,EBP:-83
 47060 lneg EAX
 47062 mov EBX,EAX
// if (!F)
 47064 cmp 0,EBX
 47067 jge 47122
// Print arg #2 (float col)
 47070 push 900
// Print arg #1 (char str)
 47073 push 46743
 47076 mov ECX,2
// Print(...)
 47079 call 40786
 47082 add ESP,2
// Print arg #2 (float col)
 47085 push 900
 47088 mov EAX,SS:ESP
 47091 add EAX,-82
// Print arg #1 (char str)
 47094 push EAX
 47096 mov ECX,2
// Print(...)
 47099 call 40786
 47102 add ESP,2
// Print arg #2 (float col)
 47105 push 900
// Print arg #1 (char str)
 47108 push 18244
 47111 mov ECX,2
// Print(...)
 47114 call 40786
 47117 add ESP,2
 47120 leave 
 47121 ret 
__2115:
__2113:
 47122 sstack EBP:-84,0
 47127 rstack EAX,EBP:-83
 47131 push EAX
 47133 mov ECX,1
// fsize(...)
 47136 call 66007
 47139 add ESP,1
 47142 sstack EBP:-85,EAX
 47146 rstack EAX,EBP:-85
 47150 add EAX,1
 47153 mov EBX,EAX
// malloc arg #1 (float n)
 47155 push EBX
 47157 mov ECX,1
// malloc(...)
 47160 call 20709
 47163 add ESP,1
 47166 sstack EBP:-86,EAX
 47170 rstack EAX,EBP:-83
 47174 push EAX
 47176 rstack EAX,EBP:-85
 47180 push EAX
 47182 rstack EAX,EBP:-86
 47186 push EAX
 47188 mov ECX,3
// fread(...)
 47191 call 65295
 47194 add ESP,3
 47197 lneg EAX
// err=!fread(str,size,F)
 47199 sstack EBP:-84,EAX
__2117:
 47203 rstack EAX,EBP:-84
// if (err)
 47207 cmp 0,EAX
 47210 jge 47228
// Print arg #2 (float col)
 47213 push 900
// Print arg #1 (char str)
 47216 push 47402
 47219 mov ECX,2
// Print(...)
 47222 call 40786
 47225 add ESP,2
__2118:
__2116:
__2121:
 47228 rstack EAX,EBP:-2
// if (binary)
 47232 cmp 0,EAX
 47235 jge 47337
 47238 sstack EBP:-87,0
// init loop
 47243 sstack EBP:-87,0
__2124:
 47248 rstack EAX,EBP:-87
 47252 rstack EBX,EBP:-85
 47256 sub EBX,EAX
 47258 mov EAX,EBX
 47260 fsgn EAX,EAX
// condition
 47262 max EAX,0
 47265 cmp 0,EAX
 47268 jz 47334
// P2 arg #3 (char* str2)
 47271 push 47396
 47274 rstack EAX,EBP:-87
// P2 arg #2 (float N)
 47278 push EAX
// P2 arg #1 (char* str1)
 47280 push 26784
 47283 mov ECX,3
// P2(...)
 47286 call 40700
 47289 add ESP,3
// P2 arg #3 (char* str2)
 47292 push 18244
 47295 rstack EAX,EBP:-87
 47299 rstack EBX,EBP:-86
 47303 add EBX,EAX
 47305 mov EAX,EBX
// P2 arg #2 (float N)
 47307 push #EAX
// P2 arg #1 (char* str1)
 47309 push 26784
 47312 mov ECX,3
// P2(...)
 47315 call 40700
 47318 add ESP,3
 47321 rstack EAX,EBP:-87
// loop step
 47325 inc EAX
 47327 sstack EBP:-87,EAX
 47331 jmp 47248
__2123:
 47334 jmp 47379
__2126:
__2122:
__2128:
 47337 rstack EAX,EBP:-85
 47341 rstack EBX,EBP:-86
 47345 add EBX,EAX
 47347 mov EAX,EBX
// str[size]=0
 47349 mov #EAX,0
 47352 rstack EAX,EBP:-86
// P arg #1 (char* str)
 47356 push EAX
 47358 mov ECX,1
// P(...)
 47361 call 40570
 47364 add ESP,1
// P arg #1 (char* str)
 47367 push 18244
 47370 mov ECX,1
// P(...)
 47373 call 40570
 47376 add ESP,1
__2127:
__2120:
 47379 jmp 47394
__2129:
__2105:
__2131:
// P arg #1 (char* str)
 47382 push 47415
 47385 mov ECX,1
// P(...)
 47388 call 40570
 47391 add ESP,1
__2130:
__2103:
__2101:
 47394 leave 
 47395 ret 
__2125:
 47396 db ": ",0
__2109:
 47399 db "-b",0
__2119:
 47402 db "fread error
",0
__2132:
 47415 db "usage: read filename [-b]
",0
read_help:
 47442 db ""read <filename> [-b]" to read a file and display it as text.
-b: read the file as binary.
"
 47533 db 0
cmd_info:
// cmd_info()
 47534 enter 84
__2134:
// strlen arg #1 (char* str)
 47537 push #55266
 47540 mov ECX,1
// strlen(...)
 47543 call 10743
 47546 add ESP,1
 47549 sstack EBP:-1,EAX
__2136:
 47553 rstack EAX,EBP:-1
 47557 mov EBX,1
 47560 sub EBX,EAX
 47562 neg EBX
 47564 fsgn EBX,EBX
 47566 max EBX,0
// if (argc>1)
 47569 cmp 0,EBX
 47572 jge 47787
 47575 mov EAX,1
 47578 add EAX,#55266
 47581 push #EAX
 47583 mov EAX,SS:ESP
 47586 add EAX,-81
 47589 push EAX
 47591 mov ECX,2
// getFullname(...)
 47594 call 43939
 47597 add ESP,2
 47600 push 40534
 47603 mov EAX,SS:ESP
 47606 add EAX,-81
 47609 push EAX
 47611 mov ECX,2
// fopen(...)
 47614 call 64589
 47617 add ESP,2
 47620 sstack EBP:-82,EAX
__2139:
 47624 rstack EAX,EBP:-82
 47628 lneg EAX
 47630 mov EBX,EAX
// if (!F)
 47632 cmp 0,EBX
 47635 jge 47690
// Print arg #2 (float col)
 47638 push 900
// Print arg #1 (char str)
 47641 push 46743
 47644 mov ECX,2
// Print(...)
 47647 call 40786
 47650 add ESP,2
// Print arg #2 (float col)
 47653 push 900
 47656 mov EAX,SS:ESP
 47659 add EAX,-81
// Print arg #1 (char str)
 47662 push EAX
 47664 mov ECX,2
// Print(...)
 47667 call 40786
 47670 add ESP,2
// Print arg #2 (float col)
 47673 push 900
// Print arg #1 (char str)
 47676 push 18244
 47679 mov ECX,2
// Print(...)
 47682 call 40786
 47685 add ESP,2
 47688 leave 
 47689 ret 
__2140:
__2138:
 47690 sstack EBP:-83,0
 47695 rstack EAX,EBP:-82
 47699 push EAX
 47701 mov ECX,1
// fsize(...)
 47704 call 66007
 47707 add ESP,1
 47710 sstack EBP:-84,EAX
__2142:
 47714 rstack EAX,EBP:-84
 47718 mov EBX,10000
 47721 sub EBX,EAX
 47723 fsgn EBX,EBX
 47725 max EBX,0
// if (size<10000)
 47728 cmp 0,EBX
 47731 jge 47758
// P2 arg #3 (char* str2)
 47734 push 47801
 47737 rstack EAX,EBP:-84
// P2 arg #2 (float N)
 47741 push EAX
// P2 arg #1 (char* str1)
 47743 push 47827
 47746 mov ECX,3
// P2(...)
 47749 call 40700
 47752 add ESP,3
 47755 jmp 47784
__2146:
__2143:
__2148:
// P2 arg #3 (char* str2)
 47758 push 43055
 47761 rstack EAX,EBP:-84
 47765 div EAX,1024
 47768 mov EBX,EAX
// P2 arg #2 (float N)
 47770 push EBX
// P2 arg #1 (char* str1)
 47772 push 47827
 47775 mov ECX,3
// P2(...)
 47778 call 40700
 47781 add ESP,3
__2147:
__2141:
 47784 jmp 47799
__2149:
__2137:
__2151:
// P arg #1 (char* str)
 47787 push 47805
 47790 mov ECX,1
// P(...)
 47793 call 40570
 47796 add ESP,1
__2150:
__2135:
__2133:
 47799 leave 
 47800 ret 
__2145:
 47801 db " B
",0
__2152:
 47805 db "usage: info filename
",0
__2144:
 47827 db "size: ",0
info_help:
 47834 db ""info <filename>" to display file info.
"
 47874 db 0
cmd_mount:
// cmd_mount()
 47875 enter -0
__2154:
// Print arg #2 (float col)
 47878 push 90
// Print arg #1 (char str)
 47881 push 47922
 47884 mov ECX,2
// Print(...)
 47887 call 40786
 47890 add ESP,2
 47893 push #83691
 47896 mov ECX,1
// filesystem_read(...)
 47899 call 67717
 47902 add ESP,1
// Print arg #2 (float col)
 47905 push 90
// Print arg #1 (char str)
 47908 push 47944
 47911 mov ECX,2
// Print(...)
 47914 call 40786
 47917 add ESP,2
__2153:
 47920 leave 
 47921 ret 
__2155:
 47922 db "Reading FS from disk
",0
__2156:
 47944 db "Done
",0
mount_help:
 47950 db "read the filesystem from (dupable HDD) disk to RAM, overwriting the current contents.
"
 48036 db 0
cmd_format:
// cmd_format()
 48037 enter -0
__2158:
// Print arg #2 (float col)
 48040 push 90
// Print arg #1 (char str)
 48043 push 48084
 48046 mov ECX,2
// Print(...)
 48049 call 40786
 48052 add ESP,2
 48055 push #83691
 48058 mov ECX,1
// filesystem_write(...)
 48061 call 67538
 48064 add ESP,1
// Print arg #2 (float col)
 48067 push 90
// Print arg #1 (char str)
 48070 push 47944
 48073 mov ECX,2
// Print(...)
 48076 call 40786
 48079 add ESP,2
__2157:
 48082 leave 
 48083 ret 
__2159:
 48084 db "Writing FS to disk
",0
format_help:
 48104 db "write the filesystem from RAM to (dupable HDD) disk. Remember to save the laptop with Advanced Duplicator, or data will still be lost when the HDD is deleted.
"
 48263 db 0
cmd_gpio:
// cmd_gpio()
 48264 enter 2
__2161:
 48267 sstack EBP:-1,0
// init loop
 48272 sstack EBP:-1,0
__2163:
 48277 rstack EAX,EBP:-1
 48281 mov EBX,8
 48284 sub EBX,EAX
 48286 fsgn EBX,EBX
// condition
 48288 max EBX,0
 48291 cmp 0,EBX
 48294 jz 48371
// P2 arg #3 (char* str2)
 48297 push 47396
 48300 rstack EAX,EBP:-1
// P2 arg #2 (float N)
 48304 push EAX
// P2 arg #1 (char* str1)
 48306 push 48373
 48309 mov ECX,3
// P2(...)
 48312 call 40700
 48315 add ESP,3
 48318 sstack EBP:-2,0
 48323 rstack EAX,EBP:-1
 48327 rstack EBX,EBP:-2
 48331 in EBX,EAX
 48333 sstack EBP:-2,EBX
// P2 arg #3 (char* str2)
 48337 push 18244
 48340 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 48344 push EAX
// P2 arg #1 (char* str1)
 48346 push 26784
 48349 mov ECX,3
// P2(...)
 48352 call 40700
 48355 add ESP,3
 48358 rstack EAX,EBP:-1
// loop step
 48362 inc EAX
 48364 sstack EBP:-1,EAX
 48368 jmp 48277
__2162:
__2160:
 48371 leave 
 48372 ret 
__2164:
 48373 db "GPIO ",0
gpio_help:
 48379 db "report the inputs from the IO bus
"
 48413 db 0
cmd_exec:
// cmd_exec()
 48414 enter 85
__2166:
// strlen arg #1 (char* str)
 48417 push #55266
 48420 mov ECX,1
// strlen(...)
 48423 call 10743
 48426 add ESP,1
 48429 sstack EBP:-1,EAX
__2168:
 48433 rstack EAX,EBP:-1
 48437 mov EBX,1
 48440 sub EBX,EAX
 48442 fabs EBX,EBX
 48444 fsgn EBX,EBX
 48446 lneg EBX
// if (argc==1)
 48448 cmp 0,EBX
 48451 jge 48468
// P arg #1 (char* str)
 48454 push 48819
 48457 mov ECX,1
// P(...)
 48460 call 40570
 48463 add ESP,1
 48466 leave 
 48467 ret 
__2169:
__2167:
 48468 mov EAX,1
 48471 add EAX,#55266
 48474 push #EAX
 48476 mov EAX,SS:ESP
 48479 add EAX,-81
 48482 push EAX
 48484 mov ECX,2
// getFullname(...)
 48487 call 43939
 48490 add ESP,2
 48493 push 40534
 48496 push #68208
 48499 mov ECX,2
// fopen(...)
 48502 call 64589
 48505 add ESP,2
 48508 sstack EBP:-82,EAX
__2172:
 48512 rstack EAX,EBP:-82
 48516 lneg EAX
 48518 mov EBX,EAX
// if (!fp)
 48520 cmp 0,EBX
 48523 jge 48564
// Perr arg #1 (char* str)
 48526 push 48802
 48529 mov ECX,1
// Perr(...)
 48532 call 40763
 48535 add ESP,1
// Perr arg #1 (char* str)
 48538 push #68208
 48541 mov ECX,1
// Perr(...)
 48544 call 40763
 48547 add ESP,1
// Perr arg #1 (char* str)
 48550 push 18244
 48553 mov ECX,1
// Perr(...)
 48556 call 40763
 48559 add ESP,1
 48562 leave 
 48563 ret 
__2173:
__2171:
// malloc arg #1 (float n)
 48564 push 80
 48567 mov ECX,1
// malloc(...)
 48570 call 20709
 48573 add ESP,1
 48576 sstack EBP:-83,EAX
 48580 sstack EBP:-84,0
 48585 sstack EBP:-85,0
 48590 rstack EAX,EBP:-82
 48594 push EAX
 48596 push 1
 48599 mov EAX,SS:ESP
 48602 add EAX,-85
 48605 push EAX
 48607 mov ECX,3
// fread(...)
 48610 call 65295
 48613 add ESP,3
 48616 rstack EAX,EBP:-85
 48620 rstack EBX,EBP:-84
 48624 mov ECX,EBX
 48626 inc EBX
 48628 sstack EBP:-84,EBX
 48632 rstack EBX,EBP:-83
 48636 add EBX,ECX
 48638 mov ECX,EBX
// str2[strI++]=C
 48640 mov #ECX,EAX
__2176:
 48642 rstack EAX,EBP:-85
// if (C
 48646 cmp 0,EAX
 48649 jz 48800
// C=0
 48652 sstack EBP:-85,0
 48657 rstack EAX,EBP:-82
 48661 push EAX
 48663 push 1
 48666 mov EAX,SS:ESP
 48669 add EAX,-85
 48672 push EAX
 48674 mov ECX,3
// fread(...)
 48677 call 65295
 48680 add ESP,3
__2178:
 48683 rstack EAX,EBP:-85
 48687 mov EBX,10
 48690 sub EBX,EAX
 48692 fabs EBX,EBX
 48694 fsgn EBX,EBX
 48696 lneg EBX
 48698 rstack EAX,EBP:-85
 48702 mov ECX,0
 48705 sub ECX,EAX
 48707 fabs ECX,ECX
 48709 fsgn ECX,ECX
 48711 lneg ECX
 48713 or ECX,EBX
// if ((C==0)||(C==10))
 48715 cmp 0,ECX
 48718 jge 48769
 48721 rstack EAX,EBP:-84
 48725 rstack EBX,EBP:-83
 48729 add EBX,EAX
 48731 mov EAX,EBX
// str2[strI]=0
 48733 mov #EAX,0
__2181:
 48736 rstack EAX,EBP:-84
// if (strI)
 48740 cmp 0,EAX
 48743 jge 48766
// strI=0
 48746 sstack EBP:-84,0
 48751 rstack EAX,EBP:-83
// ParseString arg #1 (char str)
 48755 push EAX
 48757 mov ECX,1
// ParseString(...)
 48760 call 39387
 48763 add ESP,1
__2182:
__2180:
 48766 jmp 48797
__2183:
__2179:
__2185:
 48769 rstack EAX,EBP:-85
 48773 rstack EBX,EBP:-84
 48777 rstack ECX,EBP:-83
 48781 add ECX,EBX
 48783 mov EBX,ECX
// str2[strI]=C
 48785 mov #EBX,EAX
 48787 rstack EAX,EBP:-84
// strI++
 48791 inc EAX
 48793 sstack EBP:-84,EAX
__2184:
__2177:
 48797 jmp 48642
__2175:
__2165:
 48800 leave 
 48801 ret 
__2174:
 48802 db "can't open file ",0
__2170:
 48819 db "usage: exec file.sh
",0
exec_help:
 48840 db ""exec <filename>" to execute a shell script as if typed into the console line by line.
"
 48927 db 0
cmd_dump:
// cmd_dump()
 48928 enter 89
__2187:
// strlen arg #1 (char* str)
 48931 push #55266
 48934 mov ECX,1
// strlen(...)
 48937 call 10743
 48940 add ESP,1
 48943 sstack EBP:-1,EAX
__2189:
 48947 rstack EAX,EBP:-1
 48951 mov EBX,1
 48954 sub EBX,EAX
 48956 fabs EBX,EBX
 48958 fsgn EBX,EBX
 48960 lneg EBX
// if (argc==1)
 48962 cmp 0,EBX
 48965 jge 48982
// P arg #1 (char* str)
 48968 push 49391
 48971 mov ECX,1
// P(...)
 48974 call 40570
 48977 add ESP,1
 48980 leave 
 48981 ret 
__2190:
__2188:
 48982 mov EAX,0
 48985 add EAX,#83692
 48988 mov EBX,#EAX
 48990 add EBX,-1
 48993 sstack EBP:-2,EBX
__2193:
 48997 rstack EAX,EBP:-2
 49001 lneg EAX
 49003 mov EBX,EAX
// if (!size)
 49005 cmp 0,EBX
 49008 jge 49025
// Perr arg #1 (char* str)
 49011 push 49372
 49014 mov ECX,1
// Perr(...)
 49017 call 40763
 49020 add ESP,1
 49023 leave 
 49024 ret 
__2194:
__2192:
 49025 mov EAX,1
 49028 add EAX,#55266
 49031 push #EAX
 49033 mov EAX,SS:ESP
 49036 add EAX,-82
 49039 push EAX
 49041 mov ECX,2
// getFullname(...)
 49044 call 43939
 49047 add ESP,2
 49050 push 46800
 49053 mov EAX,SS:ESP
 49056 add EAX,-82
 49059 push EAX
 49061 mov ECX,2
// fopen(...)
 49064 call 64589
 49067 add ESP,2
 49070 sstack EBP:-83,EAX
__2197:
 49074 rstack EAX,EBP:-83
 49078 lneg EAX
 49080 mov EBX,EAX
// if (!fp)
 49082 cmp 0,EBX
 49085 jge 49102
// Perr arg #1 (char* str)
 49088 push 49420
 49091 mov ECX,1
// Perr(...)
 49094 call 40763
 49097 add ESP,1
 49100 leave 
 49101 ret 
__2198:
__2196:
// P2 arg #3 (char* str2)
 49102 push 47801
 49105 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 49109 push EAX
// P2 arg #1 (char* str1)
 49111 push 49358
 49114 mov ECX,3
// P2(...)
 49117 call 40700
 49120 add ESP,3
 49123 rstack EAX,EBP:-83
 49127 push EAX
 49129 rstack EAX,EBP:-2
 49133 push EAX
 49135 mov ECX,2
// fresize(...)
 49138 call 65226
 49141 add ESP,2
 49144 mov EAX,#83692
 49147 add EAX,1
 49150 sstack EBP:-84,EAX
 49154 rstack EAX,EBP:-2
 49158 sstack EBP:-85,EAX
 49162 sstack EBP:-86,0
 49167 sstack EBP:-87,500
__2202:
 49172 rstack EAX,EBP:-85
// if (sizeleft
 49176 cmp 0,EAX
 49179 jz 49344
__2204:
 49182 rstack EAX,EBP:-85
 49186 rstack EBX,EBP:-87
 49190 sub EBX,EAX
 49192 mov EAX,EBX
 49194 neg EAX
 49196 fsgn EAX,EAX
 49198 max EAX,0
// if (sizeleft>step)
 49201 cmp 0,EAX
 49204 jge 49218
 49207 rstack EAX,EBP:-87
// dsize=step
 49211 sstack EBP:-88,EAX
 49215 jmp 49226
__2206:
__2205:
__2208:
 49218 rstack EAX,EBP:-85
// dsize=sizeleft
 49222 sstack EBP:-88,EAX
__2207:
__2203:
 49226 rstack EAX,EBP:-88
 49230 neg EAX
 49232 mov EBX,EAX
 49234 rstack EAX,EBP:-85
 49238 add EAX,EBX
 49240 mov EBX,EAX
// sizeleft=sizeleft-dsize
 49242 sstack EBP:-85,EBX
 49246 rstack EAX,EBP:-88
 49250 rstack EBX,EBP:-86
 49254 add EBX,EAX
 49256 mov EAX,EBX
// sizedone=sizedone+dsize
 49258 sstack EBP:-86,EAX
 49262 rstack EAX,EBP:-2
 49266 mov EBX,100
 49269 div EBX,EAX
 49271 rstack EAX,EBP:-86
 49275 mul EAX,EBX
 49277 mov EBX,EAX
 49279 sstack EBP:-89,EBX
 49283 rstack EAX,EBP:-83
 49287 push EAX
 49289 rstack EAX,EBP:-88
 49293 push EAX
 49295 rstack EAX,EBP:-84
 49299 push EAX
 49301 mov ECX,3
// fwrite(...)
 49304 call 65070
 49307 add ESP,3
 49310 rstack EAX,EBP:-88
 49314 rstack EBX,EBP:-84
 49318 add EBX,EAX
 49320 mov EAX,EBX
// ptrFrom=ptrFrom+dsize
 49322 sstack EBP:-84,EAX
 49326 rstack EAX,EBP:-89
// PrintProgressBar arg #1 (float percent)
 49330 push EAX
 49332 mov ECX,1
// PrintProgressBar(...)
 49335 call 41261
 49338 add ESP,1
 49341 jmp 49172
__2201:
// P arg #1 (char* str)
 49344 push 49413
 49347 mov ECX,1
// P(...)
 49350 call 40570
 49353 add ESP,1
__2186:
 49356 leave 
 49357 ret 
__2200:
 49358 db "floppy size: ",0
__2195:
 49372 db "can't read floppy
",0
__2191:
 49391 db "usage: dump filename
",0
__2209:
 49413 db "
done
",0
__2199:
 49420 db "can't open file
",0
dump_help:
 49437 db ""dump <filename>" to dump the contents of a non-executable floppy to a file. First cell must be file size. It is removed when copying.
"
 49572 db 0
progtest:
// progtest()
 49573 enter -0
__2211:
// P arg #1 (char* str)
 49576 push 49590
 49579 mov ECX,1
// P(...)
 49582 call 40570
 49585 add ESP,1
__2210:
 49588 leave 
 49589 ret 
__2212:
 49590 db "Progtest called
",0
cmd_run:
// cmd_run()
 49607 enter 82
__2214:
// strlen arg #1 (char* str)
 49610 push #55266
 49613 mov ECX,1
// strlen(...)
 49616 call 10743
 49619 add ESP,1
 49622 sstack EBP:-1,EAX
__2216:
 49626 rstack EAX,EBP:-1
 49630 mov EBX,1
 49633 sub EBX,EAX
 49635 neg EBX
 49637 fsgn EBX,EBX
 49639 max EBX,0
// if (argc>1)
 49642 cmp 0,EBX
 49645 jge 49747
 49648 mov EAX,1
 49651 add EAX,#55266
 49654 push #EAX
 49656 mov EAX,SS:ESP
 49659 add EAX,-81
 49662 push EAX
 49664 mov ECX,2
// getFullname(...)
 49667 call 43939
 49670 add ESP,2
 49673 mov EAX,SS:ESP
 49676 add EAX,-81
 49679 push EAX
 49681 mov ECX,1
// program_load(...)
 49684 call 79923
 49687 add ESP,1
 49690 sstack EBP:-82,EAX
__2219:
 49694 rstack EAX,EBP:-82
// if (ptr)
 49698 cmp 0,EAX
 49701 jge 49744
 49704 mov EAX,#55266
 49707 add EAX,1
 49710 push EAX
 49712 rstack EAX,EBP:-1
 49716 add EAX,-1
 49719 mov EBX,EAX
 49721 push EBX
 49723 rstack EAX,EBP:-82
 49727 push EAX
 49729 mov ECX,3
// program_run(...)
 49732 call 80461
 49735 add ESP,3
 49738 mov ECX,0
// redraw_all(...)
 49741 call 41250
__2220:
__2218:
 49744 jmp 49759
__2221:
__2217:
__2223:
// P arg #1 (char* str)
 49747 push 49761
 49750 mov ECX,1
// P(...)
 49753 call 40570
 49756 add ESP,1
__2222:
__2215:
__2213:
 49759 leave 
 49760 ret 
__2224:
 49761 db "usage: run filename
",0
run_help:
 49782 db ""run <filename>" to run a program compiled to a floppy. Linker and paging will be used.
"
 49870 db 0
package_args:
// package_args(pad,argc,argv)
 49871 enter 4
__2226:
 49874 sstack EBP:-1,0
// init loop
 49879 sstack EBP:-2,0
__2228:
 49884 rstack EAX,EBP:-2
 49888 rstack EBX,EBP:3
 49892 sub EBX,EAX
 49894 mov EAX,EBX
 49896 fsgn EAX,EAX
// condition
 49898 max EAX,0
 49901 cmp 0,EAX
 49904 jz 49955
 49907 rstack EAX,EBP:-2
 49911 rstack EBX,EBP:4
 49915 add EBX,EAX
 49917 mov EAX,EBX
// strlen arg #1 (char* str)
 49919 push #EAX
 49921 mov ECX,1
// strlen(...)
 49924 call 10743
 49927 add ESP,1
 49930 rstack EBX,EBP:-1
 49934 add EBX,EAX
 49936 mov EAX,EBX
// L=L+strlen(argv[I])
 49938 sstack EBP:-1,EAX
 49942 rstack EAX,EBP:-2
// loop step
 49946 inc EAX
 49948 sstack EBP:-2,EAX
 49952 jmp 49884
__2227:
 49955 rstack EAX,EBP:3
 49959 mul EAX,2
 49962 mov EBX,EAX
 49964 add EBX,1
 49967 rstack EAX,EBP:2
 49971 add EAX,EBX
 49973 mov EBX,EAX
// malloc arg #1 (float n)
 49975 push EBX
 49977 mov ECX,1
// malloc(...)
 49980 call 20709
 49983 add ESP,1
 49986 sstack EBP:-3,EAX
 49990 rstack EAX,EBP:3
 49994 add EAX,1
 49997 mov EBX,EAX
 49999 rstack EAX,EBP:2
 50003 add EAX,EBX
 50005 mov EBX,EAX
 50007 sstack EBP:-4,EBX
// init loop
 50011 sstack EBP:-2,0
__2230:
 50016 rstack EAX,EBP:-2
 50020 rstack EBX,EBP:3
 50024 sub EBX,EAX
 50026 mov EAX,EBX
 50028 fsgn EAX,EAX
// condition
 50030 max EAX,0
 50033 cmp 0,EAX
 50036 jz 50142
 50039 rstack EAX,EBP:-4
 50043 rstack EBX,EBP:-2
 50047 rstack ECX,EBP:2
 50051 add ECX,EBX
 50053 mov EBX,ECX
 50055 rstack ECX,EBP:-3
 50059 add ECX,EBX
 50061 mov EBX,ECX
// args[pad+I]=argsI
 50063 mov #EBX,EAX
 50065 rstack EAX,EBP:-2
 50069 rstack EBX,EBP:4
 50073 add EBX,EAX
 50075 mov EAX,EBX
// strcpy arg #2 (char* src)
 50077 push #EAX
 50079 rstack EAX,EBP:-4
// strcpy arg #1 (char* dest)
 50083 push EAX
 50085 mov ECX,2
// strcpy(...)
 50088 call 10585
 50091 add ESP,2
 50094 rstack EAX,EBP:-2
 50098 rstack EBX,EBP:4
 50102 add EBX,EAX
 50104 mov EAX,EBX
// strlen arg #1 (char* str)
 50106 push #EAX
 50108 mov ECX,1
// strlen(...)
 50111 call 10743
 50114 add ESP,1
 50117 rstack EBX,EBP:-4
 50121 add EBX,EAX
 50123 mov EAX,EBX
// argsI=argsI+strlen(argv[I])
 50125 sstack EBP:-4,EAX
 50129 rstack EAX,EBP:-2
// loop step
 50133 inc EAX
 50135 sstack EBP:-2,EAX
 50139 jmp 50016
__2229:
 50142 rstack EAX,EBP:3
 50146 rstack EBX,EBP:-3
 50150 add EBX,EAX
 50152 mov EAX,EBX
// args[argc]=0
 50154 mov #EAX,0
 50157 rstack EAX,EBP:-3
 50161 leave 
 50162 ret 
__2225:
 50163 leave 
 50164 ret 
cmd_runbg:
// cmd_runbg()
 50165 enter 84
__2232:
// strlen arg #1 (char* str)
 50168 push #55266
 50171 mov ECX,1
// strlen(...)
 50174 call 10743
 50177 add ESP,1
 50180 sstack EBP:-1,EAX
__2234:
 50184 rstack EAX,EBP:-1
 50188 mov EBX,1
 50191 sub EBX,EAX
 50193 neg EBX
 50195 fsgn EBX,EBX
 50197 max EBX,0
// if (argc>1)
 50200 cmp 0,EBX
 50203 jge 50352
 50206 mov EAX,1
 50209 add EAX,#55266
 50212 push #EAX
 50214 mov EAX,SS:ESP
 50217 add EAX,-81
 50220 push EAX
 50222 mov ECX,2
// getFullname(...)
 50225 call 43939
 50228 add ESP,2
 50231 mov EAX,SS:ESP
 50234 add EAX,-81
 50237 push EAX
 50239 mov ECX,1
// program_load(...)
 50242 call 79923
 50245 add ESP,1
 50248 sstack EBP:-82,EAX
__2237:
 50252 rstack EAX,EBP:-82
// if (ptr)
 50256 cmp 0,EAX
 50259 jge 50349
 50262 mov EAX,#55266
 50265 add EAX,1
// package_args arg #3 (float argv)
 50268 push EAX
 50270 rstack EAX,EBP:-1
 50274 add EAX,-1
 50277 mov EBX,EAX
// package_args arg #2 (float argc)
 50279 push EBX
// package_args arg #1 (float pad)
 50281 push 1
 50284 mov ECX,3
// package_args(...)
 50287 call 49871
 50290 add ESP,3
 50293 sstack EBP:-83,EAX
 50297 rstack EAX,EBP:-82
 50301 rstack EBX,EBP:-83
 50305 add EBX,0
 50308 mov ECX,EBX
// args[0]=ptr
 50310 mov #ECX,EAX
 50312 rstack EAX,EBP:-83
 50316 push EAX
 50318 push 80384
 50321 mov ECX,2
// thread_create(...)
 50324 call 78790
 50327 add ESP,2
 50330 sstack EBP:-84,EAX
 50334 rstack EAX,EBP:-84
 50338 push EAX
 50340 mov ECX,1
// thread_run(...)
 50343 call 77630
 50346 add ESP,1
__2238:
__2236:
 50349 jmp 50364
__2239:
__2235:
__2241:
// P arg #1 (char* str)
 50352 push 50366
 50355 mov ECX,1
// P(...)
 50358 call 40570
 50361 add ESP,1
__2240:
__2233:
__2231:
 50364 leave 
 50365 ret 
__2242:
 50366 db "usage: runbg filename
",0
runbg_help:
 50389 db ""runbg <filename>" to run a program as a separate process and return control immediately"
 50477 db 0
cmd_asm:
// cmd_asm()
 50478 enter 1
__2244:
// strlen arg #1 (char* str)
 50481 push #55266
 50484 mov ECX,1
// strlen(...)
 50487 call 10743
 50490 add ESP,1
 50493 sstack EBP:-1,EAX
__2246:
 50497 rstack EAX,EBP:-1
 50501 mov EBX,3
 50504 sub EBX,EAX
 50506 fabs EBX,EBX
 50508 fsgn EBX,EBX
// if (argc!=3)
 50510 cmp 0,EBX
 50513 jge 50530
// P arg #1 (char* str)
 50516 push 50622
 50519 mov ECX,1
// P(...)
 50522 call 40570
 50525 add ESP,1
 50528 leave 
 50529 ret 
__2247:
__2245:
// Print arg #2 (float col)
 50530 push 90
// Print arg #1 (char str)
 50533 push 50648
 50536 mov ECX,2
// Print(...)
 50539 call 40786
 50542 add ESP,2
// Print arg #2 (float col)
 50545 push 90
 50548 mov EAX,1
 50551 add EAX,#55266
// Print arg #1 (char str)
 50554 push #EAX
 50556 mov ECX,2
// Print(...)
 50559 call 40786
 50562 add ESP,2
// Print arg #2 (float col)
 50565 push 90
// Print arg #1 (char str)
 50568 push 18244
 50571 mov ECX,2
// Print(...)
 50574 call 40786
 50577 add ESP,2
 50580 mov EAX,2
 50583 add EAX,#55266
 50586 push #EAX
 50588 mov EAX,1
 50591 add EAX,#55266
 50594 push #EAX
 50596 mov ECX,2
// assembler(...)
 50599 call 68212
 50602 add ESP,2
// Print arg #2 (float col)
 50605 push 90
// Print arg #1 (char str)
 50608 push 47944
 50611 mov ECX,2
// Print(...)
 50614 call 40786
 50617 add ESP,2
__2243:
 50620 leave 
 50621 ret 
__2248:
 50622 db "Usage: asm in.asm out.exe",0
__2249:
 50648 db "Assembling ",0
asm_help:
 50660 db ""asm <input file> <output file>" to compile assembly from input into machine code at output.
"
 50753 db 0
cmd_crc:
// cmd_crc()
 50754 enter 10
__2251:
// strlen arg #1 (char* str)
 50757 push #55266
 50760 mov ECX,1
// strlen(...)
 50763 call 10743
 50766 add ESP,1
 50769 sstack EBP:-1,EAX
__2253:
 50773 rstack EAX,EBP:-1
 50777 mov EBX,1
 50780 sub EBX,EAX
 50782 neg EBX
 50784 fsgn EBX,EBX
 50786 max EBX,0
// if (argc>1)
 50789 cmp 0,EBX
 50792 jge 51810
__2257:
// strcmp arg #2 (char* dest)
 50795 push 52117
 50798 mov EAX,1
 50801 add EAX,#55266
// strcmp arg #1 (char* src)
 50804 push #EAX
 50806 mov ECX,2
// strcmp(...)
 50809 call 10414
 50812 add ESP,2
 50815 mov EBX,0
 50818 sub EBX,EAX
 50820 fabs EBX,EBX
 50822 fsgn EBX,EBX
 50824 lneg EBX
// if (strcmp(Arr[1],"all")==0)
 50826 cmp 0,EBX
 50829 jge 51222
// P arg #1 (char* str)
 50832 push 52019
 50835 mov ECX,1
// P(...)
 50838 call 40570
 50841 add ESP,1
 50844 mov EAX,83693
 50847 div EAX,100
// ceil arg #1 (float A)
 50850 push EAX
 50852 mov ECX,1
// ceil(...)
 50855 call 16728
 50858 add ESP,1
 50861 sstack EBP:-2,EAX
 50865 sstack EBP:-3,0
 50870 sstack EBP:-4,0
 50875 rstack EAX,EBP:-2
 50879 sstack EBP:-5,EAX
 50883 sstack EBP:-6,0
__2261:
 50888 rstack EAX,EBP:-3
 50892 lneg EAX
 50894 mov EBX,EAX
// if (!done
 50896 cmp 0,EBX
 50899 jz 51126
 50902 rstack EAX,EBP:-4
 50906 div EAX,83693
 50909 mov EBX,EAX
 50911 mov EAX,100
 50914 mul EAX,EBX
// round arg #1 (float A)
 50916 push EAX
 50918 mov ECX,1
// round(...)
 50921 call 16758
 50924 add ESP,1
 50927 sstack EBP:-7,EAX
// P2 arg #3 (char* str2)
 50931 push 22470
 50934 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 50938 push EAX
// P2 arg #1 (char* str1)
 50940 push 51982
 50943 mov ECX,3
// P2(...)
 50946 call 40700
 50949 add ESP,3
// P2 arg #3 (char* str2)
 50952 push 51929
 50955 rstack EAX,EBP:-5
 50959 rstack EBX,EBP:-4
 50963 add EBX,EAX
 50965 mov EAX,EBX
// P2 arg #2 (float N)
 50967 push EAX
// P2 arg #1 (char* str1)
 50969 push 26784
 50972 mov ECX,3
// P2(...)
 50975 call 40700
 50978 add ESP,3
// P2 arg #3 (char* str2)
 50981 push 52163
 50984 rstack EAX,EBP:-7
// P2 arg #2 (float N)
 50988 push EAX
// P2 arg #1 (char* str1)
 50990 push 26784
 50993 mov ECX,3
// P2(...)
 50996 call 40700
 50999 add ESP,3
 51002 rstack EAX,EBP:-5
 51006 push EAX
 51008 rstack EAX,EBP:-4
 51012 push EAX
 51014 rstack EAX,EBP:-6
 51018 push EAX
 51020 mov ECX,3
// calc_crc(...)
 51023 call 61809
 51026 add ESP,3
// result=calc_crc(result,start1,count)
 51029 sstack EBP:-6,EAX
 51033 rstack EAX,EBP:-5
 51037 rstack EBX,EBP:-4
 51041 add EBX,EAX
 51043 mov EAX,EBX
// start1=start1+count
 51045 sstack EBP:-4,EAX
__2266:
 51049 rstack EAX,EBP:-4
 51053 mov EBX,83693
 51056 sub EBX,EAX
 51058 fsgn EBX,EBX
 51060 max EBX,0
 51063 lneg EBX
// if (!(start1<END))
 51065 cmp 0,EBX
 51068 jge 51076
// done=1
 51071 sstack EBP:-3,1
__2267:
__2265:
__2269:
 51076 rstack EAX,EBP:-5
 51080 rstack EBX,EBP:-4
 51084 add EBX,EAX
 51086 mov EAX,EBX
 51088 mov EBX,83693
 51091 sub EBX,EAX
 51093 neg EBX
 51095 fsgn EBX,EBX
 51097 max EBX,0
// if ((start1+count)>END)
 51100 cmp 0,EBX
 51103 jge 51123
 51106 rstack EAX,EBP:-4
 51110 neg EAX
 51112 mov EBX,EAX
 51114 mov EAX,83693
 51117 add EAX,EBX
// count=END-start1
 51119 sstack EBP:-5,EAX
__2270:
__2268:
 51123 jmp 50888
__2260:
// P arg #1 (char* str)
 51126 push 47944
 51129 mov ECX,1
// P(...)
 51132 call 40570
 51135 add ESP,1
__2272:
 51138 mov EAX,0
 51141 sub EAX,#55261
 51144 fabs EAX,EAX
 51146 fsgn EAX,EAX
// if (crc_previous!=0)
 51148 cmp 0,EAX
 51151 jge 51203
__2275:
 51154 rstack EAX,EBP:-6
 51158 sub EAX,#55261
 51161 mov EBX,EAX
 51163 fabs EBX,EBX
 51165 fsgn EBX,EBX
// if (crc_previous!=result)
 51167 cmp 0,EBX
 51170 jge 51188
// P arg #1 (char* str)
 51173 push 51888
 51176 mov ECX,1
// P(...)
 51179 call 40570
 51182 add ESP,1
 51185 jmp 51200
__2278:
__2276:
__2280:
// P arg #1 (char* str)
 51188 push 51884
 51191 mov ECX,1
// P(...)
 51194 call 40570
 51197 add ESP,1
__2279:
__2274:
 51200 jmp 51215
__2282:
__2273:
__2284:
// P arg #1 (char* str)
 51203 push 52121
 51206 mov ECX,1
// P(...)
 51209 call 40570
 51212 add ESP,1
__2283:
__2271:
 51215 rstack EAX,EBP:-6
// crc_previous=result
 51219 mov #55261,EAX
__2258:
__2256:
__2288:
// strcmp arg #2 (char* dest)
 51222 push 52014
 51225 mov EAX,1
 51228 add EAX,#55266
// strcmp arg #1 (char* src)
 51231 push #EAX
 51233 mov ECX,2
// strcmp(...)
 51236 call 10414
 51239 add ESP,2
 51242 mov EBX,0
 51245 sub EBX,EAX
 51247 fabs EBX,EBX
 51249 fsgn EBX,EBX
 51251 lneg EBX
// if (strcmp(Arr[1],"code")==0)
 51253 cmp 0,EBX
 51256 jge 51585
// P arg #1 (char* str)
 51259 push 51898
 51262 mov ECX,1
// P(...)
 51265 call 40570
 51268 add ESP,1
 51271 sstack EBP:-8,0
 51276 mov EAX,55210
 51279 neg EAX
 51281 mov EBX,55258
 51284 add EBX,EAX
 51286 div EBX,4
 51289 sstack EBP:-9,EBX
// init loop
 51293 sstack EBP:-8,0
__2292:
 51298 rstack EAX,EBP:-8
 51302 rstack EBX,EBP:-9
 51306 sub EBX,EAX
 51308 mov EAX,EBX
 51310 fsgn EAX,EAX
// condition
 51312 max EAX,0
 51315 cmp 0,EAX
 51318 jz 51573
 51321 rstack EAX,EBP:-8
 51325 mul EAX,4
 51328 mov EBX,EAX
 51330 add EBX,55210
// start1=CRC_areas[I*4]
 51333 sstack EBP:-4,#EBX
 51337 rstack EAX,EBP:-4
 51341 neg EAX
 51343 mov EBX,EAX
 51345 rstack EAX,EBP:-8
 51349 mul EAX,4
 51352 mov ECX,EAX
 51354 add ECX,1
 51357 add ECX,55210
 51360 mov EAX,#ECX
 51362 add EAX,EBX
// count=CRC_areas[I*4+1]-start1
 51364 sstack EBP:-5,EAX
// P2 arg #3 (char* str2)
 51368 push 47396
 51371 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 51375 push EAX
// P2 arg #1 (char* str1)
 51377 push 52201
 51380 mov ECX,3
// P2(...)
 51383 call 40700
 51386 add ESP,3
// P2 arg #3 (char* str2)
 51389 push 22470
 51392 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 51396 push EAX
// P2 arg #1 (char* str1)
 51398 push 26784
 51401 mov ECX,3
// P2(...)
 51404 call 40700
 51407 add ESP,3
// P2 arg #3 (char* str2)
 51410 push 18244
 51413 rstack EAX,EBP:-5
 51417 rstack EBX,EBP:-4
 51421 add EBX,EAX
 51423 mov EAX,EBX
// P2 arg #2 (float N)
 51425 push EAX
// P2 arg #1 (char* str1)
 51427 push 26784
 51430 mov ECX,3
// P2(...)
 51433 call 40700
 51436 add ESP,3
 51439 rstack EAX,EBP:-5
 51443 push EAX
 51445 rstack EAX,EBP:-4
 51449 push EAX
 51451 push 0
 51454 mov ECX,3
// calc_crc(...)
 51457 call 61809
 51460 add ESP,3
// result=calc_crc(0,start1,count)
 51463 sstack EBP:-6,EAX
 51467 rstack EAX,EBP:-8
 51471 mul EAX,4
 51474 mov EBX,EAX
 51476 add EBX,2
 51479 add EBX,55210
 51482 sstack EBP:-10,#EBX
__2295:
 51486 rstack EAX,EBP:-10
// if (prev)
 51490 cmp 0,EAX
 51493 jge 51539
__2298:
 51496 rstack EAX,EBP:-10
 51500 rstack EBX,EBP:-6
 51504 sub EBX,EAX
 51506 mov EAX,EBX
 51508 fabs EAX,EAX
 51510 fsgn EAX,EAX
// if (prev!=result)
 51512 cmp 0,EAX
 51515 jge 51539
// P2 arg #3 (char* str2)
 51518 push 52102
 51521 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 51525 push EAX
// P2 arg #1 (char* str1)
 51527 push 52195
 51530 mov ECX,3
// P2(...)
 51533 call 40700
 51536 add ESP,3
__2299:
__2297:
__2296:
__2294:
 51539 rstack EAX,EBP:-6
 51543 rstack EBX,EBP:-8
 51547 mul EBX,4
 51550 mov ECX,EBX
 51552 add ECX,2
 51555 add ECX,55210
// CRC_areas[I*4+2]=result
 51558 mov #ECX,EAX
 51560 rstack EAX,EBP:-8
// loop step
 51564 inc EAX
 51566 sstack EBP:-8,EAX
 51570 jmp 51298
__2291:
// P arg #1 (char* str)
 51573 push 47944
 51576 mov ECX,1
// P(...)
 51579 call 40570
 51582 add ESP,1
__2289:
__2287:
__2304:
// strcmp arg #2 (char* dest)
 51585 push 51932
 51588 mov EAX,1
 51591 add EAX,#55266
// strcmp arg #1 (char* src)
 51594 push #EAX
 51596 mov ECX,2
// strcmp(...)
 51599 call 10414
 51602 add ESP,2
 51605 mov EBX,0
 51608 sub EBX,EAX
 51610 fabs EBX,EBX
 51612 fsgn EBX,EBX
 51614 lneg EBX
// if (strcmp(Arr[1],"first")==0)
 51616 cmp 0,EBX
 51619 jge 51740
// P arg #1 (char* str)
 51622 push 52050
 51625 mov ECX,1
// P(...)
 51628 call 40570
 51631 add ESP,1
 51634 push 100
 51637 push 0
 51640 push 0
 51643 mov ECX,3
// calc_crc(...)
 51646 call 61809
 51649 add ESP,3
// result=calc_crc(0,0,100)
 51652 sstack EBP:-6,EAX
__2308:
 51656 mov EAX,0
 51659 sub EAX,#55260
 51662 fabs EAX,EAX
 51664 fsgn EAX,EAX
// if (crc_prev_first!=0)
 51666 cmp 0,EAX
 51669 jge 51721
__2311:
 51672 rstack EAX,EBP:-6
 51676 mov EBX,#55260
 51679 sub EBX,EAX
 51681 fabs EBX,EBX
 51683 fsgn EBX,EBX
// if (result!=crc_prev_first)
 51685 cmp 0,EBX
 51688 jge 51706
// P arg #1 (char* str)
 51691 push 51888
 51694 mov ECX,1
// P(...)
 51697 call 40570
 51700 add ESP,1
 51703 jmp 51718
__2313:
__2312:
__2315:
// P arg #1 (char* str)
 51706 push 52191
 51709 mov ECX,1
// P(...)
 51712 call 40570
 51715 add ESP,1
__2314:
__2310:
 51718 jmp 51733
__2317:
__2309:
__2319:
// P arg #1 (char* str)
 51721 push 52121
 51724 mov ECX,1
// P(...)
 51727 call 40570
 51730 add ESP,1
__2318:
__2307:
 51733 rstack EAX,EBP:-6
// crc_prev_first=result
 51737 mov #55260,EAX
__2305:
__2303:
__2322:
// strcmp arg #2 (char* dest)
 51740 push 51957
 51743 mov EAX,1
 51746 add EAX,#55266
// strcmp arg #1 (char* src)
 51749 push #EAX
 51751 mov ECX,2
// strcmp(...)
 51754 call 10414
 51757 add ESP,2
 51760 mov EBX,0
 51763 sub EBX,EAX
 51765 fabs EBX,EBX
 51767 fsgn EBX,EBX
 51769 lneg EBX
// if (strcmp(Arr[1],"precompute")==0)
 51771 cmp 0,EBX
 51774 jge 51807
// P arg #1 (char* str)
 51777 push 51988
 51780 mov ECX,1
// P(...)
 51783 call 40570
 51786 add ESP,1
 51789 mov ECX,0
// precompute_crc(...)
 51792 call 62359
// P arg #1 (char* str)
 51795 push 47944
 51798 mov ECX,1
// P(...)
 51801 call 40570
 51804 add ESP,1
__2323:
__2321:
 51807 jmp 51882
__2325:
__2254:
__2327:
// P arg #1 (char* str)
 51810 push 52166
 51813 mov ECX,1
// P(...)
 51816 call 40570
 51819 add ESP,1
// P arg #1 (char* str)
 51822 push 52144
 51825 mov ECX,1
// P(...)
 51828 call 40570
 51831 add ESP,1
// P arg #1 (char* str)
 51834 push 52131
 51837 mov ECX,1
// P(...)
 51840 call 40570
 51843 add ESP,1
// P arg #1 (char* str)
 51846 push 52090
 51849 mov ECX,1
// P(...)
 51852 call 40570
 51855 add ESP,1
// P arg #1 (char* str)
 51858 push 51968
 51861 mov ECX,1
// P(...)
 51864 call 40570
 51867 add ESP,1
// P arg #1 (char* str)
 51870 push 51938
 51873 mov ECX,1
// P(...)
 51876 call 40570
 51879 add ESP,1
__2326:
__2252:
__2250:
 51882 leave 
 51883 ret 
__2281:
 51884 db "Ok
",0
__2277:
 51888 db "Mismatch
",0
__2290:
 51898 db "Calculating CRC of code areas
",0
__2263:
 51929 db ", ",0
__2302:
 51932 db "first",0
__2333:
 51938 db "       precompute
",0
__2320:
 51957 db "precompute",0
__2332:
 51968 db "       first
",0
__2262:
 51982 db "CRC: ",0
__2324:
 51988 db "Pre-computing CRC values
",0
__2286:
 52014 db "code",0
__2259:
 52019 db "Calculating CRC from 0 to END
",0
__2306:
 52050 db "Calculating CRC of the first 100 bytes
",0
__2331:
 52090 db "       all
",0
__2301:
 52102 db " CRC mismatch
",0
__2255:
 52117 db "all",0
__2285:
 52121 db "Computed
",0
__2330:
 52131 db "modes: code
",0
__2329:
 52144 db "usage: crc <mode>
",0
__2264:
 52163 db "%
",0
__2328:
 52166 db "Cyclic Redundancy Check
",0
__2316:
 52191 db "OK
",0
__2300:
 52195 db "Area ",0
__2293:
 52201 db "CRC ",0
crc_help:
 52206 db "Cyclic Redundancy Check
"
 52230 db "Performs a CRC check of the OS code to verify integrity. Very slow. CRC must first be precomputed. the CRC_AREAS table will be used.
"
 52363 db "usage: crc <mode>
"
 52381 db "modes: 
"
 52389 db " code - only code areas
"
 52413 db " all - everything, even data
"
 52442 db " first - first 100 bytes
"
 52467 db " precompute
"
 52479 db 0
cmd_memview:
// cmd_memview()
 52480 enter 18
__2335:
// strlen arg #1 (char* str)
 52483 push #55266
 52486 mov ECX,1
// strlen(...)
 52489 call 10743
 52492 add ESP,1
 52495 sstack EBP:-1,EAX
__2337:
 52499 rstack EAX,EBP:-1
 52503 mov EBX,3
 52506 sub EBX,EAX
 52508 fabs EBX,EBX
 52510 fsgn EBX,EBX
 52512 lneg EBX
// if (argc==3)
 52514 cmp 0,EBX
 52517 jge 52792
 52520 mov EAX,1
 52523 add EAX,#55266
// str2num arg #1 (char* str)
 52526 push #EAX
 52528 mov ECX,1
// str2num(...)
 52531 call 11422
 52534 add ESP,1
 52537 sstack EBP:-2,EAX
 52541 mov EAX,2
 52544 add EAX,#55266
// str2num arg #1 (char* str)
 52547 push #EAX
 52549 mov ECX,1
// str2num(...)
 52552 call 11422
 52555 add ESP,1
 52558 sstack EBP:-3,EAX
 52562 rstack EAX,EBP:-3
 52566 rstack EBX,EBP:-2
 52570 add EBX,EAX
 52572 mov EAX,EBX
 52574 sstack EBP:-4,EAX
// P2 arg #3 (char* str2)
 52578 push 52840
 52581 rstack EAX,EBP:-3
// P2 arg #2 (float N)
 52585 push EAX
// P2 arg #1 (char* str1)
 52587 push 52848
 52590 mov ECX,3
// P2(...)
 52593 call 40700
 52596 add ESP,3
// str[1]=0
 52599 sstack EBP:-6,0
// str2[10]=0
 52604 sstack EBP:-8,0
 52609 rstack EAX,EBP:-2
// init loop
 52613 sstack EBP:-5,EAX
__2342:
 52617 rstack EAX,EBP:-5
 52621 rstack EBX,EBP:-4
 52625 sub EBX,EAX
 52627 mov EAX,EBX
 52629 fsgn EAX,EAX
 52631 inc EAX
// condition
 52633 max EAX,0
 52636 cmp 0,EAX
 52639 jz 52789
// P2 arg #3 (char* str2)
 52642 push 47396
 52645 rstack EAX,EBP:-5
// P2 arg #2 (float N)
 52649 push EAX
// P2 arg #1 (char* str1)
 52651 push 26784
 52654 mov ECX,3
// P2(...)
 52657 call 40700
 52660 add ESP,3
// P2 arg #3 (char* str2)
 52663 push 20361
 52666 rstack EAX,EBP:-5
// P2 arg #2 (float N)
 52670 push #EAX
// P2 arg #1 (char* str1)
 52672 push 26784
 52675 mov ECX,3
// P2(...)
 52678 call 40700
 52681 add ESP,3
 52684 rstack EAX,EBP:-5
// str[0]=*I
 52688 sstack EBP:-7,#EAX
 52692 mov EAX,SS:ESP
 52695 add EAX,-7
// P arg #1 (char* str)
 52698 push EAX
 52700 mov ECX,1
// P(...)
 52703 call 40570
 52706 add ESP,1
// strncpy arg #3 (float n)
 52709 push 10
 52712 rstack EAX,EBP:-5
// strncpy arg #2 (char* src)
 52716 push #EAX
 52718 mov EAX,SS:ESP
 52721 add EAX,-18
// strncpy arg #1 (char* dest)
 52724 push EAX
 52726 mov ECX,3
// strncpy(...)
 52729 call 10631
 52732 add ESP,3
// P arg #1 (char* str)
 52735 push 52837
 52738 mov ECX,1
// P(...)
 52741 call 40570
 52744 add ESP,1
 52747 mov EAX,SS:ESP
 52750 add EAX,-18
// P arg #1 (char* str)
 52753 push EAX
 52755 mov ECX,1
// P(...)
 52758 call 40570
 52761 add ESP,1
// P arg #1 (char* str)
 52764 push 52806
 52767 mov ECX,1
// P(...)
 52770 call 40570
 52773 add ESP,1
 52776 rstack EAX,EBP:-5
// loop step
 52780 inc EAX
 52782 sstack EBP:-5,EAX
 52786 jmp 52617
__2341:
 52789 jmp 52804
__2345:
__2338:
__2347:
// P arg #1 (char* str)
 52792 push 52809
 52795 mov ECX,1
// P(...)
 52798 call 40570
 52801 add ESP,1
__2346:
__2336:
__2334:
 52804 leave 
 52805 ret 
__2344:
 52806 db "]
",0
__2348:
 52809 db "Usage: memview <from> <len>",0
__2343:
 52837 db " [",0
__2340:
 52840 db " bytes
",0
__2339:
 52848 db "Memview ",0
memview_help:
 52857 db ""memview <from> <len>" displays the contents of <len> bytes of RAM starting from address <from>. Mind the paging.
"
 52971 db 0
memtest_hlp:
// memtest_hlp(adr)
 52972 enter -0
__2350:
 52975 rstack EAX,EBP:2
 52979 add EAX,0
 52982 mov EBX,EAX
// adr[0]=1
 52984 mov #EBX,1
__2352:
 52987 rstack EAX,EBP:2
 52991 add EAX,0
 52994 mov EBX,EAX
 52996 mov EAX,1
 52999 sub EAX,#EBX
 53001 fabs EAX,EAX
 53003 fsgn EAX,EAX
 53005 lneg EAX
// if (adr[0]==1)
 53007 cmp 0,EAX
 53010 jge 53056
 53013 rstack EAX,EBP:2
 53017 add EAX,0
 53020 mov EBX,EAX
// adr[0]=0
 53022 mov #EBX,0
__2355:
 53025 rstack EAX,EBP:2
 53029 add EAX,0
 53032 mov EBX,EAX
 53034 mov EAX,0
 53037 sub EAX,#EBX
 53039 fabs EAX,EAX
 53041 fsgn EAX,EAX
 53043 lneg EAX
// if (adr[0]==0)
 53045 cmp 0,EAX
 53048 jge 53056
 53051 mov EAX,1
 53054 leave 
 53055 ret 
__2356:
__2354:
__2353:
__2351:
 53056 mov EAX,0
 53059 leave 
 53060 ret 
__2349:
 53061 leave 
 53062 ret 
memtest:
// memtest()
 53063 enter 3
__2358:
// strlen arg #1 (char* str)
 53066 push #55266
 53069 mov ECX,1
// strlen(...)
 53072 call 10743
 53075 add ESP,1
 53078 sstack EBP:-1,EAX
 53082 sstack EBP:-2,83693
__2360:
 53087 rstack EAX,EBP:-1
 53091 mov EBX,2
 53094 sub EBX,EAX
 53096 fabs EBX,EBX
 53098 fsgn EBX,EBX
 53100 lneg EBX
// if (argc==2)
 53102 cmp 0,EBX
 53105 jge 53201
 53108 mov EAX,1
 53111 add EAX,#55266
// str2num arg #1 (char* str)
 53114 push #EAX
 53116 mov ECX,1
// str2num(...)
 53119 call 11422
 53122 add ESP,1
// adr=str2num(Arr[1])
 53125 sstack EBP:-2,EAX
// P2 arg #3 (char* str2)
 53129 push 18244
 53132 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 53136 push EAX
// P2 arg #1 (char* str1)
 53138 push 53358
 53141 mov ECX,3
// P2(...)
 53144 call 40700
 53147 add ESP,3
__2364:
 53150 rstack EAX,EBP:-2
// memtest_hlp arg #1 (float adr)
 53154 push EAX
 53156 mov ECX,1
// memtest_hlp(...)
 53159 call 52972
 53162 add ESP,1
// if (memtest_hlp(adr))
 53165 cmp 0,EAX
 53168 jge 53186
// P arg #1 (char* str)
 53171 push 53349
 53174 mov ECX,1
// P(...)
 53177 call 40570
 53180 add ESP,1
 53183 jmp 53198
__2367:
__2365:
__2369:
// P arg #1 (char* str)
 53186 push 53341
 53189 mov ECX,1
// P(...)
 53192 call 40570
 53195 add ESP,1
__2368:
__2363:
 53198 jmp 53330
__2371:
__2361:
__2373:
 53201 sstack EBP:-3,0
__2375:
// if (1
 53206 cmp 0,1
 53210 jz 53330
// P2 arg #3 (char* str2)
 53213 push 18244
 53216 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 53220 push EAX
// P2 arg #1 (char* str1)
 53222 push 53332
 53225 mov ECX,3
// P2(...)
 53228 call 40700
 53231 add ESP,3
// init loop
 53234 sstack EBP:-3,0
__2378:
 53239 rstack EAX,EBP:-3
 53243 mov EBX,1000
 53246 sub EBX,EAX
 53248 fsgn EBX,EBX
// condition
 53250 max EBX,0
 53253 cmp 0,EBX
 53256 jz 53327
__2380:
 53259 rstack EAX,EBP:-2
// memtest_hlp arg #1 (float adr)
 53263 push EAX
 53265 mov ECX,1
// memtest_hlp(...)
 53268 call 52972
 53271 add ESP,1
// if (memtest_hlp(adr))
 53274 cmp 0,EAX
 53277 jge 53293
 53280 rstack EAX,EBP:-2
// adr++
 53284 inc EAX
 53286 sstack EBP:-2,EAX
 53290 jmp 53314
__2382:
__2381:
__2384:
// P2 arg #3 (char* str2)
 53293 push 18244
 53296 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 53300 push EAX
// P2 arg #1 (char* str1)
 53302 push 53377
 53305 mov ECX,3
// P2(...)
 53308 call 40700
 53311 add ESP,3
__2383:
__2379:
 53314 rstack EAX,EBP:-3
// loop step
 53318 inc EAX
 53320 sstack EBP:-3,EAX
 53324 jmp 53239
__2377:
 53327 jmp 53206
__2374:
__2372:
__2359:
__2357:
 53330 leave 
 53331 ret 
__2376:
 53332 db "testing ",0
__2370:
 53341 db "FAILED
",0
__2366:
 53349 db "SUCCESS
",0
__2362:
 53358 db "testing memory at ",0
__2385:
 53377 db "found the end at ",0
memtest_help:
 53395 db ""memtest <address>" checks if <address> is write-able. "memtest" does this for the first 1000 bytes.
"
 53496 db "used to figure out of the hardware platform actually has RAM installed.
"
 53568 db 0
cmd_checksum:
// cmd_checksum()
 53569 enter 10
__2387:
// strlen arg #1 (char* str)
 53572 push #55266
 53575 mov ECX,1
// strlen(...)
 53578 call 10743
 53581 add ESP,1
 53584 sstack EBP:-1,EAX
__2389:
 53588 rstack EAX,EBP:-1
 53592 mov EBX,1
 53595 sub EBX,EAX
 53597 neg EBX
 53599 fsgn EBX,EBX
 53601 max EBX,0
// if (argc>1)
 53604 cmp 0,EBX
 53607 jge 54567
__2392:
// strcmp arg #2 (char* dest)
 53610 push 52117
 53613 mov EAX,1
 53616 add EAX,#55266
// strcmp arg #1 (char* src)
 53619 push #EAX
 53621 mov ECX,2
// strcmp(...)
 53624 call 10414
 53627 add ESP,2
 53630 mov EBX,0
 53633 sub EBX,EAX
 53635 fabs EBX,EBX
 53637 fsgn EBX,EBX
 53639 lneg EBX
// if (strcmp(Arr[1],"all")==0)
 53641 cmp 0,EBX
 53644 jge 54037
// P arg #1 (char* str)
 53647 push 54664
 53650 mov ECX,1
// P(...)
 53653 call 40570
 53656 add ESP,1
 53659 mov EAX,83693
 53662 div EAX,100
// ceil arg #1 (float A)
 53665 push EAX
 53667 mov ECX,1
// ceil(...)
 53670 call 16728
 53673 add ESP,1
 53676 sstack EBP:-2,EAX
 53680 sstack EBP:-3,0
 53685 sstack EBP:-4,0
 53690 rstack EAX,EBP:-2
 53694 sstack EBP:-5,EAX
 53698 sstack EBP:-6,0
__2396:
 53703 rstack EAX,EBP:-3
 53707 lneg EAX
 53709 mov EBX,EAX
// if (!done
 53711 cmp 0,EBX
 53714 jz 53941
 53717 rstack EAX,EBP:-4
 53721 div EAX,83693
 53724 mov EBX,EAX
 53726 mov EAX,100
 53729 mul EAX,EBX
// round arg #1 (float A)
 53731 push EAX
 53733 mov ECX,1
// round(...)
 53736 call 16758
 53739 add ESP,1
 53742 sstack EBP:-7,EAX
// P2 arg #3 (char* str2)
 53746 push 22470
 53749 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 53753 push EAX
// P2 arg #1 (char* str1)
 53755 push 54629
 53758 mov ECX,3
// P2(...)
 53761 call 40700
 53764 add ESP,3
// P2 arg #3 (char* str2)
 53767 push 51929
 53770 rstack EAX,EBP:-5
 53774 rstack EBX,EBP:-4
 53778 add EBX,EAX
 53780 mov EAX,EBX
// P2 arg #2 (float N)
 53782 push EAX
// P2 arg #1 (char* str1)
 53784 push 26784
 53787 mov ECX,3
// P2(...)
 53790 call 40700
 53793 add ESP,3
// P2 arg #3 (char* str2)
 53796 push 52163
 53799 rstack EAX,EBP:-7
// P2 arg #2 (float N)
 53803 push EAX
// P2 arg #1 (char* str1)
 53805 push 26784
 53808 mov ECX,3
// P2(...)
 53811 call 40700
 53814 add ESP,3
 53817 rstack EAX,EBP:-5
 53821 push EAX
 53823 rstack EAX,EBP:-4
 53827 push EAX
 53829 rstack EAX,EBP:-6
 53833 push EAX
 53835 mov ECX,3
// calc_checksum(...)
 53838 call 61749
 53841 add ESP,3
// result=calc_checksum(result,start1,count)
 53844 sstack EBP:-6,EAX
 53848 rstack EAX,EBP:-5
 53852 rstack EBX,EBP:-4
 53856 add EBX,EAX
 53858 mov EAX,EBX
// start1=start1+count
 53860 sstack EBP:-4,EAX
__2399:
 53864 rstack EAX,EBP:-4
 53868 mov EBX,83693
 53871 sub EBX,EAX
 53873 fsgn EBX,EBX
 53875 max EBX,0
 53878 lneg EBX
// if (!(start1<END))
 53880 cmp 0,EBX
 53883 jge 53891
// done=1
 53886 sstack EBP:-3,1
__2400:
__2398:
__2402:
 53891 rstack EAX,EBP:-5
 53895 rstack EBX,EBP:-4
 53899 add EBX,EAX
 53901 mov EAX,EBX
 53903 mov EBX,83693
 53906 sub EBX,EAX
 53908 neg EBX
 53910 fsgn EBX,EBX
 53912 max EBX,0
// if ((start1+count)>END)
 53915 cmp 0,EBX
 53918 jge 53938
 53921 rstack EAX,EBP:-4
 53925 neg EAX
 53927 mov EBX,EAX
 53929 mov EAX,83693
 53932 add EAX,EBX
// count=END-start1
 53934 sstack EBP:-5,EAX
__2403:
__2401:
 53938 jmp 53703
__2395:
// P arg #1 (char* str)
 53941 push 47944
 53944 mov ECX,1
// P(...)
 53947 call 40570
 53950 add ESP,1
__2405:
 53953 mov EAX,0
 53956 sub EAX,#55259
 53959 fabs EAX,EAX
 53961 fsgn EAX,EAX
// if (checksum_previous!=0)
 53963 cmp 0,EAX
 53966 jge 54018
__2408:
 53969 rstack EAX,EBP:-6
 53973 sub EAX,#55259
 53976 mov EBX,EAX
 53978 fabs EBX,EBX
 53980 fsgn EBX,EBX
// if (checksum_previous!=result)
 53982 cmp 0,EBX
 53985 jge 54003
// P arg #1 (char* str)
 53988 push 51888
 53991 mov ECX,1
// P(...)
 53994 call 40570
 53997 add ESP,1
 54000 jmp 54015
__2410:
__2409:
__2412:
// P arg #1 (char* str)
 54003 push 52191
 54006 mov ECX,1
// P(...)
 54009 call 40570
 54012 add ESP,1
__2411:
__2407:
 54015 jmp 54030
__2413:
__2406:
__2415:
// P arg #1 (char* str)
 54018 push 52121
 54021 mov ECX,1
// P(...)
 54024 call 40570
 54027 add ESP,1
__2414:
__2404:
 54030 rstack EAX,EBP:-6
// checksum_previous=result
 54034 mov #55259,EAX
__2393:
__2391:
__2417:
// strcmp arg #2 (char* dest)
 54037 push 52014
 54040 mov EAX,1
 54043 add EAX,#55266
// strcmp arg #1 (char* src)
 54046 push #EAX
 54048 mov ECX,2
// strcmp(...)
 54051 call 10414
 54054 add ESP,2
 54057 mov EBX,0
 54060 sub EBX,EAX
 54062 fabs EBX,EBX
 54064 fsgn EBX,EBX
 54066 lneg EBX
// if (strcmp(Arr[1],"code")==0)
 54068 cmp 0,EBX
 54071 jge 54409
// P arg #1 (char* str)
 54074 push 54781
 54077 mov ECX,1
// P(...)
 54080 call 40570
 54083 add ESP,1
 54086 sstack EBP:-8,0
 54091 mov EAX,55210
 54094 neg EAX
 54096 mov EBX,55258
 54099 add EBX,EAX
 54101 div EBX,4
 54104 sstack EBP:-9,EBX
// init loop
 54108 sstack EBP:-8,0
__2421:
 54113 rstack EAX,EBP:-8
 54117 rstack EBX,EBP:-9
 54121 sub EBX,EAX
 54123 mov EAX,EBX
 54125 fsgn EAX,EAX
// condition
 54127 max EAX,0
 54130 cmp 0,EAX
 54133 jz 54397
 54136 rstack EAX,EBP:-8
 54140 mul EAX,4
 54143 mov EBX,EAX
 54145 add EBX,55210
// start1=CRC_areas[I*4]
 54148 sstack EBP:-4,#EBX
 54152 rstack EAX,EBP:-4
 54156 neg EAX
 54158 mov EBX,EAX
 54160 rstack EAX,EBP:-8
 54164 mul EAX,4
 54167 mov ECX,EAX
 54169 add ECX,1
 54172 add ECX,55210
 54175 mov EAX,#ECX
 54177 add EAX,EBX
// count=CRC_areas[I*4+1]-start1
 54179 sstack EBP:-5,EAX
// P2 arg #3 (char* str2)
 54183 push 47396
 54186 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 54190 push EAX
// P2 arg #1 (char* str1)
 54192 push 54817
 54195 mov ECX,3
// P2(...)
 54198 call 40700
 54201 add ESP,3
// P2 arg #3 (char* str2)
 54204 push 22470
 54207 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 54211 push EAX
// P2 arg #1 (char* str1)
 54213 push 26784
 54216 mov ECX,3
// P2(...)
 54219 call 40700
 54222 add ESP,3
// P2 arg #3 (char* str2)
 54225 push 18244
 54228 rstack EAX,EBP:-5
 54232 rstack EBX,EBP:-4
 54236 add EBX,EAX
 54238 mov EAX,EBX
// P2 arg #2 (float N)
 54240 push EAX
// P2 arg #1 (char* str1)
 54242 push 26784
 54245 mov ECX,3
// P2(...)
 54248 call 40700
 54251 add ESP,3
 54254 rstack EAX,EBP:-5
 54258 push EAX
 54260 rstack EAX,EBP:-4
 54264 push EAX
 54266 push 0
 54269 mov ECX,3
// calc_checksum(...)
 54272 call 61749
 54275 add ESP,3
// result=calc_checksum(0,start1,count)
 54278 sstack EBP:-6,EAX
 54282 rstack EAX,EBP:-8
 54286 mul EAX,4
 54289 mov EBX,EAX
 54291 add EBX,3
 54294 add EBX,55210
 54297 sstack EBP:-10,#EBX
__2424:
 54301 rstack EAX,EBP:-10
 54305 mov EBX,0
 54308 sub EBX,EAX
 54310 fabs EBX,EBX
 54312 fsgn EBX,EBX
// if (prev!=0)
 54314 cmp 0,EBX
 54317 jge 54363
__2427:
 54320 rstack EAX,EBP:-10
 54324 rstack EBX,EBP:-6
 54328 sub EBX,EAX
 54330 mov EAX,EBX
 54332 fabs EAX,EAX
 54334 fsgn EAX,EAX
// if (prev!=result)
 54336 cmp 0,EAX
 54339 jge 54363
// P2 arg #3 (char* str2)
 54342 push 54700
 54345 rstack EAX,EBP:-8
// P2 arg #2 (float N)
 54349 push EAX
// P2 arg #1 (char* str1)
 54351 push 52195
 54354 mov ECX,3
// P2(...)
 54357 call 40700
 54360 add ESP,3
__2428:
__2426:
__2425:
__2423:
 54363 rstack EAX,EBP:-6
 54367 rstack EBX,EBP:-8
 54371 mul EBX,4
 54374 mov ECX,EBX
 54376 add ECX,3
 54379 add ECX,55210
// CRC_areas[I*4+3]=result
 54382 mov #ECX,EAX
 54384 rstack EAX,EBP:-8
// loop step
 54388 inc EAX
 54390 sstack EBP:-8,EAX
 54394 jmp 54113
__2420:
// P arg #1 (char* str)
 54397 push 47944
 54400 mov ECX,1
// P(...)
 54403 call 40570
 54406 add ESP,1
__2418:
__2416:
__2431:
// strcmp arg #2 (char* dest)
 54409 push 51932
 54412 mov EAX,1
 54415 add EAX,#55266
// strcmp arg #1 (char* src)
 54418 push #EAX
 54420 mov ECX,2
// strcmp(...)
 54423 call 10414
 54426 add ESP,2
 54429 mov EBX,0
 54432 sub EBX,EAX
 54434 fabs EBX,EBX
 54436 fsgn EBX,EBX
 54438 lneg EBX
// if (strcmp(Arr[1],"first")==0)
 54440 cmp 0,EBX
 54443 jge 54564
// P arg #1 (char* str)
 54446 push 54736
 54449 mov ECX,1
// P(...)
 54452 call 40570
 54455 add ESP,1
 54458 push 100
 54461 push 0
 54464 push 0
 54467 mov ECX,3
// calc_crc(...)
 54470 call 61809
 54473 add ESP,3
// result=calc_crc(0,0,100)
 54476 sstack EBP:-6,EAX
__2435:
 54480 mov EAX,0
 54483 sub EAX,#55258
 54486 fabs EAX,EAX
 54488 fsgn EAX,EAX
// if (checksum_prev_first!=0)
 54490 cmp 0,EAX
 54493 jge 54545
__2438:
 54496 rstack EAX,EBP:-6
 54500 mov EBX,#55258
 54503 sub EBX,EAX
 54505 fabs EBX,EBX
 54507 fsgn EBX,EBX
// if (result!=checksum_prev_first)
 54509 cmp 0,EBX
 54512 jge 54530
// P arg #1 (char* str)
 54515 push 51888
 54518 mov ECX,1
// P(...)
 54521 call 40570
 54524 add ESP,1
 54527 jmp 54542
__2440:
__2439:
__2442:
// P arg #1 (char* str)
 54530 push 52191
 54533 mov ECX,1
// P(...)
 54536 call 40570
 54539 add ESP,1
__2441:
__2437:
 54542 jmp 54557
__2443:
__2436:
__2445:
// P arg #1 (char* str)
 54545 push 52121
 54548 mov ECX,1
// P(...)
 54551 call 40570
 54554 add ESP,1
__2444:
__2434:
 54557 rstack EAX,EBP:-6
// checksum_prev_first=result
 54561 mov #55258,EAX
__2432:
__2430:
 54564 jmp 54627
__2446:
__2390:
__2448:
// P arg #1 (char* str)
 54567 push 54720
 54570 mov ECX,1
// P(...)
 54573 call 40570
 54576 add ESP,1
// P arg #1 (char* str)
 54579 push 54640
 54582 mov ECX,1
// P(...)
 54585 call 40570
 54588 add ESP,1
// P arg #1 (char* str)
 54591 push 52131
 54594 mov ECX,1
// P(...)
 54597 call 40570
 54600 add ESP,1
// P arg #1 (char* str)
 54603 push 52090
 54606 mov ECX,1
// P(...)
 54609 call 40570
 54612 add ESP,1
// P arg #1 (char* str)
 54615 push 51968
 54618 mov ECX,1
// P(...)
 54621 call 40570
 54624 add ESP,1
__2447:
__2388:
__2386:
 54627 leave 
 54628 ret 
__2397:
 54629 db "checksum: ",0
__2450:
 54640 db "usage: checksum <mode>
",0
__2394:
 54664 db "Calculating checksum from 0 to END
",0
__2429:
 54700 db " checksum mismatch
",0
__2449:
 54720 db "Checksum Check
",0
__2433:
 54736 db "Calculating checksum of the first 100 bytes
",0
__2419:
 54781 db "Calculating checksum of code areas
",0
__2422:
 54817 db "sum ",0
checksum_help:
 54822 db "Checksum Check
"
 54837 db "Checks the checksum of the OS code, or computes it if not yet computed. Fast. Uses CRC_AREAS table.
"
 54937 db "usage: checksum <mode>
"
 54960 db "modes: code
"
 54972 db "       all
"
 54983 db "       first
"
 54996 db 0
SHELL_CONSTANTS:
CommandBuff:
 54997 db "cls"
 55000 db 0
 55001 db 38437
 55002 db 38482
 55003 db "help"
 55007 db 0
 55008 db 42083
 55009 db 42569
 55010 db "heap"
 55014 db 0
 55015 db 44015
 55016 db 44313
 55017 db "rpncalc"
 55024 db 0
 55025 db 44343
 55026 db 45434
 55027 db "memtest"
 55034 db 0
 55035 db 53063
 55036 db 53395
 55037 db "dump"
 55041 db 0
 55042 db 48928
 55043 db 49437
 55044 db "run"
 55047 db 0
 55048 db 49607
 55049 db 49782
 55050 db "runbg"
 55055 db 0
 55056 db 50165
 55057 db 50389
 55058 db "cd"
 55060 db 0
 55061 db 45517
 55062 db 45919
 55063 db "dir"
 55066 db 0
 55067 db 46041
 55068 db 46189
 55069 db "mkdir"
 55074 db 0
 55075 db 46230
 55076 db 46365
 55077 db "write"
 55082 db 0
 55083 db 46413
 55084 db 46802
 55085 db "read"
 55089 db 0
 55090 db 46906
 55091 db 47442
 55092 db "info"
 55096 db 0
 55097 db 47534
 55098 db 47834
 55099 db "mount"
 55104 db 0
 55105 db 47875
 55106 db 47950
 55107 db "format"
 55113 db 0
 55114 db 48037
 55115 db 48104
 55116 db "gpio"
 55120 db 0
 55121 db 48264
 55122 db 48379
 55123 db "exec"
 55127 db 0
 55128 db 48414
 55129 db 48840
 55130 db "asm"
 55133 db 0
 55134 db 50478
 55135 db 50660
 55136 db "crc"
 55139 db 0
 55140 db 50754
 55141 db 52206
 55142 db "checksum"
 55150 db 0
 55151 db 53569
 55152 db 54822
 55153 db "memview"
 55160 db 0
 55161 db 52480
 55162 db 52857
 55163 db "panic"
 55168 db 0
 55169 db 38246
 55170 db 38306
 55171 db "version"
 55178 db 0
 55179 db 42848
 55180 db 43075
 55181 db "echo"
 55185 db 0
 55186 db 43112
 55187 db 43316
 55188 db "time"
 55192 db 0
 55193 db 43551
 55194 db 43850
 55195 db "test"
 55199 db 0
 55200 db 42679
 55201 db 42822
 55202 db "test2"
 55207 db 0
 55208 db 42722
 55209 db 0
CommandBuffEnd:
SHELL_VARS:
CRC_areas:
 55210 db 10006
 55211 db 16210
 55212 db 0
 55213 db 0
 55214 db 16502
 55215 db 17780
 55216 db 0
 55217 db 0
 55218 db 17780
 55219 db 22588
 55220 db 0
 55221 db 0
 55222 db 22595
 55223 db 25698
 55224 db 0
 55225 db 0
 55226 db 25698
 55227 db 26785
 55228 db 0
 55229 db 0
 55230 db 26785
 55231 db 31424
 55232 db 0
 55233 db 0
 55234 db 31424
 55235 db 36481
 55236 db 0
 55237 db 0
 55238 db 36482
 55239 db 37053
 55240 db 0
 55241 db 0
 55242 db 37054
 55243 db 37630
 55244 db 0
 55245 db 0
 55246 db 37630
 55247 db 55210
 55248 db 0
 55249 db 0
 55250 db 61596
 55251 db 61749
 55252 db 0
 55253 db 0
 55254 db 61749
 55255 db 62692
 55256 db 0
 55257 db 0
CRC_end:
checksum_prev_first:
 55258 db 0
checksum_previous:
 55259 db 0
crc_prev_first:
 55260 db 0
crc_previous:
 55261 db 0
shell_panic_ebp:
 55262 alloc 1
shell_panic_esp:
 55263 alloc 1
R:
 55264 db 0
Echo:
 55265 db 1
Arr:
 55266 db 0
RedrawPending:
 55267 db 0
PKSI:
 55268 db 0
numModules:
 55269 db 0
printPtrY:
 55270 db 0
printPtrX:
 55271 db 0
printScrY:
 55272 db 0
printSpecials:
 55273 db 0
mems:
 55274 alloc 5
CurDir:
 55279 alloc 60
MinStrI:
 55339 db 0
MinStr:
 55340 alloc 256
ConsoleStrBuff:
 55596 alloc 6000
SHELL_END:
STACKALLOC_CODE:
stack_alloc:
 61596 mov EAX,ESP
 61598 add EAX,2
 61601 mov EBX,ESP:#2
 61605 mov ECX,ESP:#1
 61609 mov EDX,EAX
 61611 sub EDX,EBX
 61613 inc EDX
 61615 sub ESP,EBX
 61617 push ECX
 61619 push EDX
 61621 push EBX
 61623 push 8008135
 61626 push EDX
 61628 call 10120
 61631 add ESP,3
 61634 pop EAX
 61636 ret 
stack_return:
 61637 enter 0
 61640 push EBP:#3
 61644 call 61596
 61647 add ESP,1
 61650 push EBP:#4
 61654 push EBP:#3
 61658 push EBP:#2
 61662 push EBP:#1
 61666 push EBP:#0
 61670 mov EAX,EBP:#0
 61674 push EAX:#0
 61678 push EAX:#1
 61682 add EAX,EBP:#4
 61686 inc EAX
 61688 push EAX
 61690 mov EBP,ESP
 61692 mov EAX,EBP:#1
 61696 sub EAX,EBP:#7
 61700 inc EAX
 61702 push EBP:#7
 61706 push EBP:#6
 61710 push EAX
 61712 call 22595
 61715 add ESP,3
 61718 mov EAX,EBP:#1
 61722 sub EAX,EBP:#7
 61726 inc EAX
 61728 mov ESP,EBP:#1
 61732 sub ESP,EBP:#7
 61736 sub ESP,EBP:#8
 61740 push EBP:#2
 61744 mov EBP,EBP:#3
 61748 ret 
STACKALLOC_CONSTANTS:
STACKALLOC_VARS:
STACKALLOC_END:
LIBCRC_CODE:
calc_checksum:
// calc_checksum(prevchecksum,start,count)
 61749 enter -0
__2452:
__2454:
 61752 rstack EAX,EBP:4
// if (count
 61756 cmp 0,EAX
 61759 jz 61801
 61762 rstack EAX,EBP:4
// count--
 61766 dec EAX
 61768 sstack EBP:4,EAX
 61772 rstack EAX,EBP:3
 61776 rstack EBX,EBP:2
 61780 add EBX,#EAX
 61782 mov EAX,EBX
// prevchecksum=prevchecksum+*start
 61784 sstack EBP:2,EAX
 61788 rstack EAX,EBP:3
// start++
 61792 inc EAX
 61794 sstack EBP:3,EAX
 61798 jmp 61752
__2453:
 61801 rstack EAX,EBP:2
 61805 leave 
 61806 ret 
__2451:
 61807 leave 
 61808 ret 
calc_crc:
// calc_crc(prevcrc,start,count)
 61809 enter 10
__2456:
 61812 rstack EAX,EBP:2
 61816 sstack EBP:-1,EAX
 61820 rstack EAX,EBP:-1
 61824 bxor EAX,4294967295
 61827 sstack EBP:-1,EAX
 61831 rstack EAX,EBP:3
 61835 sstack EBP:-2,EAX
 61839 out 1,62436
__2458:
 61843 rstack EAX,EBP:4
// if (count
 61847 cmp 0,EAX
 61850 jz 62097
 61853 rstack EAX,EBP:4
// count--
 61857 dec EAX
 61859 sstack EBP:4,EAX
 61863 rstack EAX,EBP:-2
// num=*current
 61867 sstack EBP:-6,#EAX
 61871 rstack EAX,EBP:-2
// current++
 61875 inc EAX
 61877 sstack EBP:-2,EAX
 61881 rstack EAX,EBP:-6
 61885 sstack EBP:-7,EAX
 61889 rstack EAX,EBP:-7
 61893 mod EAX,256
 61896 sstack EBP:-7,EAX
 61900 rstack EAX,EBP:-6
 61904 div EAX,256
 61907 mov EBX,EAX
 61909 sstack EBP:-8,EBX
 61913 rstack EAX,EBP:-8
 61917 fint EAX
 61919 sstack EBP:-8,EAX
 61923 rstack EAX,EBP:-8
 61927 mod EAX,256
 61930 sstack EBP:-8,EAX
 61934 rstack EAX,EBP:-6
 61938 div EAX,65536
 61941 mov EBX,EAX
 61943 sstack EBP:-9,EBX
 61947 rstack EAX,EBP:-9
 61951 fint EAX
 61953 sstack EBP:-9,EAX
 61957 rstack EAX,EBP:-9
 61961 mod EAX,256
 61964 sstack EBP:-9,EAX
 61968 rstack EAX,EBP:-6
 61972 div EAX,16777216
 61975 mov EBX,EAX
 61977 sstack EBP:-10,EBX
 61981 rstack EAX,EBP:-10
 61985 fint EAX
 61987 sstack EBP:-10,EAX
 61991 rstack EAX,EBP:-10
 61995 mod EAX,256
 61998 sstack EBP:-10,EAX
 62002 mov EAX,SS:ESP
 62005 add EAX,-1
 62008 push EAX
 62010 rstack EAX,EBP:-7
 62014 push EAX
 62016 mov ECX,2
// calc_crc8_lookup(...)
 62019 call 62116
 62022 add ESP,2
 62025 mov EAX,SS:ESP
 62028 add EAX,-1
 62031 push EAX
 62033 rstack EAX,EBP:-8
 62037 push EAX
 62039 mov ECX,2
// calc_crc8_lookup(...)
 62042 call 62116
 62045 add ESP,2
 62048 mov EAX,SS:ESP
 62051 add EAX,-1
 62054 push EAX
 62056 rstack EAX,EBP:-9
 62060 push EAX
 62062 mov ECX,2
// calc_crc8_lookup(...)
 62065 call 62116
 62068 add ESP,2
 62071 mov EAX,SS:ESP
 62074 add EAX,-1
 62077 push EAX
 62079 rstack EAX,EBP:-10
 62083 push EAX
 62085 mov ECX,2
// calc_crc8_lookup(...)
 62088 call 62116
 62091 add ESP,2
 62094 jmp 61843
__2457:
 62097 rstack EAX,EBP:-1
 62101 bxor EAX,4294967295
 62104 sstack EBP:-1,EAX
 62108 rstack EAX,EBP:-1
 62112 leave 
 62113 ret 
__2455:
 62114 leave 
 62115 ret 
calc_crc8_lookup:
// calc_crc8_lookup(n,crc)
 62116 enter 4
__2460:
 62119 rstack EAX,EBP:3
// crc2=*crc
 62123 sstack EBP:-2,#EAX
 62127 rstack EAX,EBP:-2
 62131 bshr EAX,8
 62134 sstack EBP:-2,EAX
 62138 rstack EAX,EBP:3
// crc3=*crc
 62142 sstack EBP:-3,#EAX
 62146 rstack EAX,EBP:-3
 62150 band EAX,255
 62153 sstack EBP:-3,EAX
 62157 rstack EAX,EBP:2
 62161 rstack EBX,EBP:-3
 62165 bxor EBX,EAX
 62167 sstack EBP:-3,EBX
 62171 rstack EAX,EBP:-3
 62175 add EAX,62436
 62178 mov EBX,EAX
// crc4=crc_lookup[crc3]
 62180 sstack EBP:-4,#EBX
 62184 rstack EAX,EBP:-2
// crc1=crc2
 62188 sstack EBP:-1,EAX
 62192 rstack EAX,EBP:-4
 62196 rstack EBX,EBP:-1
 62200 bxor EBX,EAX
 62202 sstack EBP:-1,EBX
 62206 rstack EAX,EBP:-1
 62210 rstack EBX,EBP:3
// *crc=crc1
 62214 mov #EBX,EAX
__2459:
 62216 leave 
 62217 ret 
calc_crc8:
// calc_crc8(n,prevcrc)
 62218 enter 3
__2462:
 62221 rstack EAX,EBP:3
 62225 sstack EBP:-2,EAX
 62229 rstack EAX,EBP:-2
 62233 bxor EAX,4294967295
 62236 sstack EBP:-2,EAX
 62240 rstack EAX,EBP:2
 62244 rstack EBX,EBP:-2
 62248 bxor EBX,EAX
 62250 sstack EBP:-2,EBX
// init loop
 62254 sstack EBP:-1,0
__2464:
 62259 rstack EAX,EBP:-1
 62263 mov EBX,8
 62266 sub EBX,EAX
 62268 fsgn EBX,EBX
// condition
 62270 max EBX,0
 62273 cmp 0,EBX
 62276 jz 62351
 62279 rstack EAX,EBP:-2
// crc2=crc
 62283 sstack EBP:-3,EAX
 62287 rstack EAX,EBP:-3
 62291 band EAX,1
 62294 sstack EBP:-3,EAX
 62298 rstack EAX,EBP:-3
 62302 mul EAX,3988292384
 62305 mov EBX,EAX
// crc2=crc2*3988292384
 62307 sstack EBP:-3,EBX
 62311 rstack EAX,EBP:-2
 62315 div EAX,2
 62318 mov EBX,EAX
// crc=crc/2
 62320 sstack EBP:-2,EBX
 62324 rstack EAX,EBP:-3
 62328 rstack EBX,EBP:-2
 62332 bxor EBX,EAX
 62334 sstack EBP:-2,EBX
 62338 rstack EAX,EBP:-1
// loop step
 62342 inc EAX
 62344 sstack EBP:-1,EAX
 62348 jmp 62259
__2463:
 62351 rstack EAX,EBP:-2
 62355 leave 
 62356 ret 
__2461:
 62357 leave 
 62358 ret 
precompute_crc:
// precompute_crc()
 62359 enter 1
__2466:
 62362 sstack EBP:-1,0
// init loop
 62367 sstack EBP:-1,0
__2468:
 62372 rstack EAX,EBP:-1
 62376 mov EBX,256
 62379 sub EBX,EAX
 62381 fsgn EBX,EBX
// condition
 62383 max EBX,0
 62386 cmp 0,EBX
 62389 jz 62434
// calc_crc8 arg #2 (float prevcrc)
 62392 push 0
 62395 rstack EAX,EBP:-1
// calc_crc8 arg #1 (float n)
 62399 push EAX
 62401 mov ECX,2
// calc_crc8(...)
 62404 call 62218
 62407 add ESP,2
 62410 rstack EBX,EBP:-1
 62414 add EBX,62436
 62417 mov ECX,EBX
// crc_lookup[I]=calc_crc8(I,0)
 62419 mov #ECX,EAX
 62421 rstack EAX,EBP:-1
// loop step
 62425 inc EAX
 62427 sstack EBP:-1,EAX
 62431 jmp 62372
__2467:
__2465:
 62434 leave 
 62435 ret 
LIBCRC_CONSTANTS:
crc_lookup:
 62436 alloc 256
LIBCRC_VARS:
LIBCRC_END:
str_file_handle:
 62692 db "file_handle",0
check_canary:
// check_canary(this,canary)
 62704 enter -0
__2470:
__2472:
 62707 rstack EAX,EBP:2
 62711 add EAX,0
 62714 mov EBX,EAX
 62716 rstack EAX,EBP:3
 62720 sub EAX,#EBX
 62722 mov EBX,EAX
 62724 fabs EBX,EBX
 62726 fsgn EBX,EBX
// if (this[0]!=canary)
 62728 cmp 0,EBX
 62731 jge 62740
 62734 mov ECX,0
// shell_panic(...)
 62737 call 38246
__2473:
__2471:
__2469:
 62740 leave 
 62741 ret 
sizeof_file_handle:
 62742 db 3
file_handle_constructor:
// file_handle_constructor(this)
 62743 enter -0
__2475:
 62746 rstack EAX,EBP:2
 62750 add EAX,0
 62753 mov EBX,EAX
// this[0]=str_file_handle
 62755 mov #EBX,62692
 62758 rstack EAX,EBP:2
 62762 add EAX,1
 62765 mov EBX,EAX
// this[1]=0
 62767 mov #EBX,0
 62770 rstack EAX,EBP:2
 62774 add EAX,2
 62777 mov EBX,EAX
// this[2]=0
 62779 mov #EBX,0
__2474:
 62782 leave 
 62783 ret 
file_handle_copy_constructor:
// file_handle_copy_constructor(this,that)
 62784 enter -0
__2477:
 62787 rstack EAX,EBP:3
 62791 add EAX,0
 62794 mov EBX,EAX
 62796 rstack EAX,EBP:2
 62800 add EAX,0
 62803 mov ECX,EAX
// this[0]=that[0]
 62805 mov #ECX,#EBX
 62807 rstack EAX,EBP:3
 62811 add EAX,1
 62814 mov EBX,EAX
 62816 rstack EAX,EBP:2
 62820 add EAX,1
 62823 mov ECX,EAX
// this[1]=that[1]
 62825 mov #ECX,#EBX
 62827 rstack EAX,EBP:3
 62831 add EAX,2
 62834 mov EBX,EAX
 62836 rstack EAX,EBP:2
 62840 add EAX,2
 62843 mov ECX,EAX
// this[2]=that[2]
 62845 mov #ECX,#EBX
// check_canary arg #2 (float canary)
 62847 push 62692
 62850 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62854 push EAX
 62856 mov ECX,2
// check_canary(...)
 62859 call 62704
 62862 add ESP,2
__2476:
 62865 leave 
 62866 ret 
file_handle_destructor:
// file_handle_destructor(this)
 62867 enter -0
__2479:
// check_canary arg #2 (float canary)
 62870 push 62692
 62873 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62877 push EAX
 62879 mov ECX,2
// check_canary(...)
 62882 call 62704
 62885 add ESP,2
// check_canary arg #2 (float canary)
 62888 push 62692
 62891 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62895 push EAX
 62897 mov ECX,2
// check_canary(...)
 62900 call 62704
 62903 add ESP,2
__2478:
 62906 leave 
 62907 ret 
file_handle_get_canary:
// file_handle_get_canary(this)
 62908 enter -0
__2481:
// check_canary arg #2 (float canary)
 62911 push 62692
 62914 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62918 push EAX
 62920 mov ECX,2
// check_canary(...)
 62923 call 62704
 62926 add ESP,2
 62929 rstack EAX,EBP:2
 62933 add EAX,0
 62936 mov EBX,EAX
 62938 mov EAX,#EBX
 62940 leave 
 62941 ret 
__2480:
 62942 leave 
 62943 ret 
file_handle_get_rw_ptr:
// file_handle_get_rw_ptr(this)
 62944 enter -0
__2483:
// check_canary arg #2 (float canary)
 62947 push 62692
 62950 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62954 push EAX
 62956 mov ECX,2
// check_canary(...)
 62959 call 62704
 62962 add ESP,2
 62965 rstack EAX,EBP:2
 62969 add EAX,1
 62972 mov EBX,EAX
 62974 mov EAX,#EBX
 62976 leave 
 62977 ret 
__2482:
 62978 leave 
 62979 ret 
file_handle_get_imp:
// file_handle_get_imp(this)
 62980 enter -0
__2485:
// check_canary arg #2 (float canary)
 62983 push 62692
 62986 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 62990 push EAX
 62992 mov ECX,2
// check_canary(...)
 62995 call 62704
 62998 add ESP,2
 63001 rstack EAX,EBP:2
 63005 add EAX,2
 63008 mov EBX,EAX
 63010 mov EAX,#EBX
 63012 leave 
 63013 ret 
__2484:
 63014 leave 
 63015 ret 
file_handle_set_canary:
// file_handle_set_canary(this,N)
 63016 enter -0
__2487:
// check_canary arg #2 (float canary)
 63019 push 62692
 63022 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 63026 push EAX
 63028 mov ECX,2
// check_canary(...)
 63031 call 62704
 63034 add ESP,2
 63037 rstack EAX,EBP:3
 63041 rstack EBX,EBP:2
 63045 add EBX,0
 63048 mov ECX,EBX
// this[0]=N
 63050 mov #ECX,EAX
__2486:
 63052 leave 
 63053 ret 
file_handle_set_rw_ptr:
// file_handle_set_rw_ptr(this,N)
 63054 enter -0
__2489:
// check_canary arg #2 (float canary)
 63057 push 62692
 63060 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 63064 push EAX
 63066 mov ECX,2
// check_canary(...)
 63069 call 62704
 63072 add ESP,2
 63075 rstack EAX,EBP:3
 63079 rstack EBX,EBP:2
 63083 add EBX,1
 63086 mov ECX,EBX
// this[1]=N
 63088 mov #ECX,EAX
__2488:
 63090 leave 
 63091 ret 
file_handle_set_imp:
// file_handle_set_imp(this,N)
 63092 enter -0
__2491:
// check_canary arg #2 (float canary)
 63095 push 62692
 63098 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 63102 push EAX
 63104 mov ECX,2
// check_canary(...)
 63107 call 62704
 63110 add ESP,2
 63113 rstack EAX,EBP:3
 63117 rstack EBX,EBP:2
 63121 add EBX,2
 63124 mov ECX,EBX
// this[2]=N
 63126 mov #ECX,EAX
__2490:
 63128 leave 
 63129 ret 
translate_fopen_mode:
// translate_fopen_mode(mode,read,write,keepdata,from,newfile)
 63130 enter -0
__2493:
__2495:
// strcmp arg #2 (char* dest)
 63133 push 40534
 63136 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63140 push EAX
 63142 mov ECX,2
// strcmp(...)
 63145 call 10414
 63148 add ESP,2
 63151 mov EBX,0
 63154 sub EBX,EAX
 63156 fabs EBX,EBX
 63158 fsgn EBX,EBX
 63160 lneg EBX
// if (strcmp(mode,"r")==0)
 63162 cmp 0,EBX
 63165 jge 63205
 63168 rstack EAX,EBP:3
// *read=1
 63172 mov #EAX,1
 63175 rstack EAX,EBP:4
// *write=0
 63179 mov #EAX,0
 63182 rstack EAX,EBP:5
// *keepdata=1
 63186 mov #EAX,1
 63189 rstack EAX,EBP:6
// *from=0
 63193 mov #EAX,0
 63196 rstack EAX,EBP:7
// *newfile=0
 63200 mov #EAX,0
 63203 leave 
 63204 ret 
__2496:
__2494:
__2498:
// strcmp arg #2 (char* dest)
 63205 push 46800
 63208 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63212 push EAX
 63214 mov ECX,2
// strcmp(...)
 63217 call 10414
 63220 add ESP,2
 63223 mov EBX,0
 63226 sub EBX,EAX
 63228 fabs EBX,EBX
 63230 fsgn EBX,EBX
 63232 lneg EBX
// if (strcmp(mode,"w")==0)
 63234 cmp 0,EBX
 63237 jge 63277
 63240 rstack EAX,EBP:3
// *read=0
 63244 mov #EAX,0
 63247 rstack EAX,EBP:4
// *write=1
 63251 mov #EAX,1
 63254 rstack EAX,EBP:5
// *keepdata=0
 63258 mov #EAX,0
 63261 rstack EAX,EBP:6
// *from=0
 63265 mov #EAX,0
 63268 rstack EAX,EBP:7
// *newfile=1
 63272 mov #EAX,1
 63275 leave 
 63276 ret 
__2499:
__2497:
__2502:
// strcmp arg #2 (char* dest)
 63277 push 63612
 63280 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63284 push EAX
 63286 mov ECX,2
// strcmp(...)
 63289 call 10414
 63292 add ESP,2
 63295 mov EBX,0
 63298 sub EBX,EAX
 63300 fabs EBX,EBX
 63302 fsgn EBX,EBX
 63304 lneg EBX
// if (strcmp(mode,"r+")==0)
 63306 cmp 0,EBX
 63309 jge 63349
 63312 rstack EAX,EBP:3
// *read=1
 63316 mov #EAX,1
 63319 rstack EAX,EBP:4
// *write=1
 63323 mov #EAX,1
 63326 rstack EAX,EBP:5
// *keepdata=1
 63330 mov #EAX,1
 63333 rstack EAX,EBP:6
// *from=0
 63337 mov #EAX,0
 63340 rstack EAX,EBP:7
// *newfile=0
 63344 mov #EAX,0
 63347 leave 
 63348 ret 
__2503:
__2501:
__2506:
// strcmp arg #2 (char* dest)
 63349 push 63609
 63352 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63356 push EAX
 63358 mov ECX,2
// strcmp(...)
 63361 call 10414
 63364 add ESP,2
 63367 mov EBX,0
 63370 sub EBX,EAX
 63372 fabs EBX,EBX
 63374 fsgn EBX,EBX
 63376 lneg EBX
// if (strcmp(mode,"w+")==0)
 63378 cmp 0,EBX
 63381 jge 63421
 63384 rstack EAX,EBP:3
// *read=1
 63388 mov #EAX,1
 63391 rstack EAX,EBP:4
// *write=1
 63395 mov #EAX,1
 63398 rstack EAX,EBP:5
// *keepdata=0
 63402 mov #EAX,0
 63405 rstack EAX,EBP:6
// *from=0
 63409 mov #EAX,0
 63412 rstack EAX,EBP:7
// *newfile=1
 63416 mov #EAX,1
 63419 leave 
 63420 ret 
__2507:
__2505:
__2510:
// strcmp arg #2 (char* dest)
 63421 push 63607
 63424 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63428 push EAX
 63430 mov ECX,2
// strcmp(...)
 63433 call 10414
 63436 add ESP,2
 63439 mov EBX,0
 63442 sub EBX,EAX
 63444 fabs EBX,EBX
 63446 fsgn EBX,EBX
 63448 lneg EBX
// if (strcmp(mode,"a")==0)
 63450 cmp 0,EBX
 63453 jge 63493
 63456 rstack EAX,EBP:3
// *read=0
 63460 mov #EAX,0
 63463 rstack EAX,EBP:4
// *write=1
 63467 mov #EAX,1
 63470 rstack EAX,EBP:5
// *keepdata=1
 63474 mov #EAX,1
 63477 rstack EAX,EBP:6
// *from=1
 63481 mov #EAX,1
 63484 rstack EAX,EBP:7
// *newfile=1
 63488 mov #EAX,1
 63491 leave 
 63492 ret 
__2511:
__2509:
__2514:
// strcmp arg #2 (char* dest)
 63493 push 63604
 63496 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 63500 push EAX
 63502 mov ECX,2
// strcmp(...)
 63505 call 10414
 63508 add ESP,2
 63511 mov EBX,0
 63514 sub EBX,EAX
 63516 fabs EBX,EBX
 63518 fsgn EBX,EBX
 63520 lneg EBX
// if (strcmp(mode,"a+")==0)
 63522 cmp 0,EBX
 63525 jge 63565
 63528 rstack EAX,EBP:3
// *read=1
 63532 mov #EAX,1
 63535 rstack EAX,EBP:4
// *write=1
 63539 mov #EAX,1
 63542 rstack EAX,EBP:5
// *keepdata=1
 63546 mov #EAX,1
 63549 rstack EAX,EBP:6
// *from=1
 63553 mov #EAX,1
 63556 rstack EAX,EBP:7
// *newfile=1
 63560 mov #EAX,1
 63563 leave 
 63564 ret 
__2515:
__2513:
 63565 rstack EAX,EBP:3
// *read=0
 63569 mov #EAX,0
 63572 rstack EAX,EBP:4
// *write=0
 63576 mov #EAX,0
 63579 rstack EAX,EBP:5
// *keepdata=0
 63583 mov #EAX,0
 63586 rstack EAX,EBP:6
// *from=0
 63590 mov #EAX,0
 63593 rstack EAX,EBP:7
// *newfile=0
 63597 mov #EAX,0
 63600 leave 
 63601 ret 
__2492:
 63602 leave 
 63603 ret 
__2512:
 63604 db "a+",0
__2508:
 63607 db "a",0
__2504:
 63609 db "w+",0
__2500:
 63612 db "r+",0
filepath_legal:
// filepath_legal(filename)
 63615 enter 2
__2517:
 63618 sstack EBP:-1,0
__2519:
 63623 rstack EAX,EBP:-1
 63627 rstack EBX,EBP:2
 63631 add EBX,EAX
 63633 mov EAX,EBX
 63635 mov EBX,0
 63638 sub EBX,#EAX
 63640 fabs EBX,EBX
 63642 fsgn EBX,EBX
// if (filename[I]!=0
 63644 cmp 0,EBX
 63647 jz 63720
 63650 rstack EAX,EBP:-1
 63654 rstack EBX,EBP:2
 63658 add EBX,EAX
 63660 mov EAX,EBX
 63662 sstack EBP:-2,#EAX
 63666 rstack EAX,EBP:-1
// I++
 63670 inc EAX
 63672 sstack EBP:-1,EAX
__2521:
 63676 rstack EAX,EBP:-2
 63680 mov EBX,47
 63683 sub EBX,EAX
 63685 fabs EBX,EBX
 63687 fsgn EBX,EBX
 63689 rstack EAX,EBP:-2
// isAlpha arg #1 (char C)
 63693 push EAX
 63695 mov ECX,1
// isAlpha(...)
 63698 call 14560
 63701 add ESP,1
 63704 and EAX,EBX
// if (isalpha(C)&&(C!='/'))
 63706 cmp 0,EAX
 63709 jge 63717
 63712 mov EAX,0
 63715 leave 
 63716 ret 
__2522:
__2520:
 63717 jmp 63623
__2518:
 63720 mov EAX,1
 63723 leave 
 63724 ret 
__2516:
 63725 leave 
 63726 ret 
current_path:
 63727 db 0
filepath_abs:
// filepath_abs(filename)
 63728 enter 2
__2524:
__2526:
 63731 rstack EAX,EBP:2
 63735 add EAX,0
 63738 mov EBX,EAX
 63740 mov EAX,47
 63743 sub EAX,#EBX
 63745 fabs EAX,EAX
 63747 fsgn EAX,EAX
 63749 lneg EAX
// if (filename[0]=='/')
 63751 cmp 0,EAX
 63754 jge 63763
 63757 rstack EAX,EBP:2
 63761 leave 
 63762 ret 
__2527:
__2525:
 63763 rstack EAX,EBP:2
// concat arg #2 (unknown)
 63767 push EAX
// concat arg #1 (unknown)
 63769 push #63727
 63772 mov ECX,2
// concat(...)
 63775 call 15359
 63778 add ESP,2
 63781 sstack EBP:-1,EAX
 63785 rstack EAX,EBP:-1
// strlen arg #1 (char* str)
 63789 push EAX
 63791 mov ECX,1
// strlen(...)
 63794 call 10743
 63797 add ESP,1
 63800 sstack EBP:-2,EAX
 63804 push 1
 63807 rstack EAX,EBP:-2
 63811 add EAX,1
 63814 mov EBX,EAX
 63816 push EBX
 63818 rstack EAX,EBP:-1
 63822 push EAX
 63824 mov ECX,3
// stack_return(...)
 63827 call 61637
 63830 add ESP,3
__2523:
 63833 leave 
 63834 ret 
filepath_decimate:
// filepath_decimate(filename,folders,name,is_abs)
 63835 enter 5
__2529:
 63838 rstack EAX,EBP:3
// *folders=0
 63842 mov #EAX,0
 63845 rstack EAX,EBP:4
// *name=0
 63849 mov #EAX,0
 63852 rstack EAX,EBP:5
// *is_abs=0
 63856 mov #EAX,0
 63859 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 63863 push EAX
 63865 mov ECX,1
// strlen(...)
 63868 call 10743
 63871 add ESP,1
 63874 sstack EBP:-1,EAX
 63878 sstack EBP:-2,1
 63883 rstack EAX,EBP:-1
 63887 mov EBX,12
 63890 add EBX,EAX
// malloc arg #1 (float n)
 63892 push EBX
 63894 mov ECX,1
// malloc(...)
 63897 call 20709
 63900 add ESP,1
 63903 sstack EBP:-3,EAX
 63907 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 63911 push EAX
 63913 rstack EAX,EBP:-3
 63917 add EAX,11
 63920 mov EBX,EAX
// strcpy arg #1 (char* dest)
 63922 push EBX
 63924 mov ECX,2
// strcpy(...)
 63927 call 10585
 63930 add ESP,2
 63933 rstack EAX,EBP:-3
 63937 add EAX,11
 63940 mov EBX,EAX
// filename=dir_arr+11
 63942 sstack EBP:2,EBX
 63946 sstack EBP:-4,0
__2531:
 63951 rstack EAX,EBP:-1
 63955 add EAX,-1
 63958 mov EBX,EAX
 63960 rstack EAX,EBP:2
 63964 add EAX,EBX
 63966 mov EBX,EAX
 63968 mov EAX,47
 63971 sub EAX,#EBX
 63973 fabs EAX,EAX
 63975 fsgn EAX,EAX
 63977 lneg EAX
// if (filename[len-1]=='/')
 63979 cmp 0,EAX
 63982 jge 64010
// is_file=0
 63985 sstack EBP:-2,0
 63990 rstack EAX,EBP:-1
 63994 add EAX,-1
 63997 mov EBX,EAX
 63999 rstack EAX,EBP:2
 64003 add EAX,EBX
 64005 mov EBX,EAX
// filename[len-1]=0
 64007 mov #EBX,0
__2532:
__2530:
__2534:
 64010 rstack EAX,EBP:2
 64014 add EAX,0
 64017 mov EBX,EAX
 64019 mov EAX,47
 64022 sub EAX,#EBX
 64024 fabs EAX,EAX
 64026 fsgn EAX,EAX
 64028 lneg EAX
// if (filename[0]=='/')
 64030 cmp 0,EAX
 64033 jge 64053
 64036 rstack EAX,EBP:5
// *is_abs=1
 64040 mov #EAX,1
 64043 rstack EAX,EBP:2
// filename++
 64047 inc EAX
 64049 sstack EBP:2,EAX
__2535:
__2533:
 64053 sstack EBP:-5,0
fp_dec_loop:
// str_find_first_of arg #2 (char C)
 64058 push 47
 64061 rstack EAX,EBP:2
// str_find_first_of arg #1 (char* S)
 64065 push EAX
 64067 mov ECX,2
// str_find_first_of(...)
 64070 call 15885
 64073 add ESP,2
// I=str_find_first_of(filename,'/')
 64076 sstack EBP:-5,EAX
__2537:
 64080 rstack EAX,EBP:-5
 64084 mov EBX,-1
 64087 sub EBX,EAX
 64089 fabs EBX,EBX
 64091 fsgn EBX,EBX
 64093 lneg EBX
// if (I==-1)
 64095 cmp 0,EBX
 64098 jge 64139
__2540:
 64101 rstack EAX,EBP:-2
// if (is_file)
 64105 cmp 0,EAX
 64108 jge 64121
 64111 rstack EAX,EBP:2
 64115 rstack EBX,EBP:4
// *name=filename
 64119 mov #EBX,EAX
__2541:
__2539:
 64121 rstack EAX,EBP:-4
 64125 rstack EBX,EBP:-3
 64129 add EBX,EAX
 64131 mov EAX,EBX
// dir_arr[dir_arr_I]=0
 64133 mov #EAX,0
 64136 jmp 64206
__2542:
__2538:
__2544:
 64139 rstack EAX,EBP:-5
 64143 rstack EBX,EBP:2
 64147 add EBX,EAX
 64149 mov EAX,EBX
// filename[I]=0
 64151 mov #EAX,0
 64154 rstack EAX,EBP:2
 64158 rstack EBX,EBP:-4
 64162 rstack ECX,EBP:-3
 64166 add ECX,EBX
 64168 mov EBX,ECX
// dir_arr[dir_arr_I]=filename
 64170 mov #EBX,EAX
 64172 rstack EAX,EBP:-4
// dir_arr_I++
 64176 inc EAX
 64178 sstack EBP:-4,EAX
 64182 rstack EAX,EBP:-5
 64186 add EAX,1
 64189 mov EBX,EAX
 64191 rstack EAX,EBP:2
 64195 add EAX,EBX
 64197 mov EBX,EAX
// filename=filename+I+1
 64199 sstack EBP:2,EBX
 64203 jmp 64058
__2543:
__2536:
 64206 rstack EAX,EBP:-3
 64210 rstack EBX,EBP:3
// *folders=dir_arr
 64214 mov #EBX,EAX
__2528:
 64216 leave 
 64217 ret 
filepath_extension:
// filepath_extension(filename)
 64218 enter 1
__2546:
// str_find_last_of arg #2 (char C)
 64221 push 46
 64224 rstack EAX,EBP:2
// str_find_last_of arg #1 (char* S)
 64228 push EAX
 64230 mov ECX,2
// str_find_last_of(...)
 64233 call 15994
 64236 add ESP,2
 64239 sstack EBP:-1,EAX
__2548:
 64243 rstack EAX,EBP:-1
 64247 mov EBX,-1
 64250 sub EBX,EAX
 64252 fabs EBX,EBX
 64254 fsgn EBX,EBX
 64256 lneg EBX
// if (I==-1)
 64258 cmp 0,EBX
 64261 jge 64272
 64264 mov EAX,0
 64267 leave 
 64268 ret 
 64269 jmp 64293
__2550:
__2549:
__2552:
 64272 rstack EAX,EBP:-1
 64276 add EAX,1
 64279 mov EBX,EAX
 64281 rstack EAX,EBP:2
 64285 add EAX,EBX
 64287 mov EBX,EAX
 64289 mov EAX,EBX
 64291 leave 
 64292 ret 
__2551:
__2547:
__2545:
 64293 leave 
 64294 ret 
files:
 64295 db 0
filenames:
 64296 db 0
str_root:
 64297 db "/",0
filesystem_init:
// filesystem_init()
 64299 enter 1
__2554:
// current_path=str_root
 64302 mov #63727,64297
// malloc arg #1 (float n)
 64306 push 100
 64309 mov ECX,1
// malloc(...)
 64312 call 20709
 64315 add ESP,1
// files=malloc(100)
 64318 mov #64295,EAX
// malloc arg #1 (float n)
 64321 push 100
 64324 mov ECX,1
// malloc(...)
 64327 call 20709
 64330 add ESP,1
// filenames=malloc(100)
 64333 mov #64296,EAX
// init loop
 64336 sstack EBP:-1,0
__2556:
 64341 rstack EAX,EBP:-1
 64345 mov EBX,100
 64348 sub EBX,EAX
 64350 fsgn EBX,EBX
// condition
 64352 max EBX,0
 64355 cmp 0,EBX
 64358 jz 64386
 64361 rstack EAX,EBP:-1
 64365 add EAX,#64295
 64368 mov EBX,EAX
// files[I]=0
 64370 mov #EBX,0
 64373 rstack EAX,EBP:-1
// loop step
 64377 inc EAX
 64379 sstack EBP:-1,EAX
 64383 jmp 64341
__2555:
__2553:
 64386 leave 
 64387 ret 
find_file:
// find_file(filename)
 64388 enter 3
__2558:
// init loop
 64391 sstack EBP:-1,0
__2560:
 64396 rstack EAX,EBP:-1
 64400 mov EBX,100
 64403 sub EBX,EAX
 64405 fsgn EBX,EBX
// condition
 64407 max EBX,0
 64410 cmp 0,EBX
 64413 jz 64509
__2562:
 64416 rstack EAX,EBP:-1
 64420 add EAX,#64295
 64423 mov EBX,EAX
// if (files[I])
 64425 cmp 0,#EBX
 64428 jge 64496
 64431 rstack EAX,EBP:-1
 64435 add EAX,#64296
 64438 mov EBX,EAX
 64440 sstack EBP:-2,#EBX
 64444 rstack EAX,EBP:2
// strcmp arg #2 (char* dest)
 64448 push EAX
 64450 rstack EAX,EBP:-2
// strcmp arg #1 (char* src)
 64454 push EAX
 64456 mov ECX,2
// strcmp(...)
 64459 call 10414
 64462 add ESP,2
 64465 sstack EBP:-3,EAX
__2565:
 64469 rstack EAX,EBP:-3
 64473 mov EBX,0
 64476 sub EBX,EAX
 64478 fabs EBX,EBX
 64480 fsgn EBX,EBX
 64482 lneg EBX
// if (compare==0)
 64484 cmp 0,EBX
 64487 jge 64496
 64490 rstack EAX,EBP:-1
 64494 leave 
 64495 ret 
__2566:
__2564:
__2563:
__2561:
 64496 rstack EAX,EBP:-1
// loop step
 64500 inc EAX
 64502 sstack EBP:-1,EAX
 64506 jmp 64396
__2559:
 64509 mov EAX,-1
 64512 leave 
 64513 ret 
__2557:
 64514 leave 
 64515 ret 
find_free:
// find_free()
 64516 enter 1
__2568:
// init loop
 64519 sstack EBP:-1,0
__2570:
 64524 rstack EAX,EBP:-1
 64528 mov EBX,100
 64531 sub EBX,EAX
 64533 fsgn EBX,EBX
// condition
 64535 max EBX,0
 64538 cmp 0,EBX
 64541 jz 64582
__2572:
 64544 rstack EAX,EBP:-1
 64548 add EAX,#64295
 64551 mov EBX,EAX
 64553 mov EAX,#EBX
 64555 lneg EAX
// if (!files[I])
 64557 cmp 0,EAX
 64560 jge 64569
 64563 rstack EAX,EBP:-1
 64567 leave 
 64568 ret 
__2573:
__2571:
 64569 rstack EAX,EBP:-1
// loop step
 64573 inc EAX
 64575 sstack EBP:-1,EAX
 64579 jmp 64524
__2569:
 64582 mov EAX,-1
 64585 leave 
 64586 ret 
__2567:
 64587 leave 
 64588 ret 
fopen:
// fopen(filename,mode)
 64589 enter 11
__2575:
 64592 rstack EAX,EBP:2
// filepath_abs arg #1 (char* filename)
 64596 push EAX
 64598 mov ECX,1
// filepath_abs(...)
 64601 call 63728
 64604 add ESP,1
// filename=filepath_abs(filename)
 64607 sstack EBP:2,EAX
 64611 sstack EBP:-1,0
 64616 sstack EBP:-2,0
 64621 sstack EBP:-3,0
 64626 sstack EBP:-4,0
 64631 sstack EBP:-5,0
 64636 mov EAX,SS:ESP
 64639 add EAX,-5
// translate_fopen_mode arg #6 (float* newfile)
 64642 push EAX
 64644 mov EAX,SS:ESP
 64647 add EAX,-4
// translate_fopen_mode arg #5 (float* from)
 64650 push EAX
 64652 mov EAX,SS:ESP
 64655 add EAX,-3
// translate_fopen_mode arg #4 (float* keepdata)
 64658 push EAX
 64660 mov EAX,SS:ESP
 64663 add EAX,-1
// translate_fopen_mode arg #3 (float* write)
 64666 push EAX
 64668 mov EAX,SS:ESP
 64671 add EAX,-2
// translate_fopen_mode arg #2 (float* read)
 64674 push EAX
 64676 rstack EAX,EBP:3
// translate_fopen_mode arg #1 (char* mode)
 64680 push EAX
 64682 mov ECX,6
// translate_fopen_mode(...)
 64685 call 63130
 64688 add ESP,6
 64691 rstack EAX,EBP:2
// find_file arg #1 (char* filename)
 64695 push EAX
 64697 mov ECX,1
// find_file(...)
 64700 call 64388
 64703 add ESP,1
 64706 sstack EBP:-6,EAX
 64710 sstack EBP:-7,0
__2577:
 64715 rstack EAX,EBP:-6
 64719 mov EBX,-1
 64722 sub EBX,EAX
 64724 fabs EBX,EBX
 64726 fsgn EBX,EBX
 64728 lneg EBX
// if (f_index==-1)
 64730 cmp 0,EBX
 64733 jge 64918
__2580:
 64736 rstack EAX,EBP:-5
// if (newfile)
 64740 cmp 0,EAX
 64743 jge 64913
 64746 mov ECX,0
// find_free(...)
 64749 call 64516
// f_index=find_free()
 64752 sstack EBP:-6,EAX
__2583:
 64756 rstack EAX,EBP:-6
 64760 mov EBX,-1
 64763 sub EBX,EAX
 64765 fabs EBX,EBX
 64767 fsgn EBX,EBX
 64769 lneg EBX
// if (f_index==-1)
 64771 cmp 0,EBX
 64774 jge 64782
 64777 mov EAX,-1
 64780 leave 
 64781 ret 
__2584:
__2582:
// malloc arg #1 (float n)
 64782 push #22842
 64785 mov ECX,1
// malloc(...)
 64788 call 20709
 64791 add ESP,1
// body=malloc(sizeof_vector)
 64794 sstack EBP:-7,EAX
 64798 rstack EAX,EBP:-7
 64802 rstack EBX,EBP:-6
 64806 add EBX,#64295
 64809 mov ECX,EBX
// files[f_index]=body
 64811 mov #ECX,EAX
// vector_constructor arg #2 (float element_size)
 64813 push 1
 64816 rstack EAX,EBP:-7
// vector_constructor arg #1 (void* self)
 64820 push EAX
 64822 mov ECX,2
// vector_constructor(...)
 64825 call 22843
 64828 add ESP,2
 64831 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 64835 push EAX
 64837 mov ECX,1
// strlen(...)
 64840 call 10743
 64843 add ESP,1
 64846 sstack EBP:-8,EAX
 64850 rstack EAX,EBP:-8
 64854 add EAX,1
 64857 mov EBX,EAX
// malloc arg #1 (float n)
 64859 push EBX
 64861 mov ECX,1
// malloc(...)
 64864 call 20709
 64867 add ESP,1
 64870 sstack EBP:-9,EAX
 64874 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 64878 push EAX
 64880 rstack EAX,EBP:-9
// strcpy arg #1 (char* dest)
 64884 push EAX
 64886 mov ECX,2
// strcpy(...)
 64889 call 10585
 64892 add ESP,2
 64895 rstack EAX,EBP:-9
 64899 rstack EBX,EBP:-6
 64903 add EBX,#64296
 64906 mov ECX,EBX
// filenames[f_index]=filename_str
 64908 mov #ECX,EAX
 64910 jmp 64918
__2585:
__2581:
__2587:
 64913 mov EAX,-1
 64916 leave 
 64917 ret 
__2586:
__2579:
__2578:
__2576:
 64918 rstack EAX,EBP:-6
 64922 add EAX,#64295
 64925 mov EBX,EAX
// body=files[f_index]
 64927 sstack EBP:-7,#EBX
__2589:
 64931 rstack EAX,EBP:-3
 64935 lneg EAX
 64937 mov EBX,EAX
// if (!keepdata)
 64939 cmp 0,EBX
 64942 jge 64960
 64945 rstack EAX,EBP:-7
// vector_clear arg #1 (void* self)
 64949 push EAX
 64951 mov ECX,1
// vector_clear(...)
 64954 call 23492
 64957 add ESP,1
__2590:
__2588:
 64960 rstack EAX,EBP:-7
// vector_get_size arg #1 (void* self)
 64964 push EAX
 64966 mov ECX,1
// vector_get_size(...)
 64969 call 23189
 64972 add ESP,1
 64975 sstack EBP:-10,EAX
// malloc arg #1 (float n)
 64979 push #62742
 64982 mov ECX,1
// malloc(...)
 64985 call 20709
 64988 add ESP,1
 64991 sstack EBP:-11,EAX
 64995 rstack EAX,EBP:-11
// file_handle_constructor arg #1 (float this)
 64999 push EAX
 65001 mov ECX,1
// file_handle_constructor(...)
 65004 call 62743
 65007 add ESP,1
 65010 rstack EAX,EBP:-7
// file_handle_set_imp arg #2 (float N)
 65014 push EAX
 65016 rstack EAX,EBP:-11
// file_handle_set_imp arg #1 (float this)
 65020 push EAX
 65022 mov ECX,2
// file_handle_set_imp(...)
 65025 call 63092
 65028 add ESP,2
__2592:
 65031 rstack EAX,EBP:-4
// if (from)
 65035 cmp 0,EAX
 65038 jge 65062
 65041 rstack EAX,EBP:-10
// file_handle_set_rw_ptr arg #2 (float N)
 65045 push EAX
 65047 rstack EAX,EBP:-11
// file_handle_set_rw_ptr arg #1 (float this)
 65051 push EAX
 65053 mov ECX,2
// file_handle_set_rw_ptr(...)
 65056 call 63054
 65059 add ESP,2
__2593:
__2591:
 65062 rstack EAX,EBP:-11
 65066 leave 
 65067 ret 
__2574:
 65068 leave 
 65069 ret 
fwrite:
// fwrite(from,size,fp)
 65070 enter 2
__2595:
__2597:
 65073 rstack EAX,EBP:4
 65077 lneg EAX
 65079 mov EBX,EAX
// if (!fp)
 65081 cmp 0,EBX
 65084 jge 65092
 65087 mov EAX,0
 65090 leave 
 65091 ret 
__2598:
__2596:
 65092 rstack EAX,EBP:4
// file_handle_get_imp arg #1 (float this)
 65096 push EAX
 65098 mov ECX,1
// file_handle_get_imp(...)
 65101 call 62980
 65104 add ESP,1
 65107 sstack EBP:-1,EAX
 65111 rstack EAX,EBP:4
// file_handle_get_rw_ptr arg #1 (float this)
 65115 push EAX
 65117 mov ECX,1
// file_handle_get_rw_ptr(...)
 65120 call 62944
 65123 add ESP,1
 65126 sstack EBP:-2,EAX
__2600:
 65130 rstack EAX,EBP:3
 65134 mov EBX,EAX
 65136 dec EAX
 65138 sstack EBP:3,EAX
// if (size--
 65142 cmp 0,EBX
 65145 jz 65198
 65148 rstack EAX,EBP:-2
// vector_set arg #3 (float pos)
 65152 push EAX
 65154 rstack EAX,EBP:2
// vector_set arg #2 (void* element)
 65158 push #EAX
 65160 rstack EAX,EBP:-1
// vector_set arg #1 (void* self)
 65164 push EAX
 65166 mov ECX,3
// vector_set(...)
 65169 call 24427
 65172 add ESP,3
 65175 rstack EAX,EBP:-2
// idx++
 65179 inc EAX
 65181 sstack EBP:-2,EAX
 65185 rstack EAX,EBP:2
// from++
 65189 inc EAX
 65191 sstack EBP:2,EAX
 65195 jmp 65130
__2599:
 65198 rstack EAX,EBP:-2
// file_handle_set_rw_ptr arg #2 (float N)
 65202 push EAX
 65204 rstack EAX,EBP:4
// file_handle_set_rw_ptr arg #1 (float this)
 65208 push EAX
 65210 mov ECX,2
// file_handle_set_rw_ptr(...)
 65213 call 63054
 65216 add ESP,2
 65219 mov EAX,1
 65222 leave 
 65223 ret 
__2594:
 65224 leave 
 65225 ret 
fresize:
// fresize(size,fp)
 65226 enter 1
__2602:
__2604:
 65229 rstack EAX,EBP:3
 65233 lneg EAX
 65235 mov EBX,EAX
// if (!fp)
 65237 cmp 0,EBX
 65240 jge 65248
 65243 mov EAX,0
 65246 leave 
 65247 ret 
__2605:
__2603:
 65248 rstack EAX,EBP:3
// file_handle_get_imp arg #1 (float this)
 65252 push EAX
 65254 mov ECX,1
// file_handle_get_imp(...)
 65257 call 62980
 65260 add ESP,1
 65263 sstack EBP:-1,EAX
 65267 rstack EAX,EBP:2
// vector_resize arg #2 (float newcap)
 65271 push EAX
 65273 rstack EAX,EBP:-1
// vector_resize arg #1 (void* self)
 65277 push EAX
 65279 mov ECX,2
// vector_resize(...)
 65282 call 25454
 65285 add ESP,2
 65288 mov EAX,1
 65291 leave 
 65292 ret 
__2601:
 65293 leave 
 65294 ret 
fread:
// fread(to,size,fp)
 65295 enter 4
__2607:
__2609:
 65298 rstack EAX,EBP:4
 65302 lneg EAX
 65304 mov EBX,EAX
// if (!fp)
 65306 cmp 0,EBX
 65309 jge 65317
 65312 mov EAX,0
 65315 leave 
 65316 ret 
__2610:
__2608:
 65317 rstack EAX,EBP:4
// file_handle_get_imp arg #1 (float this)
 65321 push EAX
 65323 mov ECX,1
// file_handle_get_imp(...)
 65326 call 62980
 65329 add ESP,1
 65332 sstack EBP:-1,EAX
 65336 rstack EAX,EBP:4
// file_handle_get_rw_ptr arg #1 (float this)
 65340 push EAX
 65342 mov ECX,1
// file_handle_get_rw_ptr(...)
 65345 call 62944
 65348 add ESP,1
 65351 sstack EBP:-2,EAX
 65355 rstack EAX,EBP:-1
// vector_get_size arg #1 (void* self)
 65359 push EAX
 65361 mov ECX,1
// vector_get_size(...)
 65364 call 23189
 65367 add ESP,1
 65370 sstack EBP:-3,EAX
__2612:
 65374 rstack EAX,EBP:3
 65378 mov EBX,EAX
 65380 dec EAX
 65382 sstack EBP:3,EAX
// if (size--
 65386 cmp 0,EBX
 65389 jz 65485
__2614:
 65392 rstack EAX,EBP:-2
 65396 rstack EBX,EBP:-3
 65400 sub EBX,EAX
 65402 mov EAX,EBX
 65404 fabs EAX,EAX
 65406 fsgn EAX,EAX
 65408 lneg EAX
// if (idx==end)
 65410 cmp 0,EAX
 65413 jge 65424
 65416 mov EAX,0
 65419 leave 
 65420 ret 
 65421 jmp 65482
__2616:
__2615:
__2618:
 65424 rstack EAX,EBP:-2
// vector_get arg #3 (float pos)
 65428 push EAX
// vector_get arg #2 (void* element)
 65430 push 0
 65433 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 65437 push EAX
 65439 mov ECX,3
// vector_get(...)
 65442 call 24205
 65445 add ESP,3
 65448 sstack EBP:-4,EAX
 65452 rstack EAX,EBP:-4
 65456 rstack EBX,EBP:2
// *to=C
 65460 mov #EBX,EAX
 65462 rstack EAX,EBP:-2
// idx++
 65466 inc EAX
 65468 sstack EBP:-2,EAX
 65472 rstack EAX,EBP:2
// to++
 65476 inc EAX
 65478 sstack EBP:2,EAX
__2617:
__2613:
 65482 jmp 65374
__2611:
 65485 rstack EAX,EBP:-2
// file_handle_set_rw_ptr arg #2 (float N)
 65489 push EAX
 65491 rstack EAX,EBP:4
// file_handle_set_rw_ptr arg #1 (float this)
 65495 push EAX
 65497 mov ECX,2
// file_handle_set_rw_ptr(...)
 65500 call 63054
 65503 add ESP,2
 65506 mov EAX,1
 65509 leave 
 65510 ret 
__2606:
 65511 leave 
 65512 ret 
fgetstring:
// fgetstring(fp,str,num)
 65513 enter 9
__2620:
__2622:
 65516 rstack EAX,EBP:2
 65520 lneg EAX
 65522 mov EBX,EAX
// if (!fp)
 65524 cmp 0,EBX
 65527 jge 65535
 65530 mov EAX,0
 65533 leave 
 65534 ret 
__2623:
__2621:
__2625:
 65535 rstack EAX,EBP:4
 65539 mov EBX,2
 65542 sub EBX,EAX
 65544 fsgn EBX,EBX
 65546 max EBX,0
// if (num<2)
 65549 cmp 0,EBX
 65552 jge 65560
 65555 mov EAX,0
 65558 leave 
 65559 ret 
__2626:
__2624:
 65560 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 65564 push EAX
 65566 mov ECX,1
// file_handle_get_imp(...)
 65569 call 62980
 65572 add ESP,1
 65575 sstack EBP:-1,EAX
 65579 rstack EAX,EBP:2
// file_handle_get_rw_ptr arg #1 (float this)
 65583 push EAX
 65585 mov ECX,1
// file_handle_get_rw_ptr(...)
 65588 call 62944
 65591 add ESP,1
 65594 sstack EBP:-2,EAX
 65598 rstack EAX,EBP:-1
// vector_get_size arg #1 (void* self)
 65602 push EAX
 65604 mov ECX,1
// vector_get_size(...)
 65607 call 23189
 65610 add ESP,1
 65613 sstack EBP:-3,EAX
__2628:
 65617 rstack EAX,EBP:-2
 65621 rstack EBX,EBP:-3
 65625 sub EBX,EAX
 65627 mov EAX,EBX
 65629 neg EAX
 65631 fsgn EAX,EAX
 65633 inc EAX
 65635 max EAX,0
// if (idx>=end)
 65638 cmp 0,EAX
 65641 jge 65649
 65644 mov EAX,0
 65647 leave 
 65648 ret 
__2629:
__2627:
 65649 rstack EAX,EBP:-1
// vector_get_array arg #1 (void* self)
 65653 push EAX
 65655 mov ECX,1
// vector_get_array(...)
 65658 call 23153
 65661 add ESP,1
 65664 sstack EBP:-4,EAX
 65668 sstack EBP:-5,0
 65673 sstack EBP:-6,0
 65678 rstack EAX,EBP:3
 65682 sstack EBP:-7,EAX
fgetsloop:
 65686 rstack EAX,EBP:-2
 65690 rstack EBX,EBP:-4
 65694 add EBX,EAX
 65696 mov EAX,EBX
 65698 sstack EBP:-8,#EAX
 65702 rstack EAX,EBP:-2
 65706 sstack EBP:-9,EAX
 65710 rstack EAX,EBP:-2
// idx++
 65714 inc EAX
 65716 sstack EBP:-2,EAX
 65720 rstack EAX,EBP:-6
// nread++
 65724 inc EAX
 65726 sstack EBP:-6,EAX
__2631:
 65730 rstack EAX,EBP:-8
 65734 mov EBX,0
 65737 sub EBX,EAX
 65739 fabs EBX,EBX
 65741 fsgn EBX,EBX
 65743 lneg EBX
// if (C==0)
 65745 cmp 0,EBX
 65748 jge 65754
 65751 jmp 65853
__2632:
__2630:
__2634:
 65754 rstack EAX,EBP:-9
 65758 rstack EBX,EBP:-3
 65762 sub EBX,EAX
 65764 mov EAX,EBX
 65766 fabs EAX,EAX
 65768 fsgn EAX,EAX
 65770 lneg EAX
// if (previdx==end)
 65772 cmp 0,EAX
 65775 jge 65781
 65778 jmp 65853
__2635:
__2633:
__2637:
 65781 rstack EAX,EBP:-8
 65785 mov EBX,10
 65788 sub EBX,EAX
 65790 fabs EBX,EBX
 65792 fsgn EBX,EBX
 65794 lneg EBX
// if (C==10)
 65796 cmp 0,EBX
 65799 jge 65805
 65802 jmp 65853
__2638:
__2636:
__2640:
 65805 rstack EAX,EBP:-6
 65809 rstack EBX,EBP:4
 65813 sub EBX,EAX
 65815 mov EAX,EBX
 65817 fabs EAX,EAX
 65819 fsgn EAX,EAX
 65821 lneg EAX
// if (nread==num)
 65823 cmp 0,EAX
 65826 jge 65832
 65829 jmp 65853
__2641:
__2639:
 65832 rstack EAX,EBP:-8
 65836 rstack EBX,EBP:-7
 65840 mov ECX,EBX
 65842 inc EBX
 65844 sstack EBP:-7,EBX
// *strptr++=C
 65848 mov #ECX,EAX
 65850 jmp 65686
fgets_end:
 65853 rstack EAX,EBP:-7
// *strptr=0
 65857 mov #EAX,0
 65860 rstack EAX,EBP:-2
// file_handle_set_rw_ptr arg #2 (float N)
 65864 push EAX
 65866 rstack EAX,EBP:2
// file_handle_set_rw_ptr arg #1 (float this)
 65870 push EAX
 65872 mov ECX,2
// file_handle_set_rw_ptr(...)
 65875 call 63054
 65878 add ESP,2
 65881 rstack EAX,EBP:3
 65885 leave 
 65886 ret 
__2619:
 65887 leave 
 65888 ret 
feof:
// feof(fp)
 65889 enter 3
__2643:
__2645:
 65892 rstack EAX,EBP:2
 65896 lneg EAX
 65898 mov EBX,EAX
// if (!fp)
 65900 cmp 0,EBX
 65903 jge 65911
 65906 mov EAX,1
 65909 leave 
 65910 ret 
__2646:
__2644:
 65911 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 65915 push EAX
 65917 mov ECX,1
// file_handle_get_imp(...)
 65920 call 62980
 65923 add ESP,1
 65926 sstack EBP:-1,EAX
 65930 rstack EAX,EBP:2
// file_handle_get_rw_ptr arg #1 (float this)
 65934 push EAX
 65936 mov ECX,1
// file_handle_get_rw_ptr(...)
 65939 call 62944
 65942 add ESP,1
 65945 sstack EBP:-2,EAX
 65949 rstack EAX,EBP:-1
// vector_get_size arg #1 (void* self)
 65953 push EAX
 65955 mov ECX,1
// vector_get_size(...)
 65958 call 23189
 65961 add ESP,1
 65964 sstack EBP:-3,EAX
__2648:
 65968 rstack EAX,EBP:-2
 65972 rstack EBX,EBP:-3
 65976 sub EBX,EAX
 65978 mov EAX,EBX
 65980 fabs EAX,EAX
 65982 fsgn EAX,EAX
 65984 lneg EAX
// if (idx==end)
 65986 cmp 0,EAX
 65989 jge 66000
 65992 mov EAX,1
 65995 leave 
 65996 ret 
 65997 jmp 66005
__2650:
__2649:
__2652:
 66000 mov EAX,0
 66003 leave 
 66004 ret 
__2651:
__2647:
__2642:
 66005 leave 
 66006 ret 
fsize:
// fsize(fp)
 66007 enter 2
__2654:
__2656:
 66010 rstack EAX,EBP:2
 66014 lneg EAX
 66016 mov EBX,EAX
// if (!fp)
 66018 cmp 0,EBX
 66021 jge 66029
 66024 mov EAX,1
 66027 leave 
 66028 ret 
__2657:
__2655:
 66029 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 66033 push EAX
 66035 mov ECX,1
// file_handle_get_imp(...)
 66038 call 62980
 66041 add ESP,1
 66044 sstack EBP:-1,EAX
 66048 rstack EAX,EBP:-1
// vector_get_size arg #1 (void* self)
 66052 push EAX
 66054 mov ECX,1
// vector_get_size(...)
 66057 call 23189
 66060 add ESP,1
 66063 sstack EBP:-2,EAX
 66067 rstack EAX,EBP:-2
 66071 leave 
 66072 ret 
__2653:
 66073 leave 
 66074 ret 
fseek:
// fseek(fp,offs,origin)
 66075 enter 1
__2659:
__2661:
 66078 rstack EAX,EBP:2
 66082 lneg EAX
 66084 mov EBX,EAX
// if (!fp)
 66086 cmp 0,EBX
 66089 jge 66094
 66092 leave 
 66093 ret 
__2662:
__2660:
__2664:
 66094 rstack EAX,EBP:4
 66098 lneg EAX
 66100 mov EBX,EAX
// if (!origin)
 66102 cmp 0,EBX
 66105 jge 66132
 66108 rstack EAX,EBP:3
// file_handle_set_rw_ptr arg #2 (float N)
 66112 push EAX
 66114 rstack EAX,EBP:2
// file_handle_set_rw_ptr arg #1 (float this)
 66118 push EAX
 66120 mov ECX,2
// file_handle_set_rw_ptr(...)
 66123 call 63054
 66126 add ESP,2
 66129 jmp 66180
__2666:
__2665:
__2668:
 66132 rstack EAX,EBP:2
// fsize arg #1 (float fp)
 66136 push EAX
 66138 mov ECX,1
// fsize(...)
 66141 call 66007
 66144 add ESP,1
 66147 sstack EBP:-1,EAX
 66151 rstack EAX,EBP:3
 66155 rstack EBX,EBP:-1
 66159 add EBX,EAX
 66161 mov EAX,EBX
// file_handle_set_rw_ptr arg #2 (float N)
 66163 push EAX
 66165 rstack EAX,EBP:2
// file_handle_set_rw_ptr arg #1 (float this)
 66169 push EAX
 66171 mov ECX,2
// file_handle_set_rw_ptr(...)
 66174 call 63054
 66177 add ESP,2
__2667:
__2663:
__2658:
 66180 leave 
 66181 ret 
ftell:
// ftell(fp)
 66182 enter -0
__2670:
__2672:
 66185 rstack EAX,EBP:2
 66189 lneg EAX
 66191 mov EBX,EAX
// if (!fp)
 66193 cmp 0,EBX
 66196 jge 66204
 66199 mov EAX,-1
 66202 leave 
 66203 ret 
__2673:
__2671:
 66204 rstack EAX,EBP:2
// file_handle_get_rw_ptr arg #1 (float this)
 66208 push EAX
 66210 mov ECX,1
// file_handle_get_rw_ptr(...)
 66213 call 62944
 66216 add ESP,1
 66219 leave 
 66220 ret 
__2669:
 66221 leave 
 66222 ret 
flist:
// flist(filepath)
 66223 enter 4
__2675:
// malloc arg #1 (float n)
 66226 push #22842
 66229 mov ECX,1
// malloc(...)
 66232 call 20709
 66235 add ESP,1
 66238 sstack EBP:-2,EAX
// vector_constructor arg #2 (float element_size)
 66242 push 1
 66245 rstack EAX,EBP:-2
// vector_constructor arg #1 (void* self)
 66249 push EAX
 66251 mov ECX,2
// vector_constructor(...)
 66254 call 22843
 66257 add ESP,2
 66260 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 66264 push EAX
 66266 mov ECX,1
// strlen(...)
 66269 call 10743
 66272 add ESP,1
 66275 sstack EBP:-3,EAX
// init loop
 66279 sstack EBP:-1,0
__2677:
 66284 rstack EAX,EBP:-1
 66288 mov EBX,100
 66291 sub EBX,EAX
 66293 fsgn EBX,EBX
// condition
 66295 max EBX,0
 66298 cmp 0,EBX
 66301 jz 66410
__2679:
 66304 rstack EAX,EBP:-1
 66308 add EAX,#64295
 66311 mov EBX,EAX
// if (files[I])
 66313 cmp 0,#EBX
 66316 jge 66397
 66319 rstack EAX,EBP:-1
 66323 add EAX,#64296
 66326 mov EBX,EAX
 66328 sstack EBP:-4,#EBX
__2682:
 66332 rstack EAX,EBP:-3
// strncmp arg #3 (float n)
 66336 push EAX
 66338 rstack EAX,EBP:-4
// strncmp arg #2 (char* dest)
 66342 push EAX
 66344 rstack EAX,EBP:2
// strncmp arg #1 (char* src)
 66348 push EAX
 66350 mov ECX,3
// strncmp(...)
 66353 call 10488
 66356 add ESP,3
 66359 mov EBX,0
 66362 sub EBX,EAX
 66364 fabs EBX,EBX
 66366 fsgn EBX,EBX
 66368 lneg EBX
// if (strncmp(filepath,str,fplen)==0)
 66370 cmp 0,EBX
 66373 jge 66397
 66376 rstack EAX,EBP:-4
// vector_push arg #2 (void* element)
 66380 push EAX
 66382 rstack EAX,EBP:-2
// vector_push arg #1 (void* self)
 66386 push EAX
 66388 mov ECX,2
// vector_push(...)
 66391 call 23548
 66394 add ESP,2
__2683:
__2681:
__2680:
__2678:
 66397 rstack EAX,EBP:-1
// loop step
 66401 inc EAX
 66403 sstack EBP:-1,EAX
 66407 jmp 66284
__2676:
 66410 rstack EAX,EBP:-2
 66414 leave 
 66415 ret 
__2674:
 66416 leave 
 66417 ret 
fdelete:
// fdelete(filepath)
 66418 enter 3
__2685:
 66421 rstack EAX,EBP:2
// find_file arg #1 (char* filename)
 66425 push EAX
 66427 mov ECX,1
// find_file(...)
 66430 call 64388
 66433 add ESP,1
 66436 sstack EBP:-1,EAX
__2687:
 66440 rstack EAX,EBP:-1
 66444 mov EBX,-1
 66447 sub EBX,EAX
 66449 fabs EBX,EBX
 66451 fsgn EBX,EBX
 66453 lneg EBX
// if (idx==-1)
 66455 cmp 0,EBX
 66458 jge 66463
 66461 leave 
 66462 ret 
__2688:
__2686:
 66463 rstack EAX,EBP:-1
 66467 add EAX,#64295
 66470 mov EBX,EAX
 66472 sstack EBP:-2,#EBX
 66476 rstack EAX,EBP:-2
// vector_clear arg #1 (void* self)
 66480 push EAX
 66482 mov ECX,1
// vector_clear(...)
 66485 call 23492
 66488 add ESP,1
 66491 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 66495 push EAX
 66497 mov ECX,1
// free(...)
 66500 call 21231
 66503 add ESP,1
 66506 rstack EAX,EBP:-1
 66510 add EAX,#64295
 66513 mov EBX,EAX
// files[idx]=0
 66515 mov #EBX,0
 66518 rstack EAX,EBP:-1
 66522 add EAX,#64296
 66525 mov EBX,EAX
 66527 sstack EBP:-3,#EBX
 66531 rstack EAX,EBP:-3
// free arg #1 (float* ptr)
 66535 push EAX
 66537 mov ECX,1
// free(...)
 66540 call 21231
 66543 add ESP,1
 66546 rstack EAX,EBP:-1
 66550 add EAX,#64296
 66553 mov EBX,EAX
// filenames[idx]=0
 66555 mov #EBX,0
__2684:
 66558 leave 
 66559 ret 
vector_get_linear_size:
// vector_get_linear_size(V)
 66560 enter 1
__2690:
 66563 rstack EAX,EBP:2
// vector_get_size arg #1 (void* self)
 66567 push EAX
 66569 mov ECX,1
// vector_get_size(...)
 66572 call 23189
 66575 add ESP,1
 66578 sstack EBP:-1,EAX
 66582 rstack EAX,EBP:-1
 66586 add EAX,#22842
 66589 mov EBX,EAX
 66591 mov EAX,EBX
 66593 leave 
 66594 ret 
__2689:
 66595 leave 
 66596 ret 
vector_move:
// vector_move(V,newpos)
 66597 enter 2
__2692:
 66600 rstack EAX,EBP:2
// vector_get_size arg #1 (void* self)
 66604 push EAX
 66606 mov ECX,1
// vector_get_size(...)
 66609 call 23189
 66612 add ESP,1
 66615 sstack EBP:-1,EAX
 66619 rstack EAX,EBP:2
// vector_get_array arg #1 (void* self)
 66623 push EAX
 66625 mov ECX,1
// vector_get_array(...)
 66628 call 23153
 66631 add ESP,1
 66634 sstack EBP:-2,EAX
// memcpy arg #3 (float n)
 66638 push #22842
 66641 rstack EAX,EBP:2
// memcpy arg #2 (void* src)
 66645 push EAX
 66647 rstack EAX,EBP:3
// memcpy arg #1 (void* dest)
 66651 push EAX
 66653 mov ECX,3
// memcpy(...)
 66656 call 10006
 66659 add ESP,3
 66662 rstack EAX,EBP:3
// V=newpos
 66666 sstack EBP:2,EAX
 66670 rstack EAX,EBP:3
 66674 add EAX,#22842
 66677 mov EBX,EAX
// newpos=newpos+sizeof_vector
 66679 sstack EBP:3,EBX
 66683 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 66687 push EAX
 66689 rstack EAX,EBP:-2
// memcpy arg #2 (void* src)
 66693 push EAX
 66695 rstack EAX,EBP:3
// memcpy arg #1 (void* dest)
 66699 push EAX
 66701 mov ECX,3
// memcpy(...)
 66704 call 10006
 66707 add ESP,3
 66710 rstack EAX,EBP:-1
// vector_set_capacity arg #2 (float n)
 66714 push EAX
 66716 rstack EAX,EBP:2
// vector_set_capacity arg #1 (void* self)
 66720 push EAX
 66722 mov ECX,2
// vector_set_capacity(...)
 66725 call 23373
 66728 add ESP,2
 66731 rstack EAX,EBP:3
// vector_set_array arg #2 (float n)
 66735 push EAX
 66737 rstack EAX,EBP:2
// vector_set_array arg #1 (void* self)
 66741 push EAX
 66743 mov ECX,2
// vector_set_array(...)
 66746 call 23297
 66749 add ESP,2
 66752 rstack EAX,EBP:2
 66756 leave 
 66757 ret 
__2691:
 66758 leave 
 66759 ret 
vector_linearize:
// vector_linearize(V)
 66760 enter 2
__2694:
 66763 rstack EAX,EBP:2
// vector_get_linear_size arg #1 (float V)
 66767 push EAX
 66769 mov ECX,1
// vector_get_linear_size(...)
 66772 call 66560
 66775 add ESP,1
 66778 sstack EBP:-1,EAX
 66782 rstack EAX,EBP:-1
// malloc arg #1 (float n)
 66786 push EAX
 66788 mov ECX,1
// malloc(...)
 66791 call 20709
 66794 add ESP,1
 66797 sstack EBP:-2,EAX
 66801 rstack EAX,EBP:-2
// vector_move arg #2 (float* newpos)
 66805 push EAX
 66807 rstack EAX,EBP:2
// vector_move arg #1 (float* V)
 66811 push EAX
 66813 mov ECX,2
// vector_move(...)
 66816 call 66597
 66819 add ESP,2
 66822 rstack EAX,EBP:-2
 66826 leave 
 66827 ret 
__2693:
 66828 leave 
 66829 ret 
vector_delinearize:
// vector_delinearize(V)
 66830 enter 4
__2696:
// malloc arg #1 (float n)
 66833 push #22842
 66836 mov ECX,1
// malloc(...)
 66839 call 20709
 66842 add ESP,1
 66845 sstack EBP:-1,EAX
// memcpy arg #3 (float n)
 66849 push #22842
 66852 rstack EAX,EBP:2
// memcpy arg #2 (void* src)
 66856 push EAX
 66858 rstack EAX,EBP:-1
// memcpy arg #1 (void* dest)
 66862 push EAX
 66864 mov ECX,3
// memcpy(...)
 66867 call 10006
 66870 add ESP,3
 66873 rstack EAX,EBP:-1
// V=newV
 66877 sstack EBP:2,EAX
 66881 rstack EAX,EBP:2
// vector_get_size arg #1 (void* self)
 66885 push EAX
 66887 mov ECX,1
// vector_get_size(...)
 66890 call 23189
 66893 add ESP,1
 66896 sstack EBP:-2,EAX
 66900 rstack EAX,EBP:2
// vector_get_array arg #1 (void* self)
 66904 push EAX
 66906 mov ECX,1
// vector_get_array(...)
 66909 call 23153
 66912 add ESP,1
 66915 sstack EBP:-3,EAX
 66919 rstack EAX,EBP:-2
// malloc arg #1 (float n)
 66923 push EAX
 66925 mov ECX,1
// malloc(...)
 66928 call 20709
 66931 add ESP,1
 66934 sstack EBP:-4,EAX
 66938 rstack EAX,EBP:-2
// memcpy arg #3 (float n)
 66942 push EAX
 66944 rstack EAX,EBP:-3
// memcpy arg #2 (void* src)
 66948 push EAX
 66950 rstack EAX,EBP:-4
// memcpy arg #1 (void* dest)
 66954 push EAX
 66956 mov ECX,3
// memcpy(...)
 66959 call 10006
 66962 add ESP,3
 66965 rstack EAX,EBP:-4
// vector_set_array arg #2 (float n)
 66969 push EAX
 66971 rstack EAX,EBP:2
// vector_set_array arg #1 (void* self)
 66975 push EAX
 66977 mov ECX,2
// vector_set_array(...)
 66980 call 23297
 66983 add ESP,2
 66986 rstack EAX,EBP:2
 66990 leave 
 66991 ret 
__2695:
 66992 leave 
 66993 ret 
filesystem_get_size:
// filesystem_get_size()
 66994 enter 2
__2698:
 66997 sstack EBP:-1,200
 67002 sstack EBP:-2,0
// init loop
 67007 sstack EBP:-2,0
__2700:
 67012 rstack EAX,EBP:-2
 67016 mov EBX,100
 67019 sub EBX,EAX
 67021 fsgn EBX,EBX
// condition
 67023 max EBX,0
 67026 cmp 0,EBX
 67029 jz 67127
__2702:
 67032 rstack EAX,EBP:-2
 67036 add EAX,#64295
 67039 mov EBX,EAX
// if (files[I])
 67041 cmp 0,#EBX
 67044 jge 67114
 67047 rstack EAX,EBP:-2
 67051 add EAX,#64295
 67054 mov EBX,EAX
// vector_get_linear_size arg #1 (float V)
 67056 push #EBX
 67058 mov ECX,1
// vector_get_linear_size(...)
 67061 call 66560
 67064 add ESP,1
 67067 rstack EBX,EBP:-1
 67071 add EBX,EAX
 67073 mov EAX,EBX
// size=size+vector_get_linear_size(files[I])
 67075 sstack EBP:-1,EAX
 67079 rstack EAX,EBP:-2
 67083 add EAX,#64296
 67086 mov EBX,EAX
// strlen arg #1 (char* str)
 67088 push #EBX
 67090 mov ECX,1
// strlen(...)
 67093 call 10743
 67096 add ESP,1
 67099 add EAX,1
 67102 rstack EBX,EBP:-1
 67106 add EBX,EAX
 67108 mov EAX,EBX
// size=size+strlen(filenames[I])+1
 67110 sstack EBP:-1,EAX
__2703:
__2701:
 67114 rstack EAX,EBP:-2
// loop step
 67118 inc EAX
 67120 sstack EBP:-2,EAX
 67124 jmp 67012
__2699:
 67127 rstack EAX,EBP:-1
 67131 leave 
 67132 ret 
__2697:
 67133 leave 
 67134 ret 
inc_cpy:
// inc_cpy(ptr,from,size)
 67135 enter -0
__2705:
 67138 rstack EAX,EBP:4
// memcpy arg #3 (float n)
 67142 push EAX
 67144 rstack EAX,EBP:3
// memcpy arg #2 (void* src)
 67148 push EAX
 67150 rstack EAX,EBP:2
// memcpy arg #1 (void* dest)
 67154 push #EAX
 67156 mov ECX,3
// memcpy(...)
 67159 call 10006
 67162 add ESP,3
 67165 rstack EAX,EBP:4
 67169 rstack EBX,EBP:2
 67173 mov ECX,#EBX
 67175 add ECX,EAX
 67177 rstack EAX,EBP:2
// *ptr=*ptr+size
 67181 mov #EAX,ECX
__2704:
 67183 leave 
 67184 ret 
inc_move:
// inc_move(ptr,from,size)
 67185 enter 1
__2707:
 67188 rstack EAX,EBP:2
 67192 sstack EBP:-1,#EAX
 67196 rstack EAX,EBP:4
// inc_cpy arg #3 (float size)
 67200 push EAX
 67202 rstack EAX,EBP:3
// inc_cpy arg #2 (float from)
 67206 push #EAX
 67208 rstack EAX,EBP:2
// inc_cpy arg #1 (float* ptr)
 67212 push EAX
 67214 mov ECX,3
// inc_cpy(...)
 67217 call 67135
 67220 add ESP,3
 67223 rstack EAX,EBP:-1
 67227 rstack EBX,EBP:3
// *from=oldptr
 67231 mov #EBX,EAX
__2706:
 67233 leave 
 67234 ret 
filesystem_move:
// filesystem_move(newpos)
 67235 enter 6
__2709:
 67238 rstack EAX,EBP:2
 67242 sstack EBP:-1,EAX
 67246 sstack EBP:-2,#64295
 67251 sstack EBP:-3,#64296
// inc_move arg #3 (float size)
 67256 push 100
// inc_move arg #2 (float* from)
 67259 push 64295
 67262 mov EAX,SS:ESP
 67265 add EAX,-1
// inc_move arg #1 (float* ptr)
 67268 push EAX
 67270 mov ECX,3
// inc_move(...)
 67273 call 67185
 67276 add ESP,3
// inc_move arg #3 (float size)
 67279 push 100
// inc_move arg #2 (float* from)
 67282 push 64296
 67285 mov EAX,SS:ESP
 67288 add EAX,-1
// inc_move arg #1 (float* ptr)
 67291 push EAX
 67293 mov ECX,3
// inc_move(...)
 67296 call 67185
 67299 add ESP,3
// init loop
 67302 sstack EBP:-4,0
__2711:
 67307 rstack EAX,EBP:-4
 67311 mov EBX,100
 67314 sub EBX,EAX
 67316 fsgn EBX,EBX
// condition
 67318 max EBX,0
 67321 cmp 0,EBX
 67324 jz 67522
__2713:
 67327 rstack EAX,EBP:-4
 67331 add EAX,#64295
 67334 mov EBX,EAX
// if (files[I])
 67336 cmp 0,#EBX
 67339 jge 67509
 67342 rstack EAX,EBP:-4
 67346 add EAX,#64295
 67349 mov EBX,EAX
 67351 sstack EBP:-5,#EBX
 67355 rstack EAX,EBP:-5
// vector_get_linear_size arg #1 (float V)
 67359 push EAX
 67361 mov ECX,1
// vector_get_linear_size(...)
 67364 call 66560
 67367 add ESP,1
 67370 sstack EBP:-6,EAX
 67374 rstack EAX,EBP:-1
// vector_move arg #2 (float* newpos)
 67378 push EAX
 67380 rstack EAX,EBP:-5
// vector_move arg #1 (float* V)
 67384 push EAX
 67386 mov ECX,2
// vector_move(...)
 67389 call 66597
 67392 add ESP,2
// V=vector_move(V,ptr)
 67395 sstack EBP:-5,EAX
 67399 rstack EAX,EBP:-5
 67403 rstack EBX,EBP:-4
 67407 add EBX,#64295
 67410 mov ECX,EBX
// files[I]=V
 67412 mov #ECX,EAX
 67414 rstack EAX,EBP:-6
 67418 rstack EBX,EBP:-1
 67422 add EBX,EAX
 67424 mov EAX,EBX
// ptr=ptr+size
 67426 sstack EBP:-1,EAX
 67430 rstack EAX,EBP:-4
 67434 add EAX,#64296
 67437 mov EBX,EAX
// V=filenames[I]
 67439 sstack EBP:-5,#EBX
 67443 rstack EAX,EBP:-5
// strlen arg #1 (char* str)
 67447 push EAX
 67449 mov ECX,1
// strlen(...)
 67452 call 10743
 67455 add ESP,1
 67458 add EAX,1
// size=strlen(V)+1
 67461 sstack EBP:-6,EAX
 67465 rstack EAX,EBP:-1
 67469 rstack EBX,EBP:-4
 67473 add EBX,#64296
 67476 mov ECX,EBX
// filenames[I]=ptr
 67478 mov #ECX,EAX
 67480 rstack EAX,EBP:-6
// inc_cpy arg #3 (float size)
 67484 push EAX
 67486 rstack EAX,EBP:-5
// inc_cpy arg #2 (float from)
 67490 push EAX
 67492 mov EAX,SS:ESP
 67495 add EAX,-1
// inc_cpy arg #1 (float* ptr)
 67498 push EAX
 67500 mov ECX,3
// inc_cpy(...)
 67503 call 67135
 67506 add ESP,3
__2714:
__2712:
 67509 rstack EAX,EBP:-4
// loop step
 67513 inc EAX
 67515 sstack EBP:-4,EAX
 67519 jmp 67307
__2710:
 67522 rstack EAX,EBP:-2
// files=oldfiles
 67526 mov #64295,EAX
 67529 rstack EAX,EBP:-3
// filenames=oldfilenames
 67533 mov #64296,EAX
__2708:
 67536 leave 
 67537 ret 
filesystem_write:
// filesystem_write(disk)
 67538 enter 1
__2716:
// strcpy arg #2 (char* src)
 67541 push 67633
 67544 rstack EAX,EBP:2
// strcpy arg #1 (char* dest)
 67548 push EAX
 67550 mov ECX,2
// strcpy(...)
 67553 call 10585
 67556 add ESP,2
// strlen arg #1 (char* str)
 67559 push 67633
 67562 mov ECX,1
// strlen(...)
 67565 call 10743
 67568 add ESP,1
 67571 add EAX,1
 67574 rstack EBX,EBP:2
 67578 add EBX,EAX
 67580 mov EAX,EBX
// disk=disk+strlen("lightfs2")+1
 67582 sstack EBP:2,EAX
 67586 mov ECX,0
// filesystem_get_size(...)
 67589 call 66994
 67592 sstack EBP:-1,EAX
 67596 rstack EAX,EBP:-1
 67600 rstack EBX,EBP:2
// *disk=size
 67604 mov #EBX,EAX
 67606 rstack EAX,EBP:2
// disk++
 67610 inc EAX
 67612 sstack EBP:2,EAX
 67616 rstack EAX,EBP:2
// filesystem_move arg #1 (float newpos)
 67620 push EAX
 67622 mov ECX,1
// filesystem_move(...)
 67625 call 67235
 67628 add ESP,1
__2715:
 67631 leave 
 67632 ret 
__2717:
 67633 db "lightfs2",0
str_delinearize:
// str_delinearize(str)
 67642 enter 2
__2719:
 67645 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 67649 push EAX
 67651 mov ECX,1
// strlen(...)
 67654 call 10743
 67657 add ESP,1
 67660 sstack EBP:-1,EAX
 67664 rstack EAX,EBP:-1
 67668 add EAX,1
 67671 mov EBX,EAX
// malloc arg #1 (float n)
 67673 push EBX
 67675 mov ECX,1
// malloc(...)
 67678 call 20709
 67681 add ESP,1
 67684 sstack EBP:-2,EAX
 67688 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 67692 push EAX
 67694 rstack EAX,EBP:-2
// strcpy arg #1 (char* dest)
 67698 push EAX
 67700 mov ECX,2
// strcpy(...)
 67703 call 10585
 67706 add ESP,2
 67709 rstack EAX,EBP:-2
 67713 leave 
 67714 ret 
__2718:
 67715 leave 
 67716 ret 
filesystem_read:
// filesystem_read(disk)
 67717 enter 3
__2721:
__2723:
// strcmp arg #2 (char* dest)
 67720 push 67633
 67723 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 67727 push EAX
 67729 mov ECX,2
// strcmp(...)
 67732 call 10414
 67735 add ESP,2
// if (strcmp(disk,"lightfs2"))
 67738 cmp 0,EAX
 67741 jge 67761
// Print arg #2 (float col)
 67744 push 900
// Print arg #1 (char str)
 67747 push 68020
 67750 mov ECX,2
// Print(...)
 67753 call 40786
 67756 add ESP,2
 67759 leave 
 67760 ret 
__2724:
__2722:
// strlen arg #1 (char* str)
 67761 push 67633
 67764 mov ECX,1
// strlen(...)
 67767 call 10743
 67770 add ESP,1
 67773 add EAX,1
 67776 rstack EBX,EBP:2
 67780 add EBX,EAX
 67782 mov EAX,EBX
// disk=disk+strlen("lightfs2")+1
 67784 sstack EBP:2,EAX
 67788 rstack EAX,EBP:2
 67792 sstack EBP:-1,#EAX
 67796 rstack EAX,EBP:2
// disk++
 67800 inc EAX
 67802 sstack EBP:2,EAX
// memcpy arg #3 (float n)
 67806 push 100
 67809 rstack EAX,EBP:2
// memcpy arg #2 (void* src)
 67813 push EAX
// memcpy arg #1 (void* dest)
 67815 push #64295
 67818 mov ECX,3
// memcpy(...)
 67821 call 10006
 67824 add ESP,3
 67827 rstack EAX,EBP:2
 67831 add EAX,100
 67834 mov EBX,EAX
// disk=disk+100
 67836 sstack EBP:2,EBX
// memcpy arg #3 (float n)
 67840 push 100
 67843 rstack EAX,EBP:2
// memcpy arg #2 (void* src)
 67847 push EAX
// memcpy arg #1 (void* dest)
 67849 push #64296
 67852 mov ECX,3
// memcpy(...)
 67855 call 10006
 67858 add ESP,3
 67861 rstack EAX,EBP:2
 67865 add EAX,100
 67868 mov EBX,EAX
// disk=disk+100
 67870 sstack EBP:2,EBX
// init loop
 67874 sstack EBP:-2,0
__2727:
 67879 rstack EAX,EBP:-2
 67883 mov EBX,100
 67886 sub EBX,EAX
 67888 fsgn EBX,EBX
// condition
 67890 max EBX,0
 67893 cmp 0,EBX
 67896 jz 68018
 67899 rstack EAX,EBP:-2
 67903 add EAX,#64295
 67906 mov EBX,EAX
 67908 sstack EBP:-3,#EBX
__2729:
 67912 rstack EAX,EBP:-3
// if (V)
 67916 cmp 0,EAX
 67919 jge 68005
// assert_type arg #2 (float t)
 67922 push 25691
 67925 rstack EAX,EBP:-3
// assert_type arg #1 (float self)
 67929 push EAX
 67931 mov ECX,2
// assert_type(...)
 67934 call 37630
 67937 add ESP,2
 67940 rstack EAX,EBP:-3
// vector_delinearize arg #1 (float V)
 67944 push EAX
 67946 mov ECX,1
// vector_delinearize(...)
 67949 call 66830
 67952 add ESP,1
 67955 rstack EBX,EBP:-2
 67959 add EBX,#64295
 67962 mov ECX,EBX
// files[I]=vector_delinearize(V)
 67964 mov #ECX,EAX
 67966 rstack EAX,EBP:-2
 67970 add EAX,#64296
 67973 mov EBX,EAX
// V=filenames[I]
 67975 sstack EBP:-3,#EBX
 67979 rstack EAX,EBP:-3
// str_delinearize arg #1 (float str)
 67983 push EAX
 67985 mov ECX,1
// str_delinearize(...)
 67988 call 67642
 67991 add ESP,1
 67994 rstack EBX,EBP:-2
 67998 add EBX,#64296
 68001 mov ECX,EBX
// filenames[I]=str_delinearize(V)
 68003 mov #ECX,EAX
__2730:
__2728:
 68005 rstack EAX,EBP:-2
// loop step
 68009 inc EAX
 68011 sstack EBP:-2,EAX
 68015 jmp 67879
__2726:
__2720:
 68018 leave 
 68019 ret 
__2725:
 68020 db "Error: not a lightfs2 disk
",0
asm_str1:
 68048 alloc 80
asm_ident:
 68128 alloc 80
str:
 68208 alloc 1
str2:
 68209 alloc 1
fpin:
 68210 alloc 1
fpout:
 68211 alloc 1
assembler:
// assembler(infilepath,outfilepath)
 68212 enter 3
__2732:
// fopen arg #2 (char* mode)
 68215 push 40534
 68218 rstack EAX,EBP:2
// fopen arg #1 (char* filename)
 68222 push EAX
 68224 mov ECX,2
// fopen(...)
 68227 call 64589
 68230 add ESP,2
// fpin=fopen(infilepath,"r")
 68233 mov #68210,EAX
__2734:
 68236 mov EAX,#68210
 68239 lneg EAX
// if (!fpin)
 68241 cmp 0,EAX
 68244 jge 68261
// Perr arg #1 (char* str)
 68247 push 68679
 68250 mov ECX,1
// Perr(...)
 68253 call 40763
 68256 add ESP,1
 68259 leave 
 68260 ret 
__2735:
__2733:
// fopen arg #2 (char* mode)
 68261 push 46800
 68264 rstack EAX,EBP:3
// fopen arg #1 (char* filename)
 68268 push EAX
 68270 mov ECX,2
// fopen(...)
 68273 call 64589
 68276 add ESP,2
// fpout=fopen(outfilepath,"w")
 68279 mov #68211,EAX
__2738:
 68282 mov EAX,#68211
 68285 lneg EAX
// if (!fpout)
 68287 cmp 0,EAX
 68290 jge 68307
// Perr arg #1 (char* str)
 68293 push 68730
 68296 mov ECX,1
// Perr(...)
 68299 call 40763
 68302 add ESP,1
 68305 leave 
 68306 ret 
__2739:
__2737:
 68307 sstack EBP:-1,0
 68312 sstack EBP:-2,0
 68317 sstack EBP:-3,9999
// fgetstring arg #3 (float num)
 68322 push 80
// fgetstring arg #2 (float* str)
 68325 push 68048
// fgetstring arg #1 (float* fp)
 68328 push #68210
 68331 mov ECX,3
// fgetstring(...)
 68334 call 65513
 68337 add ESP,3
// str=fgetstring(fpin,asm_str1,80)
 68340 mov #68208,EAX
// str2=str
 68343 mov #68209,#68208
// init loop
 68347 sstack EBP:-1,0
__2742:
 68352 rstack EAX,EBP:-1
 68356 rstack EBX,EBP:-2
 68360 sub EBX,EAX
 68362 mov EAX,EBX
 68364 fsgn EAX,EAX
// condition
 68366 max EAX,0
 68369 cmp 0,EAX
 68372 jz 68413
// fgetstring arg #3 (float num)
 68375 push 80
// fgetstring arg #2 (float* str)
 68378 push 68048
// fgetstring arg #1 (float* fp)
 68381 push #68210
 68384 mov ECX,3
// fgetstring(...)
 68387 call 65513
 68390 add ESP,3
// str=fgetstring(fpin,asm_str1,80)
 68393 mov #68208,EAX
// str2=str
 68396 mov #68209,#68208
 68400 rstack EAX,EBP:-1
// loop step
 68404 inc EAX
 68406 sstack EBP:-1,EAX
 68410 jmp 68352
__2741:
__2744:
// if (str
 68413 cmp 0,#68208
 68417 jz 68677
// P2 arg #3 (char* str2)
 68420 push 68754
 68423 rstack EAX,EBP:-1
// P2 arg #2 (float N)
 68427 push EAX
// P2 arg #1 (char* str1)
 68429 push 68702
 68432 mov ECX,3
// P2(...)
 68435 call 40700
 68438 add ESP,3
// P arg #1 (char* str)
 68441 push #68208
 68444 mov ECX,1
// P(...)
 68447 call 40570
 68450 add ESP,1
// P arg #1 (char* str)
 68453 push 52806
 68456 mov ECX,1
// P(...)
 68459 call 40570
 68462 add ESP,1
__2748:
 68465 push 68208
 68468 mov ECX,1
// parse_acceptComment(...)
 68471 call 72124
 68474 add ESP,1
// if (parse_acceptComment(&str))
 68477 cmp 0,EAX
 68480 jge 68486
 68483 jmp 68612
__2749:
__2747:
__2751:
 68486 push 68208
 68489 mov ECX,1
// parse_acceptLabel(...)
 68492 call 72184
 68495 add ESP,1
// if (parse_acceptLabel(&str))
 68498 cmp 0,EAX
 68501 jge 68507
 68504 jmp 68612
__2752:
__2750:
__2754:
 68507 push 68208
 68510 mov ECX,1
// parse_acceptDb(...)
 68513 call 73023
 68516 add ESP,1
// if (parse_acceptDb(&str))
 68519 cmp 0,EAX
 68522 jge 68528
 68525 jmp 68612
__2755:
__2753:
__2757:
 68528 push 68208
 68531 mov ECX,1
// parse_acceptAlloc(...)
 68534 call 73550
 68537 add ESP,1
// if (parse_acceptAlloc(&str))
 68540 cmp 0,EAX
 68543 jge 68549
 68546 jmp 68612
__2758:
__2756:
__2760:
 68549 push 68208
 68552 mov ECX,1
// parse_acceptInstruction(...)
 68555 call 73658
 68558 add ESP,1
// if (parse_acceptInstruction(&str))
 68561 cmp 0,EAX
 68564 jge 68570
 68567 jmp 68612
__2761:
__2759:
parse_string_bad:
// Perr arg #1 (char* str)
 68570 push 68708
 68573 mov ECX,1
// Perr(...)
 68576 call 40763
 68579 add ESP,1
// Perr arg #1 (char* str)
 68582 push #68208
 68585 mov ECX,1
// Perr(...)
 68588 call 40763
 68591 add ESP,1
// Perr arg #1 (char* str)
 68594 push 52806
 68597 mov ECX,1
// Perr(...)
 68600 call 40763
 68603 add ESP,1
 68606 mov ECX,0
// shell_panic(...)
 68609 call 38246
parse_string_good:
 68612 rstack EAX,EBP:-1
// I++
 68616 inc EAX
 68618 sstack EBP:-1,EAX
__2764:
 68622 rstack EAX,EBP:-1
 68626 rstack EBX,EBP:-3
 68630 sub EBX,EAX
 68632 mov EAX,EBX
 68634 neg EAX
 68636 fsgn EAX,EAX
 68638 max EAX,0
// if (I>line_to)
 68641 cmp 0,EAX
 68644 jge 68649
 68647 leave 
 68648 ret 
__2765:
__2763:
// fgetstring arg #3 (float num)
 68649 push 80
// fgetstring arg #2 (float* str)
 68652 push 68048
// fgetstring arg #1 (float* fp)
 68655 push #68210
 68658 mov ECX,3
// fgetstring(...)
 68661 call 65513
 68664 add ESP,3
// str=fgetstring(fpin,asm_str1,80)
 68667 mov #68208,EAX
// str2=str
 68670 mov #68209,#68208
 68674 jmp 68413
__2743:
__2731:
 68677 leave 
 68678 ret 
__2736:
 68679 db "can't open input file
",0
__2745:
 68702 db "line ",0
__2762:
 68708 db "can't parse string: [",0
__2740:
 68730 db "can't open output file
",0
__2746:
 68754 db ": [",0
errDefault:
// errDefault()
 68758 enter -0
__2767:
// P arg #1 (char* str)
 68761 push 68802
 68764 mov ECX,1
// P(...)
 68767 call 40570
 68770 add ESP,1
// P arg #1 (char* str)
 68773 push #69216
 68776 mov ECX,1
// P(...)
 68779 call 40570
 68782 add ESP,1
// P arg #1 (char* str)
 68785 push 52806
 68788 mov ECX,1
// P(...)
 68791 call 40570
 68794 add ESP,1
 68797 jmp 68570
__2766:
 68800 leave 
 68801 ret 
__2768:
 68802 db "expected [",0
pointOutErr:
// pointOutErr()
 68813 enter 1
__2770:
 68816 mov EAX,#68208
 68819 add EAX,-68048
 68822 sstack EBP:-1,EAX
// P2 arg #3 (char* str2)
 68826 push 18244
 68829 rstack EAX,EBP:-1
// P2 arg #2 (float N)
 68833 push EAX
// P2 arg #1 (char* str1)
 68835 push 68921
 68838 mov ECX,3
// P2(...)
 68841 call 40700
 68844 add ESP,3
// P arg #1 (char* str)
 68847 push 68048
 68850 mov ECX,1
// P(...)
 68853 call 40570
 68856 add ESP,1
// P arg #1 (char* str)
 68859 push 18244
 68862 mov ECX,1
// P(...)
 68865 call 40570
 68868 add ESP,1
__2773:
 68871 rstack EAX,EBP:-1
 68875 mov EBX,EAX
 68877 dec EAX
 68879 sstack EBP:-1,EAX
// if (len--
 68883 cmp 0,EBX
 68886 jz 68904
// P arg #1 (char* str)
 68889 push 20361
 68892 mov ECX,1
// P(...)
 68895 call 40570
 68898 add ESP,1
 68901 jmp 68871
__2772:
// P arg #1 (char* str)
 68904 push 68918
 68907 mov ECX,1
// P(...)
 68910 call 40570
 68913 add ESP,1
__2769:
 68916 leave 
 68917 ret 
__2774:
 68918 db "^
",0
__2771:
 68921 db "len = ",0
caseless_strncmp:
// caseless_strncmp(str1,str2,n)
 68928 enter 5
__2776:
 68931 rstack EAX,EBP:2
 68935 sstack EBP:-1,EAX
 68939 rstack EAX,EBP:3
 68943 sstack EBP:-2,EAX
__2778:
 68947 rstack EAX,EBP:4
 68951 mov EBX,0
 68954 sub EBX,EAX
 68956 neg EBX
 68958 fsgn EBX,EBX
 68960 max EBX,0
// if (n>0
 68963 cmp 0,EBX
 68966 jz 69097
 68969 rstack EAX,EBP:-1
 68973 mov EBX,EAX
 68975 inc EAX
 68977 sstack EBP:-1,EAX
 68981 sstack EBP:-3,#EBX
 68985 rstack EAX,EBP:-2
 68989 mov EBX,EAX
 68991 inc EAX
 68993 sstack EBP:-2,EAX
 68997 sstack EBP:-4,#EBX
 69001 rstack EAX,EBP:-3
// toLower arg #1 (char C)
 69005 push EAX
 69007 mov ECX,1
// toLower(...)
 69010 call 14631
 69013 add ESP,1
// C1=toLower(C1)
 69016 sstack EBP:-3,EAX
 69020 rstack EAX,EBP:-4
// toLower arg #1 (char C)
 69024 push EAX
 69026 mov ECX,1
// toLower(...)
 69029 call 14631
 69032 add ESP,1
// C2=toLower(C2)
 69035 sstack EBP:-4,EAX
 69039 rstack EAX,EBP:-4
 69043 neg EAX
 69045 mov EBX,EAX
 69047 rstack EAX,EBP:-3
 69051 add EAX,EBX
 69053 mov EBX,EAX
 69055 sstack EBP:-5,EBX
__2780:
 69059 rstack EAX,EBP:-5
 69063 mov EBX,0
 69066 sub EBX,EAX
 69068 fabs EBX,EBX
 69070 fsgn EBX,EBX
// if (diff!=0)
 69072 cmp 0,EBX
 69075 jge 69084
 69078 rstack EAX,EBP:-5
 69082 leave 
 69083 ret 
__2781:
__2779:
 69084 rstack EAX,EBP:4
// n--
 69088 dec EAX
 69090 sstack EBP:4,EAX
 69094 jmp 68947
__2777:
 69097 mov EAX,0
 69100 leave 
 69101 ret 
__2775:
 69102 leave 
 69103 ret 
parse_accept:
// parse_accept(input,str)
 69104 enter 2
__2783:
 69107 rstack EAX,EBP:2
 69111 sstack EBP:-1,#EAX
 69115 rstack EAX,EBP:3
// strlen arg #1 (char* str)
 69119 push EAX
 69121 mov ECX,1
// strlen(...)
 69124 call 10743
 69127 add ESP,1
 69130 sstack EBP:-2,EAX
__2785:
 69134 rstack EAX,EBP:-2
// caseless_strncmp arg #3 (float n)
 69138 push EAX
 69140 rstack EAX,EBP:3
// caseless_strncmp arg #2 (float str2)
 69144 push EAX
 69146 rstack EAX,EBP:-1
// caseless_strncmp arg #1 (float str1)
 69150 push EAX
 69152 mov ECX,3
// caseless_strncmp(...)
 69155 call 68928
 69158 add ESP,3
 69161 mov EBX,0
 69164 sub EBX,EAX
 69166 fabs EBX,EBX
 69168 fsgn EBX,EBX
 69170 lneg EBX
// if (caseless_strncmp(inp,str,len)==0)
 69172 cmp 0,EBX
 69175 jge 69209
 69178 rstack EAX,EBP:-2
 69182 rstack EBX,EBP:-1
 69186 add EBX,EAX
 69188 mov EAX,EBX
// inp=inp+len
 69190 sstack EBP:-1,EAX
 69194 rstack EAX,EBP:-1
 69198 rstack EBX,EBP:2
// *input=inp
 69202 mov #EBX,EAX
 69204 mov EAX,1
 69207 leave 
 69208 ret 
__2786:
__2784:
 69209 mov EAX,0
 69212 leave 
 69213 ret 
__2782:
 69214 leave 
 69215 ret 
str_expected:
 69216 alloc 1
parse_expect:
// parse_expect(input,str,errfunc)
 69217 enter -0
__2788:
 69220 rstack EAX,EBP:3
// str_expected=str
 69224 mov #69216,EAX
__2790:
 69227 rstack EAX,EBP:3
// parse_accept arg #2 (float str)
 69231 push EAX
 69233 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 69237 push EAX
 69239 mov ECX,2
// parse_accept(...)
 69242 call 69104
 69245 add ESP,2
 69248 lneg EAX
// if (!parse_accept(input,str))
 69250 cmp 0,EAX
 69253 jge 69265
 69256 mov ECX,0
 69259 rstack EAX,EBP:4
// errfunc(...)
 69263 call EAX
__2791:
__2789:
__2787:
 69265 leave 
 69266 ret 
str2num2:
// str2num2(str,Iout)
 69267 enter 8
__2793:
 69270 sstack EBP:-1,0
 69275 sstack EBP:-2,0
 69280 sstack EBP:-3,0
 69285 sstack EBP:-4,0
 69290 sstack EBP:-5,0
 69295 sstack EBP:-6,0
 69300 sstack EBP:-7,10
 69305 rstack EAX,EBP:-2
 69309 rstack EBX,EBP:2
 69313 add EBX,EAX
 69315 mov EAX,EBX
 69317 sstack EBP:-8,#EAX
__2795:
 69321 rstack EAX,EBP:-8
 69325 mov EBX,0
 69328 sub EBX,EAX
 69330 fabs EBX,EBX
 69332 fsgn EBX,EBX
 69334 lneg EBX
// if (C==0)
 69336 cmp 0,EBX
 69339 jge 69348
 69342 jmp 70877
 69345 jmp 69556
__2797:
__2796:
__2799:
__2801:
 69348 rstack EAX,EBP:-8
 69352 mov EBX,45
 69355 sub EBX,EAX
 69357 fabs EBX,EBX
 69359 fsgn EBX,EBX
 69361 lneg EBX
// if (C=='-')
 69363 cmp 0,EBX
 69366 jge 69385
// Minus=1
 69369 sstack EBP:-4,1
 69374 rstack EAX,EBP:-2
// I+=1
 69378 add EAX,1
 69381 sstack EBP:-2,EAX
__2802:
__2800:
__2804:
 69385 rstack EAX,EBP:-8
 69389 mov EBX,48
 69392 sub EBX,EAX
 69394 fabs EBX,EBX
 69396 fsgn EBX,EBX
 69398 lneg EBX
// if (C=='0')
 69400 cmp 0,EBX
 69403 jge 69556
__2807:
 69406 rstack EAX,EBP:-2
 69410 add EAX,1
 69413 mov EBX,EAX
 69415 rstack EAX,EBP:2
 69419 add EAX,EBX
 69421 mov EBX,EAX
 69423 mov EAX,98
 69426 sub EAX,#EBX
 69428 fabs EAX,EAX
 69430 fsgn EAX,EAX
 69432 lneg EAX
// if (str[I+1]=='b')
 69434 cmp 0,EAX
 69437 jge 69456
// Base=2
 69440 sstack EBP:-7,2
 69445 rstack EAX,EBP:-2
// I+=2
 69449 add EAX,2
 69452 sstack EBP:-2,EAX
__2808:
__2806:
__2810:
 69456 rstack EAX,EBP:-2
 69460 add EAX,1
 69463 mov EBX,EAX
 69465 rstack EAX,EBP:2
 69469 add EAX,EBX
 69471 mov EBX,EAX
 69473 mov EAX,111
 69476 sub EAX,#EBX
 69478 fabs EAX,EAX
 69480 fsgn EAX,EAX
 69482 lneg EAX
// if (str[I+1]=='o')
 69484 cmp 0,EAX
 69487 jge 69506
// Base=8
 69490 sstack EBP:-7,8
 69495 rstack EAX,EBP:-2
// I+=2
 69499 add EAX,2
 69502 sstack EBP:-2,EAX
__2811:
__2809:
__2813:
 69506 rstack EAX,EBP:-2
 69510 add EAX,1
 69513 mov EBX,EAX
 69515 rstack EAX,EBP:2
 69519 add EAX,EBX
 69521 mov EBX,EAX
 69523 mov EAX,120
 69526 sub EAX,#EBX
 69528 fabs EAX,EAX
 69530 fsgn EAX,EAX
 69532 lneg EAX
// if (str[I+1]=='x')
 69534 cmp 0,EAX
 69537 jge 69556
// Base=16
 69540 sstack EBP:-7,16
 69545 rstack EAX,EBP:-2
// I+=2
 69549 add EAX,2
 69552 sstack EBP:-2,EAX
__2814:
__2812:
__2805:
__2803:
__2798:
__2794:
__2816:
 69556 rstack EAX,EBP:-1
 69560 lneg EAX
 69562 mov EBX,EAX
// if (!End
 69564 cmp 0,EBX
 69567 jz 70203
 69570 rstack EAX,EBP:-2
 69574 mov EBX,EAX
 69576 inc EAX
 69578 sstack EBP:-2,EAX
 69582 rstack EAX,EBP:2
 69586 add EAX,EBX
 69588 mov EBX,EAX
// C=str[I++]
 69590 sstack EBP:-8,#EBX
__2818:
 69594 rstack EAX,EBP:-8
 69598 mov EBX,0
 69601 sub EBX,EAX
 69603 fabs EBX,EBX
 69605 fsgn EBX,EBX
 69607 lneg EBX
// if (C==0)
 69609 cmp 0,EBX
 69612 jge 69623
// End=1
 69615 sstack EBP:-1,1
 69620 jmp 70200
__2820:
__2819:
__2822:
__2824:
 69623 rstack EAX,EBP:-8
 69627 mov EBX,46
 69630 sub EBX,EAX
 69632 fabs EBX,EBX
 69634 fsgn EBX,EBX
 69636 lneg EBX
// if (C=='.')
 69638 cmp 0,EBX
 69641 jge 69657
// End=1
 69644 sstack EBP:-1,1
// Frac=1
 69649 sstack EBP:-5,1
 69654 jmp 70200
__2826:
__2825:
__2828:
// N=-1
 69657 sstack EBP:-6,-1
__2830:
 69662 rstack EAX,EBP:-8
 69666 mov EBX,48
 69669 sub EBX,EAX
 69671 fabs EBX,EBX
 69673 fsgn EBX,EBX
 69675 lneg EBX
// if (C=='0')
 69677 cmp 0,EBX
 69680 jge 69688
// N=0
 69683 sstack EBP:-6,0
__2831:
__2829:
__2833:
 69688 rstack EAX,EBP:-8
 69692 mov EBX,49
 69695 sub EBX,EAX
 69697 fabs EBX,EBX
 69699 fsgn EBX,EBX
 69701 lneg EBX
// if (C=='1')
 69703 cmp 0,EBX
 69706 jge 69714
// N=1
 69709 sstack EBP:-6,1
__2834:
__2832:
__2836:
 69714 rstack EAX,EBP:-7
 69718 mov EBX,2
 69721 sub EBX,EAX
 69723 neg EBX
 69725 fsgn EBX,EBX
 69727 max EBX,0
// if (Base>2)
 69730 cmp 0,EBX
 69733 jge 70144
__2839:
 69736 rstack EAX,EBP:-8
 69740 mov EBX,50
 69743 sub EBX,EAX
 69745 fabs EBX,EBX
 69747 fsgn EBX,EBX
 69749 lneg EBX
// if (C=='2')
 69751 cmp 0,EBX
 69754 jge 69762
// N=2
 69757 sstack EBP:-6,2
__2840:
__2838:
__2842:
 69762 rstack EAX,EBP:-8
 69766 mov EBX,51
 69769 sub EBX,EAX
 69771 fabs EBX,EBX
 69773 fsgn EBX,EBX
 69775 lneg EBX
// if (C=='3')
 69777 cmp 0,EBX
 69780 jge 69788
// N=3
 69783 sstack EBP:-6,3
__2843:
__2841:
__2845:
 69788 rstack EAX,EBP:-8
 69792 mov EBX,52
 69795 sub EBX,EAX
 69797 fabs EBX,EBX
 69799 fsgn EBX,EBX
 69801 lneg EBX
// if (C=='4')
 69803 cmp 0,EBX
 69806 jge 69814
// N=4
 69809 sstack EBP:-6,4
__2846:
__2844:
__2848:
 69814 rstack EAX,EBP:-8
 69818 mov EBX,53
 69821 sub EBX,EAX
 69823 fabs EBX,EBX
 69825 fsgn EBX,EBX
 69827 lneg EBX
// if (C=='5')
 69829 cmp 0,EBX
 69832 jge 69840
// N=5
 69835 sstack EBP:-6,5
__2849:
__2847:
__2851:
 69840 rstack EAX,EBP:-8
 69844 mov EBX,54
 69847 sub EBX,EAX
 69849 fabs EBX,EBX
 69851 fsgn EBX,EBX
 69853 lneg EBX
// if (C=='6')
 69855 cmp 0,EBX
 69858 jge 69866
// N=6
 69861 sstack EBP:-6,6
__2852:
__2850:
__2854:
 69866 rstack EAX,EBP:-8
 69870 mov EBX,55
 69873 sub EBX,EAX
 69875 fabs EBX,EBX
 69877 fsgn EBX,EBX
 69879 lneg EBX
// if (C=='7')
 69881 cmp 0,EBX
 69884 jge 69892
// N=7
 69887 sstack EBP:-6,7
__2855:
__2853:
__2857:
 69892 rstack EAX,EBP:-7
 69896 mov EBX,8
 69899 sub EBX,EAX
 69901 neg EBX
 69903 fsgn EBX,EBX
 69905 max EBX,0
// if (Base>8)
 69908 cmp 0,EBX
 69911 jge 70144
__2860:
 69914 rstack EAX,EBP:-8
 69918 mov EBX,56
 69921 sub EBX,EAX
 69923 fabs EBX,EBX
 69925 fsgn EBX,EBX
 69927 lneg EBX
// if (C=='8')
 69929 cmp 0,EBX
 69932 jge 69940
// N=8
 69935 sstack EBP:-6,8
__2861:
__2859:
__2863:
 69940 rstack EAX,EBP:-8
 69944 mov EBX,57
 69947 sub EBX,EAX
 69949 fabs EBX,EBX
 69951 fsgn EBX,EBX
 69953 lneg EBX
// if (C=='9')
 69955 cmp 0,EBX
 69958 jge 69966
// N=9
 69961 sstack EBP:-6,9
__2864:
__2862:
__2866:
 69966 rstack EAX,EBP:-7
 69970 mov EBX,10
 69973 sub EBX,EAX
 69975 neg EBX
 69977 fsgn EBX,EBX
 69979 max EBX,0
// if (Base>10)
 69982 cmp 0,EBX
 69985 jge 70144
__2869:
 69988 rstack EAX,EBP:-8
 69992 mov EBX,65
 69995 sub EBX,EAX
 69997 fabs EBX,EBX
 69999 fsgn EBX,EBX
 70001 lneg EBX
// if (C=='A')
 70003 cmp 0,EBX
 70006 jge 70014
// N=10
 70009 sstack EBP:-6,10
__2870:
__2868:
__2872:
 70014 rstack EAX,EBP:-8
 70018 mov EBX,66
 70021 sub EBX,EAX
 70023 fabs EBX,EBX
 70025 fsgn EBX,EBX
 70027 lneg EBX
// if (C=='B')
 70029 cmp 0,EBX
 70032 jge 70040
// N=11
 70035 sstack EBP:-6,11
__2873:
__2871:
__2875:
 70040 rstack EAX,EBP:-8
 70044 mov EBX,67
 70047 sub EBX,EAX
 70049 fabs EBX,EBX
 70051 fsgn EBX,EBX
 70053 lneg EBX
// if (C=='C')
 70055 cmp 0,EBX
 70058 jge 70066
// N=12
 70061 sstack EBP:-6,12
__2876:
__2874:
__2878:
 70066 rstack EAX,EBP:-8
 70070 mov EBX,68
 70073 sub EBX,EAX
 70075 fabs EBX,EBX
 70077 fsgn EBX,EBX
 70079 lneg EBX
// if (C=='D')
 70081 cmp 0,EBX
 70084 jge 70092
// N=13
 70087 sstack EBP:-6,13
__2879:
__2877:
__2881:
 70092 rstack EAX,EBP:-8
 70096 mov EBX,69
 70099 sub EBX,EAX
 70101 fabs EBX,EBX
 70103 fsgn EBX,EBX
 70105 lneg EBX
// if (C=='E')
 70107 cmp 0,EBX
 70110 jge 70118
// N=14
 70113 sstack EBP:-6,14
__2882:
__2880:
__2884:
 70118 rstack EAX,EBP:-8
 70122 mov EBX,70
 70125 sub EBX,EAX
 70127 fabs EBX,EBX
 70129 fsgn EBX,EBX
 70131 lneg EBX
// if (C=='F')
 70133 cmp 0,EBX
 70136 jge 70144
// N=15
 70139 sstack EBP:-6,15
__2885:
__2883:
__2867:
__2865:
__2858:
__2856:
__2837:
__2835:
__2887:
 70144 rstack EAX,EBP:-6
 70148 mov EBX,-1
 70151 sub EBX,EAX
 70153 fabs EBX,EBX
 70155 fsgn EBX,EBX
 70157 lneg EBX
// if (N==-1)
 70159 cmp 0,EBX
 70162 jge 70178
// End=1
 70165 sstack EBP:-1,1
// Frac=0
 70170 sstack EBP:-5,0
 70175 jmp 70200
__2889:
__2888:
__2891:
 70178 rstack EAX,EBP:-6
 70182 rstack EBX,EBP:-7
 70186 rstack ECX,EBP:-3
 70190 mul ECX,EBX
 70192 mov EBX,ECX
 70194 add EBX,EAX
// Num=Num*Base+N
 70196 sstack EBP:-3,EBX
__2890:
__2886:
__2827:
__2823:
__2821:
__2817:
 70200 jmp 69556
__2815:
__2893:
 70203 rstack EAX,EBP:-5
 70207 mov EBX,1
 70210 sub EBX,EAX
 70212 fabs EBX,EBX
 70214 fsgn EBX,EBX
 70216 lneg EBX
// if (Frac==1)
 70218 cmp 0,EBX
 70221 jge 70818
// End=0
 70224 sstack EBP:-1,0
__2896:
 70229 rstack EAX,EBP:-1
 70233 lneg EAX
 70235 mov EBX,EAX
// if (!End
 70237 cmp 0,EBX
 70240 jz 70818
 70243 rstack EAX,EBP:-2
 70247 mov EBX,EAX
 70249 inc EAX
 70251 sstack EBP:-2,EAX
 70255 rstack EAX,EBP:2
 70259 add EAX,EBX
 70261 mov EBX,EAX
// C=str[I++]
 70263 sstack EBP:-8,#EBX
__2898:
 70267 rstack EAX,EBP:-8
 70271 mov EBX,0
 70274 sub EBX,EAX
 70276 fabs EBX,EBX
 70278 fsgn EBX,EBX
 70280 lneg EBX
// if (C==0)
 70282 cmp 0,EBX
 70285 jge 70296
// End=1
 70288 sstack EBP:-1,1
 70293 jmp 70815
__2900:
__2899:
__2902:
// N=0
 70296 sstack EBP:-6,0
__2904:
 70301 rstack EAX,EBP:-8
 70305 mov EBX,48
 70308 sub EBX,EAX
 70310 fabs EBX,EBX
 70312 fsgn EBX,EBX
 70314 lneg EBX
// if (C=='0')
 70316 cmp 0,EBX
 70319 jge 70327
// N=0
 70322 sstack EBP:-6,0
__2905:
__2903:
__2907:
 70327 rstack EAX,EBP:-8
 70331 mov EBX,49
 70334 sub EBX,EAX
 70336 fabs EBX,EBX
 70338 fsgn EBX,EBX
 70340 lneg EBX
// if (C=='1')
 70342 cmp 0,EBX
 70345 jge 70353
// N=1
 70348 sstack EBP:-6,1
__2908:
__2906:
__2910:
 70353 rstack EAX,EBP:-7
 70357 mov EBX,2
 70360 sub EBX,EAX
 70362 neg EBX
 70364 fsgn EBX,EBX
 70366 max EBX,0
// if (Base>2)
 70369 cmp 0,EBX
 70372 jge 70783
__2913:
 70375 rstack EAX,EBP:-8
 70379 mov EBX,50
 70382 sub EBX,EAX
 70384 fabs EBX,EBX
 70386 fsgn EBX,EBX
 70388 lneg EBX
// if (C=='2')
 70390 cmp 0,EBX
 70393 jge 70401
// N=2
 70396 sstack EBP:-6,2
__2914:
__2912:
__2916:
 70401 rstack EAX,EBP:-8
 70405 mov EBX,51
 70408 sub EBX,EAX
 70410 fabs EBX,EBX
 70412 fsgn EBX,EBX
 70414 lneg EBX
// if (C=='3')
 70416 cmp 0,EBX
 70419 jge 70427
// N=3
 70422 sstack EBP:-6,3
__2917:
__2915:
__2919:
 70427 rstack EAX,EBP:-8
 70431 mov EBX,52
 70434 sub EBX,EAX
 70436 fabs EBX,EBX
 70438 fsgn EBX,EBX
 70440 lneg EBX
// if (C=='4')
 70442 cmp 0,EBX
 70445 jge 70453
// N=4
 70448 sstack EBP:-6,4
__2920:
__2918:
__2922:
 70453 rstack EAX,EBP:-8
 70457 mov EBX,53
 70460 sub EBX,EAX
 70462 fabs EBX,EBX
 70464 fsgn EBX,EBX
 70466 lneg EBX
// if (C=='5')
 70468 cmp 0,EBX
 70471 jge 70479
// N=5
 70474 sstack EBP:-6,5
__2923:
__2921:
__2925:
 70479 rstack EAX,EBP:-8
 70483 mov EBX,54
 70486 sub EBX,EAX
 70488 fabs EBX,EBX
 70490 fsgn EBX,EBX
 70492 lneg EBX
// if (C=='6')
 70494 cmp 0,EBX
 70497 jge 70505
// N=6
 70500 sstack EBP:-6,6
__2926:
__2924:
__2928:
 70505 rstack EAX,EBP:-8
 70509 mov EBX,55
 70512 sub EBX,EAX
 70514 fabs EBX,EBX
 70516 fsgn EBX,EBX
 70518 lneg EBX
// if (C=='7')
 70520 cmp 0,EBX
 70523 jge 70531
// N=7
 70526 sstack EBP:-6,7
__2929:
__2927:
__2931:
 70531 rstack EAX,EBP:-7
 70535 mov EBX,8
 70538 sub EBX,EAX
 70540 neg EBX
 70542 fsgn EBX,EBX
 70544 max EBX,0
// if (Base>8)
 70547 cmp 0,EBX
 70550 jge 70783
__2934:
 70553 rstack EAX,EBP:-8
 70557 mov EBX,56
 70560 sub EBX,EAX
 70562 fabs EBX,EBX
 70564 fsgn EBX,EBX
 70566 lneg EBX
// if (C=='8')
 70568 cmp 0,EBX
 70571 jge 70579
// N=8
 70574 sstack EBP:-6,8
__2935:
__2933:
__2937:
 70579 rstack EAX,EBP:-8
 70583 mov EBX,57
 70586 sub EBX,EAX
 70588 fabs EBX,EBX
 70590 fsgn EBX,EBX
 70592 lneg EBX
// if (C=='9')
 70594 cmp 0,EBX
 70597 jge 70605
// N=9
 70600 sstack EBP:-6,9
__2938:
__2936:
__2940:
 70605 rstack EAX,EBP:-7
 70609 mov EBX,10
 70612 sub EBX,EAX
 70614 neg EBX
 70616 fsgn EBX,EBX
 70618 max EBX,0
// if (Base>10)
 70621 cmp 0,EBX
 70624 jge 70783
__2943:
 70627 rstack EAX,EBP:-8
 70631 mov EBX,65
 70634 sub EBX,EAX
 70636 fabs EBX,EBX
 70638 fsgn EBX,EBX
 70640 lneg EBX
// if (C=='A')
 70642 cmp 0,EBX
 70645 jge 70653
// N=10
 70648 sstack EBP:-6,10
__2944:
__2942:
__2946:
 70653 rstack EAX,EBP:-8
 70657 mov EBX,66
 70660 sub EBX,EAX
 70662 fabs EBX,EBX
 70664 fsgn EBX,EBX
 70666 lneg EBX
// if (C=='B')
 70668 cmp 0,EBX
 70671 jge 70679
// N=11
 70674 sstack EBP:-6,11
__2947:
__2945:
__2949:
 70679 rstack EAX,EBP:-8
 70683 mov EBX,67
 70686 sub EBX,EAX
 70688 fabs EBX,EBX
 70690 fsgn EBX,EBX
 70692 lneg EBX
// if (C=='C')
 70694 cmp 0,EBX
 70697 jge 70705
// N=12
 70700 sstack EBP:-6,12
__2950:
__2948:
__2952:
 70705 rstack EAX,EBP:-8
 70709 mov EBX,68
 70712 sub EBX,EAX
 70714 fabs EBX,EBX
 70716 fsgn EBX,EBX
 70718 lneg EBX
// if (C=='D')
 70720 cmp 0,EBX
 70723 jge 70731
// N=13
 70726 sstack EBP:-6,13
__2953:
__2951:
__2955:
 70731 rstack EAX,EBP:-8
 70735 mov EBX,69
 70738 sub EBX,EAX
 70740 fabs EBX,EBX
 70742 fsgn EBX,EBX
 70744 lneg EBX
// if (C=='E')
 70746 cmp 0,EBX
 70749 jge 70757
// N=14
 70752 sstack EBP:-6,14
__2956:
__2954:
__2958:
 70757 rstack EAX,EBP:-8
 70761 mov EBX,70
 70764 sub EBX,EAX
 70766 fabs EBX,EBX
 70768 fsgn EBX,EBX
 70770 lneg EBX
// if (C=='F')
 70772 cmp 0,EBX
 70775 jge 70783
// N=15
 70778 sstack EBP:-6,15
__2959:
__2957:
__2941:
__2939:
__2932:
__2930:
__2911:
__2909:
 70783 rstack EAX,EBP:-6
 70787 rstack EBX,EBP:-7
 70791 rstack ECX,EBP:-3
 70795 mul ECX,EBX
 70797 mov EBX,ECX
 70799 add EBX,EAX
// Num=Num*Base+N
 70801 sstack EBP:-3,EBX
 70805 rstack EAX,EBP:-5
// Frac++
 70809 inc EAX
 70811 sstack EBP:-5,EAX
__2901:
__2897:
 70815 jmp 70229
__2895:
__2894:
__2892:
__2961:
 70818 rstack EAX,EBP:-5
// if (Frac)
 70822 cmp 0,EAX
 70825 jge 70855
 70828 rstack EAX,EBP:-5
 70832 add EAX,-1
 70835 mov EBX,EAX
 70837 rstack EAX,EBP:-7
 70841 fpwr EAX,EBX
 70843 mov EBX,EAX
 70845 rstack EAX,EBP:-3
// Num/=(Base^^(Frac-1))
 70849 div EAX,EBX
 70851 sstack EBP:-3,EAX
__2962:
__2960:
__2964:
 70855 rstack EAX,EBP:-4
// if (Minus)
 70859 cmp 0,EAX
 70862 jge 70877
 70865 rstack EAX,EBP:-3
 70869 neg EAX
 70871 mov EBX,EAX
// Num=-Num
 70873 sstack EBP:-3,EBX
__2965:
__2963:
s2n2_exit:
 70877 rstack EAX,EBP:-2
 70881 add EAX,-1
 70884 mov EBX,EAX
 70886 rstack EAX,EBP:3
// *Iout=I-1
 70890 mov #EAX,EBX
 70892 rstack EAX,EBP:-3
 70896 leave 
 70897 ret 
__2792:
 70898 leave 
 70899 ret 
parse_acceptNum:
// parse_acceptNum(input,num)
 70900 enter 3
__2967:
 70903 rstack EAX,EBP:2
 70907 sstack EBP:-1,#EAX
 70911 sstack EBP:-2,0
 70916 sstack EBP:-3,-999
 70921 mov EAX,SS:ESP
 70924 add EAX,-2
// str2num2 arg #2 (float* Iout)
 70927 push EAX
 70929 rstack EAX,EBP:2
// str2num2 arg #1 (char* str)
 70933 push #EAX
 70935 mov ECX,2
// str2num2(...)
 70938 call 69267
 70941 add ESP,2
// n=str2num2(*input,&I)
 70944 sstack EBP:-3,EAX
__2969:
 70948 rstack EAX,EBP:-2
// if (I)
 70952 cmp 0,EAX
 70955 jge 70991
 70958 rstack EAX,EBP:-3
 70962 rstack EBX,EBP:3
// *num=n
 70966 mov #EBX,EAX
 70968 rstack EAX,EBP:-2
 70972 rstack EBX,EBP:2
 70976 mov ECX,#EBX
 70978 add ECX,EAX
 70980 rstack EAX,EBP:2
// *input=*input+I
 70984 mov #EAX,ECX
 70986 mov EAX,1
 70989 leave 
 70990 ret 
__2970:
__2968:
 70991 rstack EAX,EBP:-1
 70995 rstack EBX,EBP:2
// *input=inp
 70999 mov #EBX,EAX
 71001 mov EAX,0
 71004 leave 
 71005 ret 
__2966:
 71006 leave 
 71007 ret 
parse_expectNum:
// parse_expectNum(input,num,errfunc)
 71008 enter -0
__2972:
__2974:
 71011 rstack EAX,EBP:3
// parse_acceptNum arg #2 (float* num)
 71015 push EAX
 71017 rstack EAX,EBP:2
// parse_acceptNum arg #1 (float* input)
 71021 push EAX
 71023 mov ECX,2
// parse_acceptNum(...)
 71026 call 70900
 71029 add ESP,2
 71032 lneg EAX
// if (!parse_acceptNum(input,num))
 71034 cmp 0,EAX
 71037 jge 71049
 71040 mov ECX,0
 71043 rstack EAX,EBP:4
// errfunc(...)
 71047 call EAX
__2975:
__2973:
__2971:
 71049 leave 
 71050 ret 
parse_acceptSegment:
// parse_acceptSegment(input,seg)
 71051 enter 4
__2977:
 71054 rstack EAX,EBP:2
 71058 sstack EBP:-1,#EAX
// init loop
 71062 sstack EBP:-2,0
__2979:
 71067 rstack EAX,EBP:-2
 71071 mov EBX,16
 71074 sub EBX,EAX
 71076 fsgn EBX,EBX
// condition
 71078 max EBX,0
 71081 cmp 0,EBX
 71084 jz 71208
 71087 rstack EAX,EBP:-2
 71091 mov EBX,74137
 71094 add EBX,EAX
 71096 sstack EBP:-3,EBX
 71100 rstack EAX,EBP:-3
// seg_str=*seg_str
 71104 sstack EBP:-3,#EAX
__2981:
 71108 rstack EAX,EBP:-3
// parse_accept arg #2 (float str)
 71112 push EAX
 71114 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 71118 push EAX
 71120 mov ECX,2
// parse_accept(...)
 71123 call 69104
 71126 add ESP,2
// if (parse_accept(input,seg_str))
 71129 cmp 0,EAX
 71132 jge 71195
__2985:
// parse_accept arg #2 (float str)
 71135 push 71225
 71138 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 71142 push EAX
 71144 mov ECX,2
// parse_accept(...)
 71147 call 69104
 71150 add ESP,2
// if (parse_accept(input,":"))
 71153 cmp 0,EAX
 71156 jge 71195
 71159 rstack EAX,EBP:-2
 71163 add EAX,1
 71166 mov EBX,EAX
 71168 sstack EBP:-4,EBX
 71172 rstack EAX,EBP:-2
 71176 add EAX,1
 71179 mov EBX,EAX
 71181 rstack EAX,EBP:3
// *seg=I+1
 71185 mov #EAX,EBX
 71187 mov EAX,1
 71190 leave 
 71191 ret 
 71192 jmp 71195
__2987:
__2986:
__2989:
__2988:
__2984:
__2982:
__2980:
 71195 rstack EAX,EBP:-2
// loop step
 71199 inc EAX
 71201 sstack EBP:-2,EAX
 71205 jmp 71067
__2978:
 71208 rstack EAX,EBP:-1
 71212 rstack EBX,EBP:2
// *input=inp
 71216 mov #EBX,EAX
 71218 mov EAX,0
 71221 leave 
 71222 ret 
__2976:
 71223 leave 
 71224 ret 
__2983:
 71225 db ":",0
parse_acceptReg:
// parse_acceptReg(input,reg)
 71227 enter 4
__2991:
 71230 rstack EAX,EBP:2
 71234 sstack EBP:-1,#EAX
// init loop
 71238 sstack EBP:-2,0
__2993:
 71243 rstack EAX,EBP:-2
 71247 mov EBX,16
 71250 sub EBX,EAX
 71252 fsgn EBX,EBX
// condition
 71254 max EBX,0
 71257 cmp 0,EBX
 71260 jz 71352
 71263 rstack EAX,EBP:-2
 71267 mov EBX,74154
 71270 add EBX,EAX
 71272 sstack EBP:-3,EBX
 71276 rstack EAX,EBP:-3
// reg_str=*reg_str
 71280 sstack EBP:-3,#EAX
__2995:
 71284 rstack EAX,EBP:-3
// parse_accept arg #2 (float str)
 71288 push EAX
 71290 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 71294 push EAX
 71296 mov ECX,2
// parse_accept(...)
 71299 call 69104
 71302 add ESP,2
// if (parse_accept(input,reg_str))
 71305 cmp 0,EAX
 71308 jge 71339
 71311 rstack EAX,EBP:-2
 71315 add EAX,1
 71318 mov EBX,EAX
 71320 rstack EAX,EBP:3
// *reg=I+1
 71324 mov #EAX,EBX
 71326 rstack EAX,EBP:3
 71330 sstack EBP:-4,#EAX
 71334 mov EAX,1
 71337 leave 
 71338 ret 
__2996:
__2994:
 71339 rstack EAX,EBP:-2
// loop step
 71343 inc EAX
 71345 sstack EBP:-2,EAX
 71349 jmp 71243
__2992:
 71352 rstack EAX,EBP:-1
 71356 rstack EBX,EBP:2
// *input=inp
 71360 mov #EBX,EAX
 71362 mov EAX,0
 71365 leave 
 71366 ret 
__2990:
 71367 leave 
 71368 ret 
parse_acceptOperand:
// parse_acceptOperand(input,rm,seg,op)
 71369 enter 4
__2998:
 71372 rstack EAX,EBP:2
 71376 sstack EBP:-1,#EAX
 71380 sstack EBP:-2,0
 71385 sstack EBP:-3,0
 71390 sstack EBP:-4,0
 71395 rstack EAX,EBP:3
// *rm=0
 71399 mov #EAX,0
 71402 rstack EAX,EBP:4
// *seg=-4
 71406 mov #EAX,-4
 71409 rstack EAX,EBP:5
// *op=0
 71413 mov #EAX,0
 71416 rstack EAX,EBP:4
// parse_acceptSegment arg #2 (float* seg)
 71420 push EAX
 71422 rstack EAX,EBP:2
// parse_acceptSegment arg #1 (float* input)
 71426 push EAX
 71428 mov ECX,2
// parse_acceptSegment(...)
 71431 call 71051
 71434 add ESP,2
__3001:
// parse_accept arg #2 (float str)
 71437 push 71787
 71440 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 71444 push EAX
 71446 mov ECX,2
// parse_accept(...)
 71449 call 69104
 71452 add ESP,2
// if (parse_accept(input,"#"))
 71455 cmp 0,EAX
 71458 jge 71466
// memcell=1
 71461 sstack EBP:-2,1
__3002:
__3000:
__3004:
 71466 rstack EAX,EBP:5
// parse_acceptReg arg #2 (float* reg)
 71470 push EAX
 71472 rstack EAX,EBP:2
// parse_acceptReg arg #1 (float* input)
 71476 push EAX
 71478 mov ECX,2
// parse_acceptReg(...)
 71481 call 71227
 71484 add ESP,2
// if (parse_acceptReg(input,op))
 71487 cmp 0,EAX
 71490 jge 71501
// regnum=1
 71493 sstack EBP:-4,1
 71498 jmp 71533
__3006:
__3005:
__3008:
__3010:
 71501 rstack EAX,EBP:5
// parse_acceptNum arg #2 (float* num)
 71505 push EAX
 71507 rstack EAX,EBP:2
// parse_acceptNum arg #1 (float* input)
 71511 push EAX
 71513 mov ECX,2
// parse_acceptNum(...)
 71516 call 70900
 71519 add ESP,2
// if (parse_acceptNum(input,op))
 71522 cmp 0,EAX
 71525 jge 71533
// constnum=1
 71528 sstack EBP:-3,1
__3011:
__3009:
__3007:
__3003:
__3013:
 71533 rstack EAX,EBP:-3
 71537 lneg EAX
 71539 mov EBX,EAX
 71541 rstack EAX,EBP:-4
 71545 lneg EAX
 71547 mov ECX,EAX
 71549 and ECX,EBX
// if (!regnum&&!constnum)
 71551 cmp 0,ECX
 71554 jge 71572
 71557 rstack EAX,EBP:-1
 71561 rstack EBX,EBP:2
// *input=inp
 71565 mov #EBX,EAX
 71567 mov EAX,0
 71570 leave 
 71571 ret 
__3014:
__3012:
__3016:
 71572 rstack EAX,EBP:-3
 71576 rstack EBX,EBP:-4
 71580 and EBX,EAX
 71582 mov EAX,EBX
// if (regnum&&constnum)
 71584 cmp 0,EAX
 71587 jge 71608
// Perr arg #1 (char* str)
 71590 push 71789
 71593 mov ECX,1
// Perr(...)
 71596 call 40763
 71599 add ESP,1
 71602 mov ECX,0
// shell_panic(...)
 71605 call 38246
__3017:
__3015:
__3020:
 71608 rstack EAX,EBP:-3
// if (constnum)
 71612 cmp 0,EAX
 71615 jge 71674
__3023:
 71618 rstack EAX,EBP:-2
// if (memcell)
 71622 cmp 0,EAX
 71625 jge 71638
 71628 rstack EAX,EBP:3
// *rm=25
 71632 mov #EAX,25
 71635 jmp 71674
__3025:
__3024:
__3027:
__3029:
 71638 rstack EAX,EBP:4
 71642 mov EBX,-4
 71645 sub EBX,#EAX
 71647 fabs EBX,EBX
 71649 fsgn EBX,EBX
// if (*seg!=-4)
 71651 cmp 0,EBX
 71654 jge 71667
 71657 rstack EAX,EBP:3
// *rm=50
 71661 mov #EAX,50
 71664 jmp 71674
__3031:
__3030:
__3033:
 71667 rstack EAX,EBP:3
// *rm=0
 71671 mov #EAX,0
__3032:
__3028:
__3026:
__3022:
__3021:
__3019:
__3035:
 71674 rstack EAX,EBP:-4
// if (regnum)
 71678 cmp 0,EAX
 71681 jge 71780
__3038:
 71684 rstack EAX,EBP:-2
// if (memcell)
 71688 cmp 0,EAX
 71691 jge 71719
 71694 rstack EAX,EBP:5
 71698 mov EBX,#EAX
 71700 add EBX,16
 71703 rstack EAX,EBP:3
// *rm=*op+16
 71707 mov #EAX,EBX
 71709 rstack EAX,EBP:5
// *op=0
 71713 mov #EAX,0
 71716 jmp 71780
__3040:
__3039:
__3042:
__3044:
 71719 rstack EAX,EBP:4
 71723 mov EBX,-4
 71726 sub EBX,#EAX
 71728 fabs EBX,EBX
 71730 fsgn EBX,EBX
// if (*seg!=-4)
 71732 cmp 0,EBX
 71735 jge 71763
 71738 rstack EAX,EBP:5
 71742 mov EBX,#EAX
 71744 add EBX,25
 71747 rstack EAX,EBP:3
// *rm=*op+25
 71751 mov #EAX,EBX
 71753 rstack EAX,EBP:5
// *op=0
 71757 mov #EAX,0
 71760 jmp 71780
__3046:
__3045:
__3048:
 71763 rstack EAX,EBP:5
 71767 rstack EBX,EBP:3
// *rm=*op
 71771 mov #EBX,#EAX
 71773 rstack EAX,EBP:5
// *op=0
 71777 mov #EAX,0
__3047:
__3043:
__3041:
__3037:
__3036:
__3034:
 71780 mov EAX,1
 71783 leave 
 71784 ret 
__2997:
 71785 leave 
 71786 ret 
__2999:
 71787 db "#",0
__3018:
 71789 db "logic error",0
parse_expectOperand:
// parse_expectOperand(input,rm,seg,op,errfunc)
 71801 enter -0
__3050:
// str_expected="<operand>"
 71804 mov #69216,71860
__3053:
 71808 rstack EAX,EBP:5
// parse_acceptOperand arg #4 (float* op)
 71812 push EAX
 71814 rstack EAX,EBP:4
// parse_acceptOperand arg #3 (float* seg)
 71818 push EAX
 71820 rstack EAX,EBP:3
// parse_acceptOperand arg #2 (float* rm)
 71824 push EAX
 71826 rstack EAX,EBP:2
// parse_acceptOperand arg #1 (float* input)
 71830 push EAX
 71832 mov ECX,4
// parse_acceptOperand(...)
 71835 call 71369
 71838 add ESP,4
 71841 lneg EAX
// if (!parse_acceptOperand(input,rm,seg,op))
 71843 cmp 0,EAX
 71846 jge 71858
 71849 mov ECX,0
 71852 rstack EAX,EBP:6
// errfunc(...)
 71856 call EAX
__3054:
__3052:
__3049:
 71858 leave 
 71859 ret 
__3051:
 71860 db "<operand>",0
isIdent:
// isIdent(C)
 71870 enter -0
__3056:
__3058:
 71873 rstack EAX,EBP:2
// isAlpha arg #1 (char C)
 71877 push EAX
 71879 mov ECX,1
// isAlpha(...)
 71882 call 14560
 71885 add ESP,1
// if (isAlpha(C))
 71888 cmp 0,EAX
 71891 jge 71899
 71894 mov EAX,1
 71897 leave 
 71898 ret 
__3059:
__3057:
__3061:
 71899 rstack EAX,EBP:2
// isNum arg #1 (char C)
 71903 push EAX
 71905 mov ECX,1
// isNum(...)
 71908 call 14521
 71911 add ESP,1
// if (isNum(C))
 71914 cmp 0,EAX
 71917 jge 71925
 71920 mov EAX,1
 71923 leave 
 71924 ret 
__3062:
__3060:
__3064:
 71925 rstack EAX,EBP:2
 71929 mov EBX,95
 71932 sub EBX,EAX
 71934 fabs EBX,EBX
 71936 fsgn EBX,EBX
 71938 lneg EBX
// if (C=='_')
 71940 cmp 0,EBX
 71943 jge 71951
 71946 mov EAX,1
 71949 leave 
 71950 ret 
__3065:
__3063:
 71951 mov EAX,0
 71954 leave 
 71955 ret 
__3055:
 71956 leave 
 71957 ret 
parse_acceptIdent:
// parse_acceptIdent(input,id)
 71958 enter 3
__3067:
 71961 rstack EAX,EBP:2
 71965 sstack EBP:-1,#EAX
 71969 rstack EAX,EBP:2
 71973 sstack EBP:-2,#EAX
 71977 rstack EAX,EBP:3
 71981 sstack EBP:-3,EAX
__3069:
 71985 rstack EAX,EBP:-2
// isIdent arg #1 (char C)
 71989 push #EAX
 71991 mov ECX,1
// isIdent(...)
 71994 call 71870
 71997 add ESP,1
 72000 lneg EAX
// if (!isIdent(*inp2))
 72002 cmp 0,EAX
 72005 jge 72011
 72008 jmp 72107
__3070:
__3068:
__3072:
 72011 rstack EAX,EBP:-2
// isNum arg #1 (char C)
 72015 push #EAX
 72017 mov ECX,1
// isNum(...)
 72020 call 14521
 72023 add ESP,1
// if (isNum(*inp2))
 72026 cmp 0,EAX
 72029 jge 72035
 72032 jmp 72107
__3073:
__3071:
__3075:
 72035 rstack EAX,EBP:-2
// isIdent arg #1 (char C)
 72039 push #EAX
 72041 mov ECX,1
// isIdent(...)
 72044 call 71870
 72047 add ESP,1
// if (isIdent(*inp2)
 72050 cmp 0,EAX
 72053 jz 72085
 72056 rstack EAX,EBP:-2
 72060 mov EBX,EAX
 72062 inc EAX
 72064 sstack EBP:-2,EAX
 72068 rstack EAX,EBP:-3
 72072 mov ECX,EAX
 72074 inc EAX
 72076 sstack EBP:-3,EAX
// *ptr++=*inp2++
 72080 mov #ECX,#EBX
 72082 jmp 72035
__3074:
 72085 rstack EAX,EBP:-2
 72089 rstack EBX,EBP:2
// *input=inp2
 72093 mov #EBX,EAX
 72095 rstack EAX,EBP:-3
// *ptr=0
 72099 mov #EAX,0
 72102 mov EAX,1
 72105 leave 
 72106 ret 
pai_fail:
 72107 rstack EAX,EBP:-1
 72111 rstack EBX,EBP:2
// *input=inp
 72115 mov #EBX,EAX
 72117 mov EAX,0
 72120 leave 
 72121 ret 
__3066:
 72122 leave 
 72123 ret 
parse_acceptComment:
// parse_acceptComment(input)
 72124 enter 1
__3077:
 72127 rstack EAX,EBP:2
 72131 sstack EBP:-1,#EAX
__3080:
// parse_accept arg #2 (float str)
 72135 push 72181
 72138 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 72142 push EAX
 72144 mov ECX,2
// parse_accept(...)
 72147 call 69104
 72150 add ESP,2
// if (parse_accept(input,"//"))
 72153 cmp 0,EAX
 72156 jge 72164
 72159 mov EAX,1
 72162 leave 
 72163 ret 
__3081:
__3079:
 72164 rstack EAX,EBP:-1
 72168 rstack EBX,EBP:2
// *input=inp
 72172 mov #EBX,EAX
 72174 mov EAX,0
 72177 leave 
 72178 ret 
__3076:
 72179 leave 
 72180 ret 
__3078:
 72181 db "//",0
parse_acceptLabel:
// parse_acceptLabel(input)
 72184 enter 1
__3083:
 72187 rstack EAX,EBP:2
 72191 sstack EBP:-1,#EAX
__3085:
// parse_acceptIdent arg #2 (float* id)
 72195 push 68128
 72198 rstack EAX,EBP:2
// parse_acceptIdent arg #1 (float* input)
 72202 push EAX
 72204 mov ECX,2
// parse_acceptIdent(...)
 72207 call 71958
 72210 add ESP,2
// if (parse_acceptIdent(input,asm_ident))
 72213 cmp 0,EAX
 72216 jge 72248
__3088:
// parse_accept arg #2 (float str)
 72219 push 71225
 72222 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 72226 push EAX
 72228 mov ECX,2
// parse_accept(...)
 72231 call 69104
 72234 add ESP,2
// if (parse_accept(input,":"))
 72237 cmp 0,EAX
 72240 jge 72248
 72243 mov EAX,1
 72246 leave 
 72247 ret 
__3089:
__3087:
__3086:
__3084:
 72248 rstack EAX,EBP:-1
 72252 rstack EBX,EBP:2
// *input=inp
 72256 mov #EBX,EAX
 72258 mov EAX,0
 72261 leave 
 72262 ret 
__3082:
 72263 leave 
 72264 ret 
parse_acceptString:
// parse_acceptString(input,str)
 72265 enter 7
__3091:
 72268 rstack EAX,EBP:2
 72272 sstack EBP:-1,#EAX
 72276 rstack EAX,EBP:2
 72280 sstack EBP:-2,#EAX
 72284 sstack EBP:-3,0
 72289 sstack EBP:-4,0
__3093:
 72294 rstack EAX,EBP:-2
 72298 mov EBX,EAX
 72300 inc EAX
 72302 sstack EBP:-2,EAX
 72306 mov EAX,34
 72309 sub EAX,#EBX
 72311 fabs EAX,EAX
 72313 fsgn EAX,EAX
 72315 lneg EAX
// if (*I++=='"')
 72317 cmp 0,EAX
 72320 jge 72803
// malloc arg #1 (float n)
 72323 push #22842
 72326 mov ECX,1
// malloc(...)
 72329 call 20709
 72332 add ESP,1
// V=malloc(sizeof_vector)
 72335 sstack EBP:-4,EAX
// vector_constructor arg #2 (float element_size)
 72339 push 1
 72342 rstack EAX,EBP:-4
// vector_constructor arg #1 (void* self)
 72346 push EAX
 72348 mov ECX,2
// vector_constructor(...)
 72351 call 22843
 72354 add ESP,2
 72357 sstack EBP:-5,0
astr_loop:
 72362 rstack EAX,EBP:-2
 72366 mov EBX,EAX
 72368 inc EAX
 72370 sstack EBP:-2,EAX
 72374 sstack EBP:-6,#EBX
__3096:
 72378 rstack EAX,EBP:-6
 72382 mov EBX,26784
 72385 sub EBX,EAX
 72387 fabs EBX,EBX
 72389 fsgn EBX,EBX
 72391 lneg EBX
// if (C=="")
 72393 cmp 0,EBX
 72396 jge 72407
// escape=1
 72399 sstack EBP:-5,1
 72404 jmp 72362
__3097:
__3095:
__3099:
 72407 rstack EAX,EBP:-5
// if (escape)
 72411 cmp 0,EAX
 72414 jge 72669
__3102:
 72417 rstack EAX,EBP:-6
 72421 mov EBX,110
 72424 sub EBX,EAX
 72426 fabs EBX,EBX
 72428 fsgn EBX,EBX
 72430 lneg EBX
// if (C=='n')
 72432 cmp 0,EBX
 72435 jge 72459
// vector_push arg #2 (void* element)
 72438 push 10
 72441 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72445 push EAX
 72447 mov ECX,2
// vector_push(...)
 72450 call 23548
 72453 add ESP,2
 72456 jmp 72362
__3103:
__3101:
__3105:
 72459 rstack EAX,EBP:-6
 72463 mov EBX,48
 72466 sub EBX,EAX
 72468 fabs EBX,EBX
 72470 fsgn EBX,EBX
 72472 lneg EBX
// if (C=='0')
 72474 cmp 0,EBX
 72477 jge 72501
// vector_push arg #2 (void* element)
 72480 push 0
 72483 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72487 push EAX
 72489 mov ECX,2
// vector_push(...)
 72492 call 23548
 72495 add ESP,2
 72498 jmp 72362
__3106:
__3104:
__3108:
 72501 rstack EAX,EBP:-6
 72505 mov EBX,116
 72508 sub EBX,EAX
 72510 fabs EBX,EBX
 72512 fsgn EBX,EBX
 72514 lneg EBX
// if (C=='t')
 72516 cmp 0,EBX
 72519 jge 72543
// vector_push arg #2 (void* element)
 72522 push 9
 72525 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72529 push EAX
 72531 mov ECX,2
// vector_push(...)
 72534 call 23548
 72537 add ESP,2
 72540 jmp 72362
__3109:
__3107:
__3111:
 72543 rstack EAX,EBP:-6
 72547 mov EBX,34
 72550 sub EBX,EAX
 72552 fabs EBX,EBX
 72554 fsgn EBX,EBX
 72556 lneg EBX
// if (C=='"')
 72558 cmp 0,EBX
 72561 jge 72585
// vector_push arg #2 (void* element)
 72564 push 34
 72567 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72571 push EAX
 72573 mov ECX,2
// vector_push(...)
 72576 call 23548
 72579 add ESP,2
 72582 jmp 72362
__3112:
__3110:
__3114:
 72585 rstack EAX,EBP:-6
 72589 mov EBX,39
 72592 sub EBX,EAX
 72594 fabs EBX,EBX
 72596 fsgn EBX,EBX
 72598 lneg EBX
// if (C==''')
 72600 cmp 0,EBX
 72603 jge 72627
// vector_push arg #2 (void* element)
 72606 push 39
 72609 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72613 push EAX
 72615 mov ECX,2
// vector_push(...)
 72618 call 23548
 72621 add ESP,2
 72624 jmp 72362
__3115:
__3113:
__3117:
 72627 rstack EAX,EBP:-6
 72631 mov EBX,26784
 72634 sub EBX,EAX
 72636 fabs EBX,EBX
 72638 fsgn EBX,EBX
 72640 lneg EBX
// if (C=="")
 72642 cmp 0,EBX
 72645 jge 72669
// vector_push arg #2 (void* element)
 72648 push 26784
 72651 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72655 push EAX
 72657 mov ECX,2
// vector_push(...)
 72660 call 23548
 72663 add ESP,2
 72666 jmp 72362
__3118:
__3116:
__3100:
__3098:
__3120:
 72669 rstack EAX,EBP:-6
 72673 mov EBX,34
 72676 sub EBX,EAX
 72678 fabs EBX,EBX
 72680 fsgn EBX,EBX
 72682 lneg EBX
// if (C=='"')
 72684 cmp 0,EBX
 72687 jge 72693
 72690 jmp 72741
__3121:
__3119:
__3123:
 72693 rstack EAX,EBP:-6
 72697 mov EBX,0
 72700 sub EBX,EAX
 72702 fabs EBX,EBX
 72704 fsgn EBX,EBX
 72706 lneg EBX
// if (C==0)
 72708 cmp 0,EBX
 72711 jge 72717
 72714 jmp 72803
__3124:
__3122:
 72717 rstack EAX,EBP:-6
// vector_push arg #2 (void* element)
 72721 push EAX
 72723 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72727 push EAX
 72729 mov ECX,2
// vector_push(...)
 72732 call 23548
 72735 add ESP,2
 72738 jmp 72362
astr_endloop:
 72741 rstack EAX,EBP:-2
 72745 rstack EBX,EBP:2
// *input=I
 72749 mov #EBX,EAX
// vector_push arg #2 (void* element)
 72751 push 0
 72754 rstack EAX,EBP:-4
// vector_push arg #1 (void* self)
 72758 push EAX
 72760 mov ECX,2
// vector_push(...)
 72763 call 23548
 72766 add ESP,2
 72769 rstack EAX,EBP:-4
// vector_get_array arg #1 (void* self)
 72773 push EAX
 72775 mov ECX,1
// vector_get_array(...)
 72778 call 23153
 72781 add ESP,1
 72784 sstack EBP:-7,EAX
 72788 rstack EAX,EBP:-4
 72792 rstack EBX,EBP:3
// *str=V
 72796 mov #EBX,EAX
 72798 mov EAX,1
 72801 leave 
 72802 ret 
__3094:
__3092:
astr_fail:
__3126:
 72803 rstack EAX,EBP:-4
// if (V)
 72807 cmp 0,EAX
 72810 jge 72843
 72813 rstack EAX,EBP:-4
// vector_clear arg #1 (void* self)
 72817 push EAX
 72819 mov ECX,1
// vector_clear(...)
 72822 call 23492
 72825 add ESP,1
 72828 rstack EAX,EBP:-4
// free arg #1 (float* ptr)
 72832 push EAX
 72834 mov ECX,1
// free(...)
 72837 call 21231
 72840 add ESP,1
__3127:
__3125:
 72843 rstack EAX,EBP:-1
 72847 rstack EBX,EBP:2
// *input=inp
 72851 mov #EBX,EAX
 72853 mov EAX,0
 72856 leave 
 72857 ret 
__3090:
 72858 leave 
 72859 ret 
emit_code:
// emit_code(num)
 72860 enter -0
__3129:
// P2 arg #3 (char* str2)
 72863 push 18244
 72866 rstack EAX,EBP:2
// P2 arg #2 (float N)
 72870 push EAX
// P2 arg #1 (char* str1)
 72872 push 72959
 72875 mov ECX,3
// P2(...)
 72878 call 40700
 72881 add ESP,3
__3132:
// fwrite arg #3 (float* fp)
 72884 push #68211
// fwrite arg #2 (float size)
 72887 push 1
 72890 mov EAX,SS:ESP
 72893 add EAX,2
// fwrite arg #1 (float* from)
 72896 push EAX
 72898 mov ECX,3
// fwrite(...)
 72901 call 65070
 72904 add ESP,3
 72907 lneg EAX
// if (!fwrite(&num,1,fpout))
 72909 cmp 0,EAX
 72912 jge 72927
// Perr arg #1 (char* str)
 72915 push 72929
 72918 mov ECX,1
// Perr(...)
 72921 call 40763
 72924 add ESP,1
__3133:
__3131:
__3128:
 72927 leave 
 72928 ret 
__3134:
 72929 db "can't write into output file
",0
__3130:
 72959 db "emit ",0
emit_alloc:
// emit_alloc(num)
 72965 enter 1
__3136:
// init loop
 72968 sstack EBP:-1,0
__3138:
 72973 rstack EAX,EBP:-1
 72977 rstack EBX,EBP:2
 72981 sub EBX,EAX
 72983 mov EAX,EBX
 72985 fsgn EAX,EAX
// condition
 72987 max EAX,0
 72990 cmp 0,EAX
 72993 jz 73021
// emit_code arg #1 (float num)
 72996 push 0
 72999 mov ECX,1
// emit_code(...)
 73002 call 72860
 73005 add ESP,1
 73008 rstack EAX,EBP:-1
// loop step
 73012 inc EAX
 73014 sstack EBP:-1,EAX
 73018 jmp 72973
__3137:
__3135:
 73021 leave 
 73022 ret 
parse_acceptDb:
// parse_acceptDb(input)
 73023 enter 12
__3140:
 73026 rstack EAX,EBP:2
 73030 sstack EBP:-1,#EAX
// malloc arg #1 (float n)
 73034 push #22842
 73037 mov ECX,1
// malloc(...)
 73040 call 20709
 73043 add ESP,1
 73046 sstack EBP:-2,EAX
// vector_constructor arg #2 (float element_size)
 73050 push 1
 73053 rstack EAX,EBP:-2
// vector_constructor arg #1 (void* self)
 73057 push EAX
 73059 mov ECX,2
// vector_constructor(...)
 73062 call 22843
 73065 add ESP,2
__3143:
// parse_accept arg #2 (float str)
 73068 push 73544
 73071 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73075 push EAX
 73077 mov ECX,2
// parse_accept(...)
 73080 call 69104
 73083 add ESP,2
// if (parse_accept(input,"db "))
 73086 cmp 0,EAX
 73089 jge 73389
// strlen arg #1 (char* str)
 73092 push #68209
 73095 mov ECX,1
// strlen(...)
 73098 call 10743
 73101 add ESP,1
 73104 sstack EBP:-3,EAX
 73108 sstack EBP:-4,0
 73113 sstack EBP:-5,0
__3146:
// if (1
 73118 cmp 0,1
 73122 jz 73389
__3148:
 73125 mov EAX,SS:ESP
 73128 add EAX,-6
// parse_acceptNum arg #2 (float* num)
 73131 push EAX
 73133 rstack EAX,EBP:2
// parse_acceptNum arg #1 (float* input)
 73137 push EAX
 73139 mov ECX,2
// parse_acceptNum(...)
 73142 call 70900
 73145 add ESP,2
// if (parse_acceptNum(input,&num))
 73148 cmp 0,EAX
 73151 jge 73178
 73154 rstack EAX,EBP:-6
// vector_push arg #2 (void* element)
 73158 push EAX
 73160 rstack EAX,EBP:-2
// vector_push arg #1 (void* self)
 73164 push EAX
 73166 mov ECX,2
// vector_push(...)
 73169 call 23548
 73172 add ESP,2
 73175 jmp 73328
__3150:
__3149:
__3152:
__3154:
 73178 mov EAX,SS:ESP
 73181 add EAX,-7
// parse_acceptString arg #2 (float* str)
 73184 push EAX
 73186 rstack EAX,EBP:2
// parse_acceptString arg #1 (float* input)
 73190 push EAX
 73192 mov ECX,2
// parse_acceptString(...)
 73195 call 72265
 73198 add ESP,2
// if (parse_acceptString(input,&vstr))
 73201 cmp 0,EAX
 73204 jge 73325
 73207 rstack EAX,EBP:-7
// vector_get_array arg #1 (void* self)
 73211 push EAX
 73213 mov ECX,1
// vector_get_array(...)
 73216 call 23153
 73219 add ESP,1
 73222 sstack EBP:-8,EAX
 73226 rstack EAX,EBP:-8
 73230 mov EBX,EAX
 73232 inc EAX
 73234 sstack EBP:-8,EAX
 73238 sstack EBP:-9,#EBX
__3157:
 73242 rstack EAX,EBP:-9
// if (C
 73246 cmp 0,EAX
 73249 jz 73292
 73252 rstack EAX,EBP:-9
// vector_push arg #2 (void* element)
 73256 push EAX
 73258 rstack EAX,EBP:-2
// vector_push arg #1 (void* self)
 73262 push EAX
 73264 mov ECX,2
// vector_push(...)
 73267 call 23548
 73270 add ESP,2
 73273 rstack EAX,EBP:-8
 73277 mov EBX,EAX
 73279 inc EAX
 73281 sstack EBP:-8,EAX
// C=*strdata++
 73285 sstack EBP:-9,#EBX
 73289 jmp 73242
__3156:
 73292 rstack EAX,EBP:-7
// vector_clear arg #1 (void* self)
 73296 push EAX
 73298 mov ECX,1
// vector_clear(...)
 73301 call 23492
 73304 add ESP,1
 73307 rstack EAX,EBP:-7
// free arg #1 (float* ptr)
 73311 push EAX
 73313 mov ECX,1
// free(...)
 73316 call 21231
 73319 add ESP,1
 73322 jmp 73328
__3158:
__3155:
__3160:
 73325 jmp 73389
__3159:
__3153:
__3151:
__3147:
 73328 rstack EAX,EBP:-4
// nterms++
 73332 inc EAX
 73334 sstack EBP:-4,EAX
__3163:
// parse_accept arg #2 (float str)
 73338 push 73548
 73341 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73345 push EAX
 73347 mov ECX,2
// parse_accept(...)
 73350 call 69104
 73353 add ESP,2
// if (parse_accept(input,","))
 73356 cmp 0,EAX
 73359 jge 73362
__3164:
__3162:
__3166:
// parse_accept arg #2 (float str)
 73362 push 20361
 73365 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73369 push EAX
 73371 mov ECX,2
// parse_accept(...)
 73374 call 69104
 73377 add ESP,2
// if (parse_accept(input," "))
 73380 cmp 0,EAX
 73383 jge 73386
__3167:
__3165:
 73386 jmp 73118
__3145:
__3144:
__3142:
pa_db_exit:
 73389 rstack EAX,EBP:-2
// vector_get_size arg #1 (void* self)
 73393 push EAX
 73395 mov ECX,1
// vector_get_size(...)
 73398 call 23189
 73401 add ESP,1
 73404 sstack EBP:-10,EAX
__3169:
 73408 rstack EAX,EBP:-10
 73412 mov EBX,0
 73415 sub EBX,EAX
 73417 fabs EBX,EBX
 73419 fsgn EBX,EBX
 73421 lneg EBX
// if (size==0)
 73423 cmp 0,EBX
 73426 jge 73447
 73429 rstack EAX,EBP:-1
 73433 rstack EBX,EBP:2
// *input=inp
 73437 mov #EBX,EAX
 73439 mov EAX,0
 73442 leave 
 73443 ret 
 73444 jmp 73542
__3171:
__3170:
__3173:
 73447 sstack EBP:-11,0
// init loop
 73452 sstack EBP:-11,0
__3175:
 73457 rstack EAX,EBP:-11
 73461 rstack EBX,EBP:-10
 73465 sub EBX,EAX
 73467 mov EAX,EBX
 73469 fsgn EAX,EAX
// condition
 73471 max EAX,0
 73474 cmp 0,EAX
 73477 jz 73537
 73480 rstack EAX,EBP:-11
// vector_get arg #3 (float pos)
 73484 push EAX
 73486 mov EAX,SS:ESP
 73489 add EAX,-12
// vector_get arg #2 (void* element)
 73492 push EAX
 73494 rstack EAX,EBP:-2
// vector_get arg #1 (void* self)
 73498 push EAX
 73500 mov ECX,3
// vector_get(...)
 73503 call 24205
 73506 add ESP,3
 73509 rstack EAX,EBP:-12
// emit_code arg #1 (float num)
 73513 push EAX
 73515 mov ECX,1
// emit_code(...)
 73518 call 72860
 73521 add ESP,1
 73524 rstack EAX,EBP:-11
// loop step
 73528 inc EAX
 73530 sstack EBP:-11,EAX
 73534 jmp 73457
__3174:
 73537 mov EAX,1
 73540 leave 
 73541 ret 
__3172:
__3168:
__3139:
 73542 leave 
 73543 ret 
__3141:
 73544 db "db ",0
__3161:
 73548 db ",",0
parse_acceptAlloc:
// parse_acceptAlloc(input)
 73550 enter 2
__3177:
 73553 rstack EAX,EBP:2
 73557 sstack EBP:-1,#EAX
__3180:
// parse_accept arg #2 (float str)
 73561 push 73651
 73564 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73568 push EAX
 73570 mov ECX,2
// parse_accept(...)
 73573 call 69104
 73576 add ESP,2
// if (parse_accept(input,"alloc "))
 73579 cmp 0,EAX
 73582 jge 73634
__3183:
 73585 mov EAX,SS:ESP
 73588 add EAX,-2
// parse_acceptNum arg #2 (float* num)
 73591 push EAX
 73593 rstack EAX,EBP:2
// parse_acceptNum arg #1 (float* input)
 73597 push EAX
 73599 mov ECX,2
// parse_acceptNum(...)
 73602 call 70900
 73605 add ESP,2
// if (parse_acceptNum(input,&num))
 73608 cmp 0,EAX
 73611 jge 73634
 73614 rstack EAX,EBP:-2
// emit_alloc arg #1 (float num)
 73618 push EAX
 73620 mov ECX,1
// emit_alloc(...)
 73623 call 72965
 73626 add ESP,1
 73629 mov EAX,1
 73632 leave 
 73633 ret 
__3184:
__3182:
__3181:
__3179:
 73634 rstack EAX,EBP:-1
 73638 rstack EBX,EBP:2
// *input=inp
 73642 mov #EBX,EAX
 73644 mov EAX,0
 73647 leave 
 73648 ret 
__3176:
 73649 leave 
 73650 ret 
__3178:
 73651 db "alloc ",0
parse_acceptInstruction:
// parse_acceptInstruction(input)
 73658 enter 9
__3186:
 73661 rstack EAX,EBP:2
 73665 sstack EBP:-1,#EAX
__3188:
 73669 mov EAX,SS:ESP
 73672 add EAX,-2
 73675 push EAX
 73677 rstack EAX,EBP:2
 73681 push EAX
 73683 mov ECX,2
// parse_acceptCmd(...)
 73686 call 73977
 73689 add ESP,2
// if (parse_acceptCmd(input,&cmd))
 73692 cmp 0,EAX
 73695 jge 73960
// parse_accept arg #2 (float str)
 73698 push 20361
 73701 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73705 push EAX
 73707 mov ECX,2
// parse_accept(...)
 73710 call 69104
 73713 add ESP,2
// parse_acceptOperand arg #5 (unknown)
 73716 push 68758
 73719 mov EAX,SS:ESP
 73722 add EAX,-5
// parse_acceptOperand arg #4 (float* op)
 73725 push EAX
 73727 mov EAX,SS:ESP
 73730 add EAX,-4
// parse_acceptOperand arg #3 (float* seg)
 73733 push EAX
 73735 mov EAX,SS:ESP
 73738 add EAX,-3
// parse_acceptOperand arg #2 (float* rm)
 73741 push EAX
 73743 rstack EAX,EBP:2
// parse_acceptOperand arg #1 (float* input)
 73747 push EAX
 73749 mov ECX,5
// parse_acceptOperand(...)
 73752 call 71369
 73755 add ESP,5
// parse_accept arg #3 (unknown)
 73758 push 68758
// parse_accept arg #2 (float str)
 73761 push 73548
 73764 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73768 push EAX
 73770 mov ECX,3
// parse_accept(...)
 73773 call 69104
 73776 add ESP,3
// parse_accept arg #2 (float str)
 73779 push 20361
 73782 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 73786 push EAX
 73788 mov ECX,2
// parse_accept(...)
 73791 call 69104
 73794 add ESP,2
// parse_acceptOperand arg #5 (unknown)
 73797 push 68758
 73800 mov EAX,SS:ESP
 73803 add EAX,-8
// parse_acceptOperand arg #4 (float* op)
 73806 push EAX
 73808 mov EAX,SS:ESP
 73811 add EAX,-7
// parse_acceptOperand arg #3 (float* seg)
 73814 push EAX
 73816 mov EAX,SS:ESP
 73819 add EAX,-6
// parse_acceptOperand arg #2 (float* rm)
 73822 push EAX
 73824 rstack EAX,EBP:2
// parse_acceptOperand arg #1 (float* input)
 73828 push EAX
 73830 mov ECX,5
// parse_acceptOperand(...)
 73833 call 71369
 73836 add ESP,5
 73839 rstack EAX,EBP:-6
 73843 mov EBX,10000
 73846 mul EBX,EAX
 73848 rstack EAX,EBP:-3
 73852 add EAX,EBX
 73854 mov EBX,EAX
 73856 sstack EBP:-9,EBX
 73860 rstack EAX,EBP:-2
 73864 mov EBX,2000
 73867 add EBX,EAX
// emit_code arg #1 (float num)
 73869 push EBX
 73871 mov ECX,1
// emit_code(...)
 73874 call 72860
 73877 add ESP,1
 73880 rstack EAX,EBP:-9
// emit_code arg #1 (float num)
 73884 push EAX
 73886 mov ECX,1
// emit_code(...)
 73889 call 72860
 73892 add ESP,1
 73895 rstack EAX,EBP:-4
// emit_code arg #1 (float num)
 73899 push EAX
 73901 mov ECX,1
// emit_code(...)
 73904 call 72860
 73907 add ESP,1
 73910 rstack EAX,EBP:-7
// emit_code arg #1 (float num)
 73914 push EAX
 73916 mov ECX,1
// emit_code(...)
 73919 call 72860
 73922 add ESP,1
 73925 rstack EAX,EBP:-5
// emit_code arg #1 (float num)
 73929 push EAX
 73931 mov ECX,1
// emit_code(...)
 73934 call 72860
 73937 add ESP,1
 73940 rstack EAX,EBP:-8
// emit_code arg #1 (float num)
 73944 push EAX
 73946 mov ECX,1
// emit_code(...)
 73949 call 72860
 73952 add ESP,1
 73955 mov EAX,1
 73958 leave 
 73959 ret 
__3189:
__3187:
 73960 rstack EAX,EBP:-1
 73964 rstack EBX,EBP:2
// *input=inp
 73968 mov #EBX,EAX
 73970 mov EAX,0
 73973 leave 
 73974 ret 
__3185:
 73975 leave 
 73976 ret 
parse_acceptCmd:
// parse_acceptCmd(input,cmd)
 73977 enter 5
__3191:
 73980 rstack EAX,EBP:2
 73984 sstack EBP:-1,#EAX
// init loop
 73988 sstack EBP:-2,0
__3193:
 73993 rstack EAX,EBP:-2
 73997 mov EBX,166
 74000 sub EBX,EAX
 74002 fsgn EBX,EBX
// condition
 74004 max EBX,0
 74007 cmp 0,EBX
 74010 jz 74120
 74013 rstack EAX,EBP:-2
 74017 mov EBX,2
 74020 mul EBX,EAX
 74022 sstack EBP:-3,EBX
 74026 rstack EAX,EBP:-3
 74030 add EAX,1
 74033 mov EBX,EAX
 74035 mov EAX,74227
 74038 add EAX,EBX
 74040 sstack EBP:-4,EAX
 74044 rstack EAX,EBP:-4
// cmd_str=*cmd_str
 74048 sstack EBP:-4,#EAX
__3195:
 74052 rstack EAX,EBP:-4
// parse_accept arg #2 (float str)
 74056 push EAX
 74058 rstack EAX,EBP:2
// parse_accept arg #1 (float* input)
 74062 push EAX
 74064 mov ECX,2
// parse_accept(...)
 74067 call 69104
 74070 add ESP,2
// if (parse_accept(input,cmd_str))
 74073 cmp 0,EAX
 74076 jge 74107
 74079 rstack EAX,EBP:-3
 74083 add EAX,74227
 74086 mov EBX,EAX
 74088 rstack EAX,EBP:3
// *cmd=cmdTable[idx]
 74092 mov #EAX,#EBX
 74094 rstack EAX,EBP:3
 74098 sstack EBP:-5,#EAX
 74102 mov EAX,1
 74105 leave 
 74106 ret 
__3196:
__3194:
 74107 rstack EAX,EBP:-2
// loop step
 74111 inc EAX
 74113 sstack EBP:-2,EAX
 74117 jmp 73993
__3192:
 74120 rstack EAX,EBP:-1
 74124 rstack EBX,EBP:2
// *input=inp
 74128 mov #EBX,EAX
 74130 mov EAX,0
 74133 leave 
 74134 ret 
__3190:
 74135 leave 
 74136 ret 
segTable:
 74137 db 74203
 74138 db 74206
 74139 db 74209
 74140 db 74212
 74141 db 74215
 74142 db 74218
 74143 db 74221
 74144 db 74224
 74145 db 74171
 74146 db 74175
 74147 db 74179
 74148 db 74183
 74149 db 74187
 74150 db 74191
 74151 db 74195
 74152 db 74199
 74153 db 0
regTable:
 74154 db 74171
 74155 db 74175
 74156 db 74179
 74157 db 74183
 74158 db 74187
 74159 db 74191
 74160 db 74195
 74161 db 74199
 74162 db 74203
 74163 db 74206
 74164 db 74209
 74165 db 74212
 74166 db 74215
 74167 db 74218
 74168 db 74221
 74169 db 74224
 74170 db 0
str_eax:
 74171 db "EAX",0
str_ebx:
 74175 db "EBX",0
str_ecx:
 74179 db "ECX",0
str_edx:
 74183 db "EDX",0
str_esi:
 74187 db "ESI",0
str_edi:
 74191 db "EDI",0
str_esp:
 74195 db "ESP",0
str_ebp:
 74199 db "EBP",0
str_cs:
 74203 db "CS",0
str_ss:
 74206 db "SS",0
str_ds:
 74209 db "DS",0
str_es:
 74212 db "ES",0
str_gs:
 74215 db "GS",0
str_fs:
 74218 db "FS",0
str_ks:
 74221 db "KS",0
str_ls:
 74224 db "LS",0
cmdTable:
 74227 db 0
 74228 db 74563
 74229 db 1
 74230 db 74568
 74231 db 1
 74232 db 74572
 74233 db 2
 74234 db 74576
 74235 db 3
 74236 db 74580
 74237 db 3
 74238 db 74583
 74239 db 4
 74240 db 74588
 74241 db 4
 74242 db 74592
 74243 db 5
 74244 db 74596
 74245 db 5
 74246 db 74599
 74247 db 6
 74248 db 74604
 74249 db 6
 74250 db 74608
 74251 db 7
 74252 db 74612
 74253 db 7
 74254 db 74615
 74255 db 8
 74256 db 74618
 74257 db 9
 74258 db 74624
 74259 db 10
 74260 db 74629
 74261 db 11
 74262 db 74633
 74263 db 12
 74264 db 74637
 74265 db 13
 74266 db 74641
 74267 db 14
 74268 db 74645
 74269 db 15
 74270 db 74649
 74271 db 18
 74272 db 74653
 74273 db 19
 74274 db 74657
 74275 db 20
 74276 db 74661
 74277 db 21
 74278 db 74665
 74279 db 22
 74280 db 74669
 74281 db 23
 74282 db 74673
 74283 db 24
 74284 db 74678
 74285 db 25
 74286 db 74683
 74287 db 26
 74288 db 74689
 74289 db 27
 74290 db 74695
 74291 db 28
 74292 db 74701
 74293 db 29
 74294 db 74705
 74295 db 30
 74296 db 74709
 74297 db 31
 74298 db 74713
 74299 db 32
 74300 db 74718
 74301 db 33
 74302 db 74723
 74303 db 34
 74304 db 74728
 74305 db 35
 74306 db 74733
 74307 db 36
 74308 db 74739
 74309 db 38
 74310 db 74744
 74311 db 39
 74312 db 74749
 74313 db 40
 74314 db 74754
 74315 db 41
 74316 db 74758
 74317 db 42
 74318 db 74763
 74319 db 43
 74320 db 74767
 74321 db 47
 74322 db 74771
 74323 db 48
 74324 db 74776
 74325 db 49
 74326 db 74781
 74327 db 50
 74328 db 74786
 74329 db 51
 74330 db 74790
 74331 db 52
 74332 db 74793
 74333 db 53
 74334 db 74797
 74335 db 54
 74336 db 74802
 74337 db 55
 74338 db 74807
 74339 db 56
 74340 db 74812
 74341 db 57
 74342 db 74818
 74343 db 58
 74344 db 74824
 74345 db 59
 74346 db 74830
 74347 db 60
 74348 db 74834
 74349 db 61
 74350 db 74838
 74351 db 62
 74352 db 74843
 74353 db 63
 74354 db 74848
 74355 db 64
 74356 db 74853
 74357 db 65
 74358 db 74858
 74359 db 66
 74360 db 74862
 74361 db 67
 74362 db 74867
 74363 db 68
 74364 db 74872
 74365 db 69
 74366 db 74877
 74367 db 70
 74368 db 74882
 74369 db 71
 74370 db 74889
 74371 db 73
 74372 db 74893
 74373 db 73
 74374 db 74896
 74375 db 74
 74376 db 74901
 74377 db 74
 74378 db 74905
 74379 db 75
 74380 db 74909
 74381 db 75
 74382 db 74912
 74383 db 76
 74384 db 74917
 74385 db 76
 74386 db 74921
 74387 db 77
 74388 db 74925
 74389 db 77
 74390 db 74928
 74391 db 78
 74392 db 74931
 74393 db 79
 74394 db 74937
 74395 db 80
 74396 db 74943
 74397 db 81
 74398 db 74948
 74399 db 82
 74400 db 74953
 74401 db 83
 74402 db 74957
 74403 db 84
 74404 db 74964
 74405 db 85
 74406 db 74967
 74407 db 86
 74408 db 74971
 74409 db 87
 74410 db 74976
 74411 db 88
 74412 db 74981
 74413 db 89
 74414 db 74986
 74415 db 90
 74416 db 74992
 74417 db 91
 74418 db 74996
 74419 db 92
 74420 db 74999
 74421 db 93
 74422 db 75003
 74423 db 94
 74424 db 75007
 74425 db 95
 74426 db 75013
 74427 db 96
 74428 db 75018
 74429 db 97
 74430 db 75023
 74431 db 98
 74432 db 75028
 74433 db 99
 74434 db 75034
 74435 db 101
 74436 db 75040
 74437 db 101
 74438 db 75045
 74439 db 102
 74440 db 75050
 74441 db 103
 74442 db 75055
 74443 db 103
 74444 db 75059
 74445 db 104
 74446 db 75065
 74447 db 104
 74448 db 75070
 74449 db 105
 74450 db 75075
 74451 db 105
 74452 db 75079
 74453 db 106
 74454 db 75085
 74455 db 106
 74456 db 75090
 74457 db 107
 74458 db 75095
 74459 db 107
 74460 db 75099
 74461 db 108
 74462 db 75103
 74463 db 110
 74464 db 75108
 74465 db 111
 74466 db 75115
 74467 db 112
 74468 db 75120
 74469 db 114
 74470 db 75124
 74471 db 115
 74472 db 75130
 74473 db 116
 74474 db 75135
 74475 db 117
 74476 db 75140
 74477 db 118
 74478 db 75146
 74479 db 119
 74480 db 75150
 74481 db 120
 74482 db 75154
 74483 db 121
 74484 db 75161
 74485 db 122
 74486 db 75168
 74487 db 123
 74488 db 75172
 74489 db 124
 74490 db 75176
 74491 db 125
 74492 db 75180
 74493 db 126
 74494 db 75184
 74495 db 127
 74496 db 75188
 74497 db 128
 74498 db 75194
 74499 db 129
 74500 db 75201
 74501 db 130
 74502 db 75207
 74503 db 131
 74504 db 75214
 74505 db 132
 74506 db 75219
 74507 db 133
 74508 db 75224
 74509 db 134
 74510 db 75231
 74511 db 135
 74512 db 75238
 74513 db 250
 74514 db 75244
 74515 db 251
 74516 db 75249
 74517 db 252
 74518 db 75254
 74519 db 253
 74520 db 75259
 74521 db 254
 74522 db 75264
 74523 db 255
 74524 db 75271
 74525 db 256
 74526 db 75276
 74527 db 257
 74528 db 75282
 74529 db 259
 74530 db 75293
 74531 db 260
 74532 db 75300
 74533 db 261
 74534 db 75305
 74535 db 262
 74536 db 75310
 74537 db 263
 74538 db 75315
 74539 db 264
 74540 db 75323
 74541 db 265
 74542 db 75330
 74543 db 266
 74544 db 75343
 74545 db 267
 74546 db 75354
 74547 db 268
 74548 db 75362
 74549 db 269
 74550 db 75367
 74551 db 270
 74552 db 75372
 74553 db 273
 74554 db 75379
 74555 db 295
 74556 db 75385
 74557 db 296
 74558 db 75390
 74559 db 0,0,0,0
str_stop:
 74563 db "stop"
 74567 db 0
str_jne:
 74568 db "jne"
 74571 db 0
str_jnz:
 74572 db "jnz"
 74575 db 0
str_jmp:
 74576 db "jmp"
 74579 db 0
str_jg:
 74580 db "jg"
 74582 db 0
str_jnle:
 74583 db "jnle"
 74587 db 0
str_jge:
 74588 db "jge"
 74591 db 0
str_jnl:
 74592 db "jnl"
 74595 db 0
str_jl:
 74596 db "jl"
 74598 db 0
str_jnge:
 74599 db "jnge"
 74603 db 0
str_jle:
 74604 db "jle"
 74607 db 0
str_jng:
 74608 db "jng"
 74611 db 0
str_je:
 74612 db "je"
 74614 db 0
str_jz:
 74615 db "jz"
 74617 db 0
str_cpuid:
 74618 db "cpuid"
 74623 db 0
str_push:
 74624 db "push"
 74628 db 0
str_add:
 74629 db "add"
 74632 db 0
str_sub:
 74633 db "sub"
 74636 db 0
str_mul:
 74637 db "mul"
 74640 db 0
str_div:
 74641 db "div"
 74644 db 0
str_mov:
 74645 db "mov"
 74648 db 0
str_cmp:
 74649 db "cmp"
 74652 db 0
str_min:
 74653 db "min"
 74656 db 0
str_max:
 74657 db "max"
 74660 db 0
str_inc:
 74661 db "inc"
 74664 db 0
str_dec:
 74665 db "dec"
 74668 db 0
str_neg:
 74669 db "neg"
 74672 db 0
str_rand:
 74673 db "rand"
 74677 db 0
str_loop:
 74678 db "loop"
 74682 db 0
str_loopa:
 74683 db "loopa"
 74688 db 0
str_loopb:
 74689 db "loopb"
 74694 db 0
str_loopd:
 74695 db "loopd"
 74700 db 0
str_spg:
 74701 db "spg"
 74704 db 0
str_cpg:
 74705 db "cpg"
 74708 db 0
str_pop:
 74709 db "pop"
 74712 db 0
str_call:
 74713 db "call"
 74717 db 0
str_bnot:
 74718 db "bnot"
 74722 db 0
str_fint:
 74723 db "fint"
 74727 db 0
str_frnd:
 74728 db "frnd"
 74732 db 0
str_ffrac:
 74733 db "ffrac"
 74738 db 0
str_finv:
 74739 db "finv"
 74743 db 0
str_fshl:
 74744 db "fshl"
 74748 db 0
str_fshr:
 74749 db "fshr"
 74753 db 0
str_ret:
 74754 db "ret"
 74757 db 0
str_iret:
 74758 db "iret"
 74762 db 0
str_sti:
 74763 db "sti"
 74766 db 0
str_cli:
 74767 db "cli"
 74770 db 0
str_retf:
 74771 db "retf"
 74775 db 0
str_stef:
 74776 db "stef"
 74780 db 0
str_clef:
 74781 db "clef"
 74785 db 0
str_and:
 74786 db "and"
 74789 db 0
str_or:
 74790 db "or"
 74792 db 0
str_xor:
 74793 db "xor"
 74796 db 0
str_fsin:
 74797 db "fsin"
 74801 db 0
str_fcos:
 74802 db "fcos"
 74806 db 0
str_ftan:
 74807 db "ftan"
 74811 db 0
str_fasin:
 74812 db "fasin"
 74817 db 0
str_facos:
 74818 db "facos"
 74823 db 0
str_fatan:
 74824 db "fatan"
 74829 db 0
str_mod:
 74830 db "mod"
 74833 db 0
str_bit:
 74834 db "bit"
 74837 db 0
str_sbit:
 74838 db "sbit"
 74842 db 0
str_cbit:
 74843 db "cbit"
 74847 db 0
str_tbit:
 74848 db "tbit"
 74852 db 0
str_band:
 74853 db "band"
 74857 db 0
str_bor:
 74858 db "bor"
 74861 db 0
str_bxor:
 74862 db "bxor"
 74866 db 0
str_bshl:
 74867 db "bshl"
 74871 db 0
str_bshr:
 74872 db "bshr"
 74876 db 0
str_jmpf:
 74877 db "jmpf"
 74881 db 0
str_extint:
 74882 db "extint"
 74888 db 0
str_cne:
 74889 db "cne"
 74892 db 0
str_cg:
 74893 db "cg"
 74895 db 0
str_cnle:
 74896 db "cnle"
 74900 db 0
str_cge:
 74901 db "cge"
 74904 db 0
str_cnl:
 74905 db "cnl"
 74908 db 0
str_cl:
 74909 db "cl"
 74911 db 0
str_cnge:
 74912 db "cnge"
 74916 db 0
str_cle:
 74917 db "cle"
 74920 db 0
str_cng:
 74921 db "cng"
 74924 db 0
str_ce:
 74925 db "ce"
 74927 db 0
str_cz:
 74928 db "cz"
 74930 db 0
str_mcopy:
 74931 db "mcopy"
 74936 db 0
str_mxchg:
 74937 db "mxchg"
 74942 db 0
str_fpwr:
 74943 db "fpwr"
 74947 db 0
str_xchg:
 74948 db "xchg"
 74952 db 0
str_fln:
 74953 db "fln"
 74956 db 0
str_flog10:
 74957 db "flog10"
 74963 db 0
str_in:
 74964 db "in"
 74966 db 0
str_out:
 74967 db "out"
 74970 db 0
str_fabs:
 74971 db "fabs"
 74975 db 0
str_fsgn:
 74976 db "fsgn"
 74980 db 0
str_fexp:
 74981 db "fexp"
 74985 db 0
str_callf:
 74986 db "callf"
 74991 db 0
str_fpi:
 74992 db "fpi"
 74995 db 0
str_fe:
 74996 db "fe"
 74998 db 0
str_int:
 74999 db "int"
 75002 db 0
str_tpg:
 75003 db "tpg"
 75006 db 0
str_fceil:
 75007 db "fceil"
 75012 db 0
str_erpg:
 75013 db "erpg"
 75017 db 0
str_wrpg:
 75018 db "wrpg"
 75022 db 0
str_rdpg:
 75023 db "rdpg"
 75027 db 0
str_timer:
 75028 db "timer"
 75033 db 0
str_lidtr:
 75034 db "lidtr"
 75039 db 0
str_jner:
 75040 db "jner"
 75044 db 0
str_jnzr:
 75045 db "jnzr"
 75049 db 0
str_jmpr:
 75050 db "jmpr"
 75054 db 0
str_jgr:
 75055 db "jgr"
 75058 db 0
str_jnler:
 75059 db "jnler"
 75064 db 0
str_jger:
 75065 db "jger"
 75069 db 0
str_jnlr:
 75070 db "jnlr"
 75074 db 0
str_jlr:
 75075 db "jlr"
 75078 db 0
str_jnger:
 75079 db "jnger"
 75084 db 0
str_jler:
 75085 db "jler"
 75089 db 0
str_jngr:
 75090 db "jngr"
 75094 db 0
str_jer:
 75095 db "jer"
 75098 db 0
str_jzr:
 75099 db "jzr"
 75102 db 0
str_lneg:
 75103 db "lneg"
 75107 db 0
str_extret:
 75108 db "extret"
 75114 db 0
str_idle:
 75115 db "idle"
 75119 db 0
str_nop:
 75120 db "nop"
 75123 db 0
str_pusha:
 75124 db "pusha"
 75129 db 0
str_popa:
 75130 db "popa"
 75134 db 0
str_std2:
 75135 db "std2"
 75139 db 0
str_leave:
 75140 db "leave"
 75145 db 0
str_stm:
 75146 db "stm"
 75149 db 0
str_clm:
 75150 db "clm"
 75153 db 0
str_cpuget:
 75154 db "cpuget"
 75160 db 0
str_cpuset:
 75161 db "cpuset"
 75167 db 0
str_spp:
 75168 db "spp"
 75171 db 0
str_cpp:
 75172 db "cpp"
 75175 db 0
str_srl:
 75176 db "srl"
 75179 db 0
str_grl:
 75180 db "grl"
 75183 db 0
str_lea:
 75184 db "lea"
 75187 db 0
str_block:
 75188 db "block"
 75193 db 0
str_cmpand:
 75194 db "cmpand"
 75200 db 0
str_cmpor:
 75201 db "cmpor"
 75206 db 0
str_mshift:
 75207 db "mshift"
 75213 db 0
str_smap:
 75214 db "smap"
 75218 db 0
str_gmap:
 75219 db "gmap"
 75223 db 0
str_rstack:
 75224 db "rstack"
 75230 db 0
str_sstack:
 75231 db "sstack"
 75237 db 0
str_enter:
 75238 db "enter"
 75243 db 0
str_vadd:
 75244 db "vadd"
 75248 db 0
str_vsub:
 75249 db "vsub"
 75253 db 0
str_vmul:
 75254 db "vmul"
 75258 db 0
str_vdot:
 75259 db "vdot"
 75263 db 0
str_vcross:
 75264 db "vcross"
 75270 db 0
str_vmov:
 75271 db "vmov"
 75275 db 0
str_vnorm:
 75276 db "vnorm"
 75281 db 0
str_vcolornorm:
 75282 db "vcolornorm"
 75292 db 0
str_loopxy:
 75293 db "loopxy"
 75299 db 0
str_madd:
 75300 db "madd"
 75304 db 0
str_msub:
 75305 db "msub"
 75309 db 0
str_mmul:
 75310 db "mmul"
 75314 db 0
str_mrotate:
 75315 db "mrotate"
 75322 db 0
str_mscale:
 75323 db "mscale"
 75329 db 0
str_mperspective:
 75330 db "mperspective"
 75342 db 0
str_mtranslate:
 75343 db "mtranslate"
 75353 db 0
str_mlookat:
 75354 db "mlookat"
 75361 db 0
str_mmov:
 75362 db "mmov"
 75366 db 0
str_vlen:
 75367 db "vlen"
 75371 db 0
str_mident:
 75372 db "mident"
 75378 db 0
str_vmode:
 75379 db "vmode"
 75384 db 0
str_vdiv:
 75385 db "vdiv"
 75389 db 0
str_vtransform:
 75390 db "vtransform"
 75400 db 0
initPaging:
// initPaging(PT,size,flags,runlevel)
 75401 enter 1
__3198:
 75404 rstack EAX,EBP:3
 75408 push EAX
 75410 rstack EAX,EBP:2
 75414 push EAX
 75416 mov ECX,2
// setPageTable(...)
 75419 call 75507
 75422 add ESP,2
// init loop
 75425 sstack EBP:-1,-1
__3200:
 75430 rstack EAX,EBP:-1
 75434 rstack EBX,EBP:3
 75438 sub EBX,EAX
 75440 mov EAX,EBX
 75442 fsgn EAX,EAX
// condition
 75444 max EAX,0
 75447 cmp 0,EAX
 75450 jz 75505
 75453 rstack EAX,EBP:5
 75457 push EAX
 75459 rstack EAX,EBP:4
 75463 push EAX
 75465 rstack EAX,EBP:-1
 75469 push EAX
 75471 rstack EAX,EBP:-1
 75475 push EAX
 75477 rstack EAX,EBP:2
 75481 push EAX
 75483 mov ECX,5
// mapPage(...)
 75486 call 76104
 75489 add ESP,5
 75492 rstack EAX,EBP:-1
// loop step
 75496 inc EAX
 75498 sstack EBP:-1,EAX
 75502 jmp 75430
__3199:
__3197:
 75505 leave 
 75506 ret 
setPageTable:
// setPageTable(PT,size)
 75507 enter -0
__3202:
 75510 rstack EAX,EBP:2
 75514 cpuset 37,EAX
 75517 rstack EAX,EBP:3
 75521 cpuset 38,EAX
__3201:
 75524 leave 
 75525 ret 
getPage:
// getPage(PT,page)
 75526 enter -0
__3204:
 75529 rstack EAX,EBP:3
 75533 add EAX,1
 75536 mov EBX,EAX
// page=page+1
 75538 sstack EBP:3,EBX
 75542 rstack EAX,EBP:3
 75546 mul EAX,2
 75549 mov EBX,EAX
// page=page*2
 75551 sstack EBP:3,EBX
 75555 rstack EAX,EBP:3
 75559 rstack EBX,EBP:2
 75563 add EBX,EAX
 75565 mov EAX,EBX
// page=PT+page
 75567 sstack EBP:3,EAX
 75571 rstack EAX,EBP:3
 75575 leave 
 75576 ret 
__3203:
 75577 leave 
 75578 ret 
setPageFlags:
// setPageFlags(page,flags)
 75579 enter 1
__3206:
 75582 rstack EAX,EBP:2
 75586 sstack EBP:-1,#EAX
 75590 rstack EAX,EBP:-1
 75594 div EAX,256
 75597 mov EBX,EAX
// runlevel=runlevel/256
 75599 sstack EBP:-1,EBX
 75603 rstack EAX,EBP:-1
 75607 fint EAX
 75609 sstack EBP:-1,EAX
 75613 rstack EAX,EBP:-1
 75617 mov EBX,256
 75620 mul EBX,EAX
 75622 rstack EAX,EBP:3
 75626 add EAX,EBX
 75628 mov EBX,EAX
 75630 rstack EAX,EBP:2
// *page=flags+256*runlevel
 75634 mov #EAX,EBX
__3205:
 75636 leave 
 75637 ret 
getPageFlags:
// getPageFlags(page)
 75638 enter 1
__3208:
 75641 rstack EAX,EBP:2
 75645 sstack EBP:-1,#EAX
 75649 rstack EAX,EBP:-1
 75653 mod EAX,256
 75656 mov EBX,EAX
// flags=flags%256
 75658 sstack EBP:-1,EBX
 75662 rstack EAX,EBP:-1
 75666 fint EAX
 75668 sstack EBP:-1,EAX
 75672 rstack EAX,EBP:-1
 75676 leave 
 75677 ret 
__3207:
 75678 leave 
 75679 ret 
setPageRunLevel:
// setPageRunLevel(page,level)
 75680 enter 1
__3210:
 75683 rstack EAX,EBP:2
 75687 sstack EBP:-1,#EAX
 75691 rstack EAX,EBP:-1
 75695 mod EAX,256
 75698 mov EBX,EAX
// flags=flags%256
 75700 sstack EBP:-1,EBX
 75704 rstack EAX,EBP:-1
 75708 fint EAX
 75710 sstack EBP:-1,EAX
 75714 rstack EAX,EBP:3
 75718 mov EBX,256
 75721 mul EBX,EAX
 75723 rstack EAX,EBP:-1
 75727 add EAX,EBX
 75729 mov EBX,EAX
 75731 rstack EAX,EBP:2
// *page=flags+256*level
 75735 mov #EAX,EBX
__3209:
 75737 leave 
 75738 ret 
getPageRunlevel:
// getPageRunlevel(page)
 75739 enter 1
__3212:
 75742 rstack EAX,EBP:2
 75746 sstack EBP:-1,#EAX
 75750 rstack EAX,EBP:-1
 75754 div EAX,256
 75757 mov EBX,EAX
// runlevel=runlevel/256
 75759 sstack EBP:-1,EBX
 75763 rstack EAX,EBP:-1
 75767 fint EAX
 75769 sstack EBP:-1,EAX
 75773 rstack EAX,EBP:-1
 75777 leave 
 75778 ret 
__3211:
 75779 leave 
 75780 ret 
setPageMapping:
// setPageMapping(page,phys)
 75781 enter -0
__3214:
 75784 rstack EAX,EBP:3
 75788 rstack EBX,EBP:2
 75792 add EBX,1
 75795 mov ECX,EBX
// page[1]=phys
 75797 mov #ECX,EAX
__3213:
 75799 leave 
 75800 ret 
getPageMapping:
// getPageMapping(page)
 75801 enter -0
__3216:
 75804 rstack EAX,EBP:2
 75808 add EAX,1
 75811 mov EBX,EAX
 75813 mov EAX,#EBX
 75815 leave 
 75816 ret 
__3215:
 75817 leave 
 75818 ret 
reportPage:
// reportPage(pageTable,pageID)
 75819 enter 4
__3218:
 75822 rstack EAX,EBP:3
// getPage arg #2 (float page)
 75826 push EAX
 75828 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 75832 push EAX
 75834 mov ECX,2
// getPage(...)
 75837 call 75526
 75840 add ESP,2
 75843 sstack EBP:-1,EAX
 75847 rstack EAX,EBP:-1
// getPageFlags arg #1 (float page)
 75851 push EAX
 75853 mov ECX,1
// getPageFlags(...)
 75856 call 75638
 75859 add ESP,1
 75862 sstack EBP:-2,EAX
 75866 rstack EAX,EBP:-1
// getPageRunlevel arg #1 (float page)
 75870 push EAX
 75872 mov ECX,1
// getPageRunlevel(...)
 75875 call 75739
 75878 add ESP,1
 75881 sstack EBP:-3,EAX
 75885 rstack EAX,EBP:-1
// getPageMapping arg #1 (float page)
 75889 push EAX
 75891 mov ECX,1
// getPageMapping(...)
 75894 call 75801
 75897 add ESP,1
 75900 sstack EBP:-4,EAX
 75904 rstack EAX,EBP:-4
// P arg #3 (unknown)
 75908 push EAX
 75910 rstack EAX,EBP:3
// P arg #2 (unknown)
 75914 push EAX
// P arg #1 (char* str)
 75916 push 75995
 75919 mov ECX,3
// P(...)
 75922 call 40570
 75925 add ESP,3
 75928 rstack EAX,EBP:-2
// P arg #3 (unknown)
 75932 push EAX
 75934 rstack EAX,EBP:3
// P arg #2 (unknown)
 75938 push EAX
// P arg #1 (char* str)
 75940 push 76012
 75943 mov ECX,3
// P(...)
 75946 call 40570
 75949 add ESP,3
 75952 rstack EAX,EBP:-3
// P arg #3 (unknown)
 75956 push EAX
 75958 rstack EAX,EBP:3
// P arg #2 (unknown)
 75962 push EAX
// P arg #1 (char* str)
 75964 push 75978
 75967 mov ECX,3
// P(...)
 75970 call 40570
 75973 add ESP,3
__3217:
 75976 leave 
 75977 ret 
__3221:
 75978 db "P%d: level = %d
",0
__3219:
 75995 db "P%d: phys  = %d
",0
__3220:
 76012 db "P%d: flags = %d
",0
toPage:
// toPage(addr)
 76029 enter -0
__3223:
 76032 rstack EAX,EBP:2
 76036 div EAX,128
 76039 mov EBX,EAX
// addr=addr/128
 76041 sstack EBP:2,EBX
 76045 rstack EAX,EBP:2
 76049 fint EAX
 76051 sstack EBP:2,EAX
 76055 rstack EAX,EBP:2
 76059 leave 
 76060 ret 
__3222:
 76061 leave 
 76062 ret 
copyPage:
// copyPage(pageto,pagefrom)
 76063 enter -0
__3225:
 76066 rstack EAX,EBP:3
 76070 mov EBX,EAX
 76072 inc EAX
 76074 sstack EBP:3,EAX
 76078 rstack EAX,EBP:2
 76082 mov ECX,EAX
 76084 inc EAX
 76086 sstack EBP:2,EAX
// *pageto++=*pagefrom++
 76090 mov #ECX,#EBX
 76092 rstack EAX,EBP:3
 76096 rstack EBX,EBP:2
// *pageto=*pagefrom
 76100 mov #EBX,#EAX
__3224:
 76102 leave 
 76103 ret 
mapPage:
// mapPage(PT,virt,phys,flags,runlevel)
 76104 enter 1
__3227:
 76107 rstack EAX,EBP:3
// getPage arg #2 (float page)
 76111 push EAX
 76113 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 76117 push EAX
 76119 mov ECX,2
// getPage(...)
 76122 call 75526
 76125 add ESP,2
 76128 sstack EBP:-1,EAX
 76132 rstack EAX,EBP:4
// setPageMapping arg #2 (float phys)
 76136 push EAX
 76138 rstack EAX,EBP:-1
// setPageMapping arg #1 (float page)
 76142 push EAX
 76144 mov ECX,2
// setPageMapping(...)
 76147 call 75781
 76150 add ESP,2
 76153 rstack EAX,EBP:5
// setPageFlags arg #2 (float flags)
 76157 push EAX
 76159 rstack EAX,EBP:-1
// setPageFlags arg #1 (float page)
 76163 push EAX
 76165 mov ECX,2
// setPageFlags(...)
 76168 call 75579
 76171 add ESP,2
 76174 rstack EAX,EBP:6
// setPageRunLevel arg #2 (float level)
 76178 push EAX
 76180 rstack EAX,EBP:-1
// setPageRunLevel arg #1 (float page)
 76184 push EAX
 76186 mov ECX,2
// setPageRunLevel(...)
 76189 call 75680
 76192 add ESP,2
__3226:
 76195 leave 
 76196 ret 
setMemoryRunlevel:
// setMemoryRunlevel(PT,from,to,level)
 76197 enter 4
__3229:
 76200 rstack EAX,EBP:3
// toPage arg #1 (float addr)
 76204 push EAX
 76206 mov ECX,1
// toPage(...)
 76209 call 76029
 76212 add ESP,1
 76215 sstack EBP:-1,EAX
 76219 rstack EAX,EBP:4
// toPage arg #1 (float addr)
 76223 push EAX
 76225 mov ECX,1
// toPage(...)
 76228 call 76029
 76231 add ESP,1
 76234 sstack EBP:-2,EAX
 76238 rstack EAX,EBP:-1
// init loop
 76242 sstack EBP:-3,EAX
__3231:
 76246 rstack EAX,EBP:-3
 76250 rstack EBX,EBP:-2
 76254 sub EBX,EAX
 76256 mov EAX,EBX
 76258 fsgn EAX,EAX
// condition
 76260 max EAX,0
 76263 cmp 0,EAX
 76266 jz 76328
 76269 rstack EAX,EBP:-3
// getPage arg #2 (float page)
 76273 push EAX
 76275 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 76279 push EAX
 76281 mov ECX,2
// getPage(...)
 76284 call 75526
 76287 add ESP,2
 76290 sstack EBP:-4,EAX
 76294 rstack EAX,EBP:5
// setPageRunLevel arg #2 (float level)
 76298 push EAX
 76300 rstack EAX,EBP:-4
// setPageRunLevel arg #1 (float page)
 76304 push EAX
 76306 mov ECX,2
// setPageRunLevel(...)
 76309 call 75680
 76312 add ESP,2
 76315 rstack EAX,EBP:-3
// loop step
 76319 inc EAX
 76321 sstack EBP:-3,EAX
 76325 jmp 76246
__3230:
__3228:
 76328 leave 
 76329 ret 
setMemoryMapping:
// setMemoryMapping(PT,from,to,target)
 76330 enter 7
__3233:
 76333 rstack EAX,EBP:3
 76337 sstack EBP:-1,EAX
 76341 rstack EAX,EBP:4
 76345 sstack EBP:-2,EAX
 76349 rstack EAX,EBP:5
 76353 sstack EBP:-3,EAX
 76357 rstack EAX,EBP:-1
 76361 neg EAX
 76363 mov EBX,EAX
 76365 rstack EAX,EBP:-3
 76369 add EAX,EBX
 76371 mov EBX,EAX
 76373 sstack EBP:-4,EBX
 76377 rstack EAX,EBP:-1
// init loop
 76381 sstack EBP:-5,EAX
__3235:
 76385 rstack EAX,EBP:-5
 76389 rstack EBX,EBP:-2
 76393 sub EBX,EAX
 76395 mov EAX,EBX
 76397 fsgn EAX,EAX
 76399 inc EAX
// condition
 76401 max EAX,0
 76404 cmp 0,EAX
 76407 jz 76485
 76410 rstack EAX,EBP:-5
// getPage arg #2 (float page)
 76414 push EAX
 76416 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 76420 push EAX
 76422 mov ECX,2
// getPage(...)
 76425 call 75526
 76428 add ESP,2
 76431 sstack EBP:-6,EAX
 76435 rstack EAX,EBP:-4
 76439 rstack EBX,EBP:-5
 76443 add EBX,EAX
 76445 mov EAX,EBX
 76447 sstack EBP:-7,EAX
 76451 rstack EAX,EBP:-7
// setPageMapping arg #2 (float phys)
 76455 push EAX
 76457 rstack EAX,EBP:-6
// setPageMapping arg #1 (float page)
 76461 push EAX
 76463 mov ECX,2
// setPageMapping(...)
 76466 call 75781
 76469 add ESP,2
 76472 rstack EAX,EBP:-5
// loop step
 76476 inc EAX
 76478 sstack EBP:-5,EAX
 76482 jmp 76385
__3234:
__3232:
 76485 leave 
 76486 ret 
pagingEnable:
// pagingEnable()
 76487 enter -0
__3237:
 76490 stm 
__3236:
 76491 leave 
 76492 ret 
pagingDisable:
// pagingDisable()
 76493 enter -0
__3239:
 76496 clm 
__3238:
 76497 leave 
 76498 ret 
str_thread:
 76499 db "thread",0
sizeof_thread:
// sizeof_thread()
 76506 enter -0
__3241:
 76509 mov EAX,7
 76512 leave 
 76513 ret 
__3240:
 76514 leave 
 76515 ret 
thread_constructor:
// thread_constructor(this)
 76516 enter -0
__3243:
 76519 rstack EAX,EBP:2
 76523 add EAX,0
 76526 mov EBX,EAX
// this[0]=str_thread
 76528 mov #EBX,76499
 76531 rstack EAX,EBP:2
 76535 add EAX,1
 76538 mov EBX,EAX
// this[1]=0
 76540 mov #EBX,0
 76543 rstack EAX,EBP:2
 76547 add EAX,2
 76550 mov EBX,EAX
// this[2]=0
 76552 mov #EBX,0
 76555 rstack EAX,EBP:2
 76559 add EAX,3
 76562 mov EBX,EAX
// this[3]=0
 76564 mov #EBX,0
 76567 rstack EAX,EBP:2
 76571 add EAX,4
 76574 mov EBX,EAX
// this[4]=0
 76576 mov #EBX,0
 76579 rstack EAX,EBP:2
 76583 add EAX,5
 76586 mov EBX,EAX
// this[5]=0
 76588 mov #EBX,0
 76591 rstack EAX,EBP:2
 76595 add EAX,6
 76598 mov EBX,EAX
// this[6]=0
 76600 mov #EBX,0
__3242:
 76603 leave 
 76604 ret 
thread_copy_constructor:
// thread_copy_constructor(this,that)
 76605 enter -0
__3245:
 76608 rstack EAX,EBP:3
 76612 add EAX,0
 76615 mov EBX,EAX
 76617 rstack EAX,EBP:2
 76621 add EAX,0
 76624 mov ECX,EAX
// this[0]=that[0]
 76626 mov #ECX,#EBX
 76628 rstack EAX,EBP:3
 76632 add EAX,1
 76635 mov EBX,EAX
 76637 rstack EAX,EBP:2
 76641 add EAX,1
 76644 mov ECX,EAX
// this[1]=that[1]
 76646 mov #ECX,#EBX
 76648 rstack EAX,EBP:3
 76652 add EAX,2
 76655 mov EBX,EAX
 76657 rstack EAX,EBP:2
 76661 add EAX,2
 76664 mov ECX,EAX
// this[2]=that[2]
 76666 mov #ECX,#EBX
 76668 rstack EAX,EBP:3
 76672 add EAX,3
 76675 mov EBX,EAX
 76677 rstack EAX,EBP:2
 76681 add EAX,3
 76684 mov ECX,EAX
// this[3]=that[3]
 76686 mov #ECX,#EBX
 76688 rstack EAX,EBP:3
 76692 add EAX,4
 76695 mov EBX,EAX
 76697 rstack EAX,EBP:2
 76701 add EAX,4
 76704 mov ECX,EAX
// this[4]=that[4]
 76706 mov #ECX,#EBX
 76708 rstack EAX,EBP:3
 76712 add EAX,5
 76715 mov EBX,EAX
 76717 rstack EAX,EBP:2
 76721 add EAX,5
 76724 mov ECX,EAX
// this[5]=that[5]
 76726 mov #ECX,#EBX
 76728 rstack EAX,EBP:3
 76732 add EAX,6
 76735 mov EBX,EAX
 76737 rstack EAX,EBP:2
 76741 add EAX,6
 76744 mov ECX,EAX
// this[6]=that[6]
 76746 mov #ECX,#EBX
// check_canary arg #2 (float canary)
 76748 push 76499
 76751 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76755 push EAX
 76757 mov ECX,2
// check_canary(...)
 76760 call 62704
 76763 add ESP,2
__3244:
 76766 leave 
 76767 ret 
thread_destructor:
// thread_destructor(this)
 76768 enter -0
__3247:
// check_canary arg #2 (float canary)
 76771 push 76499
 76774 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76778 push EAX
 76780 mov ECX,2
// check_canary(...)
 76783 call 62704
 76786 add ESP,2
// check_canary arg #2 (float canary)
 76789 push 76499
 76792 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76796 push EAX
 76798 mov ECX,2
// check_canary(...)
 76801 call 62704
 76804 add ESP,2
__3246:
 76807 leave 
 76808 ret 
thread_new:
// thread_new()
 76809 enter 2
__3249:
 76812 mov ECX,0
// sizeof_thread(...)
 76815 call 76506
 76818 sstack EBP:-1,EAX
 76822 rstack EAX,EBP:-1
// malloc arg #1 (float n)
 76826 push EAX
 76828 mov ECX,1
// malloc(...)
 76831 call 20709
 76834 add ESP,1
 76837 sstack EBP:-2,EAX
 76841 rstack EAX,EBP:-2
// thread_constructor arg #1 (float this)
 76845 push EAX
 76847 mov ECX,1
// thread_constructor(...)
 76850 call 76516
 76853 add ESP,1
 76856 rstack EAX,EBP:-2
 76860 leave 
 76861 ret 
__3248:
 76862 leave 
 76863 ret 
thread_delete:
// thread_delete(this)
 76864 enter -0
__3251:
 76867 rstack EAX,EBP:2
// thread_destructor arg #1 (float this)
 76871 push EAX
 76873 mov ECX,1
// thread_destructor(...)
 76876 call 76768
 76879 add ESP,1
 76882 rstack EAX,EBP:2
// free arg #1 (float* ptr)
 76886 push EAX
 76888 mov ECX,1
// free(...)
 76891 call 21231
 76894 add ESP,1
__3250:
 76897 leave 
 76898 ret 
thread_get_canary:
// thread_get_canary(this)
 76899 enter -0
__3253:
// check_canary arg #2 (float canary)
 76902 push 76499
 76905 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76909 push EAX
 76911 mov ECX,2
// check_canary(...)
 76914 call 62704
 76917 add ESP,2
 76920 rstack EAX,EBP:2
 76924 add EAX,0
 76927 mov EBX,EAX
 76929 mov EAX,#EBX
 76931 leave 
 76932 ret 
__3252:
 76933 leave 
 76934 ret 
thread_get_entry:
// thread_get_entry(this)
 76935 enter -0
__3255:
// check_canary arg #2 (float canary)
 76938 push 76499
 76941 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76945 push EAX
 76947 mov ECX,2
// check_canary(...)
 76950 call 62704
 76953 add ESP,2
 76956 rstack EAX,EBP:2
 76960 add EAX,1
 76963 mov EBX,EAX
 76965 mov EAX,#EBX
 76967 leave 
 76968 ret 
__3254:
 76969 leave 
 76970 ret 
thread_get_args:
// thread_get_args(this)
 76971 enter -0
__3257:
// check_canary arg #2 (float canary)
 76974 push 76499
 76977 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 76981 push EAX
 76983 mov ECX,2
// check_canary(...)
 76986 call 62704
 76989 add ESP,2
 76992 rstack EAX,EBP:2
 76996 add EAX,2
 76999 mov EBX,EAX
 77001 mov EAX,#EBX
 77003 leave 
 77004 ret 
__3256:
 77005 leave 
 77006 ret 
thread_get_time:
// thread_get_time(this)
 77007 enter -0
__3259:
// check_canary arg #2 (float canary)
 77010 push 76499
 77013 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77017 push EAX
 77019 mov ECX,2
// check_canary(...)
 77022 call 62704
 77025 add ESP,2
 77028 rstack EAX,EBP:2
 77032 add EAX,3
 77035 mov EBX,EAX
 77037 mov EAX,#EBX
 77039 leave 
 77040 ret 
__3258:
 77041 leave 
 77042 ret 
thread_get_ip:
// thread_get_ip(this)
 77043 enter -0
__3261:
// check_canary arg #2 (float canary)
 77046 push 76499
 77049 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77053 push EAX
 77055 mov ECX,2
// check_canary(...)
 77058 call 62704
 77061 add ESP,2
 77064 rstack EAX,EBP:2
 77068 add EAX,4
 77071 mov EBX,EAX
 77073 mov EAX,#EBX
 77075 leave 
 77076 ret 
__3260:
 77077 leave 
 77078 ret 
thread_get_stack:
// thread_get_stack(this)
 77079 enter -0
__3263:
// check_canary arg #2 (float canary)
 77082 push 76499
 77085 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77089 push EAX
 77091 mov ECX,2
// check_canary(...)
 77094 call 62704
 77097 add ESP,2
 77100 rstack EAX,EBP:2
 77104 add EAX,5
 77107 mov EBX,EAX
 77109 mov EAX,#EBX
 77111 leave 
 77112 ret 
__3262:
 77113 leave 
 77114 ret 
thread_get_regs:
// thread_get_regs(this)
 77115 enter -0
__3265:
// check_canary arg #2 (float canary)
 77118 push 76499
 77121 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77125 push EAX
 77127 mov ECX,2
// check_canary(...)
 77130 call 62704
 77133 add ESP,2
 77136 rstack EAX,EBP:2
 77140 add EAX,6
 77143 mov EBX,EAX
 77145 mov EAX,#EBX
 77147 leave 
 77148 ret 
__3264:
 77149 leave 
 77150 ret 
thread_set_canary:
// thread_set_canary(this,N)
 77151 enter -0
__3267:
// check_canary arg #2 (float canary)
 77154 push 76499
 77157 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77161 push EAX
 77163 mov ECX,2
// check_canary(...)
 77166 call 62704
 77169 add ESP,2
 77172 rstack EAX,EBP:3
 77176 rstack EBX,EBP:2
 77180 add EBX,0
 77183 mov ECX,EBX
// this[0]=N
 77185 mov #ECX,EAX
__3266:
 77187 leave 
 77188 ret 
thread_set_entry:
// thread_set_entry(this,N)
 77189 enter -0
__3269:
// check_canary arg #2 (float canary)
 77192 push 76499
 77195 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77199 push EAX
 77201 mov ECX,2
// check_canary(...)
 77204 call 62704
 77207 add ESP,2
 77210 rstack EAX,EBP:3
 77214 rstack EBX,EBP:2
 77218 add EBX,1
 77221 mov ECX,EBX
// this[1]=N
 77223 mov #ECX,EAX
__3268:
 77225 leave 
 77226 ret 
thread_set_args:
// thread_set_args(this,N)
 77227 enter -0
__3271:
// check_canary arg #2 (float canary)
 77230 push 76499
 77233 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77237 push EAX
 77239 mov ECX,2
// check_canary(...)
 77242 call 62704
 77245 add ESP,2
 77248 rstack EAX,EBP:3
 77252 rstack EBX,EBP:2
 77256 add EBX,2
 77259 mov ECX,EBX
// this[2]=N
 77261 mov #ECX,EAX
__3270:
 77263 leave 
 77264 ret 
thread_set_time:
// thread_set_time(this,N)
 77265 enter -0
__3273:
// check_canary arg #2 (float canary)
 77268 push 76499
 77271 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77275 push EAX
 77277 mov ECX,2
// check_canary(...)
 77280 call 62704
 77283 add ESP,2
 77286 rstack EAX,EBP:3
 77290 rstack EBX,EBP:2
 77294 add EBX,3
 77297 mov ECX,EBX
// this[3]=N
 77299 mov #ECX,EAX
__3272:
 77301 leave 
 77302 ret 
thread_set_ip:
// thread_set_ip(this,N)
 77303 enter -0
__3275:
// check_canary arg #2 (float canary)
 77306 push 76499
 77309 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77313 push EAX
 77315 mov ECX,2
// check_canary(...)
 77318 call 62704
 77321 add ESP,2
 77324 rstack EAX,EBP:3
 77328 rstack EBX,EBP:2
 77332 add EBX,4
 77335 mov ECX,EBX
// this[4]=N
 77337 mov #ECX,EAX
__3274:
 77339 leave 
 77340 ret 
thread_set_stack:
// thread_set_stack(this,N)
 77341 enter -0
__3277:
// check_canary arg #2 (float canary)
 77344 push 76499
 77347 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77351 push EAX
 77353 mov ECX,2
// check_canary(...)
 77356 call 62704
 77359 add ESP,2
 77362 rstack EAX,EBP:3
 77366 rstack EBX,EBP:2
 77370 add EBX,5
 77373 mov ECX,EBX
// this[5]=N
 77375 mov #ECX,EAX
__3276:
 77377 leave 
 77378 ret 
thread_set_regs:
// thread_set_regs(this,N)
 77379 enter -0
__3279:
// check_canary arg #2 (float canary)
 77382 push 76499
 77385 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 77389 push EAX
 77391 mov ECX,2
// check_canary(...)
 77394 call 62704
 77397 add ESP,2
 77400 rstack EAX,EBP:3
 77404 rstack EBX,EBP:2
 77408 add EBX,6
 77411 mov ECX,EBX
// this[6]=N
 77413 mov #ECX,EAX
__3278:
 77415 leave 
 77416 ret 
threadpool:
 77417 db 0
cur_thread:
 77418 db 0
thread_stack_size:
 77419 db 5000
initThreads:
// initThreads()
 77420 enter -0
__3281:
// malloc arg #1 (float n)
 77423 push #22842
 77426 mov ECX,1
// malloc(...)
 77429 call 20709
 77432 add ESP,1
// threadpool=malloc(sizeof_vector)
 77435 mov #77417,EAX
// vector_constructor arg #2 (float element_size)
 77438 push 1
// vector_constructor arg #1 (void* self)
 77441 push #77417
 77444 mov ECX,2
// vector_constructor(...)
 77447 call 22843
 77450 add ESP,2
// P arg #1 (char* str)
 77453 push 77467
 77456 mov ECX,1
// P(...)
 77459 call 40570
 77462 add ESP,1
__3280:
 77465 leave 
 77466 ret 
__3282:
 77467 db "threads initialized
",0
regs_set_to_entry:
// regs_set_to_entry(regs,stack,entry,args)
 77488 enter 1
__3284:
// memset arg #3 (float n)
 77491 push 48
// memset arg #2 (float c)
 77494 push 0
 77497 rstack EAX,EBP:2
// memset arg #1 (void* ptr)
 77501 push EAX
 77503 mov ECX,3
// memset(...)
 77506 call 10120
 77509 add ESP,3
 77512 mov EAX,#77419
 77515 add EAX,-2000
 77518 rstack EBX,EBP:3
 77522 add EBX,EAX
 77524 mov EAX,EBX
 77526 sstack EBP:-1,EAX
 77530 rstack EAX,EBP:-1
 77534 rstack EBX,EBP:2
 77538 add EBX,6
 77541 mov ECX,EBX
// regs[6]=t_esp
 77543 mov #ECX,EAX
 77545 rstack EAX,EBP:-1
 77549 add EAX,10
 77552 mov EBX,EAX
 77554 rstack EAX,EBP:2
 77558 add EAX,7
 77561 mov ECX,EAX
// regs[7]=t_esp+10
 77563 mov #ECX,EBX
 77565 rstack EAX,EBP:2
 77569 add EAX,2
 77572 mov EBX,EAX
// regs[2]=1
 77574 mov #EBX,1
 77577 rstack EAX,EBP:5
 77581 rstack EBX,EBP:-1
 77585 add EBX,3
 77588 mov ECX,EBX
// t_esp[3]=args
 77590 mov #ECX,EAX
 77592 rstack EAX,EBP:-1
 77596 add EAX,2
 77599 mov EBX,EAX
// t_esp[2]=0
 77601 mov #EBX,0
 77604 rstack EAX,EBP:-1
 77608 add EAX,1
 77611 mov EBX,EAX
// t_esp[1]=thread_exit_func
 77613 mov #EBX,78745
 77616 rstack EAX,EBP:-1
 77620 add EAX,0
 77623 mov EBX,EAX
// t_esp[0]=0
 77625 mov #EBX,0
__3283:
 77628 leave 
 77629 ret 
thread_run:
// thread_run(thread)
 77630 enter -0
__3286:
// P arg #1 (char* str)
 77633 push 77653
 77636 mov ECX,1
// P(...)
 77639 call 40570
 77642 add ESP,1
 77645 mov ECX,0
// thread_yield(...)
 77648 call 78209
__3285:
 77651 leave 
 77652 ret 
__3287:
 77653 db "thread_run
",0
thread_enter:
// thread_enter(thread)
 77665 enter 6
__3289:
 77668 mov ECX,0
// cls(...)
 77671 call 38437
// P arg #1 (char* str)
 77674 push 78187
 77677 mov ECX,1
// P(...)
 77680 call 40570
 77683 add ESP,1
 77686 rstack EAX,EBP:2
// thread_get_regs arg #1 (float this)
 77690 push EAX
 77692 mov ECX,1
// thread_get_regs(...)
 77695 call 77115
 77698 add ESP,1
 77701 sstack EBP:-2,EAX
// P2 arg #3 (char* str2)
 77705 push 18244
 77708 rstack EAX,EBP:-2
// P2 arg #2 (float N)
 77712 push EAX
// P2 arg #1 (char* str1)
 77714 push 78177
 77717 mov ECX,3
// P2(...)
 77720 call 40700
 77723 add ESP,3
 77726 sstack EBP:-3,0
// init loop
 77731 sstack EBP:-3,0
__3293:
 77736 rstack EAX,EBP:-3
 77740 mov EBX,10
 77743 sub EBX,EAX
 77745 fsgn EBX,EBX
// condition
 77747 max EBX,0
 77750 cmp 0,EBX
 77753 jz 77819
// P2 arg #3 (char* str2)
 77756 push 47396
 77759 rstack EAX,EBP:-3
// P2 arg #2 (float N)
 77763 push EAX
// P2 arg #1 (char* str1)
 77765 push 78175
 77768 mov ECX,3
// P2(...)
 77771 call 40700
 77774 add ESP,3
// P2 arg #3 (char* str2)
 77777 push 18244
 77780 rstack EAX,EBP:-3
 77784 rstack EBX,EBP:-2
 77788 add EBX,EAX
 77790 mov EAX,EBX
// P2 arg #2 (float N)
 77792 push #EAX
// P2 arg #1 (char* str1)
 77794 push 26784
 77797 mov ECX,3
// P2(...)
 77800 call 40700
 77803 add ESP,3
 77806 rstack EAX,EBP:-3
// loop step
 77810 inc EAX
 77812 sstack EBP:-3,EAX
 77816 jmp 77736
__3292:
 77819 rstack EAX,EBP:-2
 77823 add EAX,6
 77826 mov EBX,EAX
 77828 sstack EBP:-4,#EBX
// P2 arg #3 (char* str2)
 77832 push 18244
 77835 rstack EAX,EBP:-4
// P2 arg #2 (float N)
 77839 push EAX
// P2 arg #1 (char* str1)
 77841 push 78156
 77844 mov ECX,3
// P2(...)
 77847 call 40700
 77850 add ESP,3
 77853 rstack EAX,EBP:2
// thread_get_ip arg #1 (float this)
 77857 push EAX
 77859 mov ECX,1
// thread_get_ip(...)
 77862 call 77043
 77865 add ESP,1
 77868 sstack EBP:-5,EAX
// P2 arg #3 (char* str2)
 77872 push 18244
 77875 rstack EAX,EBP:-5
// P2 arg #2 (float N)
 77879 push EAX
// P2 arg #1 (char* str1)
 77881 push 78201
 77884 mov ECX,3
// P2(...)
 77887 call 40700
 77890 add ESP,3
// P2 arg #3 (char* str2)
 77893 push 18244
// P2 arg #2 (float N)
 77896 push ESP
// P2 arg #1 (char* str1)
 77898 push 42815
 77901 mov ECX,3
// P2(...)
 77904 call 40700
 77907 add ESP,3
// P2 arg #3 (char* str2)
 77910 push 18244
// P2 arg #2 (float N)
 77913 push EBP
// P2 arg #1 (char* str1)
 77915 push 42802
 77918 mov ECX,3
// P2(...)
 77921 call 40700
 77924 add ESP,3
 77927 cpuset 9,9999999
 77931 cpuget EAX,9
// t_esz=EAX
 77934 sstack EBP:-6,EAX
// P2 arg #3 (char* str2)
 77938 push 18244
 77941 rstack EAX,EBP:-6
// P2 arg #2 (float N)
 77945 push EAX
// P2 arg #1 (char* str1)
 77947 push 78149
 77950 mov ECX,3
// P2(...)
 77953 call 40700
 77956 add ESP,3
// delay arg #1 (float time)
 77959 push 2
 77962 mov ECX,1
// delay(...)
 77965 call 36681
 77968 add ESP,1
 77971 out 7,1
 77975 rstack EAX,EBP:-2
 77979 mov R0,EAX
 77981 out 7,2
 77985 rstack EAX,EBP:-5
 77989 mov R1,EAX
 77991 out 7,3
 77995 mov EBP,R0:#7
 77999 out 7,4
 78003 mov ESP,R0:#6
 78007 out 7,5
 78011 out 7,6
 78015 out 7,7
 78019 out 7,8
 78023 out 7,9
 78027 out 7,10
 78031 out 7,11
 78035 out 7,12
 78039 out 7,13
// P arg #1 (char* str)
 78043 push 78165
 78046 mov ECX,1
// P(...)
 78049 call 40570
 78052 add ESP,1
 78055 out 7,14
 78059 out 7,15
 78063 out 7,16
 78067 out 7,17
 78071 out 7,18
 78075 out 7,19
 78079 out 7,20
 78083 out 5,ECX
 78086 call 37796
 78089 out 7,21
 78093 out 7,22
 78097 leave 
 78098 out 7,23
 78102 out 7,24
 78106 ret 
 78107 out 7,25
 78111 out 7,26
 78115 out 7,27
 78119 out 7,28
 78123 out 7,29
 78127 out 7,30
 78131 out 7,31
 78135 out 7,32
 78139 out 7,33
 78143 out 7,34
__3288:
 78147 leave 
 78148 ret 
__3297:
 78149 db "ESZ = ",0
__3295:
 78156 db "t_esp = ",0
__3298:
 78165 db "hello...
",0
__3294:
 78175 db "R",0
__3291:
 78177 db "t_regs = ",0
__3290:
 78187 db "thread_enter
",0
__3296:
 78201 db "t_ip = ",0
thread_yield:
// thread_yield()
 78209 enter 5
__3300:
// P arg #1 (char* str)
 78212 push 78707
 78215 mov ECX,1
// P(...)
 78218 call 40570
 78221 add ESP,1
 78224 sstack EBP:-1,#77418
 78229 rstack EAX,EBP:-1
// thread_get_regs arg #1 (float this)
 78233 push EAX
 78235 mov ECX,1
// thread_get_regs(...)
 78238 call 77115
 78241 add ESP,1
 78244 sstack EBP:-2,EAX
// thread_set_ip arg #2 (float N)
 78248 push 78655
 78251 rstack EAX,EBP:-1
// thread_set_ip arg #1 (float this)
 78255 push EAX
 78257 mov ECX,2
// thread_set_ip(...)
 78260 call 77303
 78263 add ESP,2
 78266 rstack EAX,EBP:-2
 78270 add EAX,0
 78273 mov EBX,EAX
// regs[0]=EAX
 78275 mov #EBX,EAX
 78277 rstack EAX,EBP:-2
 78281 add EAX,1
 78284 mov EBX,EAX
// regs[1]=EBX
 78286 mov #EBX,EBX
 78288 rstack EAX,EBP:-2
 78292 add EAX,2
 78295 mov EBX,EAX
// regs[2]=ECX
 78297 mov #EBX,ECX
 78299 rstack EAX,EBP:-2
 78303 add EAX,3
 78306 mov EBX,EAX
// regs[3]=EDX
 78308 mov #EBX,EDX
 78310 rstack EAX,EBP:-2
 78314 add EAX,4
 78317 mov EBX,EAX
// regs[4]=ESI
 78319 mov #EBX,ESI
 78321 rstack EAX,EBP:-2
 78325 add EAX,5
 78328 mov EBX,EAX
// regs[5]=EDI
 78330 mov #EBX,EDI
 78332 rstack EAX,EBP:-2
 78336 add EAX,6
 78339 mov EBX,EAX
// regs[6]=ESP
 78341 mov #EBX,ESP
 78343 rstack EAX,EBP:-2
 78347 add EAX,7
 78350 mov EBX,EAX
// regs[7]=EBP
 78352 mov #EBX,EBP
 78354 rstack EAX,EBP:-2
 78358 add EAX,8
 78361 mov EBX,EAX
// regs[8]=CS
 78363 mov #EBX,CS
 78365 rstack EAX,EBP:-2
 78369 add EAX,9
 78372 mov EBX,EAX
// regs[9]=SS
 78374 mov #EBX,SS
 78376 rstack EAX,EBP:-2
 78380 add EAX,10
 78383 mov EBX,EAX
// regs[10]=DS
 78385 mov #EBX,DS
 78387 rstack EAX,EBP:-2
 78391 add EAX,11
 78394 mov EBX,EAX
// regs[11]=ES
 78396 mov #EBX,ES
 78398 rstack EAX,EBP:-2
 78402 add EAX,12
 78405 mov EBX,EAX
// regs[12]=GS
 78407 mov #EBX,GS
 78409 rstack EAX,EBP:-2
 78413 add EAX,13
 78416 mov EBX,EAX
// regs[13]=FS
 78418 mov #EBX,FS
 78420 rstack EAX,EBP:-2
 78424 add EAX,14
 78427 mov EBX,EAX
// regs[14]=KS
 78429 mov #EBX,KS
 78431 rstack EAX,EBP:-2
 78435 add EAX,15
 78438 mov EBX,EAX
// regs[15]=LS
 78440 mov #EBX,LS
// vector_get_size arg #1 (void* self)
 78442 push #77417
 78445 mov ECX,1
// vector_get_size(...)
 78448 call 23189
 78451 add ESP,1
 78454 sstack EBP:-3,EAX
__3303:
 78458 rstack EAX,EBP:-3
 78462 mov EBX,0
 78465 sub EBX,EAX
 78467 fabs EBX,EBX
 78469 fsgn EBX,EBX
 78471 lneg EBX
// if (len==0)
 78473 cmp 0,EBX
 78476 jge 78491
// Perr arg #1 (char* str)
 78479 push 78669
 78482 mov ECX,1
// Perr(...)
 78485 call 40763
 78488 add ESP,1
__3304:
__3302:
 78491 sstack EBP:-4,0
 78496 sstack EBP:-5,-1
// init loop
 78501 sstack EBP:-4,0
__3307:
 78506 rstack EAX,EBP:-4
 78510 rstack EBX,EBP:-3
 78514 sub EBX,EAX
 78516 mov EAX,EBX
 78518 fsgn EAX,EAX
// condition
 78520 max EAX,0
 78523 cmp 0,EAX
 78526 jz 78595
 78529 rstack EAX,EBP:-4
// vector_get arg #3 (float pos)
 78533 push EAX
 78535 mov EAX,SS:ESP
 78538 add EAX,-1
// vector_get arg #2 (void* element)
 78541 push EAX
// vector_get arg #1 (void* self)
 78543 push #77417
 78546 mov ECX,3
// vector_get(...)
 78549 call 24205
 78552 add ESP,3
__3309:
 78555 rstack EAX,EBP:-5
 78559 rstack EBX,EBP:-1
 78563 sub EBX,EAX
 78565 mov EAX,EBX
 78567 fabs EAX,EAX
 78569 fsgn EAX,EAX
 78571 lneg EAX
// if (thread2==thread)
 78573 cmp 0,EAX
 78576 jge 78582
 78579 jmp 78595
__3310:
__3308:
 78582 rstack EAX,EBP:-4
// loop step
 78586 inc EAX
 78588 sstack EBP:-4,EAX
 78592 jmp 78506
__3306:
start_next_thread:
 78595 rstack EAX,EBP:-4
 78599 add EAX,1
 78602 mov EBX,EAX
// I=I+1
 78604 sstack EBP:-4,EBX
__3312:
 78608 rstack EAX,EBP:-4
 78612 rstack EBX,EBP:-3
 78616 sub EBX,EAX
 78618 mov EAX,EBX
 78620 neg EAX
 78622 fsgn EAX,EAX
 78624 inc EAX
 78626 max EAX,0
// if (I>=len)
 78629 cmp 0,EAX
 78632 jge 78640
// I=0
 78635 sstack EBP:-4,0
__3313:
__3311:
 78640 rstack EAX,EBP:-5
// thread_enter arg #1 (float thread)
 78644 push EAX
 78646 mov ECX,1
// thread_enter(...)
 78649 call 77665
 78652 add ESP,1
thread_yield_end:
// P arg #1 (char* str)
 78655 push 78727
 78658 mov ECX,1
// P(...)
 78661 call 40570
 78664 add ESP,1
__3299:
 78667 leave 
 78668 ret 
__3305:
 78669 db "thread_yield: no threads to yield to
",0
__3301:
 78707 db "thread_yield enter
",0
__3314:
 78727 db "thread_yeild end
",0
thread_exit_func:
// thread_exit_func()
 78745 enter -0
__3316:
// P arg #1 (char* str)
 78748 push 78772
 78751 mov ECX,1
// P(...)
 78754 call 40570
 78757 add ESP,1
__3319:
// if (1
 78760 cmp 0,1
 78764 jz 78770
 78767 jmp 78760
__3318:
__3315:
 78770 leave 
 78771 ret 
__3317:
 78772 db "thread_exit_func
",0
thread_create:
// thread_create(entry,args)
 78790 enter 3
__3321:
// P arg #1 (char* str)
 78793 push 79121
 78796 mov ECX,1
// P(...)
 78799 call 40570
 78802 add ESP,1
 78805 mov ECX,0
// thread_new(...)
 78808 call 76809
 78811 sstack EBP:-1,EAX
// malloc arg #1 (float n)
 78815 push #77419
 78818 mov ECX,1
// malloc(...)
 78821 call 20709
 78824 add ESP,1
 78827 sstack EBP:-2,EAX
// malloc arg #1 (float n)
 78831 push 50
 78834 mov ECX,1
// malloc(...)
 78837 call 20709
 78840 add ESP,1
 78843 sstack EBP:-3,EAX
__3324:
 78847 rstack EAX,EBP:-2
 78851 lneg EAX
 78853 mov EBX,EAX
// if (!stack)
 78855 cmp 0,EBX
 78858 jge 78873
// Perr arg #1 (char* str)
 78861 push 79067
 78864 mov ECX,1
// Perr(...)
 78867 call 40763
 78870 add ESP,1
__3325:
__3323:
 78873 rstack EAX,EBP:2
// thread_set_entry arg #2 (float N)
 78877 push EAX
 78879 rstack EAX,EBP:-1
// thread_set_entry arg #1 (float this)
 78883 push EAX
 78885 mov ECX,2
// thread_set_entry(...)
 78888 call 77189
 78891 add ESP,2
 78894 rstack EAX,EBP:3
// thread_set_args arg #2 (float N)
 78898 push EAX
 78900 rstack EAX,EBP:-1
// thread_set_args arg #1 (float this)
 78904 push EAX
 78906 mov ECX,2
// thread_set_args(...)
 78909 call 77227
 78912 add ESP,2
// thread_set_time arg #2 (float N)
 78915 push 0
 78918 rstack EAX,EBP:-1
// thread_set_time arg #1 (float this)
 78922 push EAX
 78924 mov ECX,2
// thread_set_time(...)
 78927 call 77265
 78930 add ESP,2
 78933 rstack EAX,EBP:2
// thread_set_ip arg #2 (float N)
 78937 push EAX
 78939 rstack EAX,EBP:-1
// thread_set_ip arg #1 (float this)
 78943 push EAX
 78945 mov ECX,2
// thread_set_ip(...)
 78948 call 77303
 78951 add ESP,2
 78954 rstack EAX,EBP:-2
// thread_set_stack arg #2 (float N)
 78958 push EAX
 78960 rstack EAX,EBP:-1
// thread_set_stack arg #1 (float this)
 78964 push EAX
 78966 mov ECX,2
// thread_set_stack(...)
 78969 call 77341
 78972 add ESP,2
 78975 rstack EAX,EBP:-3
// thread_set_regs arg #2 (float N)
 78979 push EAX
 78981 rstack EAX,EBP:-1
// thread_set_regs arg #1 (float this)
 78985 push EAX
 78987 mov ECX,2
// thread_set_regs(...)
 78990 call 77379
 78993 add ESP,2
 78996 rstack EAX,EBP:3
// regs_set_to_entry arg #4 (float args)
 79000 push EAX
 79002 rstack EAX,EBP:2
// regs_set_to_entry arg #3 (float entry)
 79006 push EAX
 79008 rstack EAX,EBP:-2
// regs_set_to_entry arg #2 (float stack)
 79012 push EAX
 79014 rstack EAX,EBP:-3
// regs_set_to_entry arg #1 (float regs)
 79018 push EAX
 79020 mov ECX,4
// regs_set_to_entry(...)
 79023 call 77488
 79026 add ESP,4
 79029 rstack EAX,EBP:-1
// vector_push arg #2 (void* element)
 79033 push EAX
// vector_push arg #1 (void* self)
 79035 push #77417
 79038 mov ECX,2
// vector_push(...)
 79041 call 23548
 79044 add ESP,2
// P arg #1 (char* str)
 79047 push 79101
 79050 mov ECX,1
// P(...)
 79053 call 40570
 79056 add ESP,1
 79059 rstack EAX,EBP:-1
 79063 leave 
 79064 ret 
__3320:
 79065 leave 
 79066 ret 
__3326:
 79067 db "insufficient RAM to make a thread",0
__3327:
 79101 db "thread_create exit
",0
__3322:
 79121 db "thread_create enter
",0
msize:
// msize()
 79142 enter -0
__3329:
 79145 mov EAX,#83692
 79148 mov EAX,#EAX
 79150 leave 
 79151 ret 
__3328:
 79152 leave 
 79153 ret 
mdump:
// mdump(dest)
 79154 enter 1
__3331:
 79157 mov ECX,0
// msize(...)
 79160 call 79142
 79163 sstack EBP:-1,EAX
 79167 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 79171 push EAX
// memcpy arg #2 (void* src)
 79173 push #83692
 79176 rstack EAX,EBP:2
// memcpy arg #1 (void* dest)
 79180 push EAX
 79182 mov ECX,3
// memcpy(...)
 79185 call 10006
 79188 add ESP,3
__3330:
 79191 leave 
 79192 ret 
program_link:
// program_link(ptr)
 79193 enter 3
__3333:
 79196 rstack EAX,EBP:2
 79200 mov EBX,EAX
 79202 inc EAX
 79204 sstack EBP:2,EAX
 79208 sstack EBP:-1,#EBX
 79212 rstack EAX,EBP:2
 79216 mov EBX,EAX
 79218 inc EAX
 79220 sstack EBP:2,EAX
 79224 sstack EBP:-2,#EBX
 79228 mov EAX,79268
 79231 neg EAX
 79233 mov EBX,79709
 79236 add EBX,EAX
 79238 sstack EBP:-3,EBX
 79242 rstack EAX,EBP:-3
// memcpy arg #3 (float n)
 79246 push EAX
// memcpy arg #2 (void* src)
 79248 push 79268
 79251 rstack EAX,EBP:2
// memcpy arg #1 (void* dest)
 79255 push EAX
 79257 mov ECX,3
// memcpy(...)
 79260 call 10006
 79263 add ESP,3
__3332:
 79266 leave 
 79267 ret 
export_start:
func_export_table:
 79268 db 10006
 79269 db 10063
 79270 db 10120
 79271 db 10168
 79272 db 10227
 79273 db 10310
 79274 db 10361
 79275 db 10414
 79276 db 10488
 79277 db 10585
 79278 db 10631
 79279 db 10743
 79280 db 10776
 79281 db 10846
 79282 db 10920
 79283 db 10982
 79284 db 11134
 79285 db 11422
 79286 db 12865
 79287 db 12935
 79288 db 12958
 79289 db 14455
 79290 db 14482
 79291 db 14521
 79292 db 14560
 79293 db 14631
 79294 db 14694
 79295 db 14757
 79296 db 15359
 79297 db 15763
 79298 db 15885
 79299 db 15994
 79300 db 16120
 79301 db 16151
 79302 db 16502
 79303 db 16521
 79304 db 16546
 79305 db 16564
 79306 db 16582
 79307 db 16608
 79308 db 16617
 79309 db 16632
 79310 db 16649
 79311 db 16673
 79312 db 16684
 79313 db 16711
 79314 db 16728
 79315 db 16743
 79316 db 16758
 79317 db 16773
 79318 db 16788
 79319 db 16803
 79320 db 16828
 79321 db 16875
 79322 db 16896
 79323 db 16917
 79324 db 16926
 79325 db 16945
 79326 db 16974
 79327 db 16995
 79328 db 17026
 79329 db 17035
 79330 db 17055
 79331 db 17075
 79332 db 17099
 79333 db 17123
 79334 db 17147
 79335 db 17173
 79336 db 17199
 79337 db 17225
 79338 db 17249
 79339 db 17273
 79340 db 17297
 79341 db 17337
 79342 db 17375
 79343 db 17420
 79344 db 17465
 79345 db 17503
 79346 db 17543
 79347 db 17556
 79348 db 17569
 79349 db 17582
 79350 db 17597
 79351 db 17612
 79352 db 17627
 79353 db 17640
 79354 db 17653
 79355 db 17666
 79356 db 17704
 79357 db 17742
 79358 db 17780
 79359 db 17857
 79360 db 17877
 79361 db 17897
 79362 db 17917
 79363 db 17937
 79364 db 17955
 79365 db 17973
 79366 db 17991
 79367 db 18009
 79368 db 18276
 79369 db 18297
 79370 db 18315
 79371 db 18335
 79372 db 19105
 79373 db 19329
 79374 db 19360
 79375 db 19640
 79376 db 19875
 79377 db 19977
 79378 db 20215
 79379 db 20363
 79380 db 20709
 79381 db 21231
 79382 db 21903
 79383 db 22506
 79384 db 22595
 79385 db 22767
 79386 db 22843
 79387 db 22930
 79388 db 23153
 79389 db 23189
 79390 db 23225
 79391 db 23261
 79392 db 23297
 79393 db 23335
 79394 db 23373
 79395 db 23411
 79396 db 23449
 79397 db 23492
 79398 db 23548
 79399 db 23893
 79400 db 24122
 79401 db 24158
 79402 db 24205
 79403 db 24427
 79404 db 24689
 79405 db 25183
 79406 db 25454
 79407 db 25655
 79408 db 25698
 79409 db 25805
 79410 db 25825
 79411 db 25847
 79412 db 25885
 79413 db 25922
 79414 db 25991
 79415 db 26028
 79416 db 26091
 79417 db 26143
 79418 db 26168
 79419 db 26300
 79420 db 26428
 79421 db 26573
 79422 db 26787
 79423 db 26861
 79424 db 26965
 79425 db 27109
 79426 db 27205
 79427 db 27332
 79428 db 27367
 79429 db 27473
 79430 db 27632
 79431 db 27911
 79432 db 28024
 79433 db 28169
 79434 db 28455
 79435 db 28576
 79436 db 28909
 79437 db 29028
 79438 db 29363
 79439 db 29491
 79440 db 29950
 79441 db 30078
 79442 db 30559
 79443 db 30693
 79444 db 31153
 79445 db 31329
 79446 db 31434
 79447 db 31538
 79448 db 31703
 79449 db 31708
 79450 db 31726
 79451 db 31744
 79452 db 31762
 79453 db 31780
 79454 db 31845
 79455 db 31892
 79456 db 31912
 79457 db 31932
 79458 db 31952
 79459 db 31972
 79460 db 32037
 79461 db 32086
 79462 db 32280
 79463 db 32458
 79464 db 32756
 79465 db 33119
 79466 db 33338
 79467 db 33966
 79468 db 34235
 79469 db 34347
 79470 db 34457
 79471 db 34503
 79472 db 34549
 79473 db 34635
 79474 db 34727
 79475 db 34790
 79476 db 34853
 79477 db 35925
 79478 db 36482
 79479 db 36617
 79480 db 36681
 79481 db 36726
 79482 db 36738
 79483 db 36752
 79484 db 36766
 79485 db 36780
 79486 db 36802
 79487 db 36835
 79488 db 36861
 79489 db 36878
 79490 db 36895
 79491 db 36912
 79492 db 36929
 79493 db 36986
 79494 db 37019
 79495 db 37036
 79496 db 37055
 79497 db 37067
 79498 db 37108
 79499 db 37135
 79500 db 37147
 79501 db 37187
 79502 db 37222
 79503 db 37532
 79504 db 37796
 79505 db 38122
 79506 db 38246
 79507 db 37630
 79508 db 38437
 79509 db 38521
 79510 db 39054
 79511 db 39316
 79512 db 39387
 79513 db 40536
 79514 db 40570
 79515 db 40593
 79516 db 40628
 79517 db 40662
 79518 db 40700
 79519 db 40763
 79520 db 40786
 79521 db 41513
 79522 db 41623
 79523 db 41751
 79524 db 42038
 79525 db 42083
 79526 db 42848
 79527 db 43112
 79528 db 43551
 79529 db 37787
 79530 db 44015
 79531 db 44343
 79532 db 45517
 79533 db 46041
 79534 db 46230
 79535 db 46413
 79536 db 46906
 79537 db 47534
 79538 db 47875
 79539 db 48037
 79540 db 48264
 79541 db 48414
 79542 db 48928
 79543 db 49573
 79544 db 49607
 79545 db 50478
 79546 db 50754
 79547 db 52480
 79548 db 52972
 79549 db 53063
 79550 db 53569
 79551 db 61749
 79552 db 61809
 79553 db 62116
 79554 db 62218
 79555 db 62359
 79556 db 62704
 79557 db 62743
 79558 db 62784
 79559 db 62867
 79560 db 62908
 79561 db 62944
 79562 db 62980
 79563 db 63016
 79564 db 63054
 79565 db 63092
 79566 db 63130
 79567 db 63615
 79568 db 63728
 79569 db 63835
 79570 db 64218
 79571 db 64299
 79572 db 64388
 79573 db 64516
 79574 db 64589
 79575 db 65070
 79576 db 65295
 79577 db 65513
 79578 db 65889
 79579 db 66007
 79580 db 66075
 79581 db 66182
 79582 db 66223
 79583 db 66418
 79584 db 66560
 79585 db 66597
 79586 db 66760
 79587 db 66830
 79588 db 66994
 79589 db 67135
 79590 db 67185
 79591 db 67235
 79592 db 67538
 79593 db 67642
 79594 db 67717
 79595 db 68212
 79596 db 68758
 79597 db 68813
 79598 db 68928
 79599 db 69104
 79600 db 69217
 79601 db 69267
 79602 db 70900
 79603 db 71008
 79604 db 71051
 79605 db 71227
 79606 db 71369
 79607 db 71801
 79608 db 71870
 79609 db 71958
 79610 db 72124
 79611 db 72184
 79612 db 72265
 79613 db 72860
 79614 db 72965
 79615 db 73023
 79616 db 73550
 79617 db 73658
 79618 db 73977
 79619 db 75401
 79620 db 75507
 79621 db 75526
 79622 db 75579
 79623 db 75638
 79624 db 75680
 79625 db 75739
 79626 db 75781
 79627 db 75801
 79628 db 75819
 79629 db 76029
 79630 db 76063
 79631 db 76104
 79632 db 76197
 79633 db 76330
 79634 db 76487
 79635 db 76493
 79636 db 79142
 79637 db 79154
 79638 db 79193
 79639 db 79923
 79640 db 80461
 79641 db 80535
 79642 db 83333
 79643 db 83557
func_export_table_end:
var_export_table:
 79644 db 16468
 79645 db 16469
 79646 db 22588
 79647 db 22589
 79648 db 22590
 79649 db 22591
 79650 db 22592
 79651 db 22593
 79652 db 22594
 79653 db 22842
 79654 db 26785
 79655 db 26786
 79656 db 31424
 79657 db 31425
 79658 db 31426
 79659 db 31427
 79660 db 31428
 79661 db 31429
 79662 db 31430
 79663 db 31431
 79664 db 31432
 79665 db 31433
 79666 db 36481
 79667 db 36982
 79668 db 36983
 79669 db 36984
 79670 db 36985
 79671 db 37053
 79672 db 37054
 79673 db 37217
 79674 db 37218
 79675 db 37219
 79676 db 37220
 79677 db 37221
 79678 db 55258
 79679 db 55259
 79680 db 55260
 79681 db 55261
 79682 db 55262
 79683 db 55263
 79684 db 55264
 79685 db 55265
 79686 db 55266
 79687 db 55267
 79688 db 55268
 79689 db 55269
 79690 db 55270
 79691 db 55271
 79692 db 55272
 79693 db 55273
 79694 db 55339
 79695 db 62742
 79696 db 63727
 79697 db 64295
 79698 db 64296
 79699 db 68208
 79700 db 68209
 79701 db 68210
 79702 db 68211
 79703 db 69216
 79704 db 83688
 79705 db 83689
 79706 db 83690
 79707 db 83691
 79708 db 83692
var_export_table_end:
export_end:
progressive_read:
// progressive_read(ptr,size,fp,step)
 79709 enter 3
__3335:
 79712 rstack EAX,EBP:3
 79716 sstack EBP:-1,EAX
 79720 sstack EBP:-2,0
 79725 sstack EBP:-3,0
// PrintProgressBar arg #1 (float percent)
 79730 push 0
 79733 mov ECX,1
// PrintProgressBar(...)
 79736 call 41261
 79739 add ESP,1
__3337:
 79742 rstack EAX,EBP:-1
// if (sizeleft
 79746 cmp 0,EAX
 79749 jz 79916
__3339:
 79752 rstack EAX,EBP:5
 79756 rstack EBX,EBP:-1
 79760 sub EBX,EAX
 79762 mov EAX,EBX
 79764 neg EAX
 79766 fsgn EAX,EAX
 79768 max EAX,0
// if (step>sizeleft)
 79771 cmp 0,EAX
 79774 jge 79785
 79777 rstack EAX,EBP:-1
// step=sizeleft
 79781 sstack EBP:5,EAX
__3340:
__3338:
__3342:
 79785 rstack EAX,EBP:4
// fread arg #3 (float* fp)
 79789 push EAX
 79791 rstack EAX,EBP:5
// fread arg #2 (float size)
 79795 push EAX
 79797 rstack EAX,EBP:2
// fread arg #1 (float* to)
 79801 push EAX
 79803 mov ECX,3
// fread(...)
 79806 call 65295
 79809 add ESP,3
 79812 lneg EAX
// if (!fread(ptr,step,fp))
 79814 cmp 0,EAX
 79817 jge 79825
 79820 mov EAX,0
 79823 leave 
 79824 ret 
__3343:
__3341:
 79825 rstack EAX,EBP:5
 79829 rstack EBX,EBP:2
 79833 add EBX,EAX
 79835 mov EAX,EBX
// ptr=ptr+step
 79837 sstack EBP:2,EAX
 79841 rstack EAX,EBP:5
 79845 neg EAX
 79847 mov EBX,EAX
 79849 rstack EAX,EBP:-1
 79853 add EAX,EBX
 79855 mov EBX,EAX
// sizeleft=sizeleft-step
 79857 sstack EBP:-1,EBX
 79861 rstack EAX,EBP:5
 79865 rstack EBX,EBP:-2
 79869 add EBX,EAX
 79871 mov EAX,EBX
// sizedone=sizedone+step
 79873 sstack EBP:-2,EAX
 79877 rstack EAX,EBP:3
 79881 mov EBX,100
 79884 div EBX,EAX
 79886 rstack EAX,EBP:-2
 79890 mul EAX,EBX
 79892 mov EBX,EAX
// percent=sizedone*100/size
 79894 sstack EBP:-3,EBX
 79898 rstack EAX,EBP:-3
// PrintProgressBar arg #1 (float percent)
 79902 push EAX
 79904 mov ECX,1
// PrintProgressBar(...)
 79907 call 41261
 79910 add ESP,1
 79913 jmp 79742
__3336:
 79916 mov EAX,1
 79919 leave 
 79920 ret 
__3334:
 79921 leave 
 79922 ret 
program_load:
// program_load(filename)
 79923 enter 8
__3345:
 79926 out 0,0
// fopen arg #2 (char* mode)
 79930 push 40534
 79933 rstack EAX,EBP:2
// fopen arg #1 (char* filename)
 79937 push EAX
 79939 mov ECX,2
// fopen(...)
 79942 call 64589
 79945 add ESP,2
 79948 sstack EBP:-1,EAX
__3347:
 79952 rstack EAX,EBP:-1
 79956 lneg EAX
 79958 mov EBX,EAX
// if (!fp)
 79960 cmp 0,EBX
 79963 jge 79978
// Perr arg #1 (char* str)
 79966 push 49420
 79969 mov ECX,1
// Perr(...)
 79972 call 40763
 79975 add ESP,1
__3348:
__3346:
 79978 rstack EAX,EBP:-1
// fsize arg #1 (float fp)
 79982 push EAX
 79984 mov ECX,1
// fsize(...)
 79987 call 66007
 79990 add ESP,1
 79993 sstack EBP:-2,EAX
 79997 rstack EAX,EBP:-2
 80001 add EAX,256
 80004 mov EBX,EAX
// malloc arg #1 (float n)
 80006 push EBX
 80008 mov ECX,1
// malloc(...)
 80011 call 20709
 80014 add ESP,1
 80017 sstack EBP:-3,EAX
__3350:
 80021 rstack EAX,EBP:-3
 80025 lneg EAX
 80027 mov EBX,EAX
// if (!prog)
 80029 cmp 0,EBX
 80032 jge 80047
// Perr arg #1 (char* str)
 80035 push 80324
 80038 mov ECX,1
// Perr(...)
 80041 call 40763
 80044 add ESP,1
__3351:
__3349:
 80047 rstack EAX,EBP:-3
// toPage arg #1 (float addr)
 80051 push EAX
 80053 mov ECX,1
// toPage(...)
 80056 call 76029
 80059 add ESP,1
 80062 add EAX,1
 80065 sstack EBP:-4,EAX
 80069 rstack EAX,EBP:-4
 80073 mul EAX,128
 80076 mov EBX,EAX
 80078 sstack EBP:-5,EBX
 80082 mov ECX,0
// curticks(...)
 80085 call 37769
 80088 sstack EBP:-6,EAX
__3354:
// progressive_read arg #4 (float step)
 80092 push 500
 80095 rstack EAX,EBP:-1
// progressive_read arg #3 (float fp)
 80099 push EAX
 80101 rstack EAX,EBP:-2
// progressive_read arg #2 (float size)
 80105 push EAX
 80107 rstack EAX,EBP:-5
 80111 add EAX,1
 80114 mov EBX,EAX
// progressive_read arg #1 (float ptr)
 80116 push EBX
 80118 mov ECX,4
// progressive_read(...)
 80121 call 79709
 80124 add ESP,4
 80127 lneg EAX
// if (!progressive_read(ptr+1,size,fp,500))
 80129 cmp 0,EAX
 80132 jge 80147
// Perr arg #1 (char* str)
 80135 push 80367
 80138 mov ECX,1
// Perr(...)
 80141 call 40763
 80144 add ESP,1
__3355:
__3353:
// P arg #1 (char* str)
 80147 push 18244
 80150 mov ECX,1
// P(...)
 80153 call 40570
 80156 add ESP,1
 80159 mov ECX,0
// curticks(...)
 80162 call 37769
 80165 neg EAX
 80167 rstack EBX,EBP:-6
 80171 add EBX,EAX
 80173 mov EAX,EBX
// ticks=ticks-curticks()
 80175 sstack EBP:-6,EAX
// P2 arg #3 (char* str2)
 80179 push 43806
 80182 rstack EAX,EBP:-6
// P2 arg #2 (float N)
 80186 push EAX
// P2 arg #1 (char* str1)
 80188 push 80356
 80191 mov ECX,3
// P2(...)
 80194 call 40700
 80197 add ESP,3
 80200 rstack EAX,EBP:-5
// program_link arg #1 (float ptr)
 80204 push EAX
 80206 mov ECX,1
// program_link(...)
 80209 call 79193
 80212 add ESP,1
 80215 rstack EAX,EBP:-2
// toPage arg #1 (float addr)
 80219 push EAX
 80221 mov ECX,1
// toPage(...)
 80224 call 76029
 80227 add ESP,1
 80230 add EAX,1
 80233 sstack EBP:-7,EAX
// init loop
 80237 sstack EBP:-8,0
__3359:
 80242 rstack EAX,EBP:-8
 80246 rstack EBX,EBP:-7
 80250 sub EBX,EAX
 80252 mov EAX,EBX
 80254 fsgn EAX,EAX
// condition
 80256 max EAX,0
 80259 cmp 0,EAX
 80262 jz 80316
// mapPage arg #5 (float runlevel)
 80265 push 3
// mapPage arg #4 (float flags)
 80268 push 2
 80271 rstack EAX,EBP:-8
 80275 rstack EBX,EBP:-4
 80279 add EBX,EAX
 80281 mov EAX,EBX
// mapPage arg #3 (float phys)
 80283 push EAX
 80285 rstack EAX,EBP:-8
// mapPage arg #2 (float virt)
 80289 push EAX
// mapPage arg #1 (float PT)
 80291 push 81283
 80294 mov ECX,5
// mapPage(...)
 80297 call 76104
 80300 add ESP,5
 80303 rstack EAX,EBP:-8
// loop step
 80307 inc EAX
 80309 sstack EBP:-8,EAX
 80313 jmp 80242
__3358:
 80316 rstack EAX,EBP:-5
 80320 leave 
 80321 ret 
__3344:
 80322 leave 
 80323 ret 
__3352:
 80324 db "not enough RAM to load program
",0
__3357:
 80356 db "Load took ",0
__3356:
 80367 db "can't read file
",0
program_run_background:
// program_run_background(args)
 80384 enter 3
__3361:
 80387 rstack EAX,EBP:2
 80391 add EAX,0
 80394 mov EBX,EAX
 80396 sstack EBP:-1,#EBX
 80400 rstack EAX,EBP:2
 80404 add EAX,1
 80407 mov EBX,EAX
 80409 sstack EBP:-2,EBX
 80413 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 80417 push EAX
 80419 mov ECX,1
// strlen(...)
 80422 call 10743
 80425 add ESP,1
 80428 sstack EBP:-3,EAX
 80432 rstack EAX,EBP:-2
 80436 push EAX
 80438 rstack EAX,EBP:-3
 80442 push EAX
 80444 rstack EAX,EBP:-1
 80448 push EAX
 80450 mov ECX,3
// program_run(...)
 80453 call 80461
 80456 add ESP,3
__3360:
 80459 leave 
 80460 ret 
program_run:
// program_run(ptr,argc,argv)
 80461 enter 1
__3363:
 80464 rstack EAX,EBP:2
 80468 add EAX,1
 80471 mov EBX,EAX
 80473 sstack EBP:-1,#EBX
 80477 out 0,1
 80481 mov ECX,0
// pagingEnable(...)
 80484 call 76487
 80487 out 0,2
 80491 rstack EAX,EBP:4
 80495 push EAX
 80497 rstack EAX,EBP:3
 80501 push EAX
 80503 mov ECX,2
 80506 rstack EAX,EBP:-1
// entry(...)
 80510 call EAX
 80512 add ESP,2
 80515 out 0,3
 80519 mov ECX,0
// pagingDisable(...)
 80522 call 76493
 80525 out 0,4
 80529 out 0,0
__3362:
 80533 leave 
 80534 ret 
main:
// main()
 80535 enter 4
__3365:
 80538 out 0,0
 80542 out 1,0
 80546 out 2,0
 80550 out 3,0
 80554 out 4,0
 80558 out 5,0
 80562 out 6,0
 80566 out 7,0
 80570 mov ECX,0
// init_hardware(...)
 80573 call 83333
// setKeyboard arg #1 (float ptr)
 80576 push #83690
 80579 mov ECX,1
// setKeyboard(...)
 80582 call 37055
 80585 add ESP,1
// screen_set arg #1 (float scr)
 80588 push #37053
 80591 mov ECX,1
// screen_set(...)
 80594 call 36726
 80597 add ESP,1
 80600 mov ECX,0
// screen_clear(...)
 80603 call 36738
// PrintStringXY arg #4 (float col)
 80606 push 999
// PrintStringXY arg #3 (char str)
 80609 push 81212
// PrintStringXY arg #2 (float y)
 80612 push 0
// PrintStringXY arg #1 (float x)
 80615 push 0
 80618 mov ECX,4
// PrintStringXY(...)
 80621 call 36482
 80624 add ESP,4
// malloc_set_disk arg #2 (float disk_size)
 80627 push 131072
// malloc_set_disk arg #1 (float* disk)
 80630 push #83689
 80633 mov ECX,2
// malloc_set_disk(...)
 80636 call 19329
 80639 add ESP,2
 80642 mov ECX,0
// malloc_init(...)
 80645 call 19360
// malloc_print=P
 80648 mov #22589,40570
// malloc_num2str=num2str
 80652 mov #22590,12958
// malloc_debug=0
 80656 mov #22588,0
 80660 mov ECX,0
// filesystem_init(...)
 80663 call 64299
 80666 rstack EAX,EBP:-1
 80670 in EAX,0
 80673 sstack EBP:-1,EAX
 80677 rstack EAX,EBP:-2
 80681 in EAX,1
 80684 sstack EBP:-2,EAX
 80688 rstack EAX,EBP:-3
 80692 in EAX,2
 80695 sstack EBP:-3,EAX
 80699 rstack EAX,EBP:-4
 80703 in EAX,3
 80706 sstack EBP:-4,EAX
__3368:
 80710 rstack EAX,EBP:-1
// if (a)
 80714 cmp 0,EAX
 80717 jge 80744
// PrintStringXY arg #4 (float col)
 80720 push 999
// PrintStringXY arg #3 (char str)
 80723 push 81257
// PrintStringXY arg #2 (float y)
 80726 push 1
// PrintStringXY arg #1 (float x)
 80729 push 0
 80732 mov ECX,4
// PrintStringXY(...)
 80735 call 36482
 80738 add ESP,4
 80741 jmp 80765
__3371:
__3369:
__3373:
// PrintStringXY arg #4 (float col)
 80744 push 999
// PrintStringXY arg #3 (char str)
 80747 push 81158
// PrintStringXY arg #2 (float y)
 80750 push 1
// PrintStringXY arg #1 (float x)
 80753 push 0
 80756 mov ECX,4
// PrintStringXY(...)
 80759 call 36482
 80762 add ESP,4
__3372:
__3367:
__3376:
 80765 rstack EAX,EBP:-2
// if (b)
 80769 cmp 0,EAX
 80772 jge 80799
// PrintStringXY arg #4 (float col)
 80775 push 999
// PrintStringXY arg #3 (char str)
 80778 push 81234
// PrintStringXY arg #2 (float y)
 80781 push 2
// PrintStringXY arg #1 (float x)
 80784 push 0
 80787 mov ECX,4
// PrintStringXY(...)
 80790 call 36482
 80793 add ESP,4
 80796 jmp 80820
__3379:
__3377:
__3381:
// PrintStringXY arg #4 (float col)
 80799 push 999
// PrintStringXY arg #3 (char str)
 80802 push 81090
// PrintStringXY arg #2 (float y)
 80805 push 2
// PrintStringXY arg #1 (float x)
 80808 push 0
 80811 mov ECX,4
// PrintStringXY(...)
 80814 call 36482
 80817 add ESP,4
__3380:
__3375:
__3384:
 80820 rstack EAX,EBP:-3
// if (c)
 80824 cmp 0,EAX
 80827 jge 80854
// PrintStringXY arg #4 (float col)
 80830 push 999
// PrintStringXY arg #3 (char str)
 80833 push 81061
// PrintStringXY arg #2 (float y)
 80836 push 3
// PrintStringXY arg #1 (float x)
 80839 push 0
 80842 mov ECX,4
// PrintStringXY(...)
 80845 call 36482
 80848 add ESP,4
 80851 jmp 80875
__3387:
__3385:
__3389:
// PrintStringXY arg #4 (float col)
 80854 push 999
// PrintStringXY arg #3 (char str)
 80857 push 81114
// PrintStringXY arg #2 (float y)
 80860 push 3
// PrintStringXY arg #1 (float x)
 80863 push 0
 80866 mov ECX,4
// PrintStringXY(...)
 80869 call 36482
 80872 add ESP,4
__3388:
__3383:
__3392:
 80875 rstack EAX,EBP:-4
// if (d)
 80879 cmp 0,EAX
 80882 jge 80909
// PrintStringXY arg #4 (float col)
 80885 push 999
// PrintStringXY arg #3 (char str)
 80888 push 81035
// PrintStringXY arg #2 (float y)
 80891 push 4
// PrintStringXY arg #1 (float x)
 80894 push 0
 80897 mov ECX,4
// PrintStringXY(...)
 80900 call 36482
 80903 add ESP,4
 80906 jmp 80930
__3395:
__3393:
__3397:
// PrintStringXY arg #4 (float col)
 80909 push 999
// PrintStringXY arg #3 (char str)
 80912 push 81185
// PrintStringXY arg #2 (float y)
 80915 push 4
// PrintStringXY arg #1 (float x)
 80918 push 0
 80921 mov ECX,4
// PrintStringXY(...)
 80924 call 36482
 80927 add ESP,4
__3396:
__3391:
__3400:
 80930 rstack EAX,EBP:-1
// if (a)
 80934 cmp 0,EAX
 80937 jge 80994
// PrintStringXY arg #4 (float col)
 80940 push 999
// PrintStringXY arg #3 (char str)
 80943 push 81141
// PrintStringXY arg #2 (float y)
 80946 push 5
// PrintStringXY arg #1 (float x)
 80949 push 0
 80952 mov ECX,4
// PrintStringXY(...)
 80955 call 36482
 80958 add ESP,4
// filesystem_read arg #1 (float disk)
 80961 push #83691
 80964 mov ECX,1
// filesystem_read(...)
 80967 call 67717
 80970 add ESP,1
// PrintStringXY arg #4 (float col)
 80973 push 999
// PrintStringXY arg #3 (char str)
 80976 push 81087
// PrintStringXY arg #2 (float y)
 80979 push 5
// PrintStringXY arg #1 (float x)
 80982 push 16
 80985 mov ECX,4
// PrintStringXY(...)
 80988 call 36482
 80991 add ESP,4
__3401:
__3399:
// initPaging arg #4 (float runlevel)
 80994 push 0
// initPaging arg #3 (float flags)
 80997 push 0
// initPaging arg #2 (float size)
 81000 push 512
// initPaging arg #1 (float PT)
 81003 push 81283
 81006 mov ECX,4
// initPaging(...)
 81009 call 75401
 81012 add ESP,4
 81015 mov ECX,0
// screen_clear(...)
 81018 call 36738
 81021 mov ECX,0
// initThreads(...)
 81024 call 77420
 81027 mov ECX,0
// shell(...)
 81030 call 37796
__3364:
 81033 leave 
 81034 ret 
__3394:
 81035 db "Switch 4: Unassigned: ON
",0
__3386:
 81061 db "Switch 3: Unassigned: ON
",0
__3403:
 81087 db "OK",0
__3382:
 81090 db "Switch 2: Autorun: OFF
",0
__3390:
 81114 db "Switch 3: Unassigned: OFF
",0
__3402:
 81141 db "Mounting disk...",0
__3374:
 81158 db "Switch 1: Mount disk: OFF
",0
__3398:
 81185 db "Switch 4: Unassigned: OFF
",0
__3366:
 81212 db "Loading Cyclone OS...",0
__3378:
 81234 db "Switch 2: Autorun: ON
",0
__3370:
 81257 db "Switch 1: Mount disk: ON
",0
pageTable:
 81283 alloc 1026
intTable:
 82309 alloc 1024
init_hardware:
// init_hardware()
 83333 enter -0
__3405:
// AdrEB=131072
 83336 mov #83688,131072
 83340 mov EAX,#83688
 83343 add EAX,32
// AdrRAM=AdrEB+32
 83346 mov #83689,EAX
 83349 mov EAX,#83689
 83352 add EAX,131072
// AdrKb=AdrRAM+131072
 83355 mov #83690,EAX
 83358 mov EAX,#83690
 83361 add EAX,300
// AdrScreen=AdrKb+300
 83364 mov #37053,EAX
 83367 mov EAX,#37053
 83370 add EAX,3000
// AdrHDD=AdrScreen+3000
 83373 mov #83691,EAX
 83376 mov EAX,#83691
 83379 add EAX,131072
// AdrPort=AdrHDD+131072
 83382 mov #83692,EAX
 83385 mov EAX,0
 83388 add EAX,#83688
// AdrEB[0]=0
 83391 mov #EAX,0
 83394 mov EAX,1
 83397 add EAX,#83688
// AdrEB[1]=131072-1
 83400 mov #EAX,131071
 83403 mov EAX,1
 83406 add EAX,#83688
 83409 mov EBX,#EAX
 83411 add EBX,1
 83414 mov EAX,2
 83417 add EAX,#83688
// AdrEB[2]=AdrEB[1]+1
 83420 mov #EAX,EBX
 83422 mov EAX,2
 83425 add EAX,#83688
 83428 mov EBX,#EAX
 83430 add EBX,299
 83433 mov EAX,3
 83436 add EAX,#83688
// AdrEB[3]=AdrEB[2]+300-1
 83439 mov #EAX,EBX
 83441 mov EAX,3
 83444 add EAX,#83688
 83447 mov EBX,#EAX
 83449 add EBX,1
 83452 mov EAX,4
 83455 add EAX,#83688
// AdrEB[4]=AdrEB[3]+1
 83458 mov #EAX,EBX
 83460 mov EAX,4
 83463 add EAX,#83688
 83466 mov EBX,#EAX
 83468 add EBX,2999
 83471 mov EAX,5
 83474 add EAX,#83688
// AdrEB[5]=AdrEB[4]+3000-1
 83477 mov #EAX,EBX
 83479 mov EAX,5
 83482 add EAX,#83688
 83485 mov EBX,#EAX
 83487 add EBX,1
 83490 mov EAX,6
 83493 add EAX,#83688
// AdrEB[6]=AdrEB[5]+1
 83496 mov #EAX,EBX
 83498 mov EAX,6
 83501 add EAX,#83688
 83504 mov EBX,#EAX
 83506 add EBX,131071
 83509 mov EAX,7
 83512 add EAX,#83688
// AdrEB[7]=AdrEB[6]+131072-1
 83515 mov #EAX,EBX
 83517 mov EAX,7
 83520 add EAX,#83688
 83523 mov EBX,#EAX
 83525 add EBX,1
 83528 mov EAX,8
 83531 add EAX,#83688
// AdrEB[8]=AdrEB[7]+1
 83534 mov #EAX,EBX
 83536 mov EAX,8
 83539 add EAX,#83688
 83542 mov EBX,#EAX
 83544 add EBX,131071
 83547 mov EAX,9
 83550 add EAX,#83688
// AdrEB[9]=AdrEB[8]+131072-1
 83553 mov #EAX,EBX
__3404:
 83555 leave 
 83556 ret 
memtest2:
// memtest2()
 83557 enter 1
__3407:
 83560 sstack EBP:-1,83693
__3409:
// if (1
 83565 cmp 0,1
 83569 jz 83678
 83572 rstack EAX,EBP:-1
// *I=1
 83576 mov #EAX,1
__3411:
 83579 rstack EAX,EBP:-1
 83583 mov EBX,1
 83586 sub EBX,#EAX
 83588 fabs EBX,EBX
 83590 fsgn EBX,EBX
// if (*I!=1)
 83592 cmp 0,EBX
 83595 jge 83601
 83598 int 1
__3412:
__3410:
 83601 rstack EAX,EBP:-1
// *I=0
 83605 mov #EAX,0
__3414:
 83608 rstack EAX,EBP:-1
 83612 mov EBX,0
 83615 sub EBX,#EAX
 83617 fabs EBX,EBX
 83619 fsgn EBX,EBX
// if (*I!=0)
 83621 cmp 0,EBX
 83624 jge 83630
 83627 int 1
__3415:
__3413:
 83630 rstack EAX,EBP:-1
 83634 out 0,EAX
 83637 rstack EAX,EBP:-1
 83641 div EAX,1024
 83644 mov EBX,EAX
 83646 out 1,EBX
 83649 rstack EAX,EBP:-1
 83653 add EAX,1
 83656 mov EBX,EAX
 83658 mul EBX,1.0005
// I=(I+1)*1.0005
 83661 sstack EBP:-1,EBX
 83665 rstack EAX,EBP:-1
 83669 fint EAX
 83671 sstack EBP:-1,EAX
 83675 jmp 83565
__3408:
__3406:
 83678 leave 
 83679 ret 
MAIN_CONSTANTS:
OSname:
 83680 db "test 23"
 83687 db 0
MAIN_VARS:
AdrEB:
 83688 alloc 1
AdrRam:
 83689 alloc 1
AdrKb:
 83690 alloc 1
AdrHDD:
 83691 alloc 1
AdrPort:
 83692 alloc 1
End:
