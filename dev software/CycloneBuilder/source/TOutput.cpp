#include "TOutput.h"
#include "builder_cli.h"

TOutput::TOutput(TConfig& cfg, TSymbolTable& symTable) :
	cfg(cfg), symTable(symTable) {}

void TOutput::write_symbol_table() {
	ofstream fs;

	// function and variable table, with names
	string filename = cfg.dirs.dir_output + "func_table.txt";
	fs.open(filename);
	if (!fs.is_open()) { dout << "can't open " << filename << endl; exit(1); }
	fs << "#ifndef CYCLONE_BUILDER" << endl;
	fs << "func_table:" << endl;
	for (auto I = symTable.all_funcs.begin(); I != symTable.all_funcs.end(); I++) {
		fs << "db " << (*I)->name << ", db str_" << (*I)->name << ";" << endl;
	}
	fs << "func_table_end:" << endl;
	fs << endl;
	fs << "var_table:" << endl;
	for (auto I = symTable.all_vars.begin(); I != symTable.all_vars.end(); I++) {
		fs << "db &" << (*I)->name << ", db str_" << (*I)->name << ";" << endl;
	}
	fs << "var_table_end:" << endl;
	fs << endl;
	fs << "func_name_table:" << endl;
	for (auto I = symTable.all_funcs.begin(); I != symTable.all_funcs.end(); I++) {
		fs << "str_" << (*I)->name << ": db \"" << (*I)->name << "\", db 0;" << endl;
	}
	fs << "func_name_table_end:" << endl;
	fs << endl;
	fs << "var_name_table:" << endl;
	for (auto I = symTable.all_vars.begin(); I != symTable.all_vars.end(); I++) {
		fs << "str_" << (*I)->name << ": db \"" << (*I)->name << "\", db 0;" << endl;
	}
	fs << "var_name_table_end:" << endl;
	fs << "#endif" << endl;

	if (fs.is_open()) { 
		//dout << "func_table written" << endl; 
	}
	else { dout << "func_table: error" << endl; }
	fs.close();

	// symbol export table
	filename = cfg.dirs.dir_output + "func_export_table.txt";
	fs.open(filename);
	if (!fs.is_open()) { dout << "can't open " << filename << endl; exit(1); }
	fs << "#ifndef CYCLONE_BUILDER" << endl;
	fs << "func_export_table:" << endl;
	for (auto I = symTable.all_funcs.begin(); I != symTable.all_funcs.end(); I++) {
		fs << "db " << (*I)->name << ";" << endl;
	}
	fs << "func_export_table_end:" << endl;
	fs << endl;
	fs << "var_export_table:" << endl;
	for (auto I = symTable.all_vars.begin(); I != symTable.all_vars.end(); I++) {
		fs << "db &" << (*I)->name << ";" << endl;	//vars are exported by ptr
	}
	fs << "var_export_table_end:" << endl;
	fs << "#endif" << endl;

	if (fs.is_open()) { 
		//dout << "func_export_table written" << endl; 
	}
	else { dout << "func_export_table: error" << endl; }
	fs.close();


	// symbol import table
	filename = cfg.dirs.dir_output + "func_import_table.txt";
	fs.open(filename);
	if (!fs.is_open()) { dout << "can't open " << filename << endl; exit(1); }

	fs << "#ifndef CYCLONE_BUILDER" << endl;
	fs << "func_import_table:" << endl;
	for (auto I = symTable.all_funcs.begin(); I != symTable.all_funcs.end(); I++) {
		fs << "float " << (*I)->name << ";" << endl;
	}
	fs << "func_import_table_end:" << endl;
	fs << endl;
	fs << "var_import_table:" << endl;
	for (auto I = symTable.all_vars.begin(); I != symTable.all_vars.end(); I++) {
		fs << "float " << (*I)->name << ";" << endl;	//vars are ptrs, remember
	}
	fs << "var_import_table_end:" << endl;
	fs << "#endif" << endl;
	if (fs.is_open()) { 
		//dout << "func_import_table written" << endl; 
	}
	else { dout << "func_import_table: error" << endl; }
	fs.close();

	//reverse reference table
	filename = cfg.dirs.dir_output + "reference_table.txt";
	fs.open(filename);
	if (!fs.is_open()) { dout << "can't open " << filename << endl; exit(1); }

	fs << "#ifndef CYCLONE_BUILDER" << endl;
	fs << "reference_table:" << endl;

	for (auto I = symTable.references.begin(); I != symTable.references.end(); I++) {
		int type = I->type;
		string name = I->name;

		if (type == REF_STACK) { continue; } //we don't handle stack vars. But we could.
		if (type == REF_EXT) { fs << "float " << name << "= 0; "; }//": db __PTR__";}
		if (type == REF_INT_VAR) { continue; }//{fs << "db &" << name <<",";} //we also don't handle
		if (type == REF_INT_FUNC) { continue; }//{fs << "db " << name <<",";} //internals cause they
		if (type == REF_INT_LABEL) { continue; }//{fs << "db "<< name <<",";} //just get relocated
		fs << "db str2_" << name << ";" << endl;
	}
	//we also don't handle internals because
	//of autogenerated labels like 
	//...
	//je __5;
	//"else"
	//__6:
	//...
	//and because of const-expressions
	//like ...float arg = Arr+1
	//though that can be fixed by making them all floats.


	fs << "reference_table_end:" << endl;
	fs << endl;
	fs << "reference_name_table:" << endl;
	for (auto I = symTable.references.begin(); I != symTable.references.end(); I++) {
		int type = I->type;
		string name = I->name;

		if (type == REF_STACK) { continue; }
		if (type == REF_INT_VAR) { continue; }
		if (type == REF_INT_FUNC) { continue; }
		if (type == REF_INT_LABEL) { continue; }
		fs << "str2_" << name << ": db \"" << name << "\",0;" << endl;
	}
	fs << "reference_name_table_end:" << endl;
	fs << "#endif" << endl;
	if (fs.is_open()) { 
		//dout << "reference_table written" << endl; 
	}
	else { dout << "reference_table: error" << endl; }
	fs.close();

}
