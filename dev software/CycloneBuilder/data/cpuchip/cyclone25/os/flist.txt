     0 mov ESP,12800
     3 cpuset 9,12800
     7 mov SS,67265
    10 jmp 80198
derpslot:
    13 db 7012
programslot:
    14 org 128
user_kernel_interface:
thread_entry:
// thread_entry(jmpPos)
   128 enter -0
__1:
   131 rstack EAX,EBP:2
   135 call EAX
   137 mov R0,4
   140 int 40
__0:
   143 leave 
   144 ret 
thread_entry_end:
   145 db 0
   146 org 256
current_thread:
   256 db 0
lastProcess:
   257 db 0
switchToLastProcess:
// switchToLastProcess()
   258 enter -0
__3:
__5:
// if (lastProcess)
   261 cmp 0,#257
   265 jge 280
   268 push #257
   271 mov ECX,1
// switchToProcess(...)
   274 call 282
   277 add ESP,1
__6:
__4:
__2:
   280 leave 
   281 ret 
switchToProcess:
// switchToProcess(proc_h)
   282 enter 3
__8:
   285 rstack EAX,EBP:2
   289 push EAX
   291 mov ECX,1
// process_h_get_pagemap(...)
   294 call 25296
   297 add ESP,1
   300 sstack EBP:-1,EAX
   304 rstack EAX,EBP:-1
   308 push EAX
   310 mov ECX,1
// vector_array(...)
   313 call 34499
   316 add ESP,1
   319 sstack EBP:-2,EAX
   323 rstack EAX,EBP:-2
   327 div EAX,2
   330 mov EBX,EAX
   332 sstack EBP:-3,EBX
// current_thread=1
   336 mov #256,1
   340 rstack EAX,EBP:2
// lastProcess=proc_h
   344 mov #257,EAX
   347 rstack EAX,EBP:-3
   351 push EAX
   353 rstack EAX,EBP:-2
   357 push EAX
   359 mov ECX,2
// setPageTable(...)
   362 call 36335
   365 add ESP,2
   368 mov ECX,0
// pagingEnable(...)
   371 call 37315
__7:
   374 leave 
   375 ret 
switchToProcessAndRun:
// switchToProcessAndRun(proc_h)
   376 enter 1
__10:
   379 rstack EAX,EBP:2
   383 push EAX
   385 mov ECX,1
// process_h_get_thread(...)
   388 call 25224
   391 add ESP,1
   394 sstack EBP:-1,EAX
   398 rstack EAX,EBP:2
// switchToProcess arg #1 (float proc_h)
   402 push EAX
   404 mov ECX,1
// switchToProcess(...)
   407 call 282
   410 add ESP,1
   413 rstack EAX,EBP:-1
// thread_entry arg #1 (float jmpPos)
   417 push EAX
   419 mov ECX,1
// thread_entry(...)
   422 call 128
   425 add ESP,1
__9:
   428 leave 
   429 ret 
switchToKernel:
// switchToKernel()
   430 enter -0
__12:
   433 clm 
// current_thread=0
   434 mov #256,0
__11:
   438 leave 
   439 ret 
user_ki_middle:
   440 db 0
   441 org 1280
interruptTable:
  1280 alloc 200
  1480 alloc 128
user_kernel_interface_end:
  1608 db 0
  1609 org 10000
programslot_end:
 10000 db 0
libmarker1:
 10001 db 0
va_start:
 10002 rstack EAX,ESP:2
 10006 sub EAX,DS
 10008 sub EAX,SS
 10010 ret 
va_start_0:
 10011 mov EAX,EBP:1
 10015 ret 
va_next:
 10016 rstack EBX,ESP:2
 10020 inc #EBX
 10022 rstack EAX,#EBX
 10024 ret 
va_get:
 10025 rstack EAX,ESP:2
 10029 rstack EBX,ESP:3
 10033 add EAX,EBX
 10035 inc EAX
 10037 mov EAX,#EAX
 10039 ret 
va_get_0:
 10040 rstack EAX,ESP:2
 10044 add EAX,EBP:2
 10048 rstack EAX,EAX
 10050 ret 
libmarker2:
 10051 db 0
assert:
// assert(n,str)
 10052 enter -0
__14:
__16:
 10055 rstack EAX,EBP:2
 10059 mov EBX,0
 10062 sub EBX,EAX
 10064 fabs EBX,EBX
 10066 fsgn EBX,EBX
 10068 lneg EBX
// if (n==0)
 10070 cmp 0,EBX
 10073 jge 10097
 10076 push 900
 10079 push 10099
 10082 mov ECX,2
// printf(...)
 10085 call 21772
 10088 add ESP,2
 10091 mov ECX,0
// panic(...)
 10094 call 85274
__17:
__15:
__13:
 10097 leave 
 10098 ret 
__18:
 10099 db "%massertion failed: %s
",0
assert_type:
// assert_type(self,t)
 10123 enter -0
__20:
__22:
 10126 rstack EAX,EBP:2
 10130 add EAX,0
 10133 mov EBX,EAX
 10135 rstack EAX,EBP:3
 10139 sub EAX,#EBX
 10141 mov EBX,EAX
 10143 fabs EBX,EBX
 10145 fsgn EBX,EBX
// if (self[0]!=t)
 10147 cmp 0,EBX
 10150 jge 10186
 10153 rstack EAX,EBP:3
 10157 push EAX
 10159 rstack EAX,EBP:2
 10163 push EAX
 10165 push 900
 10168 push 10188
 10171 mov ECX,4
// printf(...)
 10174 call 21772
 10177 add ESP,4
 10180 mov ECX,0
// panic(...)
 10183 call 85274
__23:
__21:
__19:
 10186 leave 
 10187 ret 
__24:
 10188 db "%mtype error: %d is not a %s
",0
curticks:
// curticks()
 10218 enter 1
__26:
 10221 cpuget EAX,29
// T=EAX
 10224 sstack EBP:-1,EAX
 10228 rstack EAX,EBP:-1
 10232 leave 
 10233 ret 
__25:
 10234 leave 
 10235 ret 
curtime:
// curtime()
 10236 enter -0
__28:
 10239 timer EAX
 10241 leave 
 10242 ret 
__27:
 10243 leave 
 10244 ret 
assert_arity:
// assert_arity(ecx_here,num_args)
 10245 enter -0
__30:
__32:
 10248 rstack EAX,EBP:2
 10252 rstack EBX,EBP:3
 10256 sub EBX,EAX
 10258 mov EAX,EBX
 10260 fabs EAX,EAX
 10262 fsgn EAX,EAX
// if (ecx_here!=num_args)
 10264 cmp 0,EAX
 10267 jge 10303
 10270 rstack EAX,EBP:2
 10274 push EAX
 10276 rstack EAX,EBP:3
 10280 push EAX
 10282 push 900
 10285 push 10305
 10288 mov ECX,4
// printf(...)
 10291 call 21772
 10294 add ESP,4
 10297 mov ECX,0
// panic(...)
 10300 call 85274
__33:
__31:
__29:
 10303 leave 
 10304 ret 
__34:
 10305 db "%mArity error: func expects %d args, but got %d
",0
libmarker3:
 10354 db 0
LIBSTRING_CODE:
memcpy:
// memcpy(dest,src,n)
 10355 enter -0
__36:
 10358 rstack ECX,EBP:3
// ESI=src
 10362 mov ESI,ECX
 10364 rstack ECX,EBP:2
// EDI=dest
 10368 mov EDI,ECX
 10370 rstack ECX,EBP:4
// rem=n
 10374 mov EAX,ECX
__38:
// if (rem
 10376 cmp 0,EAX
 10379 jz 10402
 10382 mov EBX,EAX
 10384 min EBX,8192
 10387 mcopy EBX
 10389 mov ECX,EBX
 10391 neg ECX
 10393 mov EDX,EAX
 10395 add EDX,ECX
// rem=rem-count
 10397 mov EAX,EDX
 10399 jmp 10376
__37:
 10402 rstack ECX,EBP:2
 10406 mov EAX,ECX
 10408 leave 
 10409 ret 
__35:
 10410 leave 
 10411 ret 
memchr:
// memchr(s,c,n)
 10412 enter -0
__40:
 10415 rstack ECX,EBP:2
 10419 mov EAX,ECX
 10421 rstack ECX,EBP:4
 10425 mov EBX,ECX
__42:
// if (rem
 10427 cmp 0,EBX
 10430 jz 10462
__44:
 10433 rstack ECX,EBP:3
 10437 sub ECX,#EAX
 10439 mov EDX,ECX
 10441 fabs EDX,EDX
 10443 fsgn EDX,EDX
 10445 lneg EDX
// if (*r==c)
 10447 cmp 0,EDX
 10450 jge 10455
 10453 leave 
 10454 ret 
__45:
__43:
// ++r
 10455 inc EAX
// --rem
 10457 dec EBX
 10459 jmp 10427
__41:
 10462 mov EAX,0
 10465 leave 
 10466 ret 
__39:
 10467 leave 
 10468 ret 
memset:
// memset(ptr,c,n)
 10469 enter -0
__47:
 10472 rstack EDX,EBP:2
 10476 mov EAX,EDX
 10478 rstack EDX,EBP:4
 10482 mov EBX,EDX
 10484 rstack EDX,EBP:3
 10488 mov ECX,EDX
__49:
// if (rem
 10490 cmp 0,EBX
 10493 jz 10507
 10496 mov EDX,EAX
 10498 inc EAX
// *p++=ch
 10500 mov #EDX,ECX
// --rem
 10502 dec EBX
 10504 jmp 10490
__48:
 10507 rstack EDX,EBP:2
 10511 mov EAX,EDX
 10513 leave 
 10514 ret 
__46:
 10515 leave 
 10516 ret 
strcat:
// strcat(src,dest)
 10517 enter -0
__51:
 10520 rstack ECX,EBP:2
// srcptr=src
 10524 mov EAX,ECX
__52:
 10526 inc EAX
 10528 mov ECX,EAX
// if (*++srcptr
 10530 cmp 0,#ECX
 10533 jz 10539
 10536 jmp 10526
__53:
 10539 rstack ECX,EBP:3
// destptr=dest
 10543 mov EBX,ECX
__54:
 10545 mov ECX,EBX
 10547 inc EBX
 10549 mov EDX,EAX
 10551 inc EAX
 10553 mov #EDX,#ECX
 10555 mov ESI,#EDX
// if (*srcptr++=*destptr++
 10557 cmp 0,ESI
 10560 jz 10566
 10563 jmp 10545
__55:
 10566 rstack ECX,EBP:2
 10570 mov EAX,ECX
 10572 leave 
 10573 ret 
__50:
 10574 leave 
 10575 ret 
strncat:
// strncat(src,dest,n)
 10576 enter -0
__57:
 10579 rstack EDX,EBP:2
// srcptr=src
 10583 mov EAX,EDX
// srcptr--
 10585 dec EAX
__58:
 10587 inc EAX
 10589 mov EDX,EAX
// if (*++srcptr
 10591 cmp 0,#EDX
 10594 jz 10600
 10597 jmp 10587
__59:
 10600 rstack EDX,EBP:3
// destptr=dest
 10604 mov EBX,EDX
 10606 rstack EDX,EBP:4
// i=n
 10610 mov ECX,EDX
__61:
 10612 mov EDX,ECX
 10614 dec ECX
// if (i--
 10616 cmp 0,EDX
 10619 jz 10646
__63:
 10622 mov EDX,EBX
 10624 inc EBX
 10626 mov ESI,EAX
 10628 inc EAX
 10630 mov #ESI,#EDX
 10632 mov EDI,#ESI
// if (*srcptr++=*destptr++)
 10634 cmp 0,EDI
 10637 jge 10643
 10640 jmp 10612
__62:
__64:
 10643 jmp 10612
__60:
// *srcptr=0
 10646 mov #EAX,0
 10649 rstack EDX,EBP:2
 10653 mov EAX,EDX
 10655 leave 
 10656 ret 
__56:
 10657 leave 
 10658 ret 
strchr:
// strchr(str,c)
 10659 enter -0
__66:
 10662 rstack ECX,EBP:2
// strptr=str
 10666 mov EAX,ECX
 10668 rstack ECX,EBP:3
// ch=c
 10672 mov EBX,ECX
__68:
// if (*strptr
 10674 cmp 0,#EAX
 10677 jz 10703
__70:
 10680 mov ECX,EBX
 10682 sub ECX,#EAX
 10684 fabs ECX,ECX
 10686 fsgn ECX,ECX
 10688 lneg ECX
// if (*strptr==ch)
 10690 cmp 0,ECX
 10693 jge 10698
 10696 leave 
 10697 ret 
__69:
__71:
// ++strptr
 10698 inc EAX
 10700 jmp 10674
__67:
 10703 mov EAX,0
 10706 leave 
 10707 ret 
__65:
 10708 leave 
 10709 ret 
strrchr:
// strrchr(str,c)
 10710 enter -0
__73:
// findptr=0
 10713 mov ECX,0
 10716 rstack EDX,EBP:2
// strptr=str
 10720 mov EAX,EDX
 10722 rstack EDX,EBP:3
// ch=c
 10726 mov EBX,EDX
__75:
// if (*strptr
 10728 cmp 0,#EAX
 10731 jz 10757
__77:
 10734 mov EDX,EBX
 10736 sub EDX,#EAX
 10738 fabs EDX,EDX
 10740 fsgn EDX,EDX
 10742 lneg EDX
// if (*strptr==ch)
 10744 cmp 0,EDX
 10747 jge 10752
// findptr=strptr
 10750 mov ECX,EAX
__76:
__78:
// ++strptr
 10752 inc EAX
 10754 jmp 10728
__74:
 10757 mov EAX,ECX
 10759 leave 
 10760 ret 
__72:
 10761 leave 
 10762 ret 
strcmp:
// strcmp(src,dest)
 10763 enter -0
__80:
__82:
 10766 rstack ECX,EBP:2
 10770 rstack EDX,EBP:3
 10774 sub EDX,ECX
 10776 mov ECX,EDX
 10778 fabs ECX,ECX
 10780 fsgn ECX,ECX
 10782 lneg ECX
// if (src==dest)
 10784 cmp 0,ECX
 10787 jge 10795
 10790 mov EAX,0
 10793 leave 
 10794 ret 
__83:
__81:
 10795 rstack ECX,EBP:2
// srcptr=src
 10799 mov EAX,ECX
 10801 rstack ECX,EBP:3
// destptr=dest
 10805 mov EBX,ECX
__85:
 10807 mov ECX,#EBX
 10809 sub ECX,#EAX
 10811 fabs ECX,ECX
 10813 fsgn ECX,ECX
 10815 lneg ECX
// if (*srcptr==*destptr
 10817 cmp 0,ECX
 10820 jz 10852
__87:
 10823 mov ECX,0
 10826 sub ECX,#EAX
 10828 fabs ECX,ECX
 10830 fsgn ECX,ECX
 10832 lneg ECX
// if (*srcptr==0)
 10834 cmp 0,ECX
 10837 jge 10845
 10840 mov EAX,0
 10843 leave 
 10844 ret 
__86:
__88:
// ++srcptr
 10845 inc EAX
// ++destptr
 10847 inc EBX
 10849 jmp 10807
__84:
 10852 mov ECX,#EBX
 10854 neg ECX
 10856 mov EDX,#EAX
 10858 add EDX,ECX
 10860 mov EAX,EDX
 10862 leave 
 10863 ret 
__79:
 10864 leave 
 10865 ret 
strncmp:
// strncmp(src,dest,n)
 10866 enter -0
__90:
 10869 rstack EDX,EBP:2
// srcptr=src
 10873 mov EAX,EDX
 10875 rstack EDX,EBP:3
// destptr=dest
 10879 mov EBX,EDX
 10881 rstack EDX,EBP:4
// i=n
 10885 mov ECX,EDX
__92:
 10887 mov EDX,#EBX
 10889 sub EDX,#EAX
 10891 fabs EDX,EDX
 10893 fsgn EDX,EDX
 10895 lneg EDX
 10897 mov ESI,ECX
 10899 and ESI,EDX
// if (i&&(*srcptr==*destptr)
 10901 cmp 0,ESI
 10904 jz 10938
__94:
 10907 mov EDX,0
 10910 sub EDX,#EAX
 10912 fabs EDX,EDX
 10914 fsgn EDX,EDX
 10916 lneg EDX
// if (*srcptr==0)
 10918 cmp 0,EDX
 10921 jge 10929
 10924 mov EAX,0
 10927 leave 
 10928 ret 
__93:
__95:
// ++srcptr
 10929 inc EAX
// ++destptr
 10931 inc EBX
// --i
 10933 dec ECX
 10935 jmp 10887
__91:
__97:
// if (i)
 10938 cmp 0,ECX
 10941 jge 10956
 10944 mov EDX,#EBX
 10946 neg EDX
 10948 mov ESI,#EAX
 10950 add ESI,EDX
 10952 mov EAX,ESI
 10954 leave 
 10955 ret 
__96:
__98:
 10956 mov EAX,0
 10959 leave 
 10960 ret 
__89:
 10961 leave 
 10962 ret 
strcpy:
// strcpy(dest,src)
 10963 enter -0
__100:
 10966 rstack ECX,EBP:2
// destptr=dest
 10970 mov EBX,ECX
 10972 rstack ECX,EBP:3
// srcptr=src
 10976 mov EAX,ECX
__101:
 10978 mov ECX,EAX
 10980 inc EAX
 10982 mov EDX,EBX
 10984 inc EBX
 10986 mov #EDX,#ECX
 10988 mov ESI,#EDX
// if (*destptr++=*srcptr++
 10990 cmp 0,ESI
 10993 jz 10999
 10996 jmp 10978
__102:
 10999 rstack ECX,EBP:2
 11003 mov EAX,ECX
 11005 leave 
 11006 ret 
__99:
 11007 leave 
 11008 ret 
strncpy:
// strncpy(dest,src,n)
 11009 enter -0
__104:
 11012 rstack EDX,EBP:2
// destptr=dest
 11016 mov EBX,EDX
 11018 rstack EDX,EBP:3
// srcptr=src
 11022 mov EAX,EDX
 11024 rstack EDX,EBP:4
// i=n
 11028 mov ECX,EDX
__106:
 11030 mov EDX,ECX
 11032 dec ECX
 11034 mov ESI,0
 11037 sub ESI,EDX
 11039 neg ESI
 11041 fsgn ESI,ESI
 11043 max ESI,0
// if (i-->0
 11046 cmp 0,ESI
 11049 jz 11108
__108:
 11052 mov EDX,EAX
 11054 inc EAX
 11056 mov ESI,EBX
 11058 inc EBX
 11060 mov #ESI,#EDX
 11062 mov EDI,#ESI
// if (*destptr++=*srcptr++)
 11064 cmp 0,EDI
 11067 jge 11073
 11070 jmp 11030
__107:
__109:
__110:
 11073 mov EDX,ECX
 11075 dec ECX
 11077 mov ESI,0
 11080 sub ESI,EDX
 11082 neg ESI
 11084 fsgn ESI,ESI
 11086 max ESI,0
// if (i-->0
 11089 cmp 0,ESI
 11092 jz 11105
 11095 mov EDX,EBX
 11097 inc EBX
// *destptr++=0
 11099 mov #EDX,0
 11102 jmp 11073
__111:
 11105 jmp 11030
__105:
// *destptr=0
 11108 mov #EBX,0
 11111 rstack EDX,EBP:2
 11115 mov EAX,EDX
 11117 leave 
 11118 ret 
__103:
 11119 leave 
 11120 ret 
strlen:
// strlen(str)
 11121 enter -0
__113:
 11124 rstack ECX,EBP:2
// strptr=str
 11128 mov EAX,ECX
// n=0
 11130 mov EBX,0
__114:
 11133 mov ECX,EAX
 11135 inc EAX
// if (*strptr++
 11137 cmp 0,#ECX
 11140 jz 11148
// n++
 11143 inc EBX
 11145 jmp 11133
__115:
 11148 mov EAX,EBX
 11150 leave 
 11151 ret 
__112:
 11152 leave 
 11153 ret 
strspn:
// strspn(str,accept)
 11154 enter -0
__117:
 11157 rstack ECX,EBP:2
 11161 mov EAX,ECX
 11163 rstack ECX,EBP:3
 11167 mov EBX,ECX
__119:
// if (*p
 11169 cmp 0,#EBX
 11172 jz 11206
__121:
 11175 mov ECX,EBX
 11177 inc EBX
 11179 mov EDX,#EAX
 11181 sub EDX,#ECX
 11183 fabs EDX,EDX
 11185 fsgn EDX,EDX
 11187 lneg EDX
// if (*p++==*s)
 11189 cmp 0,EDX
 11192 jge 11203
// ++s
 11195 inc EAX
 11197 rstack ECX,EBP:3
// p=accept
 11201 mov EBX,ECX
__122:
__120:
 11203 jmp 11169
__118:
 11206 rstack ECX,EBP:2
 11210 neg ECX
 11212 mov EDX,ECX
 11214 mov ECX,EAX
 11216 add ECX,EDX
 11218 mov EAX,ECX
 11220 leave 
 11221 ret 
__116:
 11222 leave 
 11223 ret 
strcspn:
// strcspn(str,reject)
 11224 enter -0
__124:
 11227 rstack ECX,EBP:2
// init loop
 11231 mov EAX,ECX
__126:
 11233 cmp 0,#EAX
 11236 jz 11280
 11239 rstack ECX,EBP:3
// init loop
 11243 mov EBX,ECX
__128:
 11245 cmp 0,#EBX
 11248 jz 11275
__130:
 11251 mov ECX,#EAX
 11253 sub ECX,#EBX
 11255 fabs ECX,ECX
 11257 fsgn ECX,ECX
 11259 lneg ECX
// if (*p==*s)
 11261 cmp 0,ECX
 11264 jge 11270
 11267 jmp 11280
__129:
__131:
// loop step
 11270 inc EBX
 11272 jmp 11245
__127:
// loop step
 11275 inc EAX
 11277 jmp 11233
__125:
done:
 11280 rstack ECX,EBP:2
 11284 neg ECX
 11286 mov EDX,ECX
 11288 mov ECX,EAX
 11290 add ECX,EDX
 11292 mov EAX,ECX
 11294 leave 
 11295 ret 
__123:
 11296 leave 
 11297 ret 
strpbrk:
// strpbrk(str,accept)
 11298 enter -0
__133:
 11301 rstack ECX,EBP:2
// init loop
 11305 mov EAX,ECX
__135:
 11307 cmp 0,#EAX
 11310 jz 11353
 11313 rstack ECX,EBP:3
// init loop
 11317 mov EBX,ECX
__137:
 11319 cmp 0,#EBX
 11322 jz 11348
__139:
 11325 mov ECX,#EAX
 11327 sub ECX,#EBX
 11329 fabs ECX,ECX
 11331 fsgn ECX,ECX
 11333 lneg ECX
// if (*p==*s)
 11335 cmp 0,ECX
 11338 jge 11343
 11341 leave 
 11342 ret 
__138:
__140:
// loop step
 11343 inc EBX
 11345 jmp 11319
__136:
// loop step
 11348 inc EAX
 11350 jmp 11307
__134:
 11353 mov EAX,0
 11356 leave 
 11357 ret 
__132:
 11358 leave 
 11359 ret 
strstr:
// strstr(haystack,needle)
 11360 enter -0
__142:
 11363 rstack ECX,EBP:2
 11367 mov EAX,ECX
 11369 rstack ECX,EBP:3
 11373 mov EBX,ECX
__144:
// if (1
 11375 cmp 0,1
 11379 jz 11461
__146:
 11382 mov ECX,#EBX
 11384 lneg ECX
// if (!*p)
 11386 cmp 0,ECX
 11389 jge 11400
 11392 rstack ECX,EBP:2
 11396 mov EAX,ECX
 11398 leave 
 11399 ret 
__147:
__145:
__149:
 11400 mov ECX,#EAX
 11402 sub ECX,#EBX
 11404 fabs ECX,ECX
 11406 fsgn ECX,ECX
 11408 lneg ECX
// if (*p==*s)
 11410 cmp 0,ECX
 11413 jge 11423
// ++p
 11416 inc EBX
// ++s
 11418 inc EAX
 11420 jmp 11458
__151:
__150:
__153:
 11423 rstack ECX,EBP:3
// p=needle
 11427 mov EBX,ECX
__155:
 11429 mov ECX,#EAX
 11431 lneg ECX
// if (!*s)
 11433 cmp 0,ECX
 11436 jge 11444
 11439 mov EAX,0
 11442 leave 
 11443 ret 
__156:
__154:
 11444 rstack ECX,EBP:2
 11448 inc ECX
 11450 mov EDX,ECX
 11452 sstack EBP:2,ECX
// s=++haystack
 11456 mov EAX,EDX
__152:
__148:
 11458 jmp 11375
__143:
__141:
 11461 leave 
 11462 ret 
STACKALLOC_CODE:
memcpy2:
// memcpy2(dest,src,n)
 11463 enter 1
__158:
__160:
 11466 rstack EAX,EBP:2
 11470 rstack EBX,EBP:3
 11474 sub EBX,EAX
 11476 mov EAX,EBX
 11478 fsgn EAX,EAX
 11480 max EAX,0
// if (dest<src)
 11483 cmp 0,EAX
 11486 jge 11559
// init loop
 11489 sstack EBP:-1,0
__163:
 11494 rstack EAX,EBP:-1
 11498 rstack EBX,EBP:4
 11502 sub EBX,EAX
 11504 mov EAX,EBX
 11506 fsgn EAX,EAX
// condition
 11508 max EAX,0
 11511 cmp 0,EAX
 11514 jz 11556
 11517 rstack EAX,EBP:-1
 11521 rstack EBX,EBP:3
 11525 add EBX,EAX
 11527 mov EAX,EBX
 11529 rstack EBX,EBP:-1
 11533 rstack ECX,EBP:2
 11537 add ECX,EBX
 11539 mov EBX,ECX
// dest[I]=src[I]
 11541 mov #EBX,#EAX
 11543 rstack EAX,EBP:-1
// loop step
 11547 inc EAX
 11549 sstack EBP:-1,EAX
 11553 jmp 11494
__162:
 11556 jmp 11633
__164:
__161:
__166:
 11559 rstack EAX,EBP:4
 11563 add EAX,-1
 11566 mov EBX,EAX
// init loop
 11568 sstack EBP:-1,EBX
__168:
 11572 rstack EAX,EBP:-1
 11576 mov EBX,-1
 11579 sub EBX,EAX
 11581 neg EBX
 11583 fsgn EBX,EBX
// condition
 11585 max EBX,0
 11588 cmp 0,EBX
 11591 jz 11633
 11594 rstack EAX,EBP:-1
 11598 rstack EBX,EBP:3
 11602 add EBX,EAX
 11604 mov EAX,EBX
 11606 rstack EBX,EBP:-1
 11610 rstack ECX,EBP:2
 11614 add ECX,EBX
 11616 mov EBX,ECX
// dest[I]=src[I]
 11618 mov #EBX,#EAX
 11620 rstack EAX,EBP:-1
// loop step
 11624 dec EAX
 11626 sstack EBP:-1,EAX
 11630 jmp 11572
__167:
__165:
__159:
__157:
 11633 leave 
 11634 ret 
stack_alloc:
 11635 mov EAX,ESP
 11637 add EAX,2
 11640 rstack EBX,ESP:2
 11644 rstack ECX,ESP:1
 11648 mov EDX,EAX
 11650 add EDX,SS
 11652 sub EDX,EBX
 11654 inc EDX
 11656 sub ESP,EBX
 11658 push ECX
 11660 push EDX
 11662 push EBX
 11664 push 8008135
 11667 push EDX
 11669 call 10469
 11672 add ESP,3
 11675 pop EAX
 11677 ret 
curFrame:
// curFrame()
 11678 enter -0
__170:
 11681 mov ECX,0
// backFrame(...)
 11684 call 11691
 11687 leave 
 11688 ret 
__169:
 11689 leave 
 11690 ret 
backFrame:
// backFrame(curEBP,num_times)
 11691 enter 4
__172:
 11694 sstack EBP:-1,ECX
 11698 sstack EBP:-2,0
 11703 sstack EBP:-3,0
__174:
 11708 rstack EAX,EBP:-1
 11712 mov EBX,0
 11715 sub EBX,EAX
 11717 fabs EBX,EBX
 11719 fsgn EBX,EBX
 11721 lneg EBX
// if (nargs==0)
 11723 cmp 0,EBX
 11726 jge 11738
// cEBP=EBP
 11729 sstack EBP:-2,EBP
// n=2
 11733 sstack EBP:-3,2
__175:
__173:
__177:
 11738 rstack EAX,EBP:-1
 11742 mov EBX,1
 11745 sub EBX,EAX
 11747 fabs EBX,EBX
 11749 fsgn EBX,EBX
 11751 lneg EBX
// if (nargs==1)
 11753 cmp 0,EBX
 11756 jge 11772
 11759 rstack EAX,EBP:2
// cEBP=curEBP
 11763 sstack EBP:-2,EAX
// n=1
 11767 sstack EBP:-3,1
__178:
__176:
__180:
 11772 rstack EAX,EBP:-1
 11776 mov EBX,2
 11779 sub EBX,EAX
 11781 fabs EBX,EBX
 11783 fsgn EBX,EBX
 11785 lneg EBX
// if (nargs==2)
 11787 cmp 0,EBX
 11790 jge 11809
 11793 rstack EAX,EBP:2
// cEBP=curEBP
 11797 sstack EBP:-2,EAX
 11801 rstack EAX,EBP:3
// n=num_times
 11805 sstack EBP:-3,EAX
__181:
__179:
// init loop
 11809 sstack EBP:-4,0
__183:
 11814 rstack EAX,EBP:-4
 11818 rstack EBX,EBP:-3
 11822 sub EBX,EAX
 11824 mov EAX,EBX
 11826 fsgn EAX,EAX
// condition
 11828 max EAX,0
 11831 cmp 0,EAX
 11834 jz 11862
 11837 rstack EAX,EBP:-2
 11841 mov EBX,SS
 11843 add EBX,EAX
// cEBP=*(SS+cEBP)
 11845 sstack EBP:-2,#EBX
 11849 rstack EAX,EBP:-4
// loop step
 11853 inc EAX
 11855 sstack EBP:-4,EAX
 11859 jmp 11814
__182:
 11862 rstack EAX,EBP:-2
 11866 leave 
 11867 ret 
__171:
 11868 leave 
 11869 ret 
stack_jump:
// stack_jump(new_ip,new_ebp,retval)
 11870 enter -0
__185:
 11873 rstack EDX,EBP:4
// EAX=retval
 11877 mov EAX,EDX
 11879 rstack EDX,EBP:2
// ECX=new_ip
 11883 mov ECX,EDX
 11885 rstack EDX,EBP:3
// EBX=new_ebp
 11889 mov EBX,EDX
 11891 mov EBP,EBX
 11893 jmp ECX
__184:
 11895 leave 
 11896 ret 
stack_return:
// stack_return(ptr,size,num_args)
 11897 enter 3
__187:
// backFrame arg #2 (float num_times)
 11900 push 1
// backFrame arg #1 (float curEBP)
 11903 push EBP
 11905 mov ECX,2
// backFrame(...)
 11908 call 11691
 11911 add ESP,2
 11914 sstack EBP:-2,EAX
 11918 rstack EAX,EBP:-2
 11922 add EAX,1
 11925 mov EBX,EAX
 11927 mov EAX,SS
 11929 add EAX,EBX
// prevIP=*(SS+x1+1)
 11931 sstack EBP:-1,#EAX
// backFrame arg #2 (float num_times)
 11935 push 2
// backFrame arg #1 (float curEBP)
 11938 push EBP
 11940 mov ECX,2
// backFrame(...)
 11943 call 11691
 11946 add ESP,2
 11949 sstack EBP:-3,EAX
 11953 rstack EAX,EBP:2
// stack_jump arg #3 (float retval)
 11957 push EAX
 11959 rstack EAX,EBP:-3
// stack_jump arg #2 (float new_ebp)
 11963 push EAX
 11965 rstack EAX,EBP:-1
// stack_jump arg #1 (float new_ip)
 11969 push EAX
 11971 mov ECX,3
// stack_jump(...)
 11974 call 11870
 11977 add ESP,3
__186:
 11980 leave 
 11981 ret 
STACKALLOC_CONSTANTS:
STACKALLOC_VARS:
STACKALLOC_END:
explode:
// explode(str,del)
 11982 enter 7
__189:
 11985 rstack EAX,EBP:2
 11989 sstack EBP:-1,EAX
 11993 rstack EAX,EBP:2
 11997 sstack EBP:-2,EAX
 12001 sstack EBP:-3,0
 12006 sstack EBP:-4,0
 12011 rstack EAX,EBP:3
// strlen arg #1 (char* str)
 12015 push EAX
 12017 mov ECX,1
// strlen(...)
 12020 call 11121
 12023 add ESP,1
 12026 sstack EBP:-5,EAX
 12030 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 12034 push EAX
 12036 mov ECX,1
// strlen(...)
 12039 call 11121
 12042 add ESP,1
 12045 sstack EBP:-6,EAX
 12049 sstack EBP:-7,0
__191:
 12054 rstack EAX,EBP:-7
 12058 lneg EAX
 12060 mov EBX,EAX
// if (!Finish
 12062 cmp 0,EBX
 12065 jz 12226
 12068 rstack EAX,EBP:-4
// Count++
 12072 inc EAX
 12074 sstack EBP:-4,EAX
 12078 rstack EAX,EBP:3
// strstr arg #2 (char* needle)
 12082 push EAX
 12084 rstack EAX,EBP:-1
// strstr arg #1 (char* haystack)
 12088 push EAX
 12090 mov ECX,2
// strstr(...)
 12093 call 11360
 12096 add ESP,2
// End=strstr(Start,del)
 12099 sstack EBP:-2,EAX
__193:
 12103 rstack EAX,EBP:-2
// if (End)
 12107 cmp 0,EAX
 12110 jge 12218
 12113 rstack EAX,EBP:-2
// *End=0
 12117 mov #EAX,0
 12120 rstack EAX,EBP:-1
 12124 rstack EBX,EBP:-3
 12128 mov ECX,66962
 12131 add ECX,EBX
// *(Array+I)=Start
 12133 mov #ECX,EAX
 12135 rstack EAX,EBP:-3
// I++
 12139 inc EAX
 12141 sstack EBP:-3,EAX
 12145 rstack EAX,EBP:-5
 12149 rstack EBX,EBP:-2
 12153 add EBX,EAX
 12155 mov EAX,EBX
// Start=End+lenD
 12157 sstack EBP:-1,EAX
__196:
 12161 rstack EAX,EBP:-1
 12165 rstack EBX,EBP:-6
 12169 rstack ECX,EBP:2
 12173 add ECX,EBX
 12175 mov EBX,ECX
 12177 sub EBX,EAX
 12179 neg EBX
 12181 fsgn EBX,EBX
 12183 max EBX,0
 12186 rstack EAX,EBP:-3
 12190 mov ECX,13
 12193 sub ECX,EAX
 12195 neg ECX
 12197 fsgn ECX,ECX
 12199 max ECX,0
 12202 bor ECX,EBX
// if ((I>13)|(Start>(str+lenS)))
 12204 cmp 0,ECX
 12207 jge 12215
// Finish=1
 12210 sstack EBP:-7,1
__197:
__195:
 12215 jmp 12223
__198:
__194:
__200:
// Finish=1
 12218 sstack EBP:-7,1
__199:
__192:
 12223 jmp 12054
__190:
 12226 rstack EAX,EBP:-1
 12230 rstack EBX,EBP:-3
 12234 add EBX,66962
 12237 mov ECX,EBX
// Array[I]=Start
 12239 mov #ECX,EAX
 12241 rstack EAX,EBP:-3
// I++
 12245 inc EAX
 12247 sstack EBP:-3,EAX
 12251 rstack EAX,EBP:-3
 12255 add EAX,66962
 12258 mov EBX,EAX
// Array[I]=0
 12260 mov #EBX,0
 12263 mov EAX,66962
 12266 leave 
 12267 ret 
__188:
 12268 leave 
 12269 ret 
str2num:
// str2num(str)
 12270 enter 8
__202:
 12273 sstack EBP:-1,0
 12278 sstack EBP:-2,0
 12283 sstack EBP:-3,0
 12288 sstack EBP:-4,0
 12293 sstack EBP:-5,0
 12298 sstack EBP:-6,0
 12303 sstack EBP:-7,10
 12308 rstack EAX,EBP:-2
 12312 rstack EBX,EBP:2
 12316 add EBX,EAX
 12318 mov EAX,EBX
 12320 sstack EBP:-8,#EAX
__204:
 12324 rstack EAX,EBP:-8
 12328 mov EBX,0
 12331 sub EBX,EAX
 12333 fabs EBX,EBX
 12335 fsgn EBX,EBX
 12337 lneg EBX
// if (C==0)
 12339 cmp 0,EBX
 12342 jge 12353
 12345 mov EAX,0
 12348 leave 
 12349 ret 
 12350 jmp 12550
__206:
__205:
__208:
__210:
 12353 rstack EAX,EBP:-8
 12357 mov EBX,45
 12360 sub EBX,EAX
 12362 fabs EBX,EBX
 12364 fsgn EBX,EBX
 12366 lneg EBX
// if (C=='-')
 12368 cmp 0,EBX
 12371 jge 12379
// Minus=1
 12374 sstack EBP:-4,1
__211:
__209:
__213:
 12379 rstack EAX,EBP:-8
 12383 mov EBX,48
 12386 sub EBX,EAX
 12388 fabs EBX,EBX
 12390 fsgn EBX,EBX
 12392 lneg EBX
// if (C=='0')
 12394 cmp 0,EBX
 12397 jge 12550
__216:
 12400 rstack EAX,EBP:-2
 12404 add EAX,1
 12407 mov EBX,EAX
 12409 rstack EAX,EBP:2
 12413 add EAX,EBX
 12415 mov EBX,EAX
 12417 mov EAX,98
 12420 sub EAX,#EBX
 12422 fabs EAX,EAX
 12424 fsgn EAX,EAX
 12426 lneg EAX
// if (str[I+1]=='b')
 12428 cmp 0,EAX
 12431 jge 12450
// Base=2
 12434 sstack EBP:-7,2
 12439 rstack EAX,EBP:-2
// I+=2
 12443 add EAX,2
 12446 sstack EBP:-2,EAX
__217:
__215:
__219:
 12450 rstack EAX,EBP:-2
 12454 add EAX,1
 12457 mov EBX,EAX
 12459 rstack EAX,EBP:2
 12463 add EAX,EBX
 12465 mov EBX,EAX
 12467 mov EAX,111
 12470 sub EAX,#EBX
 12472 fabs EAX,EAX
 12474 fsgn EAX,EAX
 12476 lneg EAX
// if (str[I+1]=='o')
 12478 cmp 0,EAX
 12481 jge 12500
// Base=8
 12484 sstack EBP:-7,8
 12489 rstack EAX,EBP:-2
// I+=2
 12493 add EAX,2
 12496 sstack EBP:-2,EAX
__220:
__218:
__222:
 12500 rstack EAX,EBP:-2
 12504 add EAX,1
 12507 mov EBX,EAX
 12509 rstack EAX,EBP:2
 12513 add EAX,EBX
 12515 mov EBX,EAX
 12517 mov EAX,120
 12520 sub EAX,#EBX
 12522 fabs EAX,EAX
 12524 fsgn EAX,EAX
 12526 lneg EAX
// if (str[I+1]=='x')
 12528 cmp 0,EAX
 12531 jge 12550
// Base=16
 12534 sstack EBP:-7,16
 12539 rstack EAX,EBP:-2
// I+=2
 12543 add EAX,2
 12546 sstack EBP:-2,EAX
__223:
__221:
__214:
__212:
__207:
__203:
__225:
 12550 rstack EAX,EBP:-1
 12554 lneg EAX
 12556 mov EBX,EAX
// if (!End
 12558 cmp 0,EBX
 12561 jz 13097
 12564 rstack EAX,EBP:-2
 12568 mov EBX,EAX
 12570 inc EAX
 12572 sstack EBP:-2,EAX
 12576 rstack EAX,EBP:2
 12580 add EAX,EBX
 12582 mov EBX,EAX
// C=str[I++]
 12584 sstack EBP:-8,#EBX
__227:
 12588 rstack EAX,EBP:-8
 12592 mov EBX,0
 12595 sub EBX,EAX
 12597 fabs EBX,EBX
 12599 fsgn EBX,EBX
 12601 lneg EBX
// if (C==0)
 12603 cmp 0,EBX
 12606 jge 12617
// End=1
 12609 sstack EBP:-1,1
 12614 jmp 13094
__229:
__228:
__231:
__233:
 12617 rstack EAX,EBP:-8
 12621 mov EBX,46
 12624 sub EBX,EAX
 12626 fabs EBX,EBX
 12628 fsgn EBX,EBX
 12630 lneg EBX
// if (C=='.')
 12632 cmp 0,EBX
 12635 jge 12651
// End=1
 12638 sstack EBP:-1,1
// Frac=1
 12643 sstack EBP:-5,1
 12648 jmp 13094
__235:
__234:
__237:
// N=0
 12651 sstack EBP:-6,0
__239:
 12656 rstack EAX,EBP:-8
 12660 mov EBX,48
 12663 sub EBX,EAX
 12665 fabs EBX,EBX
 12667 fsgn EBX,EBX
 12669 lneg EBX
// if (C=='0')
 12671 cmp 0,EBX
 12674 jge 12682
// N=0
 12677 sstack EBP:-6,0
__240:
__238:
__242:
 12682 rstack EAX,EBP:-8
 12686 mov EBX,49
 12689 sub EBX,EAX
 12691 fabs EBX,EBX
 12693 fsgn EBX,EBX
 12695 lneg EBX
// if (C=='1')
 12697 cmp 0,EBX
 12700 jge 12708
// N=1
 12703 sstack EBP:-6,1
__243:
__241:
__245:
 12708 rstack EAX,EBP:-8
 12712 mov EBX,50
 12715 sub EBX,EAX
 12717 fabs EBX,EBX
 12719 fsgn EBX,EBX
 12721 lneg EBX
// if (C=='2')
 12723 cmp 0,EBX
 12726 jge 12734
// N=2
 12729 sstack EBP:-6,2
__246:
__244:
__248:
 12734 rstack EAX,EBP:-8
 12738 mov EBX,51
 12741 sub EBX,EAX
 12743 fabs EBX,EBX
 12745 fsgn EBX,EBX
 12747 lneg EBX
// if (C=='3')
 12749 cmp 0,EBX
 12752 jge 12760
// N=3
 12755 sstack EBP:-6,3
__249:
__247:
__251:
 12760 rstack EAX,EBP:-8
 12764 mov EBX,52
 12767 sub EBX,EAX
 12769 fabs EBX,EBX
 12771 fsgn EBX,EBX
 12773 lneg EBX
// if (C=='4')
 12775 cmp 0,EBX
 12778 jge 12786
// N=4
 12781 sstack EBP:-6,4
__252:
__250:
__254:
 12786 rstack EAX,EBP:-8
 12790 mov EBX,53
 12793 sub EBX,EAX
 12795 fabs EBX,EBX
 12797 fsgn EBX,EBX
 12799 lneg EBX
// if (C=='5')
 12801 cmp 0,EBX
 12804 jge 12812
// N=5
 12807 sstack EBP:-6,5
__255:
__253:
__257:
 12812 rstack EAX,EBP:-8
 12816 mov EBX,54
 12819 sub EBX,EAX
 12821 fabs EBX,EBX
 12823 fsgn EBX,EBX
 12825 lneg EBX
// if (C=='6')
 12827 cmp 0,EBX
 12830 jge 12838
// N=6
 12833 sstack EBP:-6,6
__258:
__256:
__260:
 12838 rstack EAX,EBP:-8
 12842 mov EBX,55
 12845 sub EBX,EAX
 12847 fabs EBX,EBX
 12849 fsgn EBX,EBX
 12851 lneg EBX
// if (C=='7')
 12853 cmp 0,EBX
 12856 jge 12864
// N=7
 12859 sstack EBP:-6,7
__261:
__259:
__263:
 12864 rstack EAX,EBP:-8
 12868 mov EBX,56
 12871 sub EBX,EAX
 12873 fabs EBX,EBX
 12875 fsgn EBX,EBX
 12877 lneg EBX
// if (C=='8')
 12879 cmp 0,EBX
 12882 jge 12890
// N=8
 12885 sstack EBP:-6,8
__264:
__262:
__266:
 12890 rstack EAX,EBP:-8
 12894 mov EBX,57
 12897 sub EBX,EAX
 12899 fabs EBX,EBX
 12901 fsgn EBX,EBX
 12903 lneg EBX
// if (C=='9')
 12905 cmp 0,EBX
 12908 jge 12916
// N=9
 12911 sstack EBP:-6,9
__267:
__265:
__269:
 12916 rstack EAX,EBP:-8
 12920 mov EBX,65
 12923 sub EBX,EAX
 12925 fabs EBX,EBX
 12927 fsgn EBX,EBX
 12929 lneg EBX
// if (C=='A')
 12931 cmp 0,EBX
 12934 jge 12942
// N=10
 12937 sstack EBP:-6,10
__270:
__268:
__272:
 12942 rstack EAX,EBP:-8
 12946 mov EBX,66
 12949 sub EBX,EAX
 12951 fabs EBX,EBX
 12953 fsgn EBX,EBX
 12955 lneg EBX
// if (C=='B')
 12957 cmp 0,EBX
 12960 jge 12968
// N=11
 12963 sstack EBP:-6,11
__273:
__271:
__275:
 12968 rstack EAX,EBP:-8
 12972 mov EBX,67
 12975 sub EBX,EAX
 12977 fabs EBX,EBX
 12979 fsgn EBX,EBX
 12981 lneg EBX
// if (C=='C')
 12983 cmp 0,EBX
 12986 jge 12994
// N=12
 12989 sstack EBP:-6,12
__276:
__274:
__278:
 12994 rstack EAX,EBP:-8
 12998 mov EBX,68
 13001 sub EBX,EAX
 13003 fabs EBX,EBX
 13005 fsgn EBX,EBX
 13007 lneg EBX
// if (C=='D')
 13009 cmp 0,EBX
 13012 jge 13020
// N=13
 13015 sstack EBP:-6,13
__279:
__277:
__281:
 13020 rstack EAX,EBP:-8
 13024 mov EBX,69
 13027 sub EBX,EAX
 13029 fabs EBX,EBX
 13031 fsgn EBX,EBX
 13033 lneg EBX
// if (C=='E')
 13035 cmp 0,EBX
 13038 jge 13046
// N=14
 13041 sstack EBP:-6,14
__282:
__280:
__284:
 13046 rstack EAX,EBP:-8
 13050 mov EBX,70
 13053 sub EBX,EAX
 13055 fabs EBX,EBX
 13057 fsgn EBX,EBX
 13059 lneg EBX
// if (C=='F')
 13061 cmp 0,EBX
 13064 jge 13072
// N=15
 13067 sstack EBP:-6,15
__285:
__283:
 13072 rstack EAX,EBP:-6
 13076 rstack EBX,EBP:-7
 13080 rstack ECX,EBP:-3
 13084 mul ECX,EBX
 13086 mov EBX,ECX
 13088 add EBX,EAX
// Num=Num*Base+N
 13090 sstack EBP:-3,EBX
__236:
__232:
__230:
__226:
 13094 jmp 12550
__224:
__287:
 13097 rstack EAX,EBP:-5
 13101 mov EBX,1
 13104 sub EBX,EAX
 13106 fabs EBX,EBX
 13108 fsgn EBX,EBX
 13110 lneg EBX
// if (Frac==1)
 13112 cmp 0,EBX
 13115 jge 13646
// End=0
 13118 sstack EBP:-1,0
__290:
 13123 rstack EAX,EBP:-1
 13127 lneg EAX
 13129 mov EBX,EAX
// if (!End
 13131 cmp 0,EBX
 13134 jz 13646
 13137 rstack EAX,EBP:-2
 13141 mov EBX,EAX
 13143 inc EAX
 13145 sstack EBP:-2,EAX
 13149 rstack EAX,EBP:2
 13153 add EAX,EBX
 13155 mov EBX,EAX
// C=str[I++]
 13157 sstack EBP:-8,#EBX
__292:
 13161 rstack EAX,EBP:-8
 13165 mov EBX,0
 13168 sub EBX,EAX
 13170 fabs EBX,EBX
 13172 fsgn EBX,EBX
 13174 lneg EBX
// if (C==0)
 13176 cmp 0,EBX
 13179 jge 13190
// End=1
 13182 sstack EBP:-1,1
 13187 jmp 13643
__294:
__293:
__296:
// N=0
 13190 sstack EBP:-6,0
__298:
 13195 rstack EAX,EBP:-8
 13199 mov EBX,48
 13202 sub EBX,EAX
 13204 fabs EBX,EBX
 13206 fsgn EBX,EBX
 13208 lneg EBX
// if (C=='0')
 13210 cmp 0,EBX
 13213 jge 13221
// N=0
 13216 sstack EBP:-6,0
__299:
__297:
__301:
 13221 rstack EAX,EBP:-8
 13225 mov EBX,49
 13228 sub EBX,EAX
 13230 fabs EBX,EBX
 13232 fsgn EBX,EBX
 13234 lneg EBX
// if (C=='1')
 13236 cmp 0,EBX
 13239 jge 13247
// N=1
 13242 sstack EBP:-6,1
__302:
__300:
__304:
 13247 rstack EAX,EBP:-8
 13251 mov EBX,50
 13254 sub EBX,EAX
 13256 fabs EBX,EBX
 13258 fsgn EBX,EBX
 13260 lneg EBX
// if (C=='2')
 13262 cmp 0,EBX
 13265 jge 13273
// N=2
 13268 sstack EBP:-6,2
__305:
__303:
__307:
 13273 rstack EAX,EBP:-8
 13277 mov EBX,51
 13280 sub EBX,EAX
 13282 fabs EBX,EBX
 13284 fsgn EBX,EBX
 13286 lneg EBX
// if (C=='3')
 13288 cmp 0,EBX
 13291 jge 13299
// N=3
 13294 sstack EBP:-6,3
__308:
__306:
__310:
 13299 rstack EAX,EBP:-8
 13303 mov EBX,52
 13306 sub EBX,EAX
 13308 fabs EBX,EBX
 13310 fsgn EBX,EBX
 13312 lneg EBX
// if (C=='4')
 13314 cmp 0,EBX
 13317 jge 13325
// N=4
 13320 sstack EBP:-6,4
__311:
__309:
__313:
 13325 rstack EAX,EBP:-8
 13329 mov EBX,53
 13332 sub EBX,EAX
 13334 fabs EBX,EBX
 13336 fsgn EBX,EBX
 13338 lneg EBX
// if (C=='5')
 13340 cmp 0,EBX
 13343 jge 13351
// N=5
 13346 sstack EBP:-6,5
__314:
__312:
__316:
 13351 rstack EAX,EBP:-8
 13355 mov EBX,54
 13358 sub EBX,EAX
 13360 fabs EBX,EBX
 13362 fsgn EBX,EBX
 13364 lneg EBX
// if (C=='6')
 13366 cmp 0,EBX
 13369 jge 13377
// N=6
 13372 sstack EBP:-6,6
__317:
__315:
__319:
 13377 rstack EAX,EBP:-8
 13381 mov EBX,55
 13384 sub EBX,EAX
 13386 fabs EBX,EBX
 13388 fsgn EBX,EBX
 13390 lneg EBX
// if (C=='7')
 13392 cmp 0,EBX
 13395 jge 13403
// N=7
 13398 sstack EBP:-6,7
__320:
__318:
__322:
 13403 rstack EAX,EBP:-8
 13407 mov EBX,56
 13410 sub EBX,EAX
 13412 fabs EBX,EBX
 13414 fsgn EBX,EBX
 13416 lneg EBX
// if (C=='8')
 13418 cmp 0,EBX
 13421 jge 13429
// N=8
 13424 sstack EBP:-6,8
__323:
__321:
__325:
 13429 rstack EAX,EBP:-8
 13433 mov EBX,57
 13436 sub EBX,EAX
 13438 fabs EBX,EBX
 13440 fsgn EBX,EBX
 13442 lneg EBX
// if (C=='9')
 13444 cmp 0,EBX
 13447 jge 13455
// N=9
 13450 sstack EBP:-6,9
__326:
__324:
__328:
 13455 rstack EAX,EBP:-8
 13459 mov EBX,65
 13462 sub EBX,EAX
 13464 fabs EBX,EBX
 13466 fsgn EBX,EBX
 13468 lneg EBX
// if (C=='A')
 13470 cmp 0,EBX
 13473 jge 13481
// N=10
 13476 sstack EBP:-6,10
__329:
__327:
__331:
 13481 rstack EAX,EBP:-8
 13485 mov EBX,66
 13488 sub EBX,EAX
 13490 fabs EBX,EBX
 13492 fsgn EBX,EBX
 13494 lneg EBX
// if (C=='B')
 13496 cmp 0,EBX
 13499 jge 13507
// N=11
 13502 sstack EBP:-6,11
__332:
__330:
__334:
 13507 rstack EAX,EBP:-8
 13511 mov EBX,67
 13514 sub EBX,EAX
 13516 fabs EBX,EBX
 13518 fsgn EBX,EBX
 13520 lneg EBX
// if (C=='C')
 13522 cmp 0,EBX
 13525 jge 13533
// N=12
 13528 sstack EBP:-6,12
__335:
__333:
__337:
 13533 rstack EAX,EBP:-8
 13537 mov EBX,68
 13540 sub EBX,EAX
 13542 fabs EBX,EBX
 13544 fsgn EBX,EBX
 13546 lneg EBX
// if (C=='D')
 13548 cmp 0,EBX
 13551 jge 13559
// N=13
 13554 sstack EBP:-6,13
__338:
__336:
__340:
 13559 rstack EAX,EBP:-8
 13563 mov EBX,69
 13566 sub EBX,EAX
 13568 fabs EBX,EBX
 13570 fsgn EBX,EBX
 13572 lneg EBX
// if (C=='E')
 13574 cmp 0,EBX
 13577 jge 13585
// N=14
 13580 sstack EBP:-6,14
__341:
__339:
__343:
 13585 rstack EAX,EBP:-8
 13589 mov EBX,70
 13592 sub EBX,EAX
 13594 fabs EBX,EBX
 13596 fsgn EBX,EBX
 13598 lneg EBX
// if (C=='F')
 13600 cmp 0,EBX
 13603 jge 13611
// N=15
 13606 sstack EBP:-6,15
__344:
__342:
 13611 rstack EAX,EBP:-6
 13615 rstack EBX,EBP:-7
 13619 rstack ECX,EBP:-3
 13623 mul ECX,EBX
 13625 mov EBX,ECX
 13627 add EBX,EAX
// Num=Num*Base+N
 13629 sstack EBP:-3,EBX
 13633 rstack EAX,EBP:-5
// Frac++
 13637 inc EAX
 13639 sstack EBP:-5,EAX
__295:
__291:
 13643 jmp 13123
__289:
__288:
__286:
__346:
 13646 rstack EAX,EBP:-5
// if (Frac)
 13650 cmp 0,EAX
 13653 jge 13683
 13656 rstack EAX,EBP:-5
 13660 add EAX,-1
 13663 mov EBX,EAX
 13665 rstack EAX,EBP:-7
 13669 fpwr EAX,EBX
 13671 mov EBX,EAX
 13673 rstack EAX,EBP:-3
// Num/=(Base^^(Frac-1))
 13677 div EAX,EBX
 13679 sstack EBP:-3,EAX
__347:
__345:
__349:
 13683 rstack EAX,EBP:-4
// if (Minus)
 13687 cmp 0,EAX
 13690 jge 13705
 13693 rstack EAX,EBP:-3
 13697 neg EAX
 13699 mov EBX,EAX
// Num=-Num
 13701 sstack EBP:-3,EBX
__350:
__348:
 13705 rstack EAX,EBP:-3
 13709 leave 
 13710 ret 
__201:
 13711 leave 
 13712 ret 
getNdigit:
// getNdigit(num,digit,Base)
 13713 enter -0
__352:
 13716 rstack EBX,EBP:4
 13720 push EBX
 13722 rstack EBX,EBP:2
 13726 push EBX
 13728 mov ECX,2
// Nlog(...)
 13731 call 15282
 13734 add ESP,2
 13737 push EAX
 13739 mov EBX,EAX
 13741 pop EAX
// EAX=Nlog(num,Base)
 13743 mov EAX,EBX
 13745 fint EAX
 13747 inc EAX
 13749 rstack EBX,EBP:3
 13753 sub EAX,EBX
 13755 rstack EBX,EBP:4
 13759 mov EDX,EBX
 13761 fpwr EDX,EAX
 13763 rstack EBX,EBP:2
 13767 mov EAX,EBX
 13769 div EAX,EDX
 13771 fint EAX
 13773 rstack EBX,EBP:4
 13777 mod EAX,EBX
 13779 leave 
 13780 ret 
__351:
 13781 leave 
 13782 ret 
num2strSet:
// num2strSet(base,precision)
 13783 enter -0
__354:
 13786 rstack EAX,EBP:2
// Nbase=base
 13790 mov #66944,EAX
 13793 rstack EAX,EBP:3
// Nprec=precision
 13797 mov #66945,EAX
__353:
 13800 leave 
 13801 ret 
num2str:
// num2str(num)
 13802 enter 10
__356:
 13805 sstack EBP:-1,0
 13810 sstack EBP:-2,0
 13815 rstack EBX,EBP:2
 13819 sstack EBP:-3,EBX
 13823 sstack EBP:-4,10
 13828 sstack EBP:-5,3
// Base=Nbase
 13833 sstack EBP:-4,#66944
// Prec=Nprec
 13838 sstack EBP:-5,#66945
__358:
 13843 rstack EBX,EBP:-3
 13847 mov ECX,0
 13850 sub ECX,EBX
 13852 fsgn ECX,ECX
 13854 max ECX,0
// if (NM<0)
 13857 cmp 0,ECX
 13860 jge 13893
 13863 rstack EBX,EBP:-3
 13867 neg EBX
 13869 mov ECX,EBX
// NM=-NM
 13871 sstack EBP:-3,ECX
 13875 rstack EBX,EBP:-1
 13879 mov ECX,EBX
 13881 inc EBX
 13883 sstack EBP:-1,EBX
 13887 add ECX,66946
// Nstack[NI++]='-'
 13890 mov #ECX,45
__359:
__357:
__361:
 13893 rstack EBX,EBP:-4
 13897 mov ECX,2
 13900 sub ECX,EBX
 13902 fabs ECX,ECX
 13904 fsgn ECX,ECX
 13906 lneg ECX
// if (Base==2)
 13908 cmp 0,ECX
 13911 jge 13950
 13914 rstack EBX,EBP:-1
 13918 mov ECX,EBX
 13920 inc EBX
 13922 sstack EBP:-1,EBX
 13926 add ECX,66946
// Nstack[NI++]='0'
 13929 mov #ECX,48
 13932 rstack EBX,EBP:-1
 13936 mov ECX,EBX
 13938 inc EBX
 13940 sstack EBP:-1,EBX
 13944 add ECX,66946
// Nstack[NI++]='b'
 13947 mov #ECX,98
__362:
__360:
__364:
 13950 rstack EBX,EBP:-4
 13954 mov ECX,8
 13957 sub ECX,EBX
 13959 fabs ECX,ECX
 13961 fsgn ECX,ECX
 13963 lneg ECX
// if (Base==8)
 13965 cmp 0,ECX
 13968 jge 14007
 13971 rstack EBX,EBP:-1
 13975 mov ECX,EBX
 13977 inc EBX
 13979 sstack EBP:-1,EBX
 13983 add ECX,66946
// Nstack[NI++]='0'
 13986 mov #ECX,48
 13989 rstack EBX,EBP:-1
 13993 mov ECX,EBX
 13995 inc EBX
 13997 sstack EBP:-1,EBX
 14001 add ECX,66946
// Nstack[NI++]='o'
 14004 mov #ECX,111
__365:
__363:
__367:
 14007 rstack EBX,EBP:-4
 14011 mov ECX,16
 14014 sub ECX,EBX
 14016 fabs ECX,ECX
 14018 fsgn ECX,ECX
 14020 lneg ECX
// if (Base==16)
 14022 cmp 0,ECX
 14025 jge 14064
 14028 rstack EBX,EBP:-1
 14032 mov ECX,EBX
 14034 inc EBX
 14036 sstack EBP:-1,EBX
 14040 add ECX,66946
// Nstack[NI++]='0'
 14043 mov #ECX,48
 14046 rstack EBX,EBP:-1
 14050 mov ECX,EBX
 14052 inc EBX
 14054 sstack EBP:-1,EBX
 14058 add ECX,66946
// Nstack[NI++]='x'
 14061 mov #ECX,120
__368:
__366:
__370:
 14064 rstack EBX,EBP:-3
 14068 mov ECX,1
 14071 sub ECX,EBX
 14073 fsgn ECX,ECX
 14075 max ECX,0
// if (NM<1)
 14078 cmp 0,ECX
 14081 jge 14102
 14084 rstack EBX,EBP:-1
 14088 mov ECX,EBX
 14090 inc EBX
 14092 sstack EBP:-1,EBX
 14096 add ECX,66946
// Nstack[NI++]='0'
 14099 mov #ECX,48
__371:
__369:
 14102 rstack EBX,EBP:-4
 14106 push EBX
 14108 rstack EBX,EBP:-3
 14112 push EBX
 14114 mov ECX,2
// Nlog(...)
 14117 call 15282
 14120 add ESP,2
 14123 push EAX
 14125 mov EBX,EAX
 14127 pop EAX
// EAX=Nlog(NM,Base)
 14129 mov EAX,EBX
 14131 mov EBX,EAX
 14133 add EBX,1
 14136 sstack EBP:-6,EBX
 14140 sstack EBP:-9,0
// init loop
 14145 sstack EBP:-9,1
__373:
 14150 rstack EBX,EBP:-9
 14154 rstack ECX,EBP:-6
 14158 sub ECX,EBX
 14160 mov EBX,ECX
 14162 fsgn EBX,EBX
 14164 inc EBX
// condition
 14166 max EBX,0
 14169 cmp 0,EBX
 14172 jz 14667
// C='F'
 14175 sstack EBP:-8,70
 14180 rstack EBX,EBP:-4
// getNdigit arg #3 (float Base)
 14184 push EBX
 14186 rstack EBX,EBP:-9
// getNdigit arg #2 (float digit)
 14190 push EBX
 14192 rstack EBX,EBP:-3
// getNdigit arg #1 (float num)
 14196 push EBX
 14198 mov ECX,3
// getNdigit(...)
 14201 call 13713
 14204 add ESP,3
 14207 push EAX
 14209 mov EBX,EAX
 14211 pop EAX
// N=getNdigit(NM,I,Base)
 14213 sstack EBP:-7,EBX
__375:
 14217 rstack EBX,EBP:-7
 14221 mov ECX,0
 14224 sub ECX,EBX
 14226 fabs ECX,ECX
 14228 fsgn ECX,ECX
 14230 lneg ECX
// if (N==0)
 14232 cmp 0,ECX
 14235 jge 14243
// C='0'
 14238 sstack EBP:-8,48
__376:
__374:
__378:
 14243 rstack EBX,EBP:-7
 14247 mov ECX,1
 14250 sub ECX,EBX
 14252 fabs ECX,ECX
 14254 fsgn ECX,ECX
 14256 lneg ECX
// if (N==1)
 14258 cmp 0,ECX
 14261 jge 14269
// C='1'
 14264 sstack EBP:-8,49
__379:
__377:
__381:
 14269 rstack EBX,EBP:-7
 14273 mov ECX,2
 14276 sub ECX,EBX
 14278 fabs ECX,ECX
 14280 fsgn ECX,ECX
 14282 lneg ECX
// if (N==2)
 14284 cmp 0,ECX
 14287 jge 14295
// C='2'
 14290 sstack EBP:-8,50
__382:
__380:
__384:
 14295 rstack EBX,EBP:-7
 14299 mov ECX,3
 14302 sub ECX,EBX
 14304 fabs ECX,ECX
 14306 fsgn ECX,ECX
 14308 lneg ECX
// if (N==3)
 14310 cmp 0,ECX
 14313 jge 14321
// C='3'
 14316 sstack EBP:-8,51
__385:
__383:
__387:
 14321 rstack EBX,EBP:-7
 14325 mov ECX,4
 14328 sub ECX,EBX
 14330 fabs ECX,ECX
 14332 fsgn ECX,ECX
 14334 lneg ECX
// if (N==4)
 14336 cmp 0,ECX
 14339 jge 14347
// C='4'
 14342 sstack EBP:-8,52
__388:
__386:
__390:
 14347 rstack EBX,EBP:-7
 14351 mov ECX,5
 14354 sub ECX,EBX
 14356 fabs ECX,ECX
 14358 fsgn ECX,ECX
 14360 lneg ECX
// if (N==5)
 14362 cmp 0,ECX
 14365 jge 14373
// C='5'
 14368 sstack EBP:-8,53
__391:
__389:
__393:
 14373 rstack EBX,EBP:-7
 14377 mov ECX,6
 14380 sub ECX,EBX
 14382 fabs ECX,ECX
 14384 fsgn ECX,ECX
 14386 lneg ECX
// if (N==6)
 14388 cmp 0,ECX
 14391 jge 14399
// C='6'
 14394 sstack EBP:-8,54
__394:
__392:
__396:
 14399 rstack EBX,EBP:-7
 14403 mov ECX,7
 14406 sub ECX,EBX
 14408 fabs ECX,ECX
 14410 fsgn ECX,ECX
 14412 lneg ECX
// if (N==7)
 14414 cmp 0,ECX
 14417 jge 14425
// C='7'
 14420 sstack EBP:-8,55
__397:
__395:
__399:
 14425 rstack EBX,EBP:-7
 14429 mov ECX,8
 14432 sub ECX,EBX
 14434 fabs ECX,ECX
 14436 fsgn ECX,ECX
 14438 lneg ECX
// if (N==8)
 14440 cmp 0,ECX
 14443 jge 14451
// C='8'
 14446 sstack EBP:-8,56
__400:
__398:
__402:
 14451 rstack EBX,EBP:-7
 14455 mov ECX,9
 14458 sub ECX,EBX
 14460 fabs ECX,ECX
 14462 fsgn ECX,ECX
 14464 lneg ECX
// if (N==9)
 14466 cmp 0,ECX
 14469 jge 14477
// C='9'
 14472 sstack EBP:-8,57
__403:
__401:
__405:
 14477 rstack EBX,EBP:-7
 14481 mov ECX,10
 14484 sub ECX,EBX
 14486 fabs ECX,ECX
 14488 fsgn ECX,ECX
 14490 lneg ECX
// if (N==10)
 14492 cmp 0,ECX
 14495 jge 14503
// C='A'
 14498 sstack EBP:-8,65
__406:
__404:
__408:
 14503 rstack EBX,EBP:-7
 14507 mov ECX,11
 14510 sub ECX,EBX
 14512 fabs ECX,ECX
 14514 fsgn ECX,ECX
 14516 lneg ECX
// if (N==11)
 14518 cmp 0,ECX
 14521 jge 14529
// C='B'
 14524 sstack EBP:-8,66
__409:
__407:
__411:
 14529 rstack EBX,EBP:-7
 14533 mov ECX,12
 14536 sub ECX,EBX
 14538 fabs ECX,ECX
 14540 fsgn ECX,ECX
 14542 lneg ECX
// if (N==12)
 14544 cmp 0,ECX
 14547 jge 14555
// C='C'
 14550 sstack EBP:-8,67
__412:
__410:
__414:
 14555 rstack EBX,EBP:-7
 14559 mov ECX,13
 14562 sub ECX,EBX
 14564 fabs ECX,ECX
 14566 fsgn ECX,ECX
 14568 lneg ECX
// if (N==13)
 14570 cmp 0,ECX
 14573 jge 14581
// C='D'
 14576 sstack EBP:-8,68
__415:
__413:
__417:
 14581 rstack EBX,EBP:-7
 14585 mov ECX,14
 14588 sub ECX,EBX
 14590 fabs ECX,ECX
 14592 fsgn ECX,ECX
 14594 lneg ECX
// if (N==14)
 14596 cmp 0,ECX
 14599 jge 14607
// C='E'
 14602 sstack EBP:-8,69
__418:
__416:
__420:
 14607 rstack EBX,EBP:-7
 14611 mov ECX,15
 14614 sub ECX,EBX
 14616 fabs ECX,ECX
 14618 fsgn ECX,ECX
 14620 lneg ECX
// if (N==15)
 14622 cmp 0,ECX
 14625 jge 14633
// C='F'
 14628 sstack EBP:-8,70
__421:
__419:
 14633 rstack EBX,EBP:-8
 14637 rstack ECX,EBP:-1
 14641 mov EDX,ECX
 14643 inc ECX
 14645 sstack EBP:-1,ECX
 14649 add EDX,66946
// Nstack[NI++]=C
 14652 mov #EDX,EBX
 14654 rstack EBX,EBP:-9
// loop step
 14658 inc EBX
 14660 sstack EBP:-9,EBX
 14664 jmp 14150
__372:
 14667 rstack EBX,EBP:-3
 14671 mov EAX,EBX
 14673 ffrac EAX
__423:
 14675 rstack EBX,EBP:-5
 14679 mov ECX,0
 14682 sub ECX,EBX
 14684 neg ECX
 14686 fsgn ECX,ECX
 14688 max ECX,0
 14691 mov EBX,0
 14694 sub EBX,EAX
 14696 neg EBX
 14698 fsgn EBX,EBX
 14700 max EBX,0
 14703 and EBX,ECX
// if ((EAX>0)&&(Prec>0))
 14705 cmp 0,EBX
 14708 jge 15263
 14711 sstack EBP:-10,0
 14716 rstack EBX,EBP:-1
 14720 mov ECX,EBX
 14722 inc EBX
 14724 sstack EBP:-1,EBX
 14728 add ECX,66946
// Nstack[NI++]='.'
 14731 mov #ECX,46
 14734 rstack EBX,EBP:-9
// init loop
 14738 sstack EBP:-10,EBX
__426:
 14742 rstack EBX,EBP:-10
 14746 rstack ECX,EBP:-5
 14750 rstack EDX,EBP:-9
 14754 add EDX,ECX
 14756 mov ECX,EDX
 14758 sub ECX,EBX
 14760 fsgn ECX,ECX
// condition
 14762 max ECX,0
 14765 cmp 0,ECX
 14768 jz 15263
// C='F'
 14771 sstack EBP:-8,70
 14776 rstack EBX,EBP:-4
// getNdigit arg #3 (float Base)
 14780 push EBX
 14782 rstack EBX,EBP:-10
// getNdigit arg #2 (float digit)
 14786 push EBX
 14788 rstack EBX,EBP:-3
// getNdigit arg #1 (float num)
 14792 push EBX
 14794 mov ECX,3
// getNdigit(...)
 14797 call 13713
 14800 add ESP,3
 14803 push EAX
 14805 mov EBX,EAX
 14807 pop EAX
// N=getNdigit(NM,K,Base)
 14809 sstack EBP:-7,EBX
__428:
 14813 rstack EBX,EBP:-7
 14817 mov ECX,0
 14820 sub ECX,EBX
 14822 fabs ECX,ECX
 14824 fsgn ECX,ECX
 14826 lneg ECX
// if (N==0)
 14828 cmp 0,ECX
 14831 jge 14839
// C='0'
 14834 sstack EBP:-8,48
__429:
__427:
__431:
 14839 rstack EBX,EBP:-7
 14843 mov ECX,1
 14846 sub ECX,EBX
 14848 fabs ECX,ECX
 14850 fsgn ECX,ECX
 14852 lneg ECX
// if (N==1)
 14854 cmp 0,ECX
 14857 jge 14865
// C='1'
 14860 sstack EBP:-8,49
__432:
__430:
__434:
 14865 rstack EBX,EBP:-7
 14869 mov ECX,2
 14872 sub ECX,EBX
 14874 fabs ECX,ECX
 14876 fsgn ECX,ECX
 14878 lneg ECX
// if (N==2)
 14880 cmp 0,ECX
 14883 jge 14891
// C='2'
 14886 sstack EBP:-8,50
__435:
__433:
__437:
 14891 rstack EBX,EBP:-7
 14895 mov ECX,3
 14898 sub ECX,EBX
 14900 fabs ECX,ECX
 14902 fsgn ECX,ECX
 14904 lneg ECX
// if (N==3)
 14906 cmp 0,ECX
 14909 jge 14917
// C='3'
 14912 sstack EBP:-8,51
__438:
__436:
__440:
 14917 rstack EBX,EBP:-7
 14921 mov ECX,4
 14924 sub ECX,EBX
 14926 fabs ECX,ECX
 14928 fsgn ECX,ECX
 14930 lneg ECX
// if (N==4)
 14932 cmp 0,ECX
 14935 jge 14943
// C='4'
 14938 sstack EBP:-8,52
__441:
__439:
__443:
 14943 rstack EBX,EBP:-7
 14947 mov ECX,5
 14950 sub ECX,EBX
 14952 fabs ECX,ECX
 14954 fsgn ECX,ECX
 14956 lneg ECX
// if (N==5)
 14958 cmp 0,ECX
 14961 jge 14969
// C='5'
 14964 sstack EBP:-8,53
__444:
__442:
__446:
 14969 rstack EBX,EBP:-7
 14973 mov ECX,6
 14976 sub ECX,EBX
 14978 fabs ECX,ECX
 14980 fsgn ECX,ECX
 14982 lneg ECX
// if (N==6)
 14984 cmp 0,ECX
 14987 jge 14995
// C='6'
 14990 sstack EBP:-8,54
__447:
__445:
__449:
 14995 rstack EBX,EBP:-7
 14999 mov ECX,7
 15002 sub ECX,EBX
 15004 fabs ECX,ECX
 15006 fsgn ECX,ECX
 15008 lneg ECX
// if (N==7)
 15010 cmp 0,ECX
 15013 jge 15021
// C='7'
 15016 sstack EBP:-8,55
__450:
__448:
__452:
 15021 rstack EBX,EBP:-7
 15025 mov ECX,8
 15028 sub ECX,EBX
 15030 fabs ECX,ECX
 15032 fsgn ECX,ECX
 15034 lneg ECX
// if (N==8)
 15036 cmp 0,ECX
 15039 jge 15047
// C='8'
 15042 sstack EBP:-8,56
__453:
__451:
__455:
 15047 rstack EBX,EBP:-7
 15051 mov ECX,9
 15054 sub ECX,EBX
 15056 fabs ECX,ECX
 15058 fsgn ECX,ECX
 15060 lneg ECX
// if (N==9)
 15062 cmp 0,ECX
 15065 jge 15073
// C='9'
 15068 sstack EBP:-8,57
__456:
__454:
__458:
 15073 rstack EBX,EBP:-7
 15077 mov ECX,10
 15080 sub ECX,EBX
 15082 fabs ECX,ECX
 15084 fsgn ECX,ECX
 15086 lneg ECX
// if (N==10)
 15088 cmp 0,ECX
 15091 jge 15099
// C='A'
 15094 sstack EBP:-8,65
__459:
__457:
__461:
 15099 rstack EBX,EBP:-7
 15103 mov ECX,11
 15106 sub ECX,EBX
 15108 fabs ECX,ECX
 15110 fsgn ECX,ECX
 15112 lneg ECX
// if (N==11)
 15114 cmp 0,ECX
 15117 jge 15125
// C='B'
 15120 sstack EBP:-8,66
__462:
__460:
__464:
 15125 rstack EBX,EBP:-7
 15129 mov ECX,12
 15132 sub ECX,EBX
 15134 fabs ECX,ECX
 15136 fsgn ECX,ECX
 15138 lneg ECX
// if (N==12)
 15140 cmp 0,ECX
 15143 jge 15151
// C='C'
 15146 sstack EBP:-8,67
__465:
__463:
__467:
 15151 rstack EBX,EBP:-7
 15155 mov ECX,13
 15158 sub ECX,EBX
 15160 fabs ECX,ECX
 15162 fsgn ECX,ECX
 15164 lneg ECX
// if (N==13)
 15166 cmp 0,ECX
 15169 jge 15177
// C='D'
 15172 sstack EBP:-8,68
__468:
__466:
__470:
 15177 rstack EBX,EBP:-7
 15181 mov ECX,14
 15184 sub ECX,EBX
 15186 fabs ECX,ECX
 15188 fsgn ECX,ECX
 15190 lneg ECX
// if (N==14)
 15192 cmp 0,ECX
 15195 jge 15203
// C='E'
 15198 sstack EBP:-8,69
__471:
__469:
__473:
 15203 rstack EBX,EBP:-7
 15207 mov ECX,15
 15210 sub ECX,EBX
 15212 fabs ECX,ECX
 15214 fsgn ECX,ECX
 15216 lneg ECX
// if (N==15)
 15218 cmp 0,ECX
 15221 jge 15229
// C='F'
 15224 sstack EBP:-8,70
__474:
__472:
 15229 rstack EBX,EBP:-8
 15233 rstack ECX,EBP:-1
 15237 mov EDX,ECX
 15239 inc ECX
 15241 sstack EBP:-1,ECX
 15245 add EDX,66946
// Nstack[NI++]=C
 15248 mov #EDX,EBX
 15250 rstack EBX,EBP:-10
// loop step
 15254 inc EBX
 15256 sstack EBP:-10,EBX
 15260 jmp 14742
__425:
__424:
__422:
 15263 rstack EBX,EBP:-1
 15267 add EBX,66946
 15270 mov ECX,EBX
// Nstack[NI]=0
 15272 mov #ECX,0
 15275 mov EAX,66946
 15278 leave 
 15279 ret 
__355:
 15280 leave 
 15281 ret 
Nlog:
// Nlog(A,B)
 15282 enter -0
__476:
 15285 rstack ESI,EBP:2
 15289 mov EAX,ESI
 15291 rstack ESI,EBP:3
 15295 mov EBX,ESI
 15297 fln EDX,EAX
 15299 fln ECX,EBX
 15301 div EDX,ECX
 15303 mov EAX,EDX
 15305 leave 
 15306 ret 
__475:
 15307 leave 
 15308 ret 
isPrint:
// isPrint(C)
 15309 enter -0
__478:
 15312 rstack EAX,EBP:2
 15316 mov EBX,127
 15319 sub EBX,EAX
 15321 fsgn EBX,EBX
 15323 max EBX,0
 15326 rstack EAX,EBP:2
 15330 sub EAX,31
 15333 mov ECX,EAX
 15335 fsgn ECX,ECX
 15337 max ECX,0
 15340 and ECX,EBX
 15342 mov EAX,ECX
 15344 leave 
 15345 ret 
__477:
 15346 leave 
 15347 ret 
isNum:
// isNum(C)
 15348 enter -0
__480:
 15351 rstack EAX,EBP:2
 15355 mov EBX,58
 15358 sub EBX,EAX
 15360 fsgn EBX,EBX
 15362 max EBX,0
 15365 rstack EAX,EBP:2
 15369 sub EAX,47
 15372 mov ECX,EAX
 15374 fsgn ECX,ECX
 15376 max ECX,0
 15379 and ECX,EBX
 15381 mov EAX,ECX
 15383 leave 
 15384 ret 
__479:
 15385 leave 
 15386 ret 
isAlpha:
// isAlpha(C)
 15387 enter -0
__482:
 15390 rstack EAX,EBP:2
 15394 mov EBX,123
 15397 sub EBX,EAX
 15399 fsgn EBX,EBX
 15401 max EBX,0
 15404 rstack EAX,EBP:2
 15408 sub EAX,96
 15411 mov ECX,EAX
 15413 fsgn ECX,ECX
 15415 max ECX,0
 15418 and ECX,EBX
 15420 rstack EAX,EBP:2
 15424 mov EBX,91
 15427 sub EBX,EAX
 15429 fsgn EBX,EBX
 15431 max EBX,0
 15434 rstack EAX,EBP:2
 15438 sub EAX,64
 15441 mov EDX,EAX
 15443 fsgn EDX,EDX
 15445 max EDX,0
 15448 and EDX,EBX
 15450 or EDX,ECX
 15452 mov EAX,EDX
 15454 leave 
 15455 ret 
__481:
 15456 leave 
 15457 ret 
toLower:
// toLower(C)
 15458 enter -0
__484:
__486:
 15461 rstack EAX,EBP:2
 15465 mov EBX,91
 15468 sub EBX,EAX
 15470 fsgn EBX,EBX
 15472 max EBX,0
 15475 rstack EAX,EBP:2
 15479 sub EAX,64
 15482 mov ECX,EAX
 15484 fsgn ECX,ECX
 15486 max ECX,0
 15489 and ECX,EBX
// if ((64<C)&&(C<91))
 15491 cmp 0,ECX
 15494 jge 15513
 15497 rstack EAX,EBP:2
 15501 add EAX,32
 15504 mov EBX,EAX
 15506 mov EAX,EBX
 15508 leave 
 15509 ret 
 15510 jmp 15519
__488:
__487:
__490:
 15513 rstack EAX,EBP:2
 15517 leave 
 15518 ret 
__489:
__485:
__483:
 15519 leave 
 15520 ret 
toUpper:
// toUpper(C)
 15521 enter -0
__492:
__494:
 15524 rstack EAX,EBP:2
 15528 mov EBX,123
 15531 sub EBX,EAX
 15533 fsgn EBX,EBX
 15535 max EBX,0
 15538 rstack EAX,EBP:2
 15542 sub EAX,96
 15545 mov ECX,EAX
 15547 fsgn ECX,ECX
 15549 max ECX,0
 15552 and ECX,EBX
// if ((96<C)&&(C<123))
 15554 cmp 0,ECX
 15557 jge 15576
 15560 rstack EAX,EBP:2
 15564 add EAX,-32
 15567 mov EBX,EAX
 15569 mov EAX,EBX
 15571 leave 
 15572 ret 
 15573 jmp 15582
__496:
__495:
__498:
 15576 rstack EAX,EBP:2
 15580 leave 
 15581 ret 
__497:
__493:
__491:
 15582 leave 
 15583 ret 
Con:
// Con(str1,str2,str3,str4,str5)
 15584 enter 3
__500:
 15587 sstack EBP:-1,0
 15592 sstack EBP:-2,0
 15597 rstack EAX,EBP:-1
 15601 mov EBX,EAX
 15603 inc EAX
 15605 sstack EBP:-1,EAX
 15609 rstack EAX,EBP:2
 15613 add EAX,EBX
 15615 mov EBX,EAX
 15617 sstack EBP:-3,#EBX
__502:
 15621 rstack EAX,EBP:-2
 15625 mov EBX,256
 15628 sub EBX,EAX
 15630 fsgn EBX,EBX
 15632 max EBX,0
 15635 rstack EAX,EBP:-3
 15639 mov ECX,0
 15642 sub ECX,EAX
 15644 neg ECX
 15646 fsgn ECX,ECX
 15648 max ECX,0
 15651 band ECX,EBX
// if ((C>0)&(I2<256)
 15653 cmp 0,ECX
 15656 jz 15707
 15659 rstack EAX,EBP:-3
 15663 rstack EBX,EBP:-2
 15667 mov ECX,EBX
 15669 inc EBX
 15671 sstack EBP:-2,EBX
 15675 add ECX,66688
// Constr[I2++]=C
 15678 mov #ECX,EAX
 15680 rstack EAX,EBP:-1
 15684 mov EBX,EAX
 15686 inc EAX
 15688 sstack EBP:-1,EAX
 15692 rstack EAX,EBP:2
 15696 add EAX,EBX
 15698 mov EBX,EAX
// C=str1[I++]
 15700 sstack EBP:-3,#EBX
 15704 jmp 15621
__501:
// I=0
 15707 sstack EBP:-1,0
 15712 rstack EAX,EBP:-1
 15716 mov EBX,EAX
 15718 inc EAX
 15720 sstack EBP:-1,EAX
 15724 rstack EAX,EBP:3
 15728 add EAX,EBX
 15730 mov EBX,EAX
// C=str2[I++]
 15732 sstack EBP:-3,#EBX
__504:
 15736 rstack EAX,EBP:-2
 15740 mov EBX,256
 15743 sub EBX,EAX
 15745 fsgn EBX,EBX
 15747 max EBX,0
 15750 rstack EAX,EBP:-3
 15754 mov ECX,0
 15757 sub ECX,EAX
 15759 neg ECX
 15761 fsgn ECX,ECX
 15763 max ECX,0
 15766 band ECX,EBX
// if ((C>0)&(I2<256)
 15768 cmp 0,ECX
 15771 jz 15822
 15774 rstack EAX,EBP:-3
 15778 rstack EBX,EBP:-2
 15782 mov ECX,EBX
 15784 inc EBX
 15786 sstack EBP:-2,EBX
 15790 add ECX,66688
// Constr[I2++]=C
 15793 mov #ECX,EAX
 15795 rstack EAX,EBP:-1
 15799 mov EBX,EAX
 15801 inc EAX
 15803 sstack EBP:-1,EAX
 15807 rstack EAX,EBP:3
 15811 add EAX,EBX
 15813 mov EBX,EAX
// C=str2[I++]
 15815 sstack EBP:-3,#EBX
 15819 jmp 15736
__503:
// I=0
 15822 sstack EBP:-1,0
 15827 rstack EAX,EBP:-1
 15831 mov EBX,EAX
 15833 inc EAX
 15835 sstack EBP:-1,EAX
 15839 rstack EAX,EBP:4
 15843 add EAX,EBX
 15845 mov EBX,EAX
// C=str3[I++]
 15847 sstack EBP:-3,#EBX
__506:
 15851 rstack EAX,EBP:-2
 15855 mov EBX,256
 15858 sub EBX,EAX
 15860 fsgn EBX,EBX
 15862 max EBX,0
 15865 rstack EAX,EBP:-3
 15869 mov ECX,0
 15872 sub ECX,EAX
 15874 neg ECX
 15876 fsgn ECX,ECX
 15878 max ECX,0
 15881 band ECX,EBX
// if ((C>0)&(I2<256)
 15883 cmp 0,ECX
 15886 jz 15937
 15889 rstack EAX,EBP:-3
 15893 rstack EBX,EBP:-2
 15897 mov ECX,EBX
 15899 inc EBX
 15901 sstack EBP:-2,EBX
 15905 add ECX,66688
// Constr[I2++]=C
 15908 mov #ECX,EAX
 15910 rstack EAX,EBP:-1
 15914 mov EBX,EAX
 15916 inc EAX
 15918 sstack EBP:-1,EAX
 15922 rstack EAX,EBP:4
 15926 add EAX,EBX
 15928 mov EBX,EAX
// C=str3[I++]
 15930 sstack EBP:-3,#EBX
 15934 jmp 15851
__505:
// I=0
 15937 sstack EBP:-1,0
 15942 rstack EAX,EBP:-1
 15946 mov EBX,EAX
 15948 inc EAX
 15950 sstack EBP:-1,EAX
 15954 rstack EAX,EBP:5
 15958 add EAX,EBX
 15960 mov EBX,EAX
// C=str4[I++]
 15962 sstack EBP:-3,#EBX
__508:
 15966 rstack EAX,EBP:-2
 15970 mov EBX,256
 15973 sub EBX,EAX
 15975 fsgn EBX,EBX
 15977 max EBX,0
 15980 rstack EAX,EBP:-3
 15984 mov ECX,0
 15987 sub ECX,EAX
 15989 neg ECX
 15991 fsgn ECX,ECX
 15993 max ECX,0
 15996 band ECX,EBX
// if ((C>0)&(I2<256)
 15998 cmp 0,ECX
 16001 jz 16052
 16004 rstack EAX,EBP:-3
 16008 rstack EBX,EBP:-2
 16012 mov ECX,EBX
 16014 inc EBX
 16016 sstack EBP:-2,EBX
 16020 add ECX,66688
// Constr[I2++]=C
 16023 mov #ECX,EAX
 16025 rstack EAX,EBP:-1
 16029 mov EBX,EAX
 16031 inc EAX
 16033 sstack EBP:-1,EAX
 16037 rstack EAX,EBP:5
 16041 add EAX,EBX
 16043 mov EBX,EAX
// C=str4[I++]
 16045 sstack EBP:-3,#EBX
 16049 jmp 15966
__507:
// I=0
 16052 sstack EBP:-1,0
 16057 rstack EAX,EBP:-1
 16061 mov EBX,EAX
 16063 inc EAX
 16065 sstack EBP:-1,EAX
 16069 rstack EAX,EBP:6
 16073 add EAX,EBX
 16075 mov EBX,EAX
// C=str5[I++]
 16077 sstack EBP:-3,#EBX
__510:
 16081 rstack EAX,EBP:-2
 16085 mov EBX,256
 16088 sub EBX,EAX
 16090 fsgn EBX,EBX
 16092 max EBX,0
 16095 rstack EAX,EBP:-3
 16099 mov ECX,0
 16102 sub ECX,EAX
 16104 neg ECX
 16106 fsgn ECX,ECX
 16108 max ECX,0
 16111 band ECX,EBX
// if ((C>0)&(I2<256)
 16113 cmp 0,ECX
 16116 jz 16167
 16119 rstack EAX,EBP:-3
 16123 rstack EBX,EBP:-2
 16127 mov ECX,EBX
 16129 inc EBX
 16131 sstack EBP:-2,EBX
 16135 add ECX,66688
// Constr[I2++]=C
 16138 mov #ECX,EAX
 16140 rstack EAX,EBP:-1
 16144 mov EBX,EAX
 16146 inc EAX
 16148 sstack EBP:-1,EAX
 16152 rstack EAX,EBP:6
 16156 add EAX,EBX
 16158 mov EBX,EAX
// C=str5[I++]
 16160 sstack EBP:-3,#EBX
 16164 jmp 16081
__509:
 16167 rstack EAX,EBP:-2
 16171 add EAX,66688
 16174 mov EBX,EAX
// Constr[I2]=0
 16176 mov #EBX,0
 16179 mov EAX,66688
 16182 leave 
 16183 ret 
__499:
 16184 leave 
 16185 ret 
concat:
// concat()
 16186 enter 9
__512:
 16189 sstack EBP:-1,ECX
 16193 sstack EBP:-2,0
 16198 mov ECX,0
// va_start_0(...)
 16201 call 10011
 16204 sstack EBP:-3,EAX
 16208 sstack EBP:-4,0
__514:
 16213 rstack EAX,EBP:-2
 16217 rstack EBX,EBP:-1
 16221 sub EBX,EAX
 16223 mov EAX,EBX
 16225 fsgn EAX,EAX
 16227 max EAX,0
// if (I<n
 16230 cmp 0,EAX
 16233 jz 16346
 16236 mov EAX,SS:EBP
 16239 add EAX,-3
 16242 push EAX
 16244 mov ECX,1
// va_next(...)
 16247 call 10016
 16250 add ESP,1
 16253 sstack EBP:-5,EAX
 16257 sstack EBP:-6,0
 16262 rstack EAX,EBP:-6
 16266 mov EBX,EAX
 16268 inc EAX
 16270 sstack EBP:-6,EAX
 16274 rstack EAX,EBP:-5
 16278 add EAX,EBX
 16280 mov EBX,EAX
 16282 sstack EBP:-7,#EBX
__516:
 16286 rstack EAX,EBP:-7
// if (C
 16290 cmp 0,EAX
 16293 jz 16333
 16296 rstack EAX,EBP:-4
// len++
 16300 inc EAX
 16302 sstack EBP:-4,EAX
 16306 rstack EAX,EBP:-6
 16310 mov EBX,EAX
 16312 inc EAX
 16314 sstack EBP:-6,EAX
 16318 rstack EAX,EBP:-5
 16322 add EAX,EBX
 16324 mov EBX,EAX
// C=str[J++]
 16326 sstack EBP:-7,#EBX
 16330 jmp 16286
__515:
 16333 rstack EAX,EBP:-2
// I++
 16337 inc EAX
 16339 sstack EBP:-2,EAX
 16343 jmp 16213
__513:
 16346 rstack EAX,EBP:-4
 16350 add EAX,1
 16353 mov EBX,EAX
 16355 push EBX
 16357 mov ECX,1
// stack_alloc(...)
 16360 call 11635
 16363 add ESP,1
 16366 sstack EBP:-8,EAX
// I=0
 16370 sstack EBP:-2,0
 16375 mov ECX,0
// va_start_0(...)
 16378 call 10011
// va=va_start_0()
 16381 sstack EBP:-3,EAX
 16385 sstack EBP:-9,0
__518:
 16390 rstack EAX,EBP:-2
 16394 rstack EBX,EBP:-1
 16398 sub EBX,EAX
 16400 mov EAX,EBX
 16402 fsgn EAX,EAX
 16404 max EAX,0
// if (I<n
 16407 cmp 0,EAX
 16410 jz 16539
 16413 mov EAX,SS:EBP
 16416 add EAX,-3
 16419 push EAX
 16421 mov ECX,1
// va_next(...)
 16424 call 10016
 16427 add ESP,1
// str=va_next(&va)
 16430 sstack EBP:-5,EAX
// J=0
 16434 sstack EBP:-6,0
 16439 rstack EAX,EBP:-6
 16443 mov EBX,EAX
 16445 inc EAX
 16447 sstack EBP:-6,EAX
 16451 rstack EAX,EBP:-5
 16455 add EAX,EBX
 16457 mov EBX,EAX
// C=str[J++]
 16459 sstack EBP:-7,#EBX
__520:
 16463 rstack EAX,EBP:-7
// if (C
 16467 cmp 0,EAX
 16470 jz 16526
 16473 rstack EAX,EBP:-7
 16477 rstack EBX,EBP:-9
 16481 mov ECX,EBX
 16483 inc EBX
 16485 sstack EBP:-9,EBX
 16489 rstack EBX,EBP:-8
 16493 add EBX,ECX
 16495 mov ECX,EBX
// newstr[J2++]=C
 16497 mov #ECX,EAX
 16499 rstack EAX,EBP:-6
 16503 mov EBX,EAX
 16505 inc EAX
 16507 sstack EBP:-6,EAX
 16511 rstack EAX,EBP:-5
 16515 add EAX,EBX
 16517 mov EBX,EAX
// C=str[J++]
 16519 sstack EBP:-7,#EBX
 16523 jmp 16463
__519:
 16526 rstack EAX,EBP:-2
// I++
 16530 inc EAX
 16532 sstack EBP:-2,EAX
 16536 jmp 16390
__517:
 16539 rstack EAX,EBP:-9
 16543 rstack EBX,EBP:-8
 16547 add EBX,EAX
 16549 mov EAX,EBX
// newstr[J2]=0
 16551 mov #EAX,0
 16554 rstack EAX,EBP:-1
// stack_return arg #3 (float num_args)
 16558 push EAX
 16560 rstack EAX,EBP:-4
 16564 add EAX,1
 16567 mov EBX,EAX
// stack_return arg #2 (float size)
 16569 push EBX
 16571 rstack EAX,EBP:-8
// stack_return arg #1 (float ptr)
 16575 push EAX
 16577 mov ECX,3
// stack_return(...)
 16580 call 11897
 16583 add ESP,3
 16586 leave 
 16587 ret 
__511:
 16588 leave 
 16589 ret 
c2str:
// c2str(C)
 16590 enter -0
__522:
__524:
 16593 rstack EAX,EBP:2
 16597 mov EBX,10
 16600 sub EBX,EAX
 16602 fabs EBX,EBX
 16604 fsgn EBX,EBX
 16606 lneg EBX
// if (C=='\10')
 16608 cmp 0,EBX
 16611 jge 16632
// stack_return arg #3 (float num_args)
 16614 push 1
// stack_return arg #2 (float size)
 16617 push 3
// stack_return arg #1 (float ptr)
 16620 push 17199
 16623 mov ECX,3
// stack_return(...)
 16626 call 11897
 16629 add ESP,3
__525:
__523:
__527:
 16632 rstack EAX,EBP:2
 16636 mov EBX,0
 16639 sub EBX,EAX
 16641 fabs EBX,EBX
 16643 fsgn EBX,EBX
 16645 lneg EBX
// if (C==0)
 16647 cmp 0,EBX
 16650 jge 16671
// stack_return arg #3 (float num_args)
 16653 push 1
// stack_return arg #2 (float size)
 16656 push 3
// stack_return arg #1 (float ptr)
 16659 push 17201
 16662 mov ECX,3
// stack_return(...)
 16665 call 11897
 16668 add ESP,3
__528:
__526:
 16671 rstack EAX,EBP:2
 16675 mov EBX,0
 16678 add EBX,66686
// c2str_str[0]=C
 16681 mov #EBX,EAX
 16683 mov EAX,1
 16686 add EAX,66686
// c2str_str[1]=0
 16689 mov #EAX,0
// stack_return arg #3 (float num_args)
 16692 push 1
// stack_return arg #2 (float size)
 16695 push 2
// stack_return arg #1 (float ptr)
 16698 push 66686
 16701 mov ECX,3
// stack_return(...)
 16704 call 11897
 16707 add ESP,3
__521:
 16710 leave 
 16711 ret 
cstr_find_first_of:
// cstr_find_first_of(S,C)
 16712 enter 2
__530:
 16715 sstack EBP:-1,0
 16720 rstack EAX,EBP:-1
 16724 rstack EBX,EBP:2
 16728 add EBX,EAX
 16730 mov EAX,EBX
 16732 sstack EBP:-2,#EAX
__532:
 16736 rstack EAX,EBP:-2
 16740 mov EBX,0
 16743 sub EBX,EAX
 16745 fabs EBX,EBX
 16747 fsgn EBX,EBX
// if (C1!=0
 16749 cmp 0,EBX
 16752 jz 16814
__534:
 16755 rstack EAX,EBP:-2
 16759 rstack EBX,EBP:3
 16763 sub EBX,EAX
 16765 mov EAX,EBX
 16767 fabs EAX,EAX
 16769 fsgn EAX,EAX
 16771 lneg EAX
// if (C1==C)
 16773 cmp 0,EAX
 16776 jge 16785
 16779 rstack EAX,EBP:-1
 16783 leave 
 16784 ret 
__535:
__533:
 16785 rstack EAX,EBP:-1
// I++
 16789 inc EAX
 16791 sstack EBP:-1,EAX
 16795 rstack EAX,EBP:-1
 16799 rstack EBX,EBP:2
 16803 add EBX,EAX
 16805 mov EAX,EBX
// C1=S[I]
 16807 sstack EBP:-2,#EAX
 16811 jmp 16736
__531:
 16814 mov EAX,-1
 16817 leave 
 16818 ret 
__529:
 16819 leave 
 16820 ret 
cstr_find_last_of:
// cstr_find_last_of(S,C)
 16821 enter 2
__537:
 16824 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 16828 push EAX
 16830 mov ECX,1
// strlen(...)
 16833 call 11121
 16836 add ESP,1
 16839 add EAX,-1
 16842 sstack EBP:-1,EAX
 16846 rstack EAX,EBP:-1
 16850 rstack EBX,EBP:2
 16854 add EBX,EAX
 16856 mov EAX,EBX
 16858 sstack EBP:-2,#EAX
__539:
 16862 rstack EAX,EBP:-1
 16866 mov EBX,-1
 16869 sub EBX,EAX
 16871 fabs EBX,EBX
 16873 fsgn EBX,EBX
// if (I!=-1
 16875 cmp 0,EBX
 16878 jz 16940
__541:
 16881 rstack EAX,EBP:-2
 16885 rstack EBX,EBP:3
 16889 sub EBX,EAX
 16891 mov EAX,EBX
 16893 fabs EAX,EAX
 16895 fsgn EAX,EAX
 16897 lneg EAX
// if (C1==C)
 16899 cmp 0,EAX
 16902 jge 16911
 16905 rstack EAX,EBP:-1
 16909 leave 
 16910 ret 
__542:
__540:
 16911 rstack EAX,EBP:-1
// I--
 16915 dec EAX
 16917 sstack EBP:-1,EAX
 16921 rstack EAX,EBP:-1
 16925 rstack EBX,EBP:2
 16929 add EBX,EAX
 16931 mov EAX,EBX
// C1=S[I]
 16933 sstack EBP:-2,#EAX
 16937 jmp 16862
__538:
 16940 mov EAX,-1
 16943 leave 
 16944 ret 
__536:
 16945 leave 
 16946 ret 
stack_copy:
// stack_copy(ptr,size)
 16947 enter -0
__544:
// stack_return arg #3 (float num_args)
 16950 push 2
 16953 rstack EAX,EBP:3
// stack_return arg #2 (float size)
 16957 push EAX
 16959 rstack EAX,EBP:2
// stack_return arg #1 (float ptr)
 16963 push EAX
 16965 mov ECX,3
// stack_return(...)
 16968 call 11897
 16971 add ESP,3
 16974 leave 
 16975 ret 
__543:
 16976 leave 
 16977 ret 
cstr_stack_copy:
// cstr_stack_copy(str)
 16978 enter 1
__546:
 16981 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 16985 push EAX
 16987 mov ECX,1
// strlen(...)
 16990 call 11121
 16993 add ESP,1
 16996 sstack EBP:-1,EAX
// stack_return arg #3 (float num_args)
 17000 push 1
 17003 rstack EAX,EBP:-1
 17007 add EAX,1
 17010 mov EBX,EAX
// stack_return arg #2 (float size)
 17012 push EBX
 17014 rstack EAX,EBP:2
// stack_return arg #1 (float ptr)
 17018 push EAX
 17020 mov ECX,3
// stack_return(...)
 17023 call 11897
 17026 add ESP,3
 17029 leave 
 17030 ret 
__545:
 17031 leave 
 17032 ret 
isspace:
// isspace(C)
 17033 enter -0
__548:
__550:
 17036 rstack EAX,EBP:2
 17040 mov EBX,32
 17043 sub EBX,EAX
 17045 fabs EBX,EBX
 17047 fsgn EBX,EBX
 17049 lneg EBX
// if (C==' ')
 17051 cmp 0,EBX
 17054 jge 17062
 17057 mov EAX,1
 17060 leave 
 17061 ret 
__551:
__549:
__553:
 17062 rstack EAX,EBP:2
 17066 mov EBX,9
 17069 sub EBX,EAX
 17071 fabs EBX,EBX
 17073 fsgn EBX,EBX
 17075 lneg EBX
// if (C=='\9')
 17077 cmp 0,EBX
 17080 jge 17088
 17083 mov EAX,1
 17086 leave 
 17087 ret 
__554:
__552:
__556:
 17088 rstack EAX,EBP:2
 17092 mov EBX,10
 17095 sub EBX,EAX
 17097 fabs EBX,EBX
 17099 fsgn EBX,EBX
 17101 lneg EBX
// if (C=='\10')
 17103 cmp 0,EBX
 17106 jge 17114
 17109 mov EAX,1
 17112 leave 
 17113 ret 
__557:
__555:
__559:
 17114 rstack EAX,EBP:2
 17118 mov EBX,11
 17121 sub EBX,EAX
 17123 fabs EBX,EBX
 17125 fsgn EBX,EBX
 17127 lneg EBX
// if (C=='\11')
 17129 cmp 0,EBX
 17132 jge 17140
 17135 mov EAX,1
 17138 leave 
 17139 ret 
__560:
__558:
__562:
 17140 rstack EAX,EBP:2
 17144 mov EBX,12
 17147 sub EBX,EAX
 17149 fabs EBX,EBX
 17151 fsgn EBX,EBX
 17153 lneg EBX
// if (C=='\12')
 17155 cmp 0,EBX
 17158 jge 17166
 17161 mov EAX,1
 17164 leave 
 17165 ret 
__563:
__561:
__565:
 17166 rstack EAX,EBP:2
 17170 mov EBX,13
 17173 sub EBX,EAX
 17175 fabs EBX,EBX
 17177 fsgn EBX,EBX
 17179 lneg EBX
// if (C=='\13')
 17181 cmp 0,EBX
 17184 jge 17192
 17187 mov EAX,1
 17190 leave 
 17191 ret 
__566:
__564:
 17192 mov EAX,0
 17195 leave 
 17196 ret 
__547:
 17197 leave 
 17198 ret 
LIBSTRING_CONSTANTS:
c2str_n:
 17199 db ""
 17199 db 110
 17200 db 0
c2str_0:
 17201 db ""
 17201 db 48
 17202 db 0
LIBSTRING_END:
libmarker4:
 17203 db 0
libconsolescreen_init:
// libconsolescreen_init()
 17204 enter -0
__568:
// cs_last_x=29
 17207 mov #66677,29
// cs_last_y=17
 17211 mov #66678,17
// printScrX=0
 17215 mov #66679,0
// printScrY=0
 17219 mov #66680,0
__567:
 17223 leave 
 17224 ret 
setPrintCursor:
// setPrintCursor(x,y)
 17225 enter -0
__570:
 17228 rstack EAX,EBP:2
// printScrX=x
 17232 mov #66679,EAX
 17235 rstack EAX,EBP:3
// printScrY=y
 17239 mov #66680,EAX
__569:
 17242 leave 
 17243 ret 
Print:
// Print(str,col0)
 17244 enter 6
__572:
 17247 sstack EBP:-1,ECX
 17251 sstack EBP:-2,999
__574:
 17256 rstack EAX,EBP:-1
 17260 mov EBX,2
 17263 sub EBX,EAX
 17265 fabs EBX,EBX
 17267 fsgn EBX,EBX
 17269 lneg EBX
// if (nargs==2)
 17271 cmp 0,EBX
 17274 jge 17285
 17277 rstack EAX,EBP:3
// col=col0
 17281 sstack EBP:-2,EAX
__575:
__573:
 17285 rstack EAX,EBP:2
 17289 add EAX,0
 17292 mov EBX,EAX
 17294 sstack EBP:-3,#EBX
 17298 sstack EBP:-4,1
 17303 sstack EBP:-5,0
 17308 sstack EBP:-6,0
__577:
 17313 rstack EAX,EBP:-3
 17317 mov EBX,0
 17320 sub EBX,EAX
 17322 fabs EBX,EBX
 17324 fsgn EBX,EBX
// if (C!=0
 17326 cmp 0,EBX
 17329 jz 17607
__579:
 17332 mov EAX,#66678
 17335 sub EAX,#66680
 17338 neg EAX
 17340 fsgn EAX,EAX
 17342 max EAX,0
// if (printScrY>cs_last_y)
 17345 cmp 0,EAX
 17348 jge 17357
 17351 mov ECX,0
// ConsoleShiftUp(...)
 17354 call 18296
__580:
__578:
__582:
 17357 rstack EAX,EBP:-3
 17361 mov EBX,10
 17364 sub EBX,EAX
 17366 fabs EBX,EBX
 17368 fsgn EBX,EBX
 17370 lneg EBX
// if ((C=='\10'))
 17372 cmp 0,EBX
 17375 jge 17384
 17378 jmp 17573
 17381 jmp 17554
__584:
__583:
__586:
__588:
 17384 rstack EAX,EBP:-3
 17388 mov EBX,13
 17391 sub EBX,EAX
 17393 fabs EBX,EBX
 17395 fsgn EBX,EBX
 17397 lneg EBX
// if ((C=='\13'))
 17399 cmp 0,EBX
 17402 jge 17412
// printScrX=0
 17405 mov #66679,0
 17409 jmp 17554
__590:
__589:
__592:
__594:
 17412 rstack EAX,EBP:-3
 17416 mov EBX,8
 17419 sub EBX,EAX
 17421 fabs EBX,EBX
 17423 fsgn EBX,EBX
 17425 lneg EBX
// if ((C=='\8'))
 17427 cmp 0,EBX
 17430 jge 17443
// printScrY--
 17433 dec #66680
// printScrX=0
 17436 mov #66679,0
 17440 jmp 17554
__596:
__595:
__598:
__600:
 17443 rstack EAX,EBP:-3
 17447 mov EBX,12
 17450 sub EBX,EAX
 17452 fabs EBX,EBX
 17454 fsgn EBX,EBX
 17456 lneg EBX
// if ((C=='\12'))
 17458 cmp 0,EBX
 17461 jge 17524
__603:
 17464 mov EAX,#66677
 17467 sub EAX,#66679
 17470 fsgn EAX,EAX
 17472 inc EAX
 17474 max EAX,0
// if (printScrX<=cs_last_x
 17477 cmp 0,EAX
 17480 jz 17521
// ch=' '
 17483 sstack EBP:-6,32
 17488 rstack EAX,EBP:-2
 17492 push EAX
 17494 rstack EAX,EBP:-6
 17498 push EAX
 17500 push #66680
 17503 push #66679
 17506 mov ECX,4
// PrintCharXY(...)
 17509 call 17832
 17512 add ESP,4
// printScrX++
 17515 inc #66679
 17518 jmp 17464
__602:
 17521 jmp 17554
__604:
__601:
__606:
 17524 rstack EAX,EBP:-2
 17528 push EAX
 17530 rstack EAX,EBP:-3
 17534 push EAX
 17536 push #66680
 17539 push #66679
 17542 mov ECX,4
// PrintCharXY(...)
 17545 call 17832
 17548 add ESP,4
// printScrX++
 17551 inc #66679
__605:
__599:
__597:
__593:
__591:
__587:
__585:
__581:
__608:
 17554 mov EAX,#66677
 17557 sub EAX,#66679
 17560 neg EAX
 17562 fsgn EAX,EAX
 17564 max EAX,0
// if (printScrX>cs_last_x)
 17567 cmp 0,EAX
 17570 jge 17580
print_nextline:
// printScrX=0
 17573 mov #66679,0
// printScrY++
 17577 inc #66680
__609:
__607:
 17580 rstack EAX,EBP:-4
 17584 mov EBX,EAX
 17586 inc EAX
 17588 sstack EBP:-4,EAX
 17592 rstack EAX,EBP:2
 17596 add EAX,EBX
 17598 mov EBX,EAX
// C=str[I++]
 17600 sstack EBP:-3,#EBX
 17604 jmp 17313
__576:
__571:
 17607 leave 
 17608 ret 
PrintChar:
// PrintChar(C,col)
 17609 enter -0
__611:
 17612 rstack EAX,EBP:3
 17616 push EAX
 17618 rstack EAX,EBP:2
 17622 push EAX
 17624 push #66680
 17627 push #66679
 17630 mov ECX,4
// PrintCharXY(...)
 17633 call 17832
 17636 add ESP,4
// printScrX++
 17639 inc #66679
__613:
 17642 mov EAX,#66677
 17645 sub EAX,#66679
 17648 neg EAX
 17650 fsgn EAX,EAX
 17652 max EAX,0
// if (printScrX>cs_last_x)
 17655 cmp 0,EAX
 17658 jge 17695
// printScrX=0
 17661 mov #66679,0
// printScrY++
 17665 inc #66680
__616:
 17668 mov EAX,#66678
 17671 sub EAX,#66680
 17674 neg EAX
 17676 fsgn EAX,EAX
 17678 inc EAX
 17680 max EAX,0
// if (printScrY>=cs_last_y)
 17683 cmp 0,EAX
 17686 jge 17695
 17689 mov ECX,0
// ConsoleShiftUp(...)
 17692 call 18296
__617:
__615:
__614:
__612:
__610:
 17695 leave 
 17696 ret 
PrintStringXY:
// PrintStringXY(x,y,str,col)
 17697 enter 3
__619:
 17700 rstack EAX,EBP:2
 17704 rstack EBX,EBP:3
 17708 mul EBX,30
 17711 mov ECX,EBX
 17713 add ECX,EAX
 17715 mul ECX,2
 17718 sstack EBP:-1,ECX
 17722 sstack EBP:-2,0
 17727 rstack EAX,EBP:-2
 17731 mov EBX,EAX
 17733 inc EAX
 17735 sstack EBP:-2,EAX
 17739 rstack EAX,EBP:4
 17743 add EAX,EBX
 17745 mov EBX,EAX
 17747 sstack EBP:-3,#EBX
__621:
 17751 rstack EAX,EBP:-3
// if (C
 17755 cmp 0,EAX
 17758 jz 17830
 17761 rstack EAX,EBP:-3
 17765 rstack EBX,EBP:-1
 17769 mov ECX,EBX
 17771 inc EBX
 17773 sstack EBP:-1,EBX
 17777 add ECX,#66681
// AdrScreen[P++]=C
 17780 mov #ECX,EAX
 17782 rstack EAX,EBP:5
 17786 rstack EBX,EBP:-1
 17790 mov ECX,EBX
 17792 inc EBX
 17794 sstack EBP:-1,EBX
 17798 add ECX,#66681
// AdrScreen[P++]=col
 17801 mov #ECX,EAX
 17803 rstack EAX,EBP:-2
 17807 mov EBX,EAX
 17809 inc EAX
 17811 sstack EBP:-2,EAX
 17815 rstack EAX,EBP:4
 17819 add EAX,EBX
 17821 mov EBX,EAX
// C=str[I++]
 17823 sstack EBP:-3,#EBX
 17827 jmp 17751
__620:
__618:
 17830 leave 
 17831 ret 
PrintCharXY:
// printCharXY(X,Y,C,col)
 17832 enter 1
__623:
 17835 rstack EAX,EBP:3
 17839 mul EAX,30
 17842 mov EBX,EAX
 17844 rstack EAX,EBP:2
 17848 add EAX,EBX
 17850 mov EBX,EAX
 17852 mov EAX,2
 17855 mul EAX,EBX
 17857 mov EBX,#66681
 17860 add EBX,EAX
 17862 sstack EBP:-1,EBX
 17866 rstack EAX,EBP:4
 17870 rstack EBX,EBP:-1
 17874 mov ECX,EBX
 17876 inc EBX
 17878 sstack EBP:-1,EBX
// *P++=C
 17882 mov #ECX,EAX
 17884 rstack EAX,EBP:5
 17888 rstack EBX,EBP:-1
// *P=col
 17892 mov #EBX,EAX
__622:
 17894 leave 
 17895 ret 
screenEraseChar:
// screenEraseChar()
 17896 enter -0
__625:
__627:
 17899 mov EAX,0
 17902 sub EAX,#66679
 17905 neg EAX
 17907 fsgn EAX,EAX
 17909 max EAX,0
// if (printScrX>0)
 17912 cmp 0,EAX
 17915 jge 17924
// printScrX--
 17918 dec #66679
 17921 jmp 17950
__629:
__628:
__631:
__633:
 17924 mov EAX,0
 17927 sub EAX,#66680
 17930 neg EAX
 17932 fsgn EAX,EAX
 17934 max EAX,0
// if (printScrY>0)
 17937 cmp 0,EAX
 17940 jge 17950
// printScrY--
 17943 dec #66680
// printScrX=cs_last_x
 17946 mov #66679,#66677
__634:
__632:
__630:
__626:
 17950 push 999
 17953 push 32
 17956 push #66680
 17959 push #66679
 17962 mov ECX,4
// PrintCharXY(...)
 17965 call 17832
 17968 add ESP,4
__624:
 17971 leave 
 17972 ret 
screen_set:
// screen_set(scr)
 17973 enter -0
__636:
 17976 rstack EAX,EBP:2
// AdrScreen=scr
 17980 mov #66681,EAX
__635:
 17983 leave 
 17984 ret 
screen_clear:
// screen_clear()
 17985 enter -0
__638:
 17988 mov EAX,2041
 17991 add EAX,#66681
// AdrScreen[2041]=1
 17994 mov #EAX,1
__637:
 17997 leave 
 17998 ret 
screen_cursor_enable:
// screen_cursor_enable()
 17999 enter -0
__640:
 18002 mov EAX,2046
 18005 add EAX,#66681
// AdrScreen[2046]=1
 18008 mov #EAX,1
__639:
 18011 leave 
 18012 ret 
screen_cursor_disable:
// screen_cursor_disable()
 18013 enter -0
__642:
 18016 mov EAX,2046
 18019 add EAX,#66681
// AdrScreen[2046]=0
 18022 mov #EAX,0
__641:
 18025 leave 
 18026 ret 
screen_set_cursor_pos:
// screen_set_cursor_pos(I)
 18027 enter -0
__644:
 18030 rstack EAX,EBP:2
 18034 mov EBX,2
 18037 mul EBX,EAX
 18039 mov EAX,2045
 18042 add EAX,#66681
// AdrScreen[2045]=2*I
 18045 mov #EAX,EBX
__643:
 18047 leave 
 18048 ret 
screen_set_cursor_pos_xy:
// screen_set_cursor_pos_xy(x,y)
 18049 enter -0
__646:
 18052 rstack EAX,EBP:2
 18056 rstack EBX,EBP:3
 18060 mov ECX,30
 18063 mul ECX,EBX
 18065 add ECX,EAX
 18067 mov EAX,2
 18070 mul EAX,ECX
 18072 mov EBX,2045
 18075 add EBX,#66681
// AdrScreen[2045]=2*(30*y+x)
 18078 mov #EBX,EAX
__645:
 18080 leave 
 18081 ret 
screen_force_refresh:
// screen_force_refresh()
 18082 enter -0
__648:
 18085 mov EAX,2020
 18088 add EAX,#66681
// AdrScreen[2020]=1
 18091 mov #EAX,1
 18094 push 1
 18097 mov ECX,1
// delay(...)
 18100 call 24967
 18103 add ESP,1
__647:
 18106 leave 
 18107 ret 
screen_set_shift_box_x1:
// screen_set_shift_box_x1(n)
 18108 enter -0
__650:
 18111 rstack EAX,EBP:2
 18115 mov EBX,2031
 18118 add EBX,#66681
// AdrScreen[2031]=n
 18121 mov #EBX,EAX
__649:
 18123 leave 
 18124 ret 
screen_set_shift_box_x2:
// screen_set_shift_box_x2(n)
 18125 enter -0
__652:
 18128 rstack EAX,EBP:2
 18132 mov EBX,2032
 18135 add EBX,#66681
// AdrScreen[2032]=n
 18138 mov #EBX,EAX
__651:
 18140 leave 
 18141 ret 
screen_set_shift_box_y1:
// screen_set_shift_box_y1(n)
 18142 enter -0
__654:
 18145 rstack EAX,EBP:2
 18149 mov EBX,2033
 18152 add EBX,#66681
// AdrScreen[2033]=n
 18155 mov #EBX,EAX
__653:
 18157 leave 
 18158 ret 
screen_set_shift_box_y2:
// screen_set_shift_box_y2(n)
 18159 enter -0
__656:
 18162 rstack EAX,EBP:2
 18166 mov EBX,2034
 18169 add EBX,#66681
// AdrScreen[2034]=n
 18172 mov #EBX,EAX
__655:
 18174 leave 
 18175 ret 
screen_set_shift_box:
// screen_set_shift_box(x1,x2,y1,y2)
 18176 enter -0
__658:
 18179 rstack EAX,EBP:2
 18183 mov EBX,2031
 18186 add EBX,#66681
// AdrScreen[2031]=x1
 18189 mov #EBX,EAX
 18191 rstack EAX,EBP:3
 18195 mov EBX,2032
 18198 add EBX,#66681
// AdrScreen[2032]=x2
 18201 mov #EBX,EAX
 18203 rstack EAX,EBP:4
 18207 mov EBX,2033
 18210 add EBX,#66681
// AdrScreen[2033]=y1
 18213 mov #EBX,EAX
 18215 rstack EAX,EBP:5
 18219 mov EBX,2034
 18222 add EBX,#66681
// AdrScreen[2034]=y2
 18225 mov #EBX,EAX
__657:
 18227 leave 
 18228 ret 
screen_set_print_box:
// screen_set_print_box(x1,y1,x2,y2)
 18229 enter -0
__660:
 18232 rstack EAX,EBP:2
// screen_print_x_min=x1
 18236 mov #66682,EAX
 18239 rstack EAX,EBP:3
// screen_print_y_min=y1
 18243 mov #66683,EAX
 18246 rstack EAX,EBP:4
// screen_print_x_max=x2
 18250 mov #66684,EAX
 18253 rstack EAX,EBP:5
// screen_print_y_max=y2
 18257 mov #66685,EAX
__659:
 18260 leave 
 18261 ret 
screen_shift_vertical:
// screen_shift_vertical(n)
 18262 enter -0
__662:
 18265 rstack EAX,EBP:2
 18269 mov EBX,2038
 18272 add EBX,#66681
// AdrScreen[2038]=n
 18275 mov #EBX,EAX
__661:
 18277 leave 
 18278 ret 
screen_shift_horizontal:
// screen_shift_horizontal(n)
 18279 enter -0
__664:
 18282 rstack EAX,EBP:2
 18286 mov EBX,2037
 18289 add EBX,#66681
// AdrScreen[2037]=n
 18292 mov #EBX,EAX
__663:
 18294 leave 
 18295 ret 
ConsoleShiftUp:
// ConsoleShiftUp()
 18296 enter -0
__666:
__668:
 18299 mov EAX,#66678
 18302 sub EAX,#66680
 18305 neg EAX
 18307 fsgn EAX,EAX
 18309 inc EAX
 18311 max EAX,0
// if (printScrY>=cs_last_y)
 18314 cmp 0,EAX
 18317 jge 18335
// screen_shift_vertical arg #1 (float n)
 18320 push 1
 18323 mov ECX,1
// screen_shift_vertical(...)
 18326 call 18262
 18329 add ESP,1
// printScrY--
 18332 dec #66680
__669:
__667:
__665:
 18335 leave 
 18336 ret 
libmarker5:
 18337 db 0
udhDeviceString0:
 18338 db "None",0
udhDeviceString1:
 18343 db "Unknown",0
udhDeviceString2:
 18351 db "Extended bus",0
udhDeviceString3:
 18364 db "Address bus",0
udhDeviceString4:
 18376 db "Zyelios CPU",0
udhDeviceString5:
 18388 db "Zyelios GPU",0
udhDeviceString6:
 18400 db "Zyelios SPU",0
udhDeviceString7:
 18412 db "Flash EEPROM",0
udhDeviceString8:
 18425 db "ROM",0
udhDeviceString9:
 18429 db "Data bus",0
udhDeviceString10:
 18438 db "CD Ray",0
udhDeviceString11:
 18445 db "Console screen",0
udhDeviceString12:
 18460 db "Digital screen",0
udhDeviceString13:
 18475 db "Data plug",0
udhDeviceString14:
 18485 db "Data socket",0
udhDeviceString15:
 18497 db "Keyboard",0
udhDeviceString16:
 18506 db "Oscilloscope",0
udhDeviceString17:
 18519 db "Sound emitter",0
udhDeviceString18:
 18533 db "Constant value",0
udhDeviceString19:
 18548 db "Data port",0
udhDeviceString20:
 18558 db "RAM",0
udhDeviceName:
 18562 db 18338,18343,18351
 18565 db 18364,18376,18388
 18568 db 18400,18412,18425
 18571 db 18429,18438,18445
 18574 db 18460,18475,18485
 18577 db 18497,18506,18519
 18580 db 18533,18548,18558
udhBusOffset:
 18583 alloc 1
udhQueryCallback:
 18584 alloc 8
udhQueryCallbackCount:
 18592 db 0
udhSetBusAddress:
// udhSetBusAddress(extOffset)
 18593 enter -0
__671:
 18596 rstack EAX,EBP:2
// udhBusOffset=extOffset
 18600 mov #18583,EAX
 18603 mov ECX,0
// udhQueryDevices(...)
 18606 call 18611
__670:
 18609 leave 
 18610 ret 
udhQueryDevices:
// udhQueryDevices()
 18611 enter 2
__673:
 18614 mov EAX,16
 18617 add EAX,#18583
// udhBusOffset[16]=32+8
 18620 mov #EAX,40
 18623 mov EAX,17
 18626 add EAX,#18583
// udhBusOffset[17]=1
 18629 mov #EAX,1
// init loop
 18632 sstack EBP:-1,0
__675:
 18637 rstack EAX,EBP:-1
 18641 mov EBX,#18592
 18644 sub EBX,EAX
 18646 fsgn EBX,EBX
// condition
 18648 max EBX,0
 18651 cmp 0,EBX
 18654 jz 18692
 18657 rstack EAX,EBP:-1
 18661 add EAX,18584
 18664 mov EBX,EAX
 18666 sstack EBP:-2,#EBX
 18670 mov ECX,0
 18673 rstack EAX,EBP:-2
// functionPtr(...)
 18677 call EAX
 18679 rstack EAX,EBP:-1
// loop step
 18683 inc EAX
 18685 sstack EBP:-1,EAX
 18689 jmp 18637
__674:
__672:
 18692 leave 
 18693 ret 
udhRegisterDriver:
// udhRegisterDriver(queryDeviceFunction)
 18694 enter -0
__677:
 18697 rstack EAX,EBP:2
 18701 mov EBX,#18592
 18704 add EBX,18584
// udhQueryCallback[udhQueryCallbackCount]=queryDeviceFunction
 18707 mov #EBX,EAX
__679:
 18709 mov EAX,8
 18712 sub EAX,#18592
 18715 fsgn EAX,EAX
 18717 max EAX,0
// if (udhQueryCallbackCount<8)
 18720 cmp 0,EAX
 18723 jge 18729
// udhQueryCallbackCount++
 18726 inc #18592
__678:
__680:
__676:
 18729 leave 
 18730 ret 
udhGetDeviceType:
// udhGetDeviceType(busIndex)
 18731 enter -0
__682:
 18734 rstack EAX,EBP:2
 18738 mov EBX,32
 18741 add EBX,EAX
 18743 add EBX,#18583
 18746 mov EAX,#EBX
 18748 leave 
 18749 ret 
__681:
 18750 leave 
 18751 ret 
udhGetDeviceOffset:
// udhGetDeviceOffset(busIndex)
 18752 enter -0
__684:
 18755 rstack EAX,EBP:2
 18759 mul EAX,2
 18762 mov EBX,EAX
 18764 add EBX,#18583
 18767 mov EAX,8
 18770 add EAX,#EBX
 18772 mov EBX,32
 18775 add EBX,EAX
 18777 mov EAX,#18583
 18780 add EAX,EBX
 18782 leave 
 18783 ret 
__683:
 18784 leave 
 18785 ret 
udhGetDeviceStart:
// udhGetDeviceStart(busIndex)
 18786 enter -0
__686:
 18789 rstack EAX,EBP:2
 18793 mul EAX,2
 18796 mov EBX,EAX
 18798 add EBX,#18583
 18801 mov EAX,#EBX
 18803 leave 
 18804 ret 
__685:
 18805 leave 
 18806 ret 
udhGetDeviceEnd:
// udhGetDeviceEnd(busIndex)
 18807 enter -0
__688:
 18810 rstack EAX,EBP:2
 18814 mul EAX,2
 18817 mov EBX,EAX
 18819 add EBX,1
 18822 add EBX,#18583
 18825 mov EAX,#EBX
 18827 leave 
 18828 ret 
__687:
 18829 leave 
 18830 ret 
udhSetDeviceStart:
// udhSetDeviceStart(busIndex,val)
 18831 enter -0
__690:
 18834 rstack EAX,EBP:3
 18838 rstack EBX,EBP:2
 18842 mul EBX,2
 18845 mov ECX,EBX
 18847 add ECX,#18583
// udhBusOffset[busIndex*2]=val
 18850 mov #ECX,EAX
__689:
 18852 leave 
 18853 ret 
udhSetDeviceEnd:
// udhSetDeviceEnd(busIndex,val)
 18854 enter -0
__692:
 18857 rstack EAX,EBP:3
 18861 rstack EBX,EBP:2
 18865 mul EBX,2
 18868 mov ECX,EBX
 18870 add ECX,1
 18873 add ECX,#18583
 18876 mov #ECX,EAX
 18878 mov EBX,#ECX
 18880 mov EAX,EBX
 18882 leave 
 18883 ret 
__691:
 18884 leave 
 18885 ret 
udhGetDeviceName:
// udhGetDeviceName(busIndex)
 18886 enter 1
__694:
 18889 rstack EAX,EBP:2
// udhGetDeviceType arg #1 (float busIndex)
 18893 push EAX
 18895 mov ECX,1
// udhGetDeviceType(...)
 18898 call 18731
 18901 add ESP,1
 18904 sstack EBP:-1,EAX
__696:
 18908 rstack EAX,EBP:-1
 18912 mov EBX,20
 18915 sub EBX,EAX
 18917 fsgn EBX,EBX
 18919 inc EBX
 18921 max EBX,0
 18924 rstack EAX,EBP:-1
 18928 mov ECX,0
 18931 sub ECX,EAX
 18933 neg ECX
 18935 fsgn ECX,ECX
 18937 inc ECX
 18939 max ECX,0
 18942 and ECX,EBX
// if ((deviceType>=0)&&(deviceType<=20))
 18944 cmp 0,ECX
 18947 jge 18966
 18950 rstack EAX,EBP:-1
 18954 add EAX,18562
 18957 mov EBX,EAX
 18959 mov EAX,#EBX
 18961 leave 
 18962 ret 
 18963 jmp 18976
__698:
__697:
__700:
 18966 mov EAX,1
 18969 add EAX,18562
 18972 mov EAX,#EAX
 18974 leave 
 18975 ret 
__699:
__695:
__693:
 18976 leave 
 18977 ret 
udhTypeToString:
// udhTypeToString(type)
 18978 enter -0
__702:
__704:
 18981 rstack EAX,EBP:2
 18985 mov EBX,20
 18988 sub EBX,EAX
 18990 fsgn EBX,EBX
 18992 inc EBX
 18994 max EBX,0
 18997 rstack EAX,EBP:2
 19001 mov ECX,0
 19004 sub ECX,EAX
 19006 neg ECX
 19008 fsgn ECX,ECX
 19010 inc ECX
 19012 max ECX,0
 19015 and ECX,EBX
// if ((type>=0)&&(type<=20))
 19017 cmp 0,ECX
 19020 jge 19039
 19023 rstack EAX,EBP:2
 19027 add EAX,18562
 19030 mov EBX,EAX
 19032 mov EAX,#EBX
 19034 leave 
 19035 ret 
 19036 jmp 19049
__706:
__705:
__708:
 19039 mov EAX,1
 19042 add EAX,18562
 19045 mov EAX,#EAX
 19047 leave 
 19048 ret 
__707:
__703:
__701:
 19049 leave 
 19050 ret 
udhSetDeviceOffsetSize:
// udhSetDeviceOffsetSize(busIndex,offst,size)
 19051 enter -0
__710:
 19054 rstack EAX,EBP:3
 19058 rstack EBX,EBP:2
 19062 mul EBX,2
 19065 mov ECX,EBX
 19067 add ECX,0
 19070 add ECX,#18583
// udhBusOffset[busIndex*2+0]=offst
 19073 mov #ECX,EAX
 19075 rstack EAX,EBP:4
 19079 add EAX,-1
 19082 mov EBX,EAX
 19084 rstack EAX,EBP:3
 19088 add EAX,EBX
 19090 mov EBX,EAX
 19092 rstack EAX,EBP:2
 19096 mul EAX,2
 19099 mov ECX,EAX
 19101 add ECX,1
 19104 add ECX,#18583
// udhBusOffset[busIndex*2+1]=offst+size-1
 19107 mov #ECX,EBX
__709:
 19109 leave 
 19110 ret 
udhGetNumDevices:
// udhGetNumDevices()
 19111 enter -0
__712:
 19114 mov EAX,8
 19117 leave 
 19118 ret 
__711:
 19119 leave 
 19120 ret 
udhGetDevices:
// udhGetDevices(type,maxCount,deviceList)
 19121 enter 3
__714:
 19124 rstack EAX,EBP:4
// devPtr=deviceList
 19128 sstack EBP:-2,EAX
// n=0
 19132 sstack EBP:-3,0
// init loop
 19137 sstack EBP:-1,0
__716:
 19142 rstack EAX,EBP:-1
 19146 mov EBX,8
 19149 sub EBX,EAX
 19151 fsgn EBX,EBX
// condition
 19153 max EBX,0
 19156 cmp 0,EBX
 19159 jz 19263
__718:
 19162 rstack EAX,EBP:-3
 19166 rstack EBX,EBP:3
 19170 sub EBX,EAX
 19172 mov EAX,EBX
 19174 fsgn EAX,EAX
 19176 max EAX,0
 19179 rstack EBX,EBP:-1
// udhGetDeviceType arg #1 (float busIndex)
 19183 push EBX
 19185 mov ECX,1
// udhGetDeviceType(...)
 19188 call 18731
 19191 add ESP,1
 19194 push EAX
 19196 mov EBX,EAX
 19198 pop EAX
 19200 rstack ECX,EBP:2
 19204 sub ECX,EBX
 19206 mov EBX,ECX
 19208 fabs EBX,EBX
 19210 fsgn EBX,EBX
 19212 lneg EBX
 19214 and EBX,EAX
// if ((udhGetDeviceType(i)==type)&&(n<maxCount))
 19216 cmp 0,EBX
 19219 jge 19250
 19222 rstack EAX,EBP:-3
// n++
 19226 inc EAX
 19228 sstack EBP:-3,EAX
 19232 rstack EAX,EBP:-1
 19236 rstack EBX,EBP:-2
 19240 mov ECX,EBX
 19242 inc EBX
 19244 sstack EBP:-2,EBX
// *devPtr++=i
 19248 mov #ECX,EAX
__719:
__717:
 19250 rstack EAX,EBP:-1
// loop step
 19254 inc EAX
 19256 sstack EBP:-1,EAX
 19260 jmp 19142
__715:
 19263 rstack EAX,EBP:-3
 19267 leave 
 19268 ret 
__713:
 19269 leave 
 19270 ret 
udhSetRecursive:
// udhSetRecursive(val)
 19271 enter -0
__721:
 19274 rstack EAX,EBP:2
 19278 mov EBX,20
 19281 add EBX,#18583
// udhBusOffset[20]=val
 19284 mov #EBX,EAX
__720:
 19286 leave 
 19287 ret 
udh_getSizeFromType:
// udh_getSizeFromType(type)
 19288 enter 1
__723:
 19291 sstack EBP:-1,4096
__725:
 19296 rstack EAX,EBP:2
 19300 mov EBX,15
 19303 sub EBX,EAX
 19305 fabs EBX,EBX
 19307 fsgn EBX,EBX
 19309 lneg EBX
// if (type==15)
 19311 cmp 0,EBX
 19314 jge 19322
// size=32+128
 19317 sstack EBP:-1,160
__726:
__724:
__728:
 19322 rstack EAX,EBP:2
 19326 mov EBX,20
 19329 sub EBX,EAX
 19331 fabs EBX,EBX
 19333 fsgn EBX,EBX
 19335 lneg EBX
// if (type==20)
 19337 cmp 0,EBX
 19340 jge 19348
// size=128*1024
 19343 sstack EBP:-1,131072
__729:
__727:
__731:
 19348 rstack EAX,EBP:2
 19352 mov EBX,8
 19355 sub EBX,EAX
 19357 fabs EBX,EBX
 19359 fsgn EBX,EBX
 19361 lneg EBX
// if (type==8)
 19363 cmp 0,EBX
 19366 jge 19374
// size=256*1024
 19369 sstack EBP:-1,262144
__732:
__730:
__734:
 19374 rstack EAX,EBP:2
 19378 mov EBX,11
 19381 sub EBX,EAX
 19383 fabs EBX,EBX
 19385 fsgn EBX,EBX
 19387 lneg EBX
// if (type==11)
 19389 cmp 0,EBX
 19392 jge 19400
// size=2048
 19395 sstack EBP:-1,2048
__735:
__733:
__737:
 19400 rstack EAX,EBP:2
 19404 mov EBX,12
 19407 sub EBX,EAX
 19409 fabs EBX,EBX
 19411 fsgn EBX,EBX
 19413 lneg EBX
// if (type==12)
 19415 cmp 0,EBX
 19418 jge 19426
// size=256*256
 19421 sstack EBP:-1,65536
__738:
__736:
__740:
 19426 rstack EAX,EBP:2
 19430 mov EBX,4
 19433 sub EBX,EAX
 19435 fabs EBX,EBX
 19437 fsgn EBX,EBX
 19439 lneg EBX
// if (type==4)
 19441 cmp 0,EBX
 19444 jge 19452
// size=65536
 19447 sstack EBP:-1,65536
__741:
__739:
 19452 rstack EAX,EBP:-1
 19456 leave 
 19457 ret 
__722:
 19458 leave 
 19459 ret 
typeof_EBcb_entry:
 19460 db "EBcbEntry",0
sizeof_EBcb_entry:
 19470 db 5
EBcb_entry_constructor:
// EBcb_entry_constructor(this)
 19471 enter 1
__743:
 19474 rstack EAX,EBP:2
 19478 add EAX,0
 19481 mov EBX,EAX
// this[0]=typeof_EBcb_entry
 19483 mov #EBX,19460
// init loop
 19486 sstack EBP:-1,1
__745:
 19491 rstack EAX,EBP:-1
 19495 mov EBX,5
 19498 sub EBX,EAX
 19500 fsgn EBX,EBX
// condition
 19502 max EBX,0
 19505 cmp 0,EBX
 19508 jz 19539
 19511 rstack EAX,EBP:-1
 19515 rstack EBX,EBP:2
 19519 add EBX,EAX
 19521 mov EAX,EBX
// this[I]=0
 19523 mov #EAX,0
 19526 rstack EAX,EBP:-1
// loop step
 19530 inc EAX
 19532 sstack EBP:-1,EAX
 19536 jmp 19491
__744:
__742:
 19539 leave 
 19540 ret 
EBcb_entry_set_type:
// EBcb_entry_set_type(this,val)
 19541 enter -0
__747:
 19544 rstack EAX,EBP:3
 19548 rstack EBX,EBP:2
 19552 add EBX,1
 19555 mov ECX,EBX
// this[1]=val
 19557 mov #ECX,EAX
__746:
 19559 leave 
 19560 ret 
EBcb_entry_set_size:
// EBcb_entry_set_size(this,val)
 19561 enter -0
__749:
 19564 rstack EAX,EBP:3
 19568 rstack EBX,EBP:2
 19572 add EBX,2
 19575 mov ECX,EBX
// this[2]=val
 19577 mov #ECX,EAX
__748:
 19579 leave 
 19580 ret 
EBcb_entry_set_addr:
// EBcb_entry_set_addr(this,val)
 19581 enter -0
__751:
 19584 rstack EAX,EBP:3
 19588 rstack EBX,EBP:2
 19592 add EBX,3
 19595 mov ECX,EBX
// this[3]=val
 19597 mov #ECX,EAX
__750:
 19599 leave 
 19600 ret 
EBcb_entry_set_user:
// EBcb_entry_set_user(this,val)
 19601 enter -0
__753:
 19604 rstack EAX,EBP:3
 19608 rstack EBX,EBP:2
 19612 add EBX,4
 19615 mov ECX,EBX
// this[4]=val
 19617 mov #ECX,EAX
__752:
 19619 leave 
 19620 ret 
EBcb_entry_get_type:
// EBcb_entry_get_type(this)
 19621 enter -0
__755:
 19624 rstack EAX,EBP:2
 19628 add EAX,1
 19631 mov EBX,EAX
 19633 mov EAX,#EBX
 19635 leave 
 19636 ret 
__754:
 19637 leave 
 19638 ret 
EBcb_entry_get_size:
// EBcb_entry_get_size(this)
 19639 enter -0
__757:
 19642 rstack EAX,EBP:2
 19646 add EAX,2
 19649 mov EBX,EAX
 19651 mov EAX,#EBX
 19653 leave 
 19654 ret 
__756:
 19655 leave 
 19656 ret 
EBcb_entry_get_addr:
// EBcb_entry_get_addr(this)
 19657 enter -0
__759:
 19660 rstack EAX,EBP:2
 19664 add EAX,3
 19667 mov EBX,EAX
 19669 mov EAX,#EBX
 19671 leave 
 19672 ret 
__758:
 19673 leave 
 19674 ret 
EBcb_entry_get_user:
// EBcb_entry_get_user(this)
 19675 enter -0
__761:
 19678 rstack EAX,EBP:2
 19682 add EAX,4
 19685 mov EBX,EAX
 19687 mov EAX,#EBX
 19689 leave 
 19690 ret 
__760:
 19691 leave 
 19692 ret 
typeof_EBcb:
 19693 db "EBctrlBlock",0
sizeof_EBcb:
 19705 db 46
EBcb_constructor:
// EBcb_constructor(this)
 19706 enter 2
__763:
 19709 rstack EAX,EBP:2
 19713 add EAX,0
 19716 mov EBX,EAX
// this[0]=typeof_EBcb
 19718 mov #EBX,19693
// init loop
 19721 sstack EBP:-1,0
__765:
 19726 rstack EAX,EBP:-1
 19730 mov EBX,9
 19733 sub EBX,EAX
 19735 fsgn EBX,EBX
// condition
 19737 max EBX,0
 19740 cmp 0,EBX
 19743 jz 19799
 19746 rstack EAX,EBP:-1
 19750 push EAX
 19752 rstack EAX,EBP:2
 19756 push EAX
 19758 mov ECX,2
// EBcb_get_entry(...)
 19761 call 19801
 19764 add ESP,2
 19767 sstack EBP:-2,EAX
 19771 rstack EAX,EBP:-2
// EBcb_entry_constructor arg #1 (float this)
 19775 push EAX
 19777 mov ECX,1
// EBcb_entry_constructor(...)
 19780 call 19471
 19783 add ESP,1
 19786 rstack EAX,EBP:-1
// loop step
 19790 inc EAX
 19792 sstack EBP:-1,EAX
 19796 jmp 19726
__764:
__762:
 19799 leave 
 19800 ret 
EBcb_get_entry:
// EBcb_get_entry(this,num)
 19801 enter 1
__767:
 19804 rstack EAX,EBP:3
 19808 mov EBX,#19470
 19811 mul EBX,EAX
 19813 add EBX,1
 19816 rstack EAX,EBP:2
 19820 add EAX,EBX
 19822 mov EBX,EAX
 19824 sstack EBP:-1,EBX
 19828 rstack EAX,EBP:-1
 19832 leave 
 19833 ret 
__766:
 19834 leave 
 19835 ret 
EBcb_populate:
// EBcb_populate(this)
 19836 enter 8
__769:
// EBcb_get_entry arg #2 (float num)
 19839 push 0
 19842 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 19846 push EAX
 19848 mov ECX,2
// EBcb_get_entry(...)
 19851 call 19801
 19854 add ESP,2
 19857 sstack EBP:-1,EAX
 19861 rstack EAX,EBP:-1
// EBcb_entry_get_addr arg #1 (float this)
 19865 push EAX
 19867 mov ECX,1
// EBcb_entry_get_addr(...)
 19870 call 19657
 19873 add ESP,1
 19876 sstack EBP:-2,EAX
 19880 rstack EAX,EBP:-2
// udhSetBusAddress arg #1 (float extOffset)
 19884 push EAX
 19886 mov ECX,1
// udhSetBusAddress(...)
 19889 call 18593
 19892 add ESP,1
// udhSetRecursive arg #1 (float val)
 19895 push 0
 19898 mov ECX,1
// udhSetRecursive(...)
 19901 call 19271
 19904 add ESP,1
 19907 mov ECX,0
// udhQueryDevices(...)
 19910 call 18611
// init loop
 19913 sstack EBP:-3,0
__771:
 19918 rstack EAX,EBP:-3
 19922 mov EBX,8
 19925 sub EBX,EAX
 19927 fsgn EBX,EBX
// condition
 19929 max EBX,0
 19932 cmp 0,EBX
 19935 jz 20132
 19938 rstack EAX,EBP:-3
 19942 add EAX,1
 19945 mov EBX,EAX
 19947 sstack EBP:-4,EBX
 19951 rstack EAX,EBP:-4
// EBcb_get_entry arg #2 (float num)
 19955 push EAX
 19957 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 19961 push EAX
 19963 mov ECX,2
// EBcb_get_entry(...)
 19966 call 19801
 19969 add ESP,2
// EBentry=EBcb_get_entry(this,entryNum)
 19972 sstack EBP:-1,EAX
 19976 rstack EAX,EBP:-3
// udhGetDeviceType arg #1 (float busIndex)
 19980 push EAX
 19982 mov ECX,1
// udhGetDeviceType(...)
 19985 call 18731
 19988 add ESP,1
 19991 sstack EBP:-5,EAX
 19995 rstack EAX,EBP:-3
// udhGetDeviceStart arg #1 (float busIndex)
 19999 push EAX
 20001 mov ECX,1
// udhGetDeviceStart(...)
 20004 call 18786
 20007 add ESP,1
 20010 sstack EBP:-6,EAX
 20014 rstack EAX,EBP:-3
// udhGetDeviceEnd arg #1 (float busIndex)
 20018 push EAX
 20020 mov ECX,1
// udhGetDeviceEnd(...)
 20023 call 18807
 20026 add ESP,1
 20029 sstack EBP:-7,EAX
 20033 rstack EAX,EBP:-6
 20037 neg EAX
 20039 mov EBX,EAX
 20041 add EBX,1
 20044 rstack EAX,EBP:-7
 20048 add EAX,EBX
 20050 mov EBX,EAX
 20052 sstack EBP:-8,EBX
 20056 rstack EAX,EBP:-5
// EBcb_entry_set_type arg #2 (float val)
 20060 push EAX
 20062 rstack EAX,EBP:-1
// EBcb_entry_set_type arg #1 (float this)
 20066 push EAX
 20068 mov ECX,2
// EBcb_entry_set_type(...)
 20071 call 19541
 20074 add ESP,2
 20077 rstack EAX,EBP:-8
// EBcb_entry_set_size arg #2 (float val)
 20081 push EAX
 20083 rstack EAX,EBP:-1
// EBcb_entry_set_size arg #1 (float this)
 20087 push EAX
 20089 mov ECX,2
// EBcb_entry_set_size(...)
 20092 call 19561
 20095 add ESP,2
 20098 rstack EAX,EBP:-6
// EBcb_entry_set_addr arg #2 (float val)
 20102 push EAX
 20104 rstack EAX,EBP:-1
// EBcb_entry_set_addr arg #1 (float this)
 20108 push EAX
 20110 mov ECX,2
// EBcb_entry_set_addr(...)
 20113 call 19581
 20116 add ESP,2
 20119 rstack EAX,EBP:-3
// loop step
 20123 inc EAX
 20125 sstack EBP:-3,EAX
 20129 jmp 19918
__770:
__768:
 20132 leave 
 20133 ret 
getSizeFromDevType:
// getSizeFromDevType(type)
 20134 enter -0
__773:
 20137 rstack EAX,EBP:2
// udh_getSizeFromType arg #1 (float type)
 20141 push EAX
 20143 mov ECX,1
// udh_getSizeFromType(...)
 20146 call 19288
 20149 add ESP,1
 20152 leave 
 20153 ret 
__772:
 20154 leave 
 20155 ret 
EBcb_autoconf:
// EBcb_autoconf(this)
 20156 enter 11
__775:
// EBcb_get_entry arg #2 (float num)
 20159 push 0
 20162 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20166 push EAX
 20168 mov ECX,2
// EBcb_get_entry(...)
 20171 call 19801
 20174 add ESP,2
 20177 sstack EBP:-1,EAX
 20181 rstack EAX,EBP:-1
// EBcb_entry_get_addr arg #1 (float this)
 20185 push EAX
 20187 mov ECX,1
// EBcb_entry_get_addr(...)
 20190 call 19657
 20193 add ESP,1
 20196 sstack EBP:-2,EAX
 20200 rstack EAX,EBP:-2
// udhSetBusAddress arg #1 (float extOffset)
 20204 push EAX
 20206 mov ECX,1
// udhSetBusAddress(...)
 20209 call 18593
 20212 add ESP,1
// udhSetRecursive arg #1 (float val)
 20215 push 0
 20218 mov ECX,1
// udhSetRecursive(...)
 20221 call 19271
 20224 add ESP,1
 20227 mov ECX,0
// udhQueryDevices(...)
 20230 call 18611
 20233 sstack EBP:-3,0
// init loop
 20238 sstack EBP:-4,0
__777:
 20243 rstack EAX,EBP:-4
 20247 mov EBX,8
 20250 sub EBX,EAX
 20252 fsgn EBX,EBX
// condition
 20254 max EBX,0
 20257 cmp 0,EBX
 20260 jz 20513
 20263 rstack EAX,EBP:-4
 20267 add EAX,1
 20270 mov EBX,EAX
 20272 sstack EBP:-5,EBX
 20276 rstack EAX,EBP:-5
// EBcb_get_entry arg #2 (float num)
 20280 push EAX
 20282 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20286 push EAX
 20288 mov ECX,2
// EBcb_get_entry(...)
 20291 call 19801
 20294 add ESP,2
 20297 sstack EBP:-6,EAX
 20301 rstack EAX,EBP:-4
// udhGetDeviceType arg #1 (float busIndex)
 20305 push EAX
 20307 mov ECX,1
// udhGetDeviceType(...)
 20310 call 18731
 20313 add ESP,1
 20316 sstack EBP:-7,EAX
 20320 rstack EAX,EBP:-3
 20324 sstack EBP:-8,EAX
 20328 rstack EAX,EBP:-7
// getSizeFromDevType arg #1 (float type)
 20332 push EAX
 20334 mov ECX,1
// getSizeFromDevType(...)
 20337 call 20134
 20340 add ESP,1
 20343 sstack EBP:-9,EAX
 20347 rstack EAX,EBP:-9
 20351 rstack EBX,EBP:-8
 20355 add EBX,EAX
 20357 mov EAX,EBX
 20359 sstack EBP:-10,EAX
 20363 rstack EAX,EBP:-8
// udhSetDeviceStart arg #2 (float val)
 20367 push EAX
 20369 rstack EAX,EBP:-4
// udhSetDeviceStart arg #1 (float busIndex)
 20373 push EAX
 20375 mov ECX,2
// udhSetDeviceStart(...)
 20378 call 18831
 20381 add ESP,2
 20384 rstack EAX,EBP:-10
// udhSetDeviceEnd arg #2 (float val)
 20388 push EAX
 20390 rstack EAX,EBP:-4
// udhSetDeviceEnd arg #1 (float busIndex)
 20394 push EAX
 20396 mov ECX,2
// udhSetDeviceEnd(...)
 20399 call 18854
 20402 add ESP,2
 20405 rstack EAX,EBP:-10
 20409 add EAX,1
 20412 mov EBX,EAX
// accumulatedAddr=devEnd+1
 20414 sstack EBP:-3,EBX
 20418 rstack EAX,EBP:-7
// EBcb_entry_set_type arg #2 (float val)
 20422 push EAX
 20424 rstack EAX,EBP:-6
// EBcb_entry_set_type arg #1 (float this)
 20428 push EAX
 20430 mov ECX,2
// EBcb_entry_set_type(...)
 20433 call 19541
 20436 add ESP,2
 20439 rstack EAX,EBP:-9
// EBcb_entry_set_size arg #2 (float val)
 20443 push EAX
 20445 rstack EAX,EBP:-6
// EBcb_entry_set_size arg #1 (float this)
 20449 push EAX
 20451 mov ECX,2
// EBcb_entry_set_size(...)
 20454 call 19561
 20457 add ESP,2
 20460 rstack EAX,EBP:-4
// udhGetDeviceOffset arg #1 (float busIndex)
 20464 push EAX
 20466 mov ECX,1
// udhGetDeviceOffset(...)
 20469 call 18752
 20472 add ESP,1
 20475 sstack EBP:-11,EAX
 20479 rstack EAX,EBP:-11
// EBcb_entry_set_addr arg #2 (float val)
 20483 push EAX
 20485 rstack EAX,EBP:-6
// EBcb_entry_set_addr arg #1 (float this)
 20489 push EAX
 20491 mov ECX,2
// EBcb_entry_set_addr(...)
 20494 call 19581
 20497 add ESP,2
 20500 rstack EAX,EBP:-4
// loop step
 20504 inc EAX
 20506 sstack EBP:-4,EAX
 20510 jmp 20243
__776:
__774:
 20513 leave 
 20514 ret 
EBcb_resize_dev:
// EBcb_resize_dev(this,num,size)
 20515 enter 10
__779:
// EBcb_get_entry arg #2 (float num)
 20518 push 0
 20521 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20525 push EAX
 20527 mov ECX,2
// EBcb_get_entry(...)
 20530 call 19801
 20533 add ESP,2
 20536 sstack EBP:-1,EAX
 20540 rstack EAX,EBP:-1
// EBcb_entry_get_addr arg #1 (float this)
 20544 push EAX
 20546 mov ECX,1
// EBcb_entry_get_addr(...)
 20549 call 19657
 20552 add ESP,1
 20555 sstack EBP:-2,EAX
 20559 rstack EAX,EBP:3
 20563 add EAX,1
 20566 mov EBX,EAX
// EBcb_get_entry arg #2 (float num)
 20568 push EBX
 20570 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20574 push EAX
 20576 mov ECX,2
// EBcb_get_entry(...)
 20579 call 19801
 20582 add ESP,2
 20585 sstack EBP:-3,EAX
 20589 rstack EAX,EBP:3
// udhGetDeviceStart arg #1 (float busIndex)
 20593 push EAX
 20595 mov ECX,1
// udhGetDeviceStart(...)
 20598 call 18786
 20601 add ESP,1
 20604 sstack EBP:-4,EAX
 20608 rstack EAX,EBP:4
 20612 sstack EBP:-5,EAX
 20616 rstack EAX,EBP:-5
 20620 rstack EBX,EBP:-4
 20624 add EBX,EAX
 20626 mov EAX,EBX
 20628 sstack EBP:-6,EAX
 20632 rstack EAX,EBP:-4
// udhSetDeviceStart arg #2 (float val)
 20636 push EAX
 20638 rstack EAX,EBP:3
// udhSetDeviceStart arg #1 (float busIndex)
 20642 push EAX
 20644 mov ECX,2
// udhSetDeviceStart(...)
 20647 call 18831
 20650 add ESP,2
 20653 rstack EAX,EBP:-6
// udhSetDeviceEnd arg #2 (float val)
 20657 push EAX
 20659 rstack EAX,EBP:3
// udhSetDeviceEnd arg #1 (float busIndex)
 20663 push EAX
 20665 mov ECX,2
// udhSetDeviceEnd(...)
 20668 call 18854
 20671 add ESP,2
 20674 rstack EAX,EBP:-6
 20678 add EAX,1
 20681 mov EBX,EAX
 20683 sstack EBP:-7,EBX
 20687 rstack EAX,EBP:3
 20691 add EAX,1
 20694 mov EBX,EAX
// init loop
 20696 sstack EBP:-8,EBX
__781:
 20700 rstack EAX,EBP:-8
 20704 mov EBX,8
 20707 sub EBX,EAX
 20709 fsgn EBX,EBX
// condition
 20711 max EBX,0
 20714 cmp 0,EBX
 20717 jz 20909
 20720 rstack EAX,EBP:-8
 20724 add EAX,1
 20727 mov EBX,EAX
 20729 sstack EBP:-9,EBX
 20733 rstack EAX,EBP:-9
// EBcb_get_entry arg #2 (float num)
 20737 push EAX
 20739 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20743 push EAX
 20745 mov ECX,2
// EBcb_get_entry(...)
 20748 call 19801
 20751 add ESP,2
// devEntry=EBcb_get_entry(this,entryNum)
 20754 sstack EBP:-3,EAX
 20758 rstack EAX,EBP:-7
// devStart=accumulatedAddr
 20762 sstack EBP:-4,EAX
 20766 rstack EAX,EBP:-3
// EBcb_entry_get_size arg #1 (float this)
 20770 push EAX
 20772 mov ECX,1
// EBcb_entry_get_size(...)
 20775 call 19639
 20778 add ESP,1
// devSize=EBcb_entry_get_size(devEntry)
 20781 sstack EBP:-5,EAX
 20785 rstack EAX,EBP:-5
 20789 rstack EBX,EBP:-4
 20793 add EBX,EAX
 20795 mov EAX,EBX
// devEnd=devStart+devSize
 20797 sstack EBP:-6,EAX
 20801 rstack EAX,EBP:-4
// udhSetDeviceStart arg #2 (float val)
 20805 push EAX
 20807 rstack EAX,EBP:-8
// udhSetDeviceStart arg #1 (float busIndex)
 20811 push EAX
 20813 mov ECX,2
// udhSetDeviceStart(...)
 20816 call 18831
 20819 add ESP,2
 20822 rstack EAX,EBP:-6
// udhSetDeviceEnd arg #2 (float val)
 20826 push EAX
 20828 rstack EAX,EBP:-8
// udhSetDeviceEnd arg #1 (float busIndex)
 20832 push EAX
 20834 mov ECX,2
// udhSetDeviceEnd(...)
 20837 call 18854
 20840 add ESP,2
 20843 rstack EAX,EBP:-8
// udhGetDeviceOffset arg #1 (float busIndex)
 20847 push EAX
 20849 mov ECX,1
// udhGetDeviceOffset(...)
 20852 call 18752
 20855 add ESP,1
 20858 sstack EBP:-10,EAX
 20862 rstack EAX,EBP:-10
// EBcb_entry_set_addr arg #2 (float val)
 20866 push EAX
 20868 rstack EAX,EBP:-3
// EBcb_entry_set_addr arg #1 (float this)
 20872 push EAX
 20874 mov ECX,2
// EBcb_entry_set_addr(...)
 20877 call 19581
 20880 add ESP,2
 20883 rstack EAX,EBP:-6
 20887 add EAX,1
 20890 mov EBX,EAX
// accumulatedAddr=devEnd+1
 20892 sstack EBP:-7,EBX
 20896 rstack EAX,EBP:-8
// loop step
 20900 inc EAX
 20902 sstack EBP:-8,EAX
 20906 jmp 20700
__780:
__778:
 20909 leave 
 20910 ret 
EBcb_device_bind:
// EBcb_device_bind(this,type,user)
 20911 enter 7
__783:
// init loop
 20914 sstack EBP:-1,0
__785:
 20919 rstack EAX,EBP:-1
 20923 mov EBX,8
 20926 sub EBX,EAX
 20928 fsgn EBX,EBX
// condition
 20930 max EBX,0
 20933 cmp 0,EBX
 20936 jz 21117
 20939 rstack EAX,EBP:-1
 20943 add EAX,1
 20946 mov EBX,EAX
 20948 sstack EBP:-2,EBX
 20952 rstack EAX,EBP:-2
// EBcb_get_entry arg #2 (float num)
 20956 push EAX
 20958 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 20962 push EAX
 20964 mov ECX,2
// EBcb_get_entry(...)
 20967 call 19801
 20970 add ESP,2
 20973 sstack EBP:-3,EAX
 20977 rstack EAX,EBP:-3
// EBcb_entry_get_type arg #1 (float this)
 20981 push EAX
 20983 mov ECX,1
// EBcb_entry_get_type(...)
 20986 call 19621
 20989 add ESP,1
 20992 sstack EBP:-4,EAX
 20996 rstack EAX,EBP:-3
// EBcb_entry_get_user arg #1 (float this)
 21000 push EAX
 21002 mov ECX,1
// EBcb_entry_get_user(...)
 21005 call 19675
 21008 add ESP,1
 21011 sstack EBP:-5,EAX
 21015 rstack EAX,EBP:-4
 21019 rstack EBX,EBP:3
 21023 sub EBX,EAX
 21025 mov EAX,EBX
 21027 fabs EAX,EAX
 21029 fsgn EAX,EAX
 21031 lneg EAX
 21033 sstack EBP:-6,EAX
 21037 rstack EAX,EBP:-5
 21041 mov EBX,0
 21044 sub EBX,EAX
 21046 fabs EBX,EBX
 21048 fsgn EBX,EBX
 21050 lneg EBX
 21052 sstack EBP:-7,EBX
__787:
 21056 rstack EAX,EBP:-7
 21060 rstack EBX,EBP:-6
 21064 and EBX,EAX
 21066 mov EAX,EBX
// if (bTypeOk&&bUserOk)
 21068 cmp 0,EAX
 21071 jge 21104
 21074 rstack EAX,EBP:4
// EBcb_entry_set_user arg #2 (float val)
 21078 push EAX
 21080 rstack EAX,EBP:-3
// EBcb_entry_set_user arg #1 (float this)
 21084 push EAX
 21086 mov ECX,2
// EBcb_entry_set_user(...)
 21089 call 19601
 21092 add ESP,2
 21095 rstack EAX,EBP:-2
 21099 leave 
 21100 ret 
 21101 jmp 21104
__789:
__788:
__791:
__790:
__786:
 21104 rstack EAX,EBP:-1
// loop step
 21108 inc EAX
 21110 sstack EBP:-1,EAX
 21114 jmp 20919
__784:
 21117 mov EAX,0
 21120 leave 
 21121 ret 
__782:
 21122 leave 
 21123 ret 
EBcb_device_bind_addr:
// EBcb_device_bind_addr(this,type,user,res)
 21124 enter 3
__793:
 21127 rstack EAX,EBP:4
// EBcb_device_bind arg #3 (float user)
 21131 push EAX
 21133 rstack EAX,EBP:3
// EBcb_device_bind arg #2 (float type)
 21137 push EAX
 21139 rstack EAX,EBP:2
// EBcb_device_bind arg #1 (float this)
 21143 push EAX
 21145 mov ECX,3
// EBcb_device_bind(...)
 21148 call 20911
 21151 add ESP,3
 21154 sstack EBP:-1,EAX
 21158 sstack EBP:-2,0
__795:
 21163 rstack EAX,EBP:-1
// if (entryNum)
 21167 cmp 0,EAX
 21170 jge 21217
 21173 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 21177 push EAX
 21179 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 21183 push EAX
 21185 mov ECX,2
// EBcb_get_entry(...)
 21188 call 19801
 21191 add ESP,2
 21194 sstack EBP:-3,EAX
 21198 rstack EAX,EBP:-3
// EBcb_entry_get_addr arg #1 (float this)
 21202 push EAX
 21204 mov ECX,1
// EBcb_entry_get_addr(...)
 21207 call 19657
 21210 add ESP,1
// addr=EBcb_entry_get_addr(devEntry)
 21213 sstack EBP:-2,EAX
__796:
__794:
 21217 rstack EAX,EBP:-2
 21221 rstack EBX,EBP:5
// *res=addr
 21225 mov #EBX,EAX
 21227 rstack EAX,EBP:-2
 21231 leave 
 21232 ret 
__792:
 21233 leave 
 21234 ret 
EBcb_print:
// EBcb_print(this)
 21235 enter 7
__798:
// init loop
 21238 sstack EBP:-1,0
__800:
 21243 rstack EAX,EBP:-1
 21247 mov EBX,9
 21250 sub EBX,EAX
 21252 fsgn EBX,EBX
// condition
 21254 max EBX,0
 21257 cmp 0,EBX
 21260 jz 21396
 21263 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 21267 push EAX
 21269 rstack EAX,EBP:2
// EBcb_get_entry arg #1 (float this)
 21273 push EAX
 21275 mov ECX,2
// EBcb_get_entry(...)
 21278 call 19801
 21281 add ESP,2
 21284 sstack EBP:-2,EAX
 21288 rstack EAX,EBP:-2
// EBcb_entry_get_type arg #1 (float this)
 21292 push EAX
 21294 mov ECX,1
// EBcb_entry_get_type(...)
 21297 call 19621
 21300 add ESP,1
 21303 sstack EBP:-3,EAX
 21307 rstack EAX,EBP:-3
// udhTypeToString arg #1 (float type)
 21311 push EAX
 21313 mov ECX,1
// udhTypeToString(...)
 21316 call 18978
 21319 add ESP,1
 21322 sstack EBP:-4,EAX
 21326 rstack EAX,EBP:-2
// EBcb_entry_get_size arg #1 (float this)
 21330 push EAX
 21332 mov ECX,1
// EBcb_entry_get_size(...)
 21335 call 19639
 21338 add ESP,1
 21341 sstack EBP:-5,EAX
 21345 rstack EAX,EBP:-2
// EBcb_entry_get_addr arg #1 (float this)
 21349 push EAX
 21351 mov ECX,1
// EBcb_entry_get_addr(...)
 21354 call 19657
 21357 add ESP,1
 21360 sstack EBP:-6,EAX
 21364 rstack EAX,EBP:-2
// EBcb_entry_get_user arg #1 (float this)
 21368 push EAX
 21370 mov ECX,1
// EBcb_entry_get_user(...)
 21373 call 19675
 21376 add ESP,1
 21379 sstack EBP:-7,EAX
 21383 rstack EAX,EBP:-1
// loop step
 21387 inc EAX
 21389 sstack EBP:-1,EAX
 21393 jmp 21243
__799:
__797:
 21396 leave 
 21397 ret 
libmarker6:
 21398 db 0
ioRead:
// ioRead(pos)
 21399 enter 1
__802:
// assert_arity arg #2 (float num_args)
 21402 push 1
// assert_arity arg #1 (float ecx_here)
 21405 push ECX
 21407 mov ECX,2
// assert_arity(...)
 21410 call 10245
 21413 add ESP,2
 21416 rstack EAX,EBP:2
 21420 rstack EBX,EBP:-1
 21424 in EBX,EAX
 21426 sstack EBP:-1,EBX
 21430 rstack EAX,EBP:-1
 21434 leave 
 21435 ret 
__801:
 21436 leave 
 21437 ret 
ioReadBuff:
// ioReadBuff(dest,src,size)
 21438 enter 1
__804:
// assert_arity arg #2 (float num_args)
 21441 push 3
// assert_arity arg #1 (float ecx_here)
 21444 push ECX
 21446 mov ECX,2
// assert_arity(...)
 21449 call 10245
 21452 add ESP,2
// init loop
 21455 sstack EBP:-1,0
__806:
 21460 rstack EAX,EBP:-1
 21464 rstack EBX,EBP:4
 21468 sub EBX,EAX
 21470 mov EAX,EBX
 21472 fsgn EAX,EAX
// condition
 21474 max EAX,0
 21477 cmp 0,EAX
 21480 jz 21533
 21483 rstack EAX,EBP:3
 21487 mov EBX,EAX
 21489 inc EAX
 21491 sstack EBP:3,EAX
// ioRead arg #1 (float pos)
 21495 push EBX
 21497 mov ECX,1
// ioRead(...)
 21500 call 21399
 21503 add ESP,1
 21506 rstack EBX,EBP:2
 21510 mov ECX,EBX
 21512 inc EBX
 21514 sstack EBP:2,EBX
// *dest++=ioRead(src++)
 21518 mov #ECX,EAX
 21520 rstack EAX,EBP:-1
// loop step
 21524 inc EAX
 21526 sstack EBP:-1,EAX
 21530 jmp 21460
__805:
__803:
 21533 leave 
 21534 ret 
ioWrite:
// ioWrite(pos,val)
 21535 enter -0
__808:
// assert_arity arg #2 (float num_args)
 21538 push 2
// assert_arity arg #1 (float ecx_here)
 21541 push ECX
 21543 mov ECX,2
// assert_arity(...)
 21546 call 10245
 21549 add ESP,2
 21552 rstack EAX,EBP:3
 21556 rstack EBX,EBP:2
 21560 out EBX,EAX
 21562 sstack EBP:2,EBX
__807:
 21566 leave 
 21567 ret 
ioWriteBuff:
// ioWriteBuff(dest,src,size)
 21568 enter 1
__810:
// assert_arity arg #2 (float num_args)
 21571 push 3
// assert_arity arg #1 (float ecx_here)
 21574 push ECX
 21576 mov ECX,2
// assert_arity(...)
 21579 call 10245
 21582 add ESP,2
// init loop
 21585 sstack EBP:-1,0
__812:
 21590 rstack EAX,EBP:-1
 21594 rstack EBX,EBP:4
 21598 sub EBX,EAX
 21600 mov EAX,EBX
 21602 fsgn EAX,EAX
// condition
 21604 max EAX,0
 21607 cmp 0,EAX
 21610 jz 21663
 21613 rstack EAX,EBP:3
 21617 mov EBX,EAX
 21619 inc EAX
 21621 sstack EBP:3,EAX
// ioWrite arg #2 (float val)
 21625 push #EBX
 21627 rstack EAX,EBP:2
 21631 mov EBX,EAX
 21633 inc EAX
 21635 sstack EBP:2,EAX
// ioWrite arg #1 (float pos)
 21639 push EBX
 21641 mov ECX,2
// ioWrite(...)
 21644 call 21535
 21647 add ESP,2
 21650 rstack EAX,EBP:-1
// loop step
 21654 inc EAX
 21656 sstack EBP:-1,EAX
 21660 jmp 21590
__811:
__809:
 21663 leave 
 21664 ret 
iocpy:
// iocpy(dest,src,num)
 21665 enter 3
__814:
// assert_arity arg #2 (float num_args)
 21668 push 3
// assert_arity arg #1 (float ecx_here)
 21671 push ECX
 21673 mov ECX,2
// assert_arity(...)
 21676 call 10245
 21679 add ESP,2
// init loop
 21682 sstack EBP:-1,0
__816:
 21687 rstack EAX,EBP:-1
 21691 rstack EBX,EBP:4
 21695 sub EBX,EAX
 21697 mov EAX,EBX
 21699 fsgn EAX,EAX
// condition
 21701 max EAX,0
 21704 cmp 0,EAX
 21707 jz 21769
 21710 rstack EAX,EBP:-1
 21714 rstack EBX,EBP:3
 21718 add EBX,EAX
 21720 mov EAX,EBX
 21722 sstack EBP:-2,#EAX
 21726 rstack EAX,EBP:-1
 21730 rstack EBX,EBP:2
 21734 add EBX,EAX
 21736 mov EAX,EBX
 21738 sstack EBP:-3,EAX
 21742 rstack EAX,EBP:-2
 21746 rstack EBX,EBP:-3
 21750 out EBX,EAX
 21752 sstack EBP:-3,EBX
 21756 rstack EAX,EBP:-1
// loop step
 21760 inc EAX
 21762 sstack EBP:-1,EAX
 21766 jmp 21687
__815:
__813:
 21769 leave 
 21770 ret 
libmarker7:
 21771 db 0
printf:
// printf(format)
 21772 enter 13
__818:
 21775 mov EAX,SS:EBP
 21778 add EAX,2
 21781 push EAX
 21783 mov ECX,1
// va_start(...)
 21786 call 10002
 21789 add ESP,1
 21792 sstack EBP:-1,EAX
 21796 sstack EBP:-2,0
 21801 sstack EBP:-3,0
 21806 sstack EBP:-4,0
 21811 sstack EBP:-5,0
 21816 sstack EBP:-6,0
 21821 sstack EBP:-7,0
 21826 sstack EBP:-8,0
 21831 sstack EBP:-9,999
 21836 sstack EBP:-10,999
 21841 sstack EBP:-11,222
 21846 sstack EBP:-12,0
 21851 rstack EAX,EBP:-2
 21855 rstack EBX,EBP:2
 21859 add EBX,EAX
 21861 mov EAX,EBX
// C=format[I]
 21863 sstack EBP:-3,#EAX
__820:
 21867 rstack EAX,EBP:-3
 21871 mov EBX,0
 21874 sub EBX,EAX
 21876 fabs EBX,EBX
 21878 fsgn EBX,EBX
// if (C!=0
 21880 cmp 0,EBX
 21883 jz 23740
__822:
 21886 rstack EAX,EBP:-3
 21890 mov EBX,37
 21893 sub EBX,EAX
 21895 fabs EBX,EBX
 21897 fsgn EBX,EBX
 21899 lneg EBX
// if (C=='%')
 21901 cmp 0,EBX
 21904 jge 22900
 21907 rstack EAX,EBP:-2
 21911 add EAX,1
 21914 mov EBX,EAX
 21916 rstack EAX,EBP:2
 21920 add EAX,EBX
 21922 mov EBX,EAX
// S=format[I+1]
 21924 sstack EBP:-4,#EBX
__825:
 21928 rstack EAX,EBP:-4
 21932 mov EBX,100
 21935 sub EBX,EAX
 21937 fabs EBX,EBX
 21939 fsgn EBX,EBX
 21941 lneg EBX
// if (S=='d')
 21943 cmp 0,EBX
 21946 jge 22023
 21949 mov EAX,SS:EBP
 21952 add EAX,-1
 21955 push EAX
 21957 mov ECX,1
// va_next(...)
 21960 call 10016
 21963 add ESP,1
// A=va_next(&va)
 21966 sstack EBP:-5,EAX
 21970 rstack EAX,EBP:-5
// num2str arg #1 (float num)
 21974 push EAX
 21976 mov ECX,1
// num2str(...)
 21979 call 13802
 21982 add ESP,1
 21985 sstack EBP:-13,EAX
 21989 rstack EAX,EBP:-9
// Print arg #2 (float col0)
 21993 push EAX
 21995 rstack EAX,EBP:-13
// Print arg #1 (char str)
 21999 push EAX
 22001 mov ECX,2
// Print(...)
 22004 call 17244
 22007 add ESP,2
 22010 rstack EAX,EBP:-2
 22014 add EAX,2
 22017 mov EBX,EAX
// I=I+2
 22019 sstack EBP:-2,EBX
__826:
__824:
__828:
 22023 rstack EAX,EBP:-4
 22027 mov EBX,99
 22030 sub EBX,EAX
 22032 fabs EBX,EBX
 22034 fsgn EBX,EBX
 22036 lneg EBX
// if (S=='c')
 22038 cmp 0,EBX
 22041 jge 22552
 22044 mov EAX,SS:EBP
 22047 add EAX,-1
 22050 push EAX
 22052 mov ECX,1
// va_next(...)
 22055 call 10016
 22058 add ESP,1
// A=va_next(&va)
 22061 sstack EBP:-5,EAX
 22065 rstack EAX,EBP:-5
// A2=A
 22069 sstack EBP:-6,EAX
 22073 rstack EAX,EBP:-9
// pcolor2=pcolor
 22077 sstack EBP:-10,EAX
__831:
 22081 rstack EAX,EBP:-12
 22085 mov EBX,2
 22088 sub EBX,EAX
 22090 fabs EBX,EBX
 22092 fsgn EBX,EBX
 22094 lneg EBX
// if (escmode==2)
 22096 cmp 0,EBX
 22099 jge 22159
__834:
 22102 rstack EAX,EBP:-5
// isPrint arg #1 (char C)
 22106 push EAX
 22108 mov ECX,1
// isPrint(...)
 22111 call 15309
 22114 add ESP,1
 22117 mov EBX,0
 22120 sub EBX,EAX
 22122 fabs EBX,EBX
 22124 fsgn EBX,EBX
 22126 lneg EBX
// if (isPrint(A)==0)
 22128 cmp 0,EBX
 22131 jge 22159
// A2='.'
 22134 sstack EBP:-6,46
 22139 rstack EAX,EBP:-11
 22143 neg EAX
 22145 mov EBX,EAX
 22147 rstack EAX,EBP:-9
 22151 add EAX,EBX
 22153 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22155 sstack EBP:-10,EBX
__835:
__833:
__832:
__830:
__837:
 22159 rstack EAX,EBP:-12
 22163 mov EBX,1
 22166 sub EBX,EAX
 22168 fabs EBX,EBX
 22170 fsgn EBX,EBX
 22172 lneg EBX
// if (escmode==1)
 22174 cmp 0,EBX
 22177 jge 22508
__840:
 22180 rstack EAX,EBP:-5
// isPrint arg #1 (char C)
 22184 push EAX
 22186 mov ECX,1
// isPrint(...)
 22189 call 15309
 22192 add ESP,1
 22195 mov EBX,0
 22198 sub EBX,EAX
 22200 fabs EBX,EBX
 22202 fsgn EBX,EBX
 22204 lneg EBX
// if (isPrint(A)==0)
 22206 cmp 0,EBX
 22209 jge 22232
 22212 rstack EAX,EBP:-11
 22216 neg EAX
 22218 mov EBX,EAX
 22220 rstack EAX,EBP:-9
 22224 add EAX,EBX
 22226 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22228 sstack EBP:-10,EBX
__841:
__839:
__843:
 22232 rstack EAX,EBP:-5
 22236 mov EBX,7
 22239 sub EBX,EAX
 22241 fabs EBX,EBX
 22243 fsgn EBX,EBX
 22245 lneg EBX
// if (A=='\7')
 22247 cmp 0,EBX
 22250 jge 22278
// A2='a'
 22253 sstack EBP:-6,97
 22258 rstack EAX,EBP:-11
 22262 neg EAX
 22264 mov EBX,EAX
 22266 rstack EAX,EBP:-9
 22270 add EAX,EBX
 22272 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22274 sstack EBP:-10,EBX
__844:
__842:
__846:
 22278 rstack EAX,EBP:-5
 22282 mov EBX,8
 22285 sub EBX,EAX
 22287 fabs EBX,EBX
 22289 fsgn EBX,EBX
 22291 lneg EBX
// if (A=='\8')
 22293 cmp 0,EBX
 22296 jge 22324
// A2='b'
 22299 sstack EBP:-6,98
 22304 rstack EAX,EBP:-11
 22308 neg EAX
 22310 mov EBX,EAX
 22312 rstack EAX,EBP:-9
 22316 add EAX,EBX
 22318 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22320 sstack EBP:-10,EBX
__847:
__845:
__849:
 22324 rstack EAX,EBP:-5
 22328 mov EBX,10
 22331 sub EBX,EAX
 22333 fabs EBX,EBX
 22335 fsgn EBX,EBX
 22337 lneg EBX
// if (A=='\10')
 22339 cmp 0,EBX
 22342 jge 22370
// A2='n'
 22345 sstack EBP:-6,110
 22350 rstack EAX,EBP:-11
 22354 neg EAX
 22356 mov EBX,EAX
 22358 rstack EAX,EBP:-9
 22362 add EAX,EBX
 22364 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22366 sstack EBP:-10,EBX
__850:
__848:
__852:
 22370 rstack EAX,EBP:-5
 22374 mov EBX,13
 22377 sub EBX,EAX
 22379 fabs EBX,EBX
 22381 fsgn EBX,EBX
 22383 lneg EBX
// if (A=='\13')
 22385 cmp 0,EBX
 22388 jge 22416
// A2='r'
 22391 sstack EBP:-6,114
 22396 rstack EAX,EBP:-11
 22400 neg EAX
 22402 mov EBX,EAX
 22404 rstack EAX,EBP:-9
 22408 add EAX,EBX
 22410 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22412 sstack EBP:-10,EBX
__853:
__851:
__855:
 22416 rstack EAX,EBP:-5
 22420 mov EBX,9
 22423 sub EBX,EAX
 22425 fabs EBX,EBX
 22427 fsgn EBX,EBX
 22429 lneg EBX
// if (A=='\9')
 22431 cmp 0,EBX
 22434 jge 22462
// A2='t'
 22437 sstack EBP:-6,116
 22442 rstack EAX,EBP:-11
 22446 neg EAX
 22448 mov EBX,EAX
 22450 rstack EAX,EBP:-9
 22454 add EAX,EBX
 22456 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22458 sstack EBP:-10,EBX
__856:
__854:
__858:
 22462 rstack EAX,EBP:-5
 22466 mov EBX,0
 22469 sub EBX,EAX
 22471 fabs EBX,EBX
 22473 fsgn EBX,EBX
 22475 lneg EBX
// if (A=='\0')
 22477 cmp 0,EBX
 22480 jge 22508
// A2='0'
 22483 sstack EBP:-6,48
 22488 rstack EAX,EBP:-11
 22492 neg EAX
 22494 mov EBX,EAX
 22496 rstack EAX,EBP:-9
 22500 add EAX,EBX
 22502 mov EBX,EAX
// pcolor2=pcolor-pdarken
 22504 sstack EBP:-10,EBX
__859:
__857:
__838:
__836:
 22508 rstack EAX,EBP:-6
// c2=A2
 22512 sstack EBP:-8,EAX
 22516 rstack EAX,EBP:-10
// Print arg #2 (float col0)
 22520 push EAX
 22522 mov EAX,SS:EBP
 22525 add EAX,-8
// Print arg #1 (char str)
 22528 push EAX
 22530 mov ECX,2
// Print(...)
 22533 call 17244
 22536 add ESP,2
 22539 rstack EAX,EBP:-2
 22543 add EAX,2
 22546 mov EBX,EAX
// I=I+2
 22548 sstack EBP:-2,EBX
__829:
__827:
__861:
 22552 rstack EAX,EBP:-4
 22556 mov EBX,115
 22559 sub EBX,EAX
 22561 fabs EBX,EBX
 22563 fsgn EBX,EBX
 22565 lneg EBX
// if (S=='s')
 22567 cmp 0,EBX
 22570 jge 22647
 22573 mov EAX,SS:EBP
 22576 add EAX,-1
 22579 push EAX
 22581 mov ECX,1
// va_next(...)
 22584 call 10016
 22587 add ESP,1
// A=va_next(&va)
 22590 sstack EBP:-5,EAX
__864:
 22594 rstack EAX,EBP:-5
 22598 lneg EAX
 22600 mov EBX,EAX
// if (!A)
 22602 cmp 0,EBX
 22605 jge 22613
// A="<null>"
 22608 sstack EBP:-5,23748
__865:
__863:
 22613 rstack EAX,EBP:-9
// Print arg #2 (float col0)
 22617 push EAX
 22619 rstack EAX,EBP:-5
// Print arg #1 (char str)
 22623 push EAX
 22625 mov ECX,2
// Print(...)
 22628 call 17244
 22631 add ESP,2
 22634 rstack EAX,EBP:-2
 22638 add EAX,2
 22641 mov EBX,EAX
// I=I+2
 22643 sstack EBP:-2,EBX
__862:
__860:
__868:
 22647 rstack EAX,EBP:-4
 22651 mov EBX,109
 22654 sub EBX,EAX
 22656 fabs EBX,EBX
 22658 fsgn EBX,EBX
 22660 lneg EBX
// if (S=='m')
 22662 cmp 0,EBX
 22665 jge 22710
 22668 mov EAX,SS:EBP
 22671 add EAX,-1
 22674 push EAX
 22676 mov ECX,1
// va_next(...)
 22679 call 10016
 22682 add ESP,1
// A=va_next(&va)
 22685 sstack EBP:-5,EAX
 22689 rstack EAX,EBP:-5
// pcolor=A
 22693 sstack EBP:-9,EAX
 22697 rstack EAX,EBP:-2
 22701 add EAX,2
 22704 mov EBX,EAX
// I=I+2
 22706 sstack EBP:-2,EBX
__869:
__867:
__871:
 22710 rstack EAX,EBP:-4
 22714 mov EBX,101
 22717 sub EBX,EAX
 22719 fabs EBX,EBX
 22721 fsgn EBX,EBX
 22723 lneg EBX
// if (S=='e')
 22725 cmp 0,EBX
 22728 jge 22773
 22731 mov EAX,SS:EBP
 22734 add EAX,-1
 22737 push EAX
 22739 mov ECX,1
// va_next(...)
 22742 call 10016
 22745 add ESP,1
// A=va_next(&va)
 22748 sstack EBP:-5,EAX
 22752 rstack EAX,EBP:-5
// escmode=A
 22756 sstack EBP:-12,EAX
 22760 rstack EAX,EBP:-2
 22764 add EAX,2
 22767 mov EBX,EAX
// I=I+2
 22769 sstack EBP:-2,EBX
__872:
__870:
__874:
 22773 rstack EAX,EBP:-4
 22777 mov EBX,120
 22780 sub EBX,EAX
 22782 fabs EBX,EBX
 22784 fsgn EBX,EBX
 22786 lneg EBX
// if (S=='x')
 22788 cmp 0,EBX
 22791 jge 22835
 22794 mov EAX,SS:EBP
 22797 add EAX,-1
 22800 push EAX
 22802 mov ECX,1
// va_next(...)
 22805 call 10016
 22808 add ESP,1
// A=va_next(&va)
 22811 sstack EBP:-5,EAX
 22815 rstack EAX,EBP:-5
// PrintScrX=A
 22819 mov #66679,EAX
 22822 rstack EAX,EBP:-2
 22826 add EAX,2
 22829 mov EBX,EAX
// I=I+2
 22831 sstack EBP:-2,EBX
__875:
__873:
__877:
 22835 rstack EAX,EBP:-4
 22839 mov EBX,121
 22842 sub EBX,EAX
 22844 fabs EBX,EBX
 22846 fsgn EBX,EBX
 22848 lneg EBX
// if (S=='y')
 22850 cmp 0,EBX
 22853 jge 22897
 22856 mov EAX,SS:EBP
 22859 add EAX,-1
 22862 push EAX
 22864 mov ECX,1
// va_next(...)
 22867 call 10016
 22870 add ESP,1
// A=va_next(&va)
 22873 sstack EBP:-5,EAX
 22877 rstack EAX,EBP:-5
// PrintScrY=A
 22881 mov #66680,EAX
 22884 rstack EAX,EBP:-2
 22888 add EAX,2
 22891 mov EBX,EAX
// I=I+2
 22893 sstack EBP:-2,EBX
__878:
__876:
 22897 jmp 23721
__879:
__823:
__881:
__884:
 22900 rstack EAX,EBP:-3
 22904 mov EBX,23747
 22907 sub EBX,EAX
 22909 fabs EBX,EBX
 22911 fsgn EBX,EBX
 22913 lneg EBX
// if (C=="")
 22915 cmp 0,EBX
 22918 jge 23242
 22921 rstack EAX,EBP:-2
 22925 add EAX,1
 22928 mov EBX,EAX
 22930 rstack EAX,EBP:2
 22934 add EAX,EBX
 22936 mov EBX,EAX
// S=format[I+1]
 22938 sstack EBP:-4,#EBX
__887:
 22942 rstack EAX,EBP:-4
 22946 mov EBX,97
 22949 sub EBX,EAX
 22951 fabs EBX,EBX
 22953 fsgn EBX,EBX
 22955 lneg EBX
// if (S=='a')
 22957 cmp 0,EBX
 22960 jge 22975
// PrintChar arg #1 (float C)
 22963 push 7
 22966 mov ECX,1
// PrintChar(...)
 22969 call 17609
 22972 add ESP,1
__888:
__886:
__890:
 22975 rstack EAX,EBP:-4
 22979 mov EBX,98
 22982 sub EBX,EAX
 22984 fabs EBX,EBX
 22986 fsgn EBX,EBX
 22988 lneg EBX
// if (S=='b')
 22990 cmp 0,EBX
 22993 jge 23008
// PrintChar arg #1 (float C)
 22996 push 8
 22999 mov ECX,1
// PrintChar(...)
 23002 call 17609
 23005 add ESP,1
__891:
__889:
__893:
 23008 rstack EAX,EBP:-4
 23012 mov EBX,110
 23015 sub EBX,EAX
 23017 fabs EBX,EBX
 23019 fsgn EBX,EBX
 23021 lneg EBX
// if (S=='n')
 23023 cmp 0,EBX
 23026 jge 23041
// PrintChar arg #1 (float C)
 23029 push 10
 23032 mov ECX,1
// PrintChar(...)
 23035 call 17609
 23038 add ESP,1
__894:
__892:
__896:
 23041 rstack EAX,EBP:-4
 23045 mov EBX,114
 23048 sub EBX,EAX
 23050 fabs EBX,EBX
 23052 fsgn EBX,EBX
 23054 lneg EBX
// if (S=='r')
 23056 cmp 0,EBX
 23059 jge 23074
// PrintChar arg #1 (float C)
 23062 push 13
 23065 mov ECX,1
// PrintChar(...)
 23068 call 17609
 23071 add ESP,1
__897:
__895:
__899:
 23074 rstack EAX,EBP:-4
 23078 mov EBX,116
 23081 sub EBX,EAX
 23083 fabs EBX,EBX
 23085 fsgn EBX,EBX
 23087 lneg EBX
// if (S=='t')
 23089 cmp 0,EBX
 23092 jge 23107
// PrintChar arg #1 (float C)
 23095 push 9
 23098 mov ECX,1
// PrintChar(...)
 23101 call 17609
 23104 add ESP,1
__900:
__898:
__902:
 23107 rstack EAX,EBP:-4
 23111 mov EBX,23747
 23114 sub EBX,EAX
 23116 fabs EBX,EBX
 23118 fsgn EBX,EBX
 23120 lneg EBX
// if (S=="")
 23122 cmp 0,EBX
 23125 jge 23140
// PrintChar arg #1 (float C)
 23128 push 23747
 23131 mov ECX,1
// PrintChar(...)
 23134 call 17609
 23137 add ESP,1
__903:
__901:
__905:
 23140 rstack EAX,EBP:-4
 23144 mov EBX,39
 23147 sub EBX,EAX
 23149 fabs EBX,EBX
 23151 fsgn EBX,EBX
 23153 lneg EBX
// if (S==''')
 23155 cmp 0,EBX
 23158 jge 23173
// PrintChar arg #1 (float C)
 23161 push 39
 23164 mov ECX,1
// PrintChar(...)
 23167 call 17609
 23170 add ESP,1
__906:
__904:
__908:
 23173 rstack EAX,EBP:-4
 23177 mov EBX,34
 23180 sub EBX,EAX
 23182 fabs EBX,EBX
 23184 fsgn EBX,EBX
 23186 lneg EBX
// if (S=='"')
 23188 cmp 0,EBX
 23191 jge 23206
// PrintChar arg #1 (float C)
 23194 push 34
 23197 mov ECX,1
// PrintChar(...)
 23200 call 17609
 23203 add ESP,1
__909:
__907:
__911:
 23206 rstack EAX,EBP:-4
 23210 mov EBX,48
 23213 sub EBX,EAX
 23215 fabs EBX,EBX
 23217 fsgn EBX,EBX
 23219 lneg EBX
// if (S=='0')
 23221 cmp 0,EBX
 23224 jge 23239
// PrintChar arg #1 (float C)
 23227 push 0
 23230 mov ECX,1
// PrintChar(...)
 23233 call 17609
 23236 add ESP,1
__912:
__910:
 23239 jmp 23721
__913:
__885:
__915:
 23242 rstack EAX,EBP:-9
// pcolor2=pcolor
 23246 sstack EBP:-10,EAX
__917:
 23250 rstack EAX,EBP:-12
 23254 mov EBX,2
 23257 sub EBX,EAX
 23259 fabs EBX,EBX
 23261 fsgn EBX,EBX
 23263 lneg EBX
// if (escmode==2)
 23265 cmp 0,EBX
 23268 jge 23328
__920:
 23271 rstack EAX,EBP:-3
// isPrint arg #1 (char C)
 23275 push EAX
 23277 mov ECX,1
// isPrint(...)
 23280 call 15309
 23283 add ESP,1
 23286 mov EBX,0
 23289 sub EBX,EAX
 23291 fabs EBX,EBX
 23293 fsgn EBX,EBX
 23295 lneg EBX
// if (isPrint(C)==0)
 23297 cmp 0,EBX
 23300 jge 23328
// C='.'
 23303 sstack EBP:-3,46
 23308 rstack EAX,EBP:-11
 23312 neg EAX
 23314 mov EBX,EAX
 23316 rstack EAX,EBP:-9
 23320 add EAX,EBX
 23322 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23324 sstack EBP:-10,EBX
__921:
__919:
__918:
__916:
__923:
 23328 rstack EAX,EBP:-12
 23332 mov EBX,1
 23335 sub EBX,EAX
 23337 fabs EBX,EBX
 23339 fsgn EBX,EBX
 23341 lneg EBX
// if (escmode==1)
 23343 cmp 0,EBX
 23346 jge 23677
__926:
 23349 rstack EAX,EBP:-3
 23353 mov EBX,7
 23356 sub EBX,EAX
 23358 fabs EBX,EBX
 23360 fsgn EBX,EBX
 23362 lneg EBX
// if (C=='\7')
 23364 cmp 0,EBX
 23367 jge 23395
// C='a'
 23370 sstack EBP:-3,97
 23375 rstack EAX,EBP:-11
 23379 neg EAX
 23381 mov EBX,EAX
 23383 rstack EAX,EBP:-9
 23387 add EAX,EBX
 23389 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23391 sstack EBP:-10,EBX
__927:
__925:
__929:
 23395 rstack EAX,EBP:-3
 23399 mov EBX,8
 23402 sub EBX,EAX
 23404 fabs EBX,EBX
 23406 fsgn EBX,EBX
 23408 lneg EBX
// if (C=='\8')
 23410 cmp 0,EBX
 23413 jge 23441
// C='b'
 23416 sstack EBP:-3,98
 23421 rstack EAX,EBP:-11
 23425 neg EAX
 23427 mov EBX,EAX
 23429 rstack EAX,EBP:-9
 23433 add EAX,EBX
 23435 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23437 sstack EBP:-10,EBX
__930:
__928:
__932:
 23441 rstack EAX,EBP:-3
 23445 mov EBX,10
 23448 sub EBX,EAX
 23450 fabs EBX,EBX
 23452 fsgn EBX,EBX
 23454 lneg EBX
// if (C=='\10')
 23456 cmp 0,EBX
 23459 jge 23487
// C='n'
 23462 sstack EBP:-3,110
 23467 rstack EAX,EBP:-11
 23471 neg EAX
 23473 mov EBX,EAX
 23475 rstack EAX,EBP:-9
 23479 add EAX,EBX
 23481 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23483 sstack EBP:-10,EBX
__933:
__931:
__935:
 23487 rstack EAX,EBP:-3
 23491 mov EBX,13
 23494 sub EBX,EAX
 23496 fabs EBX,EBX
 23498 fsgn EBX,EBX
 23500 lneg EBX
// if (C=='\13')
 23502 cmp 0,EBX
 23505 jge 23533
// C='r'
 23508 sstack EBP:-3,114
 23513 rstack EAX,EBP:-11
 23517 neg EAX
 23519 mov EBX,EAX
 23521 rstack EAX,EBP:-9
 23525 add EAX,EBX
 23527 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23529 sstack EBP:-10,EBX
__936:
__934:
__938:
 23533 rstack EAX,EBP:-3
 23537 mov EBX,9
 23540 sub EBX,EAX
 23542 fabs EBX,EBX
 23544 fsgn EBX,EBX
 23546 lneg EBX
// if (C=='\9')
 23548 cmp 0,EBX
 23551 jge 23579
// C='t'
 23554 sstack EBP:-3,116
 23559 rstack EAX,EBP:-11
 23563 neg EAX
 23565 mov EBX,EAX
 23567 rstack EAX,EBP:-9
 23571 add EAX,EBX
 23573 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23575 sstack EBP:-10,EBX
__939:
__937:
__941:
 23579 rstack EAX,EBP:-3
 23583 mov EBX,0
 23586 sub EBX,EAX
 23588 fabs EBX,EBX
 23590 fsgn EBX,EBX
 23592 lneg EBX
// if (C=='\0')
 23594 cmp 0,EBX
 23597 jge 23625
// C='0'
 23600 sstack EBP:-3,48
 23605 rstack EAX,EBP:-11
 23609 neg EAX
 23611 mov EBX,EAX
 23613 rstack EAX,EBP:-9
 23617 add EAX,EBX
 23619 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23621 sstack EBP:-10,EBX
__942:
__940:
__944:
 23625 rstack EAX,EBP:-3
// isPrint arg #1 (char C)
 23629 push EAX
 23631 mov ECX,1
// isPrint(...)
 23634 call 15309
 23637 add ESP,1
 23640 mov EBX,0
 23643 sub EBX,EAX
 23645 fabs EBX,EBX
 23647 fsgn EBX,EBX
 23649 lneg EBX
// if (isPrint(C)==0)
 23651 cmp 0,EBX
 23654 jge 23677
 23657 rstack EAX,EBP:-11
 23661 neg EAX
 23663 mov EBX,EAX
 23665 rstack EAX,EBP:-9
 23669 add EAX,EBX
 23671 mov EBX,EAX
// pcolor2=pcolor-pdarken
 23673 sstack EBP:-10,EBX
__945:
__943:
__924:
__922:
 23677 rstack EAX,EBP:-3
// c2=C
 23681 sstack EBP:-8,EAX
 23685 rstack EAX,EBP:-10
// Print arg #2 (float col0)
 23689 push EAX
 23691 mov EAX,SS:EBP
 23694 add EAX,-8
// Print arg #1 (char str)
 23697 push EAX
 23699 mov ECX,2
// Print(...)
 23702 call 17244
 23705 add ESP,2
 23708 rstack EAX,EBP:-2
 23712 add EAX,1
 23715 mov EBX,EAX
// I=I+1
 23717 sstack EBP:-2,EBX
__914:
__883:
__880:
__821:
 23721 rstack EAX,EBP:-2
 23725 rstack EBX,EBP:2
 23729 add EBX,EAX
 23731 mov EAX,EBX
// C=format[I]
 23733 sstack EBP:-3,#EAX
 23737 jmp 21867
__819:
 23740 mov EAX,1
 23743 leave 
 23744 ret 
__817:
 23745 leave 
 23746 ret 
__882:
 23747 db "",0
__866:
 23748 db "<null>",0
snprintf_cpy:
// snprintf_cpy(ppbuff,pn,src)
 23755 enter 2
__947:
 23758 rstack EAX,EBP:2
 23762 sstack EBP:-1,#EAX
 23766 rstack EAX,EBP:3
 23770 sstack EBP:-2,#EAX
__949:
 23774 rstack EAX,EBP:4
 23778 rstack EBX,EBP:-2
 23782 and EBX,#EAX
 23784 mov EAX,EBX
// if (n&&(*src)
 23786 cmp 0,EAX
 23789 jz 23831
 23792 rstack EAX,EBP:4
 23796 mov EBX,EAX
 23798 inc EAX
 23800 sstack EBP:4,EAX
 23804 rstack EAX,EBP:-1
 23808 mov ECX,EAX
 23810 inc EAX
 23812 sstack EBP:-1,EAX
// *pbuff++=*src++
 23816 mov #ECX,#EBX
 23818 rstack EAX,EBP:-2
// n--
 23822 dec EAX
 23824 sstack EBP:-2,EAX
 23828 jmp 23774
__948:
 23831 rstack EAX,EBP:-1
 23835 rstack EBX,EBP:2
// *ppbuff=pbuff
 23839 mov #EBX,EAX
 23841 rstack EAX,EBP:-2
 23845 rstack EBX,EBP:3
// *pn=n
 23849 mov #EBX,EAX
__946:
 23851 leave 
 23852 ret 
snprintf_putch:
// snprintf_putch(ppbuff,pn,c)
 23853 enter 2
__951:
 23856 rstack EAX,EBP:2
 23860 sstack EBP:-1,#EAX
 23864 rstack EAX,EBP:3
 23868 sstack EBP:-2,#EAX
__953:
 23872 rstack EAX,EBP:-2
// if (n)
 23876 cmp 0,EAX
 23879 jge 23900
 23882 rstack EAX,EBP:4
 23886 rstack EBX,EBP:-1
 23890 mov ECX,EBX
 23892 inc EBX
 23894 sstack EBP:-1,EBX
// *pbuff++=c
 23898 mov #ECX,EAX
__954:
__952:
 23900 rstack EAX,EBP:-1
 23904 rstack EBX,EBP:2
// *ppbuff=pbuff
 23908 mov #EBX,EAX
 23910 rstack EAX,EBP:-2
 23914 rstack EBX,EBP:3
// *pn=n
 23918 mov #EBX,EAX
__950:
 23920 leave 
 23921 ret 
snprintf:
// snprintf(buff,n,format)
 23922 enter 10
__956:
 23925 mov EAX,SS:EBP
 23928 add EAX,4
 23931 push EAX
 23933 mov ECX,1
// va_start(...)
 23936 call 10002
 23939 add ESP,1
 23942 sstack EBP:-1,EAX
 23946 sstack EBP:-2,0
 23951 sstack EBP:-3,0
 23956 sstack EBP:-4,0
 23961 sstack EBP:-5,0
 23966 sstack EBP:-6,0
 23971 sstack EBP:-7,0
 23976 sstack EBP:-8,0
 23981 rstack EAX,EBP:2
 23985 sstack EBP:-9,EAX
 23989 rstack EAX,EBP:-2
 23993 rstack EBX,EBP:4
 23997 add EBX,EAX
 23999 mov EAX,EBX
// C=format[I]
 24001 sstack EBP:-3,#EAX
__958:
 24005 rstack EAX,EBP:-3
 24009 mov EBX,0
 24012 sub EBX,EAX
 24014 fabs EBX,EBX
 24016 fsgn EBX,EBX
// if (C!=0
 24018 cmp 0,EBX
 24021 jz 24914
__960:
 24024 rstack EAX,EBP:-3
 24028 mov EBX,37
 24031 sub EBX,EAX
 24033 fabs EBX,EBX
 24035 fsgn EBX,EBX
 24037 lneg EBX
// if (C=='%')
 24039 cmp 0,EBX
 24042 jge 24365
 24045 rstack EAX,EBP:-2
 24049 add EAX,1
 24052 mov EBX,EAX
 24054 rstack EAX,EBP:4
 24058 add EAX,EBX
 24060 mov EBX,EAX
// S=format[I+1]
 24062 sstack EBP:-4,#EBX
__963:
 24066 rstack EAX,EBP:-4
 24070 mov EBX,100
 24073 sub EBX,EAX
 24075 fabs EBX,EBX
 24077 fsgn EBX,EBX
 24079 lneg EBX
// if (S=='d')
 24081 cmp 0,EBX
 24084 jge 24171
 24087 mov EAX,SS:EBP
 24090 add EAX,-1
 24093 push EAX
 24095 mov ECX,1
// va_next(...)
 24098 call 10016
 24101 add ESP,1
// A=va_next(&va)
 24104 sstack EBP:-5,EAX
 24108 rstack EAX,EBP:-5
// num2str arg #1 (float num)
 24112 push EAX
 24114 mov ECX,1
// num2str(...)
 24117 call 13802
 24120 add ESP,1
 24123 sstack EBP:-10,EAX
 24127 rstack EAX,EBP:-10
// snprintf_cpy arg #3 (float src)
 24131 push EAX
 24133 mov EAX,SS:EBP
 24136 add EAX,3
// snprintf_cpy arg #2 (float pn)
 24139 push EAX
 24141 mov EAX,SS:EBP
 24144 add EAX,-9
// snprintf_cpy arg #1 (float ppbuff)
 24147 push EAX
 24149 mov ECX,3
// snprintf_cpy(...)
 24152 call 23755
 24155 add ESP,3
 24158 rstack EAX,EBP:-2
 24162 add EAX,2
 24165 mov EBX,EAX
// I=I+2
 24167 sstack EBP:-2,EBX
__964:
__962:
__966:
 24171 rstack EAX,EBP:-4
 24175 mov EBX,99
 24178 sub EBX,EAX
 24180 fabs EBX,EBX
 24182 fsgn EBX,EBX
 24184 lneg EBX
// if (S=='c')
 24186 cmp 0,EBX
 24189 jge 24257
 24192 mov EAX,SS:EBP
 24195 add EAX,-1
 24198 push EAX
 24200 mov ECX,1
// va_next(...)
 24203 call 10016
 24206 add ESP,1
// A=va_next(&va)
 24209 sstack EBP:-5,EAX
 24213 rstack EAX,EBP:-5
// snprintf_putch arg #3 (float c)
 24217 push EAX
 24219 mov EAX,SS:EBP
 24222 add EAX,3
// snprintf_putch arg #2 (float pn)
 24225 push EAX
 24227 mov EAX,SS:EBP
 24230 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24233 push EAX
 24235 mov ECX,3
// snprintf_putch(...)
 24238 call 23853
 24241 add ESP,3
 24244 rstack EAX,EBP:-2
 24248 add EAX,2
 24251 mov EBX,EAX
// I=I+2
 24253 sstack EBP:-2,EBX
__967:
__965:
__969:
 24257 rstack EAX,EBP:-4
 24261 mov EBX,115
 24264 sub EBX,EAX
 24266 fabs EBX,EBX
 24268 fsgn EBX,EBX
 24270 lneg EBX
// if (S=='s')
 24272 cmp 0,EBX
 24275 jge 24362
 24278 mov EAX,SS:EBP
 24281 add EAX,-1
 24284 push EAX
 24286 mov ECX,1
// va_next(...)
 24289 call 10016
 24292 add ESP,1
// A=va_next(&va)
 24295 sstack EBP:-5,EAX
__972:
 24299 rstack EAX,EBP:-5
 24303 lneg EAX
 24305 mov EBX,EAX
// if (!A)
 24307 cmp 0,EBX
 24310 jge 24318
// A="<null>"
 24313 sstack EBP:-5,23748
__973:
__971:
 24318 rstack EAX,EBP:-5
// snprintf_cpy arg #3 (float src)
 24322 push EAX
 24324 mov EAX,SS:EBP
 24327 add EAX,3
// snprintf_cpy arg #2 (float pn)
 24330 push EAX
 24332 mov EAX,SS:EBP
 24335 add EAX,-9
// snprintf_cpy arg #1 (float ppbuff)
 24338 push EAX
 24340 mov ECX,3
// snprintf_cpy(...)
 24343 call 23755
 24346 add ESP,3
 24349 rstack EAX,EBP:-2
 24353 add EAX,2
 24356 mov EBX,EAX
// I=I+2
 24358 sstack EBP:-2,EBX
__970:
__968:
 24362 jmp 24895
__974:
__961:
__976:
__978:
 24365 rstack EAX,EBP:-3
 24369 mov EBX,23747
 24372 sub EBX,EAX
 24374 fabs EBX,EBX
 24376 fsgn EBX,EBX
 24378 lneg EBX
// if (C=="")
 24380 cmp 0,EBX
 24383 jge 24851
 24386 rstack EAX,EBP:-2
 24390 add EAX,1
 24393 mov EBX,EAX
 24395 rstack EAX,EBP:4
 24399 add EAX,EBX
 24401 mov EBX,EAX
// S=format[I+1]
 24403 sstack EBP:-4,#EBX
__981:
 24407 rstack EAX,EBP:-4
 24411 mov EBX,97
 24414 sub EBX,EAX
 24416 fabs EBX,EBX
 24418 fsgn EBX,EBX
 24420 lneg EBX
// if (S=='a')
 24422 cmp 0,EBX
 24425 jge 24456
// snprintf_putch arg #3 (float c)
 24428 push 7
 24431 mov EAX,SS:EBP
 24434 add EAX,3
// snprintf_putch arg #2 (float pn)
 24437 push EAX
 24439 mov EAX,SS:EBP
 24442 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24445 push EAX
 24447 mov ECX,3
// snprintf_putch(...)
 24450 call 23853
 24453 add ESP,3
__982:
__980:
__984:
 24456 rstack EAX,EBP:-4
 24460 mov EBX,98
 24463 sub EBX,EAX
 24465 fabs EBX,EBX
 24467 fsgn EBX,EBX
 24469 lneg EBX
// if (S=='b')
 24471 cmp 0,EBX
 24474 jge 24505
// snprintf_putch arg #3 (float c)
 24477 push 8
 24480 mov EAX,SS:EBP
 24483 add EAX,3
// snprintf_putch arg #2 (float pn)
 24486 push EAX
 24488 mov EAX,SS:EBP
 24491 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24494 push EAX
 24496 mov ECX,3
// snprintf_putch(...)
 24499 call 23853
 24502 add ESP,3
__985:
__983:
__987:
 24505 rstack EAX,EBP:-4
 24509 mov EBX,110
 24512 sub EBX,EAX
 24514 fabs EBX,EBX
 24516 fsgn EBX,EBX
 24518 lneg EBX
// if (S=='n')
 24520 cmp 0,EBX
 24523 jge 24554
// snprintf_putch arg #3 (float c)
 24526 push 10
 24529 mov EAX,SS:EBP
 24532 add EAX,3
// snprintf_putch arg #2 (float pn)
 24535 push EAX
 24537 mov EAX,SS:EBP
 24540 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24543 push EAX
 24545 mov ECX,3
// snprintf_putch(...)
 24548 call 23853
 24551 add ESP,3
__988:
__986:
__990:
 24554 rstack EAX,EBP:-4
 24558 mov EBX,114
 24561 sub EBX,EAX
 24563 fabs EBX,EBX
 24565 fsgn EBX,EBX
 24567 lneg EBX
// if (S=='r')
 24569 cmp 0,EBX
 24572 jge 24603
// snprintf_putch arg #3 (float c)
 24575 push 13
 24578 mov EAX,SS:EBP
 24581 add EAX,3
// snprintf_putch arg #2 (float pn)
 24584 push EAX
 24586 mov EAX,SS:EBP
 24589 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24592 push EAX
 24594 mov ECX,3
// snprintf_putch(...)
 24597 call 23853
 24600 add ESP,3
__991:
__989:
__993:
 24603 rstack EAX,EBP:-4
 24607 mov EBX,116
 24610 sub EBX,EAX
 24612 fabs EBX,EBX
 24614 fsgn EBX,EBX
 24616 lneg EBX
// if (S=='t')
 24618 cmp 0,EBX
 24621 jge 24652
// snprintf_putch arg #3 (float c)
 24624 push 9
 24627 mov EAX,SS:EBP
 24630 add EAX,3
// snprintf_putch arg #2 (float pn)
 24633 push EAX
 24635 mov EAX,SS:EBP
 24638 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24641 push EAX
 24643 mov ECX,3
// snprintf_putch(...)
 24646 call 23853
 24649 add ESP,3
__994:
__992:
__996:
 24652 rstack EAX,EBP:-4
 24656 mov EBX,23747
 24659 sub EBX,EAX
 24661 fabs EBX,EBX
 24663 fsgn EBX,EBX
 24665 lneg EBX
// if (S=="")
 24667 cmp 0,EBX
 24670 jge 24701
// snprintf_putch arg #3 (float c)
 24673 push 23747
 24676 mov EAX,SS:EBP
 24679 add EAX,3
// snprintf_putch arg #2 (float pn)
 24682 push EAX
 24684 mov EAX,SS:EBP
 24687 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24690 push EAX
 24692 mov ECX,3
// snprintf_putch(...)
 24695 call 23853
 24698 add ESP,3
__997:
__995:
__999:
 24701 rstack EAX,EBP:-4
 24705 mov EBX,39
 24708 sub EBX,EAX
 24710 fabs EBX,EBX
 24712 fsgn EBX,EBX
 24714 lneg EBX
// if (S==''')
 24716 cmp 0,EBX
 24719 jge 24750
// snprintf_putch arg #3 (float c)
 24722 push 39
 24725 mov EAX,SS:EBP
 24728 add EAX,3
// snprintf_putch arg #2 (float pn)
 24731 push EAX
 24733 mov EAX,SS:EBP
 24736 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24739 push EAX
 24741 mov ECX,3
// snprintf_putch(...)
 24744 call 23853
 24747 add ESP,3
__1000:
__998:
__1002:
 24750 rstack EAX,EBP:-4
 24754 mov EBX,34
 24757 sub EBX,EAX
 24759 fabs EBX,EBX
 24761 fsgn EBX,EBX
 24763 lneg EBX
// if (S=='"')
 24765 cmp 0,EBX
 24768 jge 24799
// snprintf_putch arg #3 (float c)
 24771 push 34
 24774 mov EAX,SS:EBP
 24777 add EAX,3
// snprintf_putch arg #2 (float pn)
 24780 push EAX
 24782 mov EAX,SS:EBP
 24785 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24788 push EAX
 24790 mov ECX,3
// snprintf_putch(...)
 24793 call 23853
 24796 add ESP,3
__1003:
__1001:
__1005:
 24799 rstack EAX,EBP:-4
 24803 mov EBX,48
 24806 sub EBX,EAX
 24808 fabs EBX,EBX
 24810 fsgn EBX,EBX
 24812 lneg EBX
// if (S=='0')
 24814 cmp 0,EBX
 24817 jge 24848
// snprintf_putch arg #3 (float c)
 24820 push 0
 24823 mov EAX,SS:EBP
 24826 add EAX,3
// snprintf_putch arg #2 (float pn)
 24829 push EAX
 24831 mov EAX,SS:EBP
 24834 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24837 push EAX
 24839 mov ECX,3
// snprintf_putch(...)
 24842 call 23853
 24845 add ESP,3
__1006:
__1004:
 24848 jmp 24895
__1007:
__979:
__1009:
 24851 rstack EAX,EBP:-3
// snprintf_putch arg #3 (float c)
 24855 push EAX
 24857 mov EAX,SS:EBP
 24860 add EAX,3
// snprintf_putch arg #2 (float pn)
 24863 push EAX
 24865 mov EAX,SS:EBP
 24868 add EAX,-9
// snprintf_putch arg #1 (float ppbuff)
 24871 push EAX
 24873 mov ECX,3
// snprintf_putch(...)
 24876 call 23853
 24879 add ESP,3
 24882 rstack EAX,EBP:-2
 24886 add EAX,1
 24889 mov EBX,EAX
// I=I+1
 24891 sstack EBP:-2,EBX
__1008:
__977:
__975:
__959:
 24895 rstack EAX,EBP:-2
 24899 rstack EBX,EBP:4
 24903 add EBX,EAX
 24905 mov EAX,EBX
// C=format[I]
 24907 sstack EBP:-3,#EAX
 24911 jmp 24005
__957:
__1011:
 24914 rstack EAX,EBP:3
// if (n)
 24918 cmp 0,EAX
 24921 jge 24942
 24924 rstack EAX,EBP:-9
 24928 mov EBX,EAX
 24930 inc EAX
 24932 sstack EBP:-9,EAX
// *pbuff++=0
 24936 mov #EBX,0
 24939 jmp 24959
__1013:
__1012:
__1015:
 24942 rstack EAX,EBP:-9
// pbuff--
 24946 dec EAX
 24948 sstack EBP:-9,EAX
 24952 rstack EAX,EBP:-9
// *pbuff=0
 24956 mov #EAX,0
__1014:
__1010:
 24959 mov EAX,1
 24962 leave 
 24963 ret 
__955:
 24964 leave 
 24965 ret 
libmarker8:
 24966 db 0
delay:
// delay(time)
 24967 enter 1
__1017:
 24970 timer EDX
 24972 sstack EBP:-1,EDX
__1019:
 24976 rstack EAX,EBP:-1
 24980 neg EAX
 24982 mov EBX,EAX
 24984 add EDX,EBX
 24986 rstack EAX,EBP:2
 24990 sub EAX,EDX
 24992 mov EBX,EAX
 24994 fsgn EBX,EBX
 24996 max EBX,0
// if ((EDX-T)<time
 24999 cmp 0,EBX
 25002 jz 25010
 25005 timer EDX
 25007 jmp 24976
__1018:
__1016:
 25010 leave 
 25011 ret 
getTime:
// getTime()
 25012 enter 1
__1021:
 25015 timer EDX
 25017 sstack EBP:-1,EDX
 25021 rstack EAX,EBP:-1
 25025 leave 
 25026 ret 
__1020:
 25027 leave 
 25028 ret 
setTimeout:
// setTimeout(timeleft)
 25029 enter 1
__1023:
 25032 mov ECX,0
// getTime(...)
 25035 call 25012
 25038 sstack EBP:-1,EAX
 25042 rstack EAX,EBP:2
 25046 rstack EBX,EBP:-1
 25050 add EBX,EAX
 25052 mov EAX,EBX
// T=T+timeleft
 25054 sstack EBP:-1,EAX
 25058 rstack EAX,EBP:-1
 25062 leave 
 25063 ret 
__1022:
 25064 leave 
 25065 ret 
timePassed:
// timePassed(timestamp)
 25066 enter -0
__1025:
 25069 mov ECX,0
// getTime(...)
 25072 call 25012
 25075 rstack EBX,EBP:2
 25079 sub EBX,EAX
 25081 mov EAX,EBX
 25083 neg EAX
 25085 fsgn EAX,EAX
 25087 max EAX,0
 25090 leave 
 25091 ret 
__1024:
 25092 leave 
 25093 ret 
libmarker9:
 25094 db 0
typeof_process_h:
 25095 db "h_process",0
sizeof_process_h:
 25105 db 11
process_h_constructor:
// process_h_constructor(this)
 25106 enter -0
__1027:
 25109 rstack EAX,EBP:2
 25113 add EAX,0
 25116 mov EBX,EAX
// this[0]=typeof_process_h
 25118 mov #EBX,25095
 25121 rstack EAX,EBP:2
 25125 add EAX,1
 25128 mov EBX,EAX
// this[1]=0
 25130 mov #EBX,0
 25133 rstack EAX,EBP:2
 25137 add EAX,2
 25140 mov EBX,EAX
// this[2]=0
 25142 mov #EBX,0
 25145 rstack EAX,EBP:2
 25149 add EAX,3
 25152 mov EBX,EAX
// this[3]=0
 25154 mov #EBX,0
 25157 rstack EAX,EBP:2
 25161 add EAX,4
 25164 mov EBX,EAX
// this[4]=0
 25166 mov #EBX,0
 25169 rstack EAX,EBP:2
 25173 add EAX,5
 25176 mov EBX,EAX
// this[5]=0
 25178 mov #EBX,0
 25181 push 1
 25184 rstack EAX,EBP:2
 25188 add EAX,6
 25191 mov EBX,EAX
 25193 push EBX
 25195 mov ECX,2
// vector_constructor(...)
 25198 call 31359
 25201 add ESP,2
__1026:
 25204 leave 
 25205 ret 
process_h_get_procID:
// process_h_get_procID(this)
 25206 enter -0
__1029:
 25209 rstack EAX,EBP:2
 25213 add EAX,1
 25216 mov EBX,EAX
 25218 mov EAX,#EBX
 25220 leave 
 25221 ret 
__1028:
 25222 leave 
 25223 ret 
process_h_get_thread:
// process_h_get_thread(this)
 25224 enter -0
__1031:
 25227 rstack EAX,EBP:2
 25231 add EAX,2
 25234 mov EBX,EAX
 25236 mov EAX,#EBX
 25238 leave 
 25239 ret 
__1030:
 25240 leave 
 25241 ret 
process_h_get_free_pages_start:
// process_h_get_free_pages_start(this)
 25242 enter -0
__1033:
 25245 rstack EAX,EBP:2
 25249 add EAX,3
 25252 mov EBX,EAX
 25254 mov EAX,#EBX
 25256 leave 
 25257 ret 
__1032:
 25258 leave 
 25259 ret 
process_h_get_free_pages_end:
// process_h_get_free_pages_end(this)
 25260 enter -0
__1035:
 25263 rstack EAX,EBP:2
 25267 add EAX,4
 25270 mov EBX,EAX
 25272 mov EAX,#EBX
 25274 leave 
 25275 ret 
__1034:
 25276 leave 
 25277 ret 
process_h_get_proginfo:
// process_h_get_proginfo(this)
 25278 enter -0
__1037:
 25281 rstack EAX,EBP:2
 25285 add EAX,5
 25288 mov EBX,EAX
 25290 mov EAX,#EBX
 25292 leave 
 25293 ret 
__1036:
 25294 leave 
 25295 ret 
process_h_get_pagemap:
// process_h_get_pagemap(this)
 25296 enter -0
__1039:
 25299 rstack EAX,EBP:2
 25303 add EAX,6
 25306 mov EBX,EAX
 25308 mov EAX,EBX
 25310 leave 
 25311 ret 
__1038:
 25312 leave 
 25313 ret 
process_h_set_procID:
// process_h_set_procID(this,val)
 25314 enter -0
__1041:
 25317 rstack EAX,EBP:3
 25321 rstack EBX,EBP:2
 25325 add EBX,1
 25328 mov ECX,EBX
// this[1]=val
 25330 mov #ECX,EAX
__1040:
 25332 leave 
 25333 ret 
process_h_set_thread:
// process_h_set_thread(this,val)
 25334 enter -0
__1043:
 25337 rstack EAX,EBP:3
 25341 rstack EBX,EBP:2
 25345 add EBX,2
 25348 mov ECX,EBX
// this[2]=val
 25350 mov #ECX,EAX
__1042:
 25352 leave 
 25353 ret 
process_h_set_free_pages_start:
// process_h_set_free_pages_start(this,val)
 25354 enter -0
__1045:
 25357 rstack EAX,EBP:3
 25361 rstack EBX,EBP:2
 25365 add EBX,3
 25368 mov ECX,EBX
// this[3]=val
 25370 mov #ECX,EAX
__1044:
 25372 leave 
 25373 ret 
process_h_set_free_pages_end:
// process_h_set_free_pages_end(this,val)
 25374 enter -0
__1047:
 25377 rstack EAX,EBP:3
 25381 rstack EBX,EBP:2
 25385 add EBX,4
 25388 mov ECX,EBX
// this[4]=val
 25390 mov #ECX,EAX
__1046:
 25392 leave 
 25393 ret 
process_h_set_proginfo:
// process_h_set_proginfo(this,val)
 25394 enter -0
__1049:
 25397 rstack EAX,EBP:3
 25401 rstack EBX,EBP:2
 25405 add EBX,5
 25408 mov ECX,EBX
// this[5]=val
 25410 mov #ECX,EAX
__1048:
 25412 leave 
 25413 ret 
libmarker11:
 25414 db 0
ZMALLOC_CODE:
allocation_constructor:
// allocation_constructor(A)
 25415 enter -0
__1051:
 25418 push 0
 25421 rstack EAX,EBP:2
 25425 push EAX
 25427 mov ECX,2
// allocation_set_size(...)
 25430 call 25492
 25433 add ESP,2
 25436 push 0
 25439 rstack EAX,EBP:2
 25443 push EAX
 25445 mov ECX,2
// allocation_set_owner(...)
 25448 call 25512
 25451 add ESP,2
 25454 push 0
 25457 rstack EAX,EBP:2
 25461 push EAX
 25463 mov ECX,2
// allocation_set_prev(...)
 25466 call 25532
 25469 add ESP,2
 25472 push 0
 25475 rstack EAX,EBP:2
 25479 push EAX
 25481 mov ECX,2
// allocation_set_next(...)
 25484 call 25552
 25487 add ESP,2
__1050:
 25490 leave 
 25491 ret 
allocation_set_size:
// allocation_set_size(A,n)
 25492 enter -0
__1053:
 25495 rstack EAX,EBP:3
 25499 rstack EBX,EBP:2
 25503 add EBX,0
 25506 mov ECX,EBX
// A[0]=n
 25508 mov #ECX,EAX
__1052:
 25510 leave 
 25511 ret 
allocation_set_owner:
// allocation_set_owner(A,n)
 25512 enter -0
__1055:
 25515 rstack EAX,EBP:3
 25519 rstack EBX,EBP:2
 25523 add EBX,1
 25526 mov ECX,EBX
// A[1]=n
 25528 mov #ECX,EAX
__1054:
 25530 leave 
 25531 ret 
allocation_set_prev:
// allocation_set_prev(A,n)
 25532 enter -0
__1057:
 25535 rstack EAX,EBP:3
 25539 rstack EBX,EBP:2
 25543 add EBX,2
 25546 mov ECX,EBX
// A[2]=n
 25548 mov #ECX,EAX
__1056:
 25550 leave 
 25551 ret 
allocation_set_next:
// allocation_set_next(A,n)
 25552 enter -0
__1059:
 25555 rstack EAX,EBP:3
 25559 rstack EBX,EBP:2
 25563 add EBX,3
 25566 mov ECX,EBX
// A[3]=n
 25568 mov #ECX,EAX
__1058:
 25570 leave 
 25571 ret 
allocation_get_size:
// allocation_get_size(A)
 25572 enter -0
__1061:
 25575 rstack EAX,EBP:2
 25579 add EAX,0
 25582 mov EBX,EAX
 25584 mov EAX,#EBX
 25586 leave 
 25587 ret 
__1060:
 25588 leave 
 25589 ret 
allocation_get_owner:
// allocation_get_owner(A)
 25590 enter -0
__1063:
 25593 rstack EAX,EBP:2
 25597 add EAX,1
 25600 mov EBX,EAX
 25602 mov EAX,#EBX
 25604 leave 
 25605 ret 
__1062:
 25606 leave 
 25607 ret 
allocation_get_prev:
// allocation_get_prev(A)
 25608 enter -0
__1065:
 25611 rstack EAX,EBP:2
 25615 add EAX,2
 25618 mov EBX,EAX
 25620 mov EAX,#EBX
 25622 leave 
 25623 ret 
__1064:
 25624 leave 
 25625 ret 
allocation_get_next:
// allocation_get_next(A)
 25626 enter -0
__1067:
 25629 rstack EAX,EBP:2
 25633 add EAX,3
 25636 mov EBX,EAX
 25638 mov EAX,#EBX
 25640 leave 
 25641 ret 
__1066:
 25642 leave 
 25643 ret 
malloc_getAllocation:
// malloc_getAllocation(I)
 25644 enter -0
__1069:
__1071:
 25647 rstack EAX,EBP:2
 25651 mov EBX,1
 25654 sub EBX,EAX
 25656 fsgn EBX,EBX
 25658 max EBX,0
// if (I<1)
 25661 cmp 0,EBX
 25664 jge 25729
__1074:
// if (malloc_debug)
 25667 cmp 0,#66978
 25671 jge 25724
 25674 push 25887
 25677 mov ECX,1
// malloc_print(...)
 25680 call #66979
 25683 add ESP,1
 25686 rstack EAX,EBP:2
 25690 push EAX
 25692 mov ECX,1
// malloc_num2str(...)
 25695 call #66980
 25698 add ESP,1
 25701 push EAX
 25703 mov ECX,1
// malloc_print(...)
 25706 call #66979
 25709 add ESP,1
 25712 push 25881
 25715 mov ECX,1
// malloc_print(...)
 25718 call #66979
 25721 add ESP,1
__1075:
__1073:
 25724 mov EAX,0
 25727 leave 
 25728 ret 
__1072:
__1070:
__1079:
 25729 rstack EAX,EBP:2
 25733 mov EBX,#66983
 25736 neg EBX
 25738 mov ECX,#66982
 25741 add ECX,EBX
 25743 sub ECX,EAX
 25745 neg ECX
 25747 fsgn ECX,ECX
 25749 max ECX,0
// if (I>malloc_max_disk-malloc_header)
 25752 cmp 0,ECX
 25755 jge 25864
__1082:
// if (malloc_debug)
 25758 cmp 0,#66978
 25762 jge 25859
 25765 push 25887
 25768 mov ECX,1
// malloc_print(...)
 25771 call #66979
 25774 add ESP,1
 25777 rstack EAX,EBP:2
 25781 push EAX
 25783 mov ECX,1
// malloc_num2str(...)
 25786 call #66980
 25789 add ESP,1
 25792 push EAX
 25794 mov ECX,1
// malloc_print(...)
 25797 call #66979
 25800 add ESP,1
 25803 push 25909
 25806 mov ECX,1
// malloc_print(...)
 25809 call #66979
 25812 add ESP,1
 25815 mov EAX,#66983
 25818 neg EAX
 25820 mov EBX,#66982
 25823 add EBX,EAX
 25825 push EBX
 25827 mov ECX,1
// malloc_num2str(...)
 25830 call #66980
 25833 add ESP,1
 25836 push EAX
 25838 mov ECX,1
// malloc_print(...)
 25841 call #66979
 25844 add ESP,1
 25847 push 25879
 25850 mov ECX,1
// malloc_print(...)
 25853 call #66979
 25856 add ESP,1
__1083:
__1081:
 25859 mov EAX,0
 25862 leave 
 25863 ret 
__1080:
__1078:
 25864 rstack EAX,EBP:2
 25868 mov EBX,#66981
 25871 add EBX,EAX
 25873 mov EAX,EBX
 25875 leave 
 25876 ret 
__1068:
 25877 leave 
 25878 ret 
__1085:
 25879 db "
",0
__1077:
 25881 db "<= 0
",0
__1076:
 25887 db "getAllocation fails: ",0
__1084:
 25909 db ">",0
malloc_getDataFromIndex:
// malloc_getDataFromIndex(I)
 25911 enter -0
__1087:
 25914 rstack EAX,EBP:2
 25918 add EAX,#66983
 25921 mov EBX,EAX
 25923 mov EAX,#66981
 25926 add EAX,EBX
 25928 leave 
 25929 ret 
__1086:
 25930 leave 
 25931 ret 
malloc_getDataFromAllocation:
// malloc_getDataFromAllocation(A)
 25932 enter -0
__1089:
 25935 rstack EAX,EBP:2
 25939 add EAX,#66983
 25942 mov EBX,EAX
 25944 mov EAX,EBX
 25946 leave 
 25947 ret 
__1088:
 25948 leave 
 25949 ret 
malloc_getIndex:
// malloc_getIndex(ptr)
 25950 enter -0
__1091:
 25953 mov EAX,#66981
 25956 neg EAX
 25958 rstack EBX,EBP:2
 25962 add EBX,EAX
 25964 mov EAX,EBX
 25966 leave 
 25967 ret 
__1090:
 25968 leave 
 25969 ret 
malloc_trySplit:
// malloc_trySplit(A,returnB,n)
 25970 enter 7
__1093:
 25973 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 25977 push EAX
 25979 mov ECX,1
// allocation_get_size(...)
 25982 call 25572
 25985 add ESP,1
 25988 sstack EBP:-1,EAX
 25992 mov EAX,#66983
 25995 add EAX,1
 25998 rstack EBX,EBP:4
 26002 add EBX,EAX
 26004 mov EAX,EBX
 26006 sstack EBP:-2,EAX
__1095:
 26010 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 26014 push EAX
 26016 mov ECX,1
// allocation_get_size(...)
 26019 call 25572
 26022 add ESP,1
 26025 mov EBX,#66983
 26028 add EBX,1
 26031 rstack ECX,EBP:4
 26035 add ECX,EBX
 26037 mov EBX,ECX
 26039 sub EBX,EAX
 26041 fsgn EBX,EBX
 26043 max EBX,0
// if (allocation_get_size(A)<n+malloc_header+1)
 26046 cmp 0,EBX
 26049 jge 26097
// printf arg #2 (unknown)
 26052 push 990
// printf arg #1 (char* format)
 26055 push 26532
 26058 mov ECX,2
// printf(...)
 26061 call 21772
 26064 add ESP,2
 26067 rstack EAX,EBP:-2
// printf arg #4 (unknown)
 26071 push EAX
 26073 rstack EAX,EBP:-1
// printf arg #3 (unknown)
 26077 push EAX
 26079 rstack EAX,EBP:2
// printf arg #2 (unknown)
 26083 push EAX
// printf arg #1 (char* format)
 26085 push 26486
 26088 mov ECX,4
// printf(...)
 26091 call 21772
 26094 add ESP,4
__1096:
__1094:
 26097 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 26101 push EAX
 26103 mov ECX,1
// allocation_get_size(...)
 26106 call 25572
 26109 add ESP,1
 26112 sstack EBP:-3,EAX
 26116 rstack EAX,EBP:4
// allocation_set_size arg #2 (float n)
 26120 push EAX
 26122 rstack EAX,EBP:2
// allocation_set_size arg #1 (float* A)
 26126 push EAX
 26128 mov ECX,2
// allocation_set_size(...)
 26131 call 25492
 26134 add ESP,2
 26137 rstack EAX,EBP:2
// malloc_getDataFromAllocation arg #1 (float* A)
 26141 push EAX
 26143 mov ECX,1
// malloc_getDataFromAllocation(...)
 26146 call 25932
 26149 add ESP,1
 26152 sstack EBP:-4,EAX
 26156 rstack EAX,EBP:4
 26160 rstack EBX,EBP:-4
 26164 add EBX,EAX
 26166 mov EAX,EBX
// tmp=tmp+n
 26168 sstack EBP:-4,EAX
 26172 rstack EAX,EBP:-4
// malloc_getIndex arg #1 (float* ptr)
 26176 push EAX
 26178 mov ECX,1
// malloc_getIndex(...)
 26181 call 25950
 26184 add ESP,1
// tmp=malloc_getIndex(tmp)
 26187 sstack EBP:-4,EAX
 26191 rstack EAX,EBP:-4
// malloc_getAllocation arg #1 (float I)
 26195 push EAX
 26197 mov ECX,1
// malloc_getAllocation(...)
 26200 call 25644
 26203 add ESP,1
 26206 sstack EBP:-5,EAX
 26210 rstack EAX,EBP:-5
 26214 sstack EBP:-6,EAX
 26218 mov EAX,#66983
 26221 neg EAX
 26223 rstack EBX,EBP:4
 26227 neg EBX
 26229 mov ECX,EBX
 26231 add ECX,EAX
 26233 rstack EAX,EBP:-3
 26237 add EAX,ECX
 26239 mov EBX,EAX
 26241 sstack EBP:-7,EBX
 26245 rstack EAX,EBP:-7
// allocation_set_size arg #2 (float n)
 26249 push EAX
 26251 rstack EAX,EBP:-6
// allocation_set_size arg #1 (float* A)
 26255 push EAX
 26257 mov ECX,2
// allocation_set_size(...)
 26260 call 25492
 26263 add ESP,2
 26266 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 26270 push EAX
 26272 mov ECX,1
// allocation_get_owner(...)
 26275 call 25590
 26278 add ESP,1
// allocation_set_owner arg #2 (float n)
 26281 push EAX
 26283 rstack EAX,EBP:-6
// allocation_set_owner arg #1 (float* A)
 26287 push EAX
 26289 mov ECX,2
// allocation_set_owner(...)
 26292 call 25512
 26295 add ESP,2
 26298 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 26302 push EAX
 26304 mov ECX,1
// malloc_getIndex(...)
 26307 call 25950
 26310 add ESP,1
// allocation_set_prev arg #2 (float n)
 26313 push EAX
 26315 rstack EAX,EBP:-6
// allocation_set_prev arg #1 (float* A)
 26319 push EAX
 26321 mov ECX,2
// allocation_set_prev(...)
 26324 call 25532
 26327 add ESP,2
 26330 rstack EAX,EBP:2
// allocation_get_next arg #1 (float* A)
 26334 push EAX
 26336 mov ECX,1
// allocation_get_next(...)
 26339 call 25626
 26342 add ESP,1
// allocation_set_next arg #2 (float n)
 26345 push EAX
 26347 rstack EAX,EBP:-6
// allocation_set_next arg #1 (float* A)
 26351 push EAX
 26353 mov ECX,2
// allocation_set_next(...)
 26356 call 25552
 26359 add ESP,2
 26362 rstack EAX,EBP:-6
// malloc_getIndex arg #1 (float* ptr)
 26366 push EAX
 26368 mov ECX,1
// malloc_getIndex(...)
 26371 call 25950
 26374 add ESP,1
// allocation_set_next arg #2 (float n)
 26377 push EAX
 26379 rstack EAX,EBP:2
// allocation_set_next arg #1 (float* A)
 26383 push EAX
 26385 mov ECX,2
// allocation_set_next(...)
 26388 call 25552
 26391 add ESP,2
__1100:
 26394 rstack EAX,EBP:-6
// allocation_get_next arg #1 (float* A)
 26398 push EAX
 26400 mov ECX,1
// allocation_get_next(...)
 26403 call 25626
 26406 add ESP,1
// if (allocation_get_next(B))
 26409 cmp 0,EAX
 26412 jge 26469
 26415 rstack EAX,EBP:-6
// malloc_getIndex arg #1 (float* ptr)
 26419 push EAX
 26421 mov ECX,1
// malloc_getIndex(...)
 26424 call 25950
 26427 add ESP,1
// allocation_set_prev arg #2 (float n)
 26430 push EAX
 26432 rstack EAX,EBP:-6
// allocation_get_next arg #1 (float* A)
 26436 push EAX
 26438 mov ECX,1
// allocation_get_next(...)
 26441 call 25626
 26444 add ESP,1
// malloc_getAllocation arg #1 (float I)
 26447 push EAX
 26449 mov ECX,1
// malloc_getAllocation(...)
 26452 call 25644
 26455 add ESP,1
// allocation_set_prev arg #1 (float* A)
 26458 push EAX
 26460 mov ECX,2
// allocation_set_prev(...)
 26463 call 25532
 26466 add ESP,2
__1101:
__1099:
 26469 rstack EAX,EBP:-6
 26473 rstack EBX,EBP:3
// *returnB=B
 26477 mov #EBX,EAX
 26479 mov EAX,1
 26482 leave 
 26483 ret 
__1092:
 26484 leave 
 26485 ret 
__1098:
 26486 db "size of allocation %d is %d, need %d or more
",0
__1097:
 26532 db "%mmalloc: too small, cant split
",0
malloc_join:
// malloc_join(A,B)
 26565 enter 2
__1103:
 26568 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 26572 push EAX
 26574 mov ECX,1
// allocation_get_size(...)
 26577 call 25572
 26580 add ESP,1
 26583 sstack EBP:-1,EAX
 26587 rstack EAX,EBP:3
// allocation_get_size arg #1 (float* A)
 26591 push EAX
 26593 mov ECX,1
// allocation_get_size(...)
 26596 call 25572
 26599 add ESP,1
 26602 rstack EBX,EBP:-1
 26606 add EBX,EAX
 26608 mov EAX,EBX
// tmp=tmp+allocation_get_size(B)
 26610 sstack EBP:-1,EAX
 26614 rstack EAX,EBP:-1
 26618 add EAX,#66983
 26621 mov EBX,EAX
// tmp=tmp+malloc_header
 26623 sstack EBP:-1,EBX
 26627 rstack EAX,EBP:-1
// allocation_set_size arg #2 (float n)
 26631 push EAX
 26633 rstack EAX,EBP:2
// allocation_set_size arg #1 (float* A)
 26637 push EAX
 26639 mov ECX,2
// allocation_set_size(...)
 26642 call 25492
 26645 add ESP,2
 26648 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 26652 push EAX
 26654 mov ECX,1
// allocation_get_next(...)
 26657 call 25626
 26660 add ESP,1
// tmp=allocation_get_next(B)
 26663 sstack EBP:-1,EAX
 26667 rstack EAX,EBP:-1
// allocation_set_next arg #2 (float n)
 26671 push EAX
 26673 rstack EAX,EBP:2
// allocation_set_next arg #1 (float* A)
 26677 push EAX
 26679 mov ECX,2
// allocation_set_next(...)
 26682 call 25552
 26685 add ESP,2
__1105:
 26688 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 26692 push EAX
 26694 mov ECX,1
// allocation_get_next(...)
 26697 call 25626
 26700 add ESP,1
// if (allocation_get_next(B))
 26703 cmp 0,EAX
 26706 jge 26787
 26709 rstack EAX,EBP:3
// allocation_get_next arg #1 (float* A)
 26713 push EAX
 26715 mov ECX,1
// allocation_get_next(...)
 26718 call 25626
 26721 add ESP,1
// tmp=allocation_get_next(B)
 26724 sstack EBP:-1,EAX
 26728 rstack EAX,EBP:-1
// malloc_getAllocation arg #1 (float I)
 26732 push EAX
 26734 mov ECX,1
// malloc_getAllocation(...)
 26737 call 25644
 26740 add ESP,1
// tmp=malloc_getAllocation(tmp)
 26743 sstack EBP:-1,EAX
 26747 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 26751 push EAX
 26753 mov ECX,1
// malloc_getIndex(...)
 26756 call 25950
 26759 add ESP,1
 26762 sstack EBP:-2,EAX
 26766 rstack EAX,EBP:-2
// allocation_set_prev arg #2 (float n)
 26770 push EAX
 26772 rstack EAX,EBP:-1
// allocation_set_prev arg #1 (float* A)
 26776 push EAX
 26778 mov ECX,2
// allocation_set_prev(...)
 26781 call 25532
 26784 add ESP,2
__1106:
__1104:
__1102:
 26787 leave 
 26788 ret 
malloc_set_disk:
// malloc_set_disk(disk,disk_size)
 26789 enter -0
__1108:
 26792 rstack EAX,EBP:2
// malloc_disk=disk
 26796 mov #66981,EAX
 26799 rstack EAX,EBP:3
// malloc_max_disk=disk_size
 26803 mov #66982,EAX
// malloc_header=4
 26806 mov #66983,4
// malloc_user=1
 26810 mov #66984,1
// malloc_debug=0
 26814 mov #66978,0
__1107:
 26818 leave 
 26819 ret 
malloc_init:
// malloc_init()
 26820 enter 1
__1110:
__1112:
// if (malloc_debug)
 26823 cmp 0,#66978
 26827 jge 26877
 26830 push 27092
 26833 mov ECX,1
// malloc_print(...)
 26836 call #66979
 26839 add ESP,1
 26842 push #66981
 26845 mov ECX,1
// malloc_num2str(...)
 26848 call #66980
 26851 add ESP,1
 26854 push EAX
 26856 mov ECX,1
// malloc_print(...)
 26859 call #66979
 26862 add ESP,1
 26865 push 25879
 26868 mov ECX,1
// malloc_print(...)
 26871 call #66979
 26874 add ESP,1
__1113:
__1111:
// malloc_getAllocation arg #1 (float I)
 26877 push 1
 26880 mov ECX,1
// malloc_getAllocation(...)
 26883 call 25644
 26886 add ESP,1
 26889 sstack EBP:-1,EAX
__1116:
// if (malloc_debug)
 26893 cmp 0,#66978
 26897 jge 26950
 26900 push 27055
 26903 mov ECX,1
// malloc_print(...)
 26906 call #66979
 26909 add ESP,1
 26912 rstack EAX,EBP:-1
 26916 push EAX
 26918 mov ECX,1
// malloc_num2str(...)
 26921 call #66980
 26924 add ESP,1
 26927 push EAX
 26929 mov ECX,1
// malloc_print(...)
 26932 call #66979
 26935 add ESP,1
 26938 push 25879
 26941 mov ECX,1
// malloc_print(...)
 26944 call #66979
 26947 add ESP,1
__1117:
__1115:
 26950 mov EAX,#66983
 26953 neg EAX
 26955 add EAX,-1
 26958 mov EBX,#66982
 26961 add EBX,EAX
// allocation_set_size arg #2 (float n)
 26963 push EBX
 26965 rstack EAX,EBP:-1
// allocation_set_size arg #1 (float* A)
 26969 push EAX
 26971 mov ECX,2
// allocation_set_size(...)
 26974 call 25492
 26977 add ESP,2
// allocation_set_owner arg #2 (float n)
 26980 push 0
 26983 rstack EAX,EBP:-1
// allocation_set_owner arg #1 (float* A)
 26987 push EAX
 26989 mov ECX,2
// allocation_set_owner(...)
 26992 call 25512
 26995 add ESP,2
// allocation_set_prev arg #2 (float n)
 26998 push 0
 27001 rstack EAX,EBP:-1
// allocation_set_prev arg #1 (float* A)
 27005 push EAX
 27007 mov ECX,2
// allocation_set_prev(...)
 27010 call 25532
 27013 add ESP,2
// allocation_set_next arg #2 (float n)
 27016 push 0
 27019 rstack EAX,EBP:-1
// allocation_set_next arg #1 (float* A)
 27023 push EAX
 27025 mov ECX,2
// allocation_set_next(...)
 27028 call 25552
 27031 add ESP,2
__1120:
// if (malloc_debug)
 27034 cmp 0,#66978
 27038 jge 27053
 27041 push 27069
 27044 mov ECX,1
// malloc_print(...)
 27047 call #66979
 27050 add ESP,1
__1121:
__1119:
__1109:
 27053 leave 
 27054 ret 
__1118:
 27055 db "allocation = ",0
__1122:
 27069 db "malloc_init returning
",0
__1114:
 27092 db "disk = ",0
malloc_test:
// malloc_test()
 27100 enter 5
__1124:
 27103 mov EAX,SS:EBP
 27106 add EAX,-4
 27109 push EAX
 27111 mov EAX,SS:EBP
 27114 add EAX,-3
 27117 push EAX
 27119 mov EAX,SS:EBP
 27122 add EAX,-2
 27125 push EAX
 27127 mov EAX,SS:EBP
 27130 add EAX,-1
 27133 push EAX
 27135 mov ECX,4
// malloc_count(...)
 27138 call 27440
 27141 add ESP,4
__1126:
 27144 rstack EAX,EBP:-4
 27148 rstack EBX,EBP:-3
 27152 add EBX,EAX
 27154 mov EAX,EBX
 27156 mov EBX,#66983
 27159 mul EBX,EAX
 27161 add EBX,1
 27164 rstack EAX,EBP:-2
 27168 add EAX,EBX
 27170 mov EBX,EAX
 27172 rstack EAX,EBP:-1
 27176 add EAX,EBX
 27178 mov EBX,EAX
 27180 sstack EBP:-5,EBX
__1128:
 27184 rstack EAX,EBP:-5
 27188 mov EBX,#66982
 27191 sub EBX,EAX
 27193 fabs EBX,EBX
 27195 fsgn EBX,EBX
// if (calcsize!=malloc_max_disk)
 27197 cmp 0,EBX
 27200 jge 27300
__1131:
// if (malloc_print)
 27203 cmp 0,#66979
 27207 jge 27295
 27210 push 27307
 27213 mov ECX,1
// malloc_print(...)
 27216 call #66979
 27219 add ESP,1
 27222 rstack EAX,EBP:-5
 27226 push EAX
 27228 mov ECX,1
// malloc_num2str(...)
 27231 call #66980
 27234 add ESP,1
 27237 push EAX
 27239 mov ECX,1
// malloc_print(...)
 27242 call #66979
 27245 add ESP,1
 27248 push 27334
 27251 mov ECX,1
// malloc_print(...)
 27254 call #66979
 27257 add ESP,1
 27260 push #66982
 27263 mov ECX,1
// malloc_num2str(...)
 27266 call #66980
 27269 add ESP,1
 27272 push EAX
 27274 mov ECX,1
// malloc_print(...)
 27277 call #66979
 27280 add ESP,1
 27283 push 27331
 27286 mov ECX,1
// malloc_print(...)
 27289 call #66979
 27292 add ESP,1
__1132:
__1130:
 27295 mov EAX,1
 27298 leave 
 27299 ret 
__1129:
__1127:
__1125:
 27300 mov EAX,0
 27303 leave 
 27304 ret 
__1123:
 27305 leave 
 27306 ret 
__1133:
 27307 db "ERROR: HEAP CORRUPTED
(",0
__1135:
 27331 db ")
",0
__1134:
 27334 db " / ",0
malloc_print_count:
// malloc_print_count()
 27338 enter 1
__1137:
// malloc_getAllocation arg #1 (float I)
 27341 push 1
 27344 mov ECX,1
// malloc_getAllocation(...)
 27347 call 25644
 27350 add ESP,1
 27353 sstack EBP:-1,EAX
__1139:
// if (1
 27357 cmp 0,1
 27361 jz 27438
 27364 rstack EAX,EBP:-1
 27368 push EAX
 27370 mov ECX,1
// printAllocationSimple(...)
 27373 call 27678
 27376 add ESP,1
__1141:
 27379 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 27383 push EAX
 27385 mov ECX,1
// allocation_get_next(...)
 27388 call 25626
 27391 add ESP,1
// if (allocation_get_next(A))
 27394 cmp 0,EAX
 27397 jge 27433
 27400 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 27404 push EAX
 27406 mov ECX,1
// allocation_get_next(...)
 27409 call 25626
 27412 add ESP,1
// malloc_getAllocation arg #1 (float I)
 27415 push EAX
 27417 mov ECX,1
// malloc_getAllocation(...)
 27420 call 25644
 27423 add ESP,1
// A=malloc_getAllocation(allocation_get_next(A))
 27426 sstack EBP:-1,EAX
 27430 jmp 27435
__1143:
__1142:
__1145:
 27433 leave 
 27434 ret 
__1144:
__1140:
 27435 jmp 27357
__1138:
__1136:
 27438 leave 
 27439 ret 
malloc_count:
// malloc_count(freesize,usedsize,freecount,usedcount)
 27440 enter 1
__1147:
 27443 rstack EAX,EBP:2
// *freesize=0
 27447 mov #EAX,0
 27450 rstack EAX,EBP:3
// *usedsize=0
 27454 mov #EAX,0
 27457 rstack EAX,EBP:4
// *freecount=0
 27461 mov #EAX,0
 27464 rstack EAX,EBP:5
// *usedcount=0
 27468 mov #EAX,0
// malloc_getAllocation arg #1 (float I)
 27471 push 1
 27474 mov ECX,1
// malloc_getAllocation(...)
 27477 call 25644
 27480 add ESP,1
 27483 sstack EBP:-1,EAX
__1149:
// if (1
 27487 cmp 0,1
 27491 jz 27676
__1151:
 27494 rstack EAX,EBP:-1
// allocation_get_owner arg #1 (float* A)
 27498 push EAX
 27500 mov ECX,1
// allocation_get_owner(...)
 27503 call 25590
 27506 add ESP,1
 27509 mov EBX,0
 27512 sub EBX,EAX
 27514 fabs EBX,EBX
 27516 fsgn EBX,EBX
 27518 lneg EBX
// if (allocation_get_owner(A)==0)
 27520 cmp 0,EBX
 27523 jge 27573
 27526 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 27530 push EAX
 27532 mov ECX,1
// allocation_get_size(...)
 27535 call 25572
 27538 add ESP,1
 27541 rstack EBX,EBP:2
 27545 mov ECX,#EBX
 27547 add ECX,EAX
 27549 rstack EAX,EBP:2
// *freesize=*freesize+allocation_get_size(A)
 27553 mov #EAX,ECX
 27555 rstack EAX,EBP:4
 27559 mov EBX,#EAX
 27561 add EBX,1
 27564 rstack EAX,EBP:4
// *freecount=*freecount+1
 27568 mov #EAX,EBX
 27570 jmp 27617
__1153:
__1152:
__1155:
 27573 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 27577 push EAX
 27579 mov ECX,1
// allocation_get_size(...)
 27582 call 25572
 27585 add ESP,1
 27588 rstack EBX,EBP:3
 27592 mov ECX,#EBX
 27594 add ECX,EAX
 27596 rstack EAX,EBP:3
// *usedsize=*usedsize+allocation_get_size(A)
 27600 mov #EAX,ECX
 27602 rstack EAX,EBP:5
 27606 mov EBX,#EAX
 27608 add EBX,1
 27611 rstack EAX,EBP:5
// *usedcount=*usedcount+1
 27615 mov #EAX,EBX
__1154:
__1150:
__1157:
 27617 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 27621 push EAX
 27623 mov ECX,1
// allocation_get_next(...)
 27626 call 25626
 27629 add ESP,1
// if (allocation_get_next(A))
 27632 cmp 0,EAX
 27635 jge 27671
 27638 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 27642 push EAX
 27644 mov ECX,1
// allocation_get_next(...)
 27647 call 25626
 27650 add ESP,1
// malloc_getAllocation arg #1 (float I)
 27653 push EAX
 27655 mov ECX,1
// malloc_getAllocation(...)
 27658 call 25644
 27661 add ESP,1
// A=malloc_getAllocation(allocation_get_next(A))
 27664 sstack EBP:-1,EAX
 27668 jmp 27673
__1159:
__1158:
__1161:
 27671 leave 
 27672 ret 
__1160:
__1156:
 27673 jmp 27487
__1148:
__1146:
 27676 leave 
 27677 ret 
printAllocationSimple:
// printAllocationSimple(A)
 27678 enter -0
__1163:
__1165:
 27681 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 27685 push EAX
 27687 mov ECX,1
// allocation_get_owner(...)
 27690 call 25590
 27693 add ESP,1
// if (allocation_get_owner(A))
 27696 cmp 0,EAX
 27699 jge 27717
 27702 push 27821
 27705 mov ECX,1
// malloc_print(...)
 27708 call #66979
 27711 add ESP,1
 27714 jmp 27729
__1168:
__1166:
__1170:
 27717 push 27818
 27720 mov ECX,1
// malloc_print(...)
 27723 call #66979
 27726 add ESP,1
__1169:
__1164:
 27729 rstack EAX,EBP:2
 27733 push EAX
 27735 mov ECX,1
// malloc_num2str(...)
 27738 call #66980
 27741 add ESP,1
 27744 push EAX
 27746 mov ECX,1
// malloc_print(...)
 27749 call #66979
 27752 add ESP,1
 27755 push 27824
 27758 mov ECX,1
// malloc_print(...)
 27761 call #66979
 27764 add ESP,1
 27767 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 27771 push EAX
 27773 mov ECX,1
// allocation_get_size(...)
 27776 call 25572
 27779 add ESP,1
 27782 push EAX
 27784 mov ECX,1
// malloc_num2str(...)
 27787 call #66980
 27790 add ESP,1
 27793 push EAX
 27795 mov ECX,1
// malloc_print(...)
 27798 call #66979
 27801 add ESP,1
 27804 push 25879
 27807 mov ECX,1
// malloc_print(...)
 27810 call #66979
 27813 add ESP,1
__1162:
 27816 leave 
 27817 ret 
__1171:
 27818 db "O ",0
__1167:
 27821 db "X ",0
__1172:
 27824 db " ",0
printAllocation:
// printAllocation(A)
 27826 enter -0
__1174:
 27829 push 28150
 27832 mov ECX,1
// malloc_print(...)
 27835 call #66979
 27838 add ESP,1
 27841 rstack EAX,EBP:2
 27845 push EAX
 27847 mov ECX,1
// malloc_num2str(...)
 27850 call #66980
 27853 add ESP,1
 27856 push EAX
 27858 mov ECX,1
// malloc_print(...)
 27861 call #66979
 27864 add ESP,1
 27867 push 28126
 27870 mov ECX,1
// malloc_print(...)
 27873 call #66979
 27876 add ESP,1
 27879 rstack EAX,EBP:2
// malloc_getDataFromAllocation arg #1 (float* A)
 27883 push EAX
 27885 mov ECX,1
// malloc_getDataFromAllocation(...)
 27888 call 25932
 27891 add ESP,1
 27894 push EAX
 27896 mov ECX,1
// malloc_num2str(...)
 27899 call #66980
 27902 add ESP,1
 27905 push EAX
 27907 mov ECX,1
// malloc_print(...)
 27910 call #66979
 27913 add ESP,1
 27916 push 28142
 27919 mov ECX,1
// malloc_print(...)
 27922 call #66979
 27925 add ESP,1
 27928 rstack EAX,EBP:2
// allocation_get_size arg #1 (float* A)
 27932 push EAX
 27934 mov ECX,1
// allocation_get_size(...)
 27937 call 25572
 27940 add ESP,1
 27943 push EAX
 27945 mov ECX,1
// malloc_num2str(...)
 27948 call #66980
 27951 add ESP,1
 27954 push EAX
 27956 mov ECX,1
// malloc_print(...)
 27959 call #66979
 27962 add ESP,1
 27965 push 28163
 27968 mov ECX,1
// malloc_print(...)
 27971 call #66979
 27974 add ESP,1
 27977 rstack EAX,EBP:2
// allocation_get_owner arg #1 (float* A)
 27981 push EAX
 27983 mov ECX,1
// allocation_get_owner(...)
 27986 call 25590
 27989 add ESP,1
 27992 push EAX
 27994 mov ECX,1
// malloc_num2str(...)
 27997 call #66980
 28000 add ESP,1
 28003 push EAX
 28005 mov ECX,1
// malloc_print(...)
 28008 call #66979
 28011 add ESP,1
 28014 push 28134
 28017 mov ECX,1
// malloc_print(...)
 28020 call #66979
 28023 add ESP,1
 28026 rstack EAX,EBP:2
// allocation_get_prev arg #1 (float* A)
 28030 push EAX
 28032 mov ECX,1
// allocation_get_prev(...)
 28035 call 25608
 28038 add ESP,1
 28041 push EAX
 28043 mov ECX,1
// malloc_num2str(...)
 28046 call #66980
 28049 add ESP,1
 28052 push EAX
 28054 mov ECX,1
// malloc_print(...)
 28057 call #66979
 28060 add ESP,1
 28063 push 28155
 28066 mov ECX,1
// malloc_print(...)
 28069 call #66979
 28072 add ESP,1
 28075 rstack EAX,EBP:2
// allocation_get_next arg #1 (float* A)
 28079 push EAX
 28081 mov ECX,1
// allocation_get_next(...)
 28084 call 25626
 28087 add ESP,1
 28090 push EAX
 28092 mov ECX,1
// malloc_num2str(...)
 28095 call #66980
 28098 add ESP,1
 28101 push EAX
 28103 mov ECX,1
// malloc_print(...)
 28106 call #66979
 28109 add ESP,1
 28112 push 25879
 28115 mov ECX,1
// malloc_print(...)
 28118 call #66979
 28121 add ESP,1
__1173:
 28124 leave 
 28125 ret 
__1176:
 28126 db ", data ",0
__1179:
 28134 db ", prev ",0
__1177:
 28142 db ", size ",0
__1175:
 28150 db "Alc ",0
__1180:
 28155 db ", next ",0
__1178:
 28163 db ", owner ",0
mallocLast:
// mallocLast(n)
 28172 enter 9
__1182:
// malloc_getAllocation arg #1 (float I)
 28175 push #66985
 28178 mov ECX,1
// malloc_getAllocation(...)
 28181 call 25644
 28184 add ESP,1
 28187 sstack EBP:-1,EAX
__1184:
// if (1
 28191 cmp 0,1
 28195 jz 28484
// malloc_debug_iters++
 28198 inc #66986
 28201 rstack EAX,EBP:-1
// allocation_get_owner arg #1 (float* A)
 28205 push EAX
 28207 mov ECX,1
// allocation_get_owner(...)
 28210 call 25590
 28213 add ESP,1
 28216 sstack EBP:-2,EAX
 28220 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 28224 push EAX
 28226 mov ECX,1
// allocation_get_size(...)
 28229 call 25572
 28232 add ESP,1
 28235 sstack EBP:-3,EAX
 28239 rstack EAX,EBP:-2
 28243 mov EBX,0
 28246 sub EBX,EAX
 28248 fabs EBX,EBX
 28250 fsgn EBX,EBX
 28252 lneg EBX
 28254 sstack EBP:-4,EBX
 28258 rstack EAX,EBP:-3
 28262 rstack EBX,EBP:2
 28266 add EBX,-1
 28269 mov ECX,EBX
 28271 sub ECX,EAX
 28273 neg ECX
 28275 fsgn ECX,ECX
 28277 max ECX,0
 28280 sstack EBP:-5,ECX
 28284 rstack EAX,EBP:-5
 28288 rstack EBX,EBP:-4
 28292 and EBX,EAX
 28294 mov EAX,EBX
 28296 sstack EBP:-6,EAX
__1186:
 28300 rstack EAX,EBP:-6
// if (cond)
 28304 cmp 0,EAX
 28307 jge 28414
 28310 rstack EAX,EBP:2
// malloc_trySplit arg #3 (float n)
 28314 push EAX
 28316 mov EAX,SS:EBP
 28319 add EAX,-7
// malloc_trySplit arg #2 (float** returnB)
 28322 push EAX
 28324 rstack EAX,EBP:-1
// malloc_trySplit arg #1 (float* A)
 28328 push EAX
 28330 mov ECX,3
// malloc_trySplit(...)
 28333 call 25970
 28336 add ESP,3
// allocation_set_owner arg #2 (float n)
 28339 push #66984
 28342 rstack EAX,EBP:-1
// allocation_set_owner arg #1 (float* A)
 28346 push EAX
 28348 mov ECX,2
// allocation_set_owner(...)
 28351 call 25512
 28354 add ESP,2
 28357 rstack EAX,EBP:-7
// malloc_getIndex arg #1 (float* ptr)
 28361 push EAX
 28363 mov ECX,1
// malloc_getIndex(...)
 28366 call 25950
 28369 add ESP,1
// lastFreeAllocation=malloc_getIndex(B)
 28372 mov #66985,EAX
 28375 rstack EAX,EBP:-7
// allocation_get_size arg #1 (float* A)
 28379 push EAX
 28381 mov ECX,1
// allocation_get_size(...)
 28384 call 25572
 28387 add ESP,1
 28390 sstack EBP:-8,EAX
 28394 rstack EAX,EBP:-1
// malloc_getDataFromAllocation arg #1 (float* A)
 28398 push EAX
 28400 mov ECX,1
// malloc_getDataFromAllocation(...)
 28403 call 25932
 28406 add ESP,1
 28409 leave 
 28410 ret 
 28411 jmp 28481
__1188:
__1187:
__1190:
__1192:
 28414 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 28418 push EAX
 28420 mov ECX,1
// allocation_get_next(...)
 28423 call 25626
 28426 add ESP,1
// if (allocation_get_next(A))
 28429 cmp 0,EAX
 28432 jge 28476
 28435 rstack EAX,EBP:-1
// allocation_get_next arg #1 (float* A)
 28439 push EAX
 28441 mov ECX,1
// allocation_get_next(...)
 28444 call 25626
 28447 add ESP,1
 28450 sstack EBP:-9,EAX
 28454 rstack EAX,EBP:-9
// malloc_getAllocation arg #1 (float I)
 28458 push EAX
 28460 mov ECX,1
// malloc_getAllocation(...)
 28463 call 25644
 28466 add ESP,1
// A=malloc_getAllocation(tmp)
 28469 sstack EBP:-1,EAX
 28473 jmp 28481
__1194:
__1193:
__1196:
 28476 mov EAX,0
 28479 leave 
 28480 ret 
__1195:
__1191:
__1189:
__1185:
 28481 jmp 28191
__1183:
__1181:
 28484 leave 
 28485 ret 
malloc:
// malloc(n)
 28486 enter 12
__1198:
// malloc_debug_iters=0
 28489 mov #66986,0
 28493 sstack EBP:-2,0
 28498 sstack EBP:-3,0
__1200:
// if (malloc_debug)
 28503 cmp 0,#66978
 28507 jge 28516
 28510 timer EAX
 28512 sstack EBP:-2,EAX
__1201:
__1199:
 28516 rstack EAX,EBP:2
// mallocLast arg #1 (float n)
 28520 push EAX
 28522 mov ECX,1
// mallocLast(...)
 28525 call 28172
 28528 add ESP,1
// res=mallocLast(n)
 28531 sstack EBP:-1,EAX
__1203:
 28535 rstack EAX,EBP:-1
// if (res)
 28539 cmp 0,EAX
 28542 jge 28548
 28545 jmp 28878
__1204:
__1202:
// malloc_getAllocation arg #1 (float I)
 28548 push 1
 28551 mov ECX,1
// malloc_getAllocation(...)
 28554 call 25644
 28557 add ESP,1
 28560 sstack EBP:-4,EAX
__1206:
// if (1
 28564 cmp 0,1
 28568 jz 28878
// malloc_debug_iters++
 28571 inc #66986
 28574 rstack EAX,EBP:-4
// allocation_get_owner arg #1 (float* A)
 28578 push EAX
 28580 mov ECX,1
// allocation_get_owner(...)
 28583 call 25590
 28586 add ESP,1
 28589 sstack EBP:-5,EAX
 28593 rstack EAX,EBP:-4
// allocation_get_size arg #1 (float* A)
 28597 push EAX
 28599 mov ECX,1
// allocation_get_size(...)
 28602 call 25572
 28605 add ESP,1
 28608 sstack EBP:-6,EAX
 28612 rstack EAX,EBP:-5
 28616 mov EBX,0
 28619 sub EBX,EAX
 28621 fabs EBX,EBX
 28623 fsgn EBX,EBX
 28625 lneg EBX
 28627 sstack EBP:-7,EBX
 28631 rstack EAX,EBP:-6
 28635 rstack EBX,EBP:2
 28639 add EBX,-1
 28642 mov ECX,EBX
 28644 sub ECX,EAX
 28646 neg ECX
 28648 fsgn ECX,ECX
 28650 max ECX,0
 28653 sstack EBP:-8,ECX
 28657 rstack EAX,EBP:-8
 28661 rstack EBX,EBP:-7
 28665 and EBX,EAX
 28667 mov EAX,EBX
 28669 sstack EBP:-9,EAX
__1208:
 28673 rstack EAX,EBP:-9
// if (cond)
 28677 cmp 0,EAX
 28680 jge 28768
__1211:
 28683 rstack EAX,EBP:2
// malloc_trySplit arg #3 (float n)
 28687 push EAX
 28689 mov EAX,SS:EBP
 28692 add EAX,-10
// malloc_trySplit arg #2 (float** returnB)
 28695 push EAX
 28697 rstack EAX,EBP:-4
// malloc_trySplit arg #1 (float* A)
 28701 push EAX
 28703 mov ECX,3
// malloc_trySplit(...)
 28706 call 25970
 28709 add ESP,3
// if (malloc_trySplit(A,&B,n))
 28712 cmp 0,EAX
 28715 jge 28721
 28718 jmp 28725
__1213:
__1212:
__1215:
// lastFreeAllocation=1
 28721 mov #66985,1
__1214:
__1210:
// allocation_set_owner arg #2 (float n)
 28725 push #66984
 28728 rstack EAX,EBP:-4
// allocation_set_owner arg #1 (float* A)
 28732 push EAX
 28734 mov ECX,2
// allocation_set_owner(...)
 28737 call 25512
 28740 add ESP,2
 28743 rstack EAX,EBP:-4
// malloc_getDataFromAllocation arg #1 (float* A)
 28747 push EAX
 28749 mov ECX,1
// malloc_getDataFromAllocation(...)
 28752 call 25932
 28755 add ESP,1
// res=malloc_getDataFromAllocation(A)
 28758 sstack EBP:-1,EAX
 28762 jmp 28878
 28765 jmp 28875
__1216:
__1209:
__1218:
__1220:
 28768 rstack EAX,EBP:-4
// allocation_get_next arg #1 (float* A)
 28772 push EAX
 28774 mov ECX,1
// allocation_get_next(...)
 28777 call 25626
 28780 add ESP,1
// if (allocation_get_next(A))
 28783 cmp 0,EAX
 28786 jge 28830
 28789 rstack EAX,EBP:-4
// allocation_get_next arg #1 (float* A)
 28793 push EAX
 28795 mov ECX,1
// allocation_get_next(...)
 28798 call 25626
 28801 add ESP,1
 28804 sstack EBP:-11,EAX
 28808 rstack EAX,EBP:-11
// malloc_getAllocation arg #1 (float I)
 28812 push EAX
 28814 mov ECX,1
// malloc_getAllocation(...)
 28817 call 25644
 28820 add ESP,1
// A=malloc_getAllocation(tmp)
 28823 sstack EBP:-4,EAX
 28827 jmp 28875
__1222:
__1221:
__1224:
__1226:
// if (malloc_debug)
 28830 cmp 0,#66978
 28834 jge 28849
 28837 push 28919
 28840 mov ECX,1
// malloc_print(...)
 28843 call #66979
 28846 add ESP,1
__1227:
__1225:
// printf arg #2 (unknown)
 28849 push 900
// printf arg #1 (char* format)
 28852 push 28951
 28855 mov ECX,2
// printf(...)
 28858 call 21772
 28861 add ESP,2
 28864 mov ECX,0
// panic(...)
 28867 call 85274
 28870 mov EAX,0
 28873 leave 
 28874 ret 
__1223:
__1219:
__1217:
__1207:
 28875 jmp 28564
__1205:
malloc_goodreturn:
__1231:
// if (malloc_debug)
 28878 cmp 0,#66978
 28882 jge 28911
 28885 timer EAX
 28887 sstack EBP:-3,EAX
 28891 rstack EAX,EBP:-2
 28895 neg EAX
 28897 mov EBX,EAX
 28899 rstack EAX,EBP:-3
 28903 add EAX,EBX
 28905 mov EBX,EAX
 28907 sstack EBP:-12,EBX
__1232:
__1230:
 28911 rstack EAX,EBP:-1
 28915 leave 
 28916 ret 
__1197:
 28917 leave 
 28918 ret 
__1228:
 28919 db "malloc: no memory, returning 0
",0
__1229:
 28951 db "%mERROR MALLOC FAILED PANIC
",0
free:
// free(ptr)
 28980 enter 6
__1234:
__1236:
// if (malloc_debug)
 28983 cmp 0,#66978
 28987 jge 29040
 28990 push 29437
 28993 mov ECX,1
// malloc_print(...)
 28996 call #66979
 28999 add ESP,1
 29002 rstack EAX,EBP:2
 29006 push EAX
 29008 mov ECX,1
// malloc_num2str(...)
 29011 call #66980
 29014 add ESP,1
 29017 push EAX
 29019 mov ECX,1
// malloc_print(...)
 29022 call #66979
 29025 add ESP,1
 29028 push 27331
 29031 mov ECX,1
// malloc_print(...)
 29034 call #66979
 29037 add ESP,1
__1237:
__1235:
__1240:
 29040 rstack EAX,EBP:2
 29044 mov EBX,1
 29047 add EBX,#66983
 29050 mov ECX,#66981
 29053 add ECX,EBX
 29055 sub ECX,EAX
 29057 fsgn ECX,ECX
 29059 max ECX,0
// if (ptr<malloc_disk+1+malloc_header)
 29062 cmp 0,ECX
 29065 jge 29138
__1243:
// if (malloc_debug)
 29068 cmp 0,#66978
 29072 jge 29136
 29075 push 29443
 29078 mov ECX,1
// malloc_print(...)
 29081 call #66979
 29084 add ESP,1
 29087 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 29091 push EAX
 29093 mov ECX,1
// malloc_getIndex(...)
 29096 call 25950
 29099 add ESP,1
 29102 push EAX
 29104 mov ECX,1
// malloc_num2str(...)
 29107 call #66980
 29110 add ESP,1
 29113 push EAX
 29115 mov ECX,1
// malloc_print(...)
 29118 call #66979
 29121 add ESP,1
 29124 push 27331
 29127 mov ECX,1
// malloc_print(...)
 29130 call #66979
 29133 add ESP,1
__1244:
__1242:
 29136 leave 
 29137 ret 
__1241:
__1239:
 29138 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 29142 push EAX
 29144 mov ECX,1
// malloc_getIndex(...)
 29147 call 25950
 29150 add ESP,1
 29153 sstack EBP:-1,EAX
 29157 mov EAX,#66983
 29160 neg EAX
 29162 rstack EBX,EBP:-1
 29166 add EBX,EAX
 29168 mov EAX,EBX
// tmp=tmp-malloc_header
 29170 sstack EBP:-1,EAX
 29174 rstack EAX,EBP:-1
// malloc_getAllocation arg #1 (float I)
 29178 push EAX
 29180 mov ECX,1
// malloc_getAllocation(...)
 29183 call 25644
 29186 add ESP,1
// tmp=malloc_getAllocation(tmp)
 29189 sstack EBP:-1,EAX
 29193 rstack EAX,EBP:-1
 29197 sstack EBP:-2,EAX
// allocation_set_owner arg #2 (float n)
 29201 push 0
 29204 rstack EAX,EBP:-2
// allocation_set_owner arg #1 (float* A)
 29208 push EAX
 29210 mov ECX,2
// allocation_set_owner(...)
 29213 call 25512
 29216 add ESP,2
free_loop1:
 29219 rstack EAX,EBP:-2
// allocation_get_prev arg #1 (float* A)
 29223 push EAX
 29225 mov ECX,1
// allocation_get_prev(...)
 29228 call 25608
 29231 add ESP,1
// prev=allocation_get_prev(A)
 29234 sstack EBP:-3,EAX
__1247:
 29238 rstack EAX,EBP:-3
// if (prev)
 29242 cmp 0,EAX
 29245 jge 29331
 29248 rstack EAX,EBP:-3
// malloc_getAllocation arg #1 (float I)
 29252 push EAX
 29254 mov ECX,1
// malloc_getAllocation(...)
 29257 call 25644
 29260 add ESP,1
// prevA=malloc_getAllocation(prev)
 29263 sstack EBP:-4,EAX
__1250:
 29267 rstack EAX,EBP:-4
// allocation_get_owner arg #1 (float* A)
 29271 push EAX
 29273 mov ECX,1
// allocation_get_owner(...)
 29276 call 25590
 29279 add ESP,1
 29282 mov EBX,0
 29285 sub EBX,EAX
 29287 fabs EBX,EBX
 29289 fsgn EBX,EBX
 29291 lneg EBX
// if (allocation_get_owner(prevA)==0)
 29293 cmp 0,EBX
 29296 jge 29331
 29299 rstack EAX,EBP:-2
// malloc_join arg #2 (float* B)
 29303 push EAX
 29305 rstack EAX,EBP:-4
// malloc_join arg #1 (float* A)
 29309 push EAX
 29311 mov ECX,2
// malloc_join(...)
 29314 call 26565
 29317 add ESP,2
 29320 rstack EAX,EBP:-4
// A=prevA
 29324 sstack EBP:-2,EAX
 29328 jmp 29219
__1251:
__1249:
__1248:
__1246:
free_loop2:
 29331 rstack EAX,EBP:-2
// allocation_get_next arg #1 (float* A)
 29335 push EAX
 29337 mov ECX,1
// allocation_get_next(...)
 29340 call 25626
 29343 add ESP,1
// next=allocation_get_next(A)
 29346 sstack EBP:-5,EAX
__1253:
 29350 rstack EAX,EBP:-5
// if (next)
 29354 cmp 0,EAX
 29357 jge 29435
 29360 rstack EAX,EBP:-5
// malloc_getAllocation arg #1 (float I)
 29364 push EAX
 29366 mov ECX,1
// malloc_getAllocation(...)
 29369 call 25644
 29372 add ESP,1
// nextA=malloc_getAllocation(next)
 29375 sstack EBP:-6,EAX
__1256:
 29379 rstack EAX,EBP:-6
// allocation_get_owner arg #1 (float* A)
 29383 push EAX
 29385 mov ECX,1
// allocation_get_owner(...)
 29388 call 25590
 29391 add ESP,1
 29394 mov EBX,0
 29397 sub EBX,EAX
 29399 fabs EBX,EBX
 29401 fsgn EBX,EBX
 29403 lneg EBX
// if (allocation_get_owner(nextA)==0)
 29405 cmp 0,EBX
 29408 jge 29435
 29411 rstack EAX,EBP:-6
// malloc_join arg #2 (float* B)
 29415 push EAX
 29417 rstack EAX,EBP:-2
// malloc_join arg #1 (float* A)
 29421 push EAX
 29423 mov ECX,2
// malloc_join(...)
 29426 call 26565
 29429 add ESP,2
 29432 jmp 29331
__1257:
__1255:
__1254:
__1252:
__1233:
 29435 leave 
 29436 ret 
__1238:
 29437 db "free(",0
__1245:
 29443 db "free: null pointer (index ",0
realloc:
// realloc(ptr,n)
 29470 enter 4
__1259:
 29473 rstack EAX,EBP:3
// malloc arg #1 (float n)
 29477 push EAX
 29479 mov ECX,1
// malloc(...)
 29482 call 28486
 29485 add ESP,1
 29488 sstack EBP:-1,EAX
__1261:
 29492 rstack EAX,EBP:-1
// if (newp)
 29496 cmp 0,EAX
 29499 jge 29704
__1264:
 29502 rstack EAX,EBP:2
// if (ptr)
 29506 cmp 0,EAX
 29509 jge 29695
 29512 rstack EAX,EBP:2
// malloc_getIndex arg #1 (float* ptr)
 29516 push EAX
 29518 mov ECX,1
// malloc_getIndex(...)
 29521 call 25950
 29524 add ESP,1
 29527 sstack EBP:-2,EAX
 29531 mov EAX,#66983
 29534 neg EAX
 29536 rstack EBX,EBP:-2
 29540 add EBX,EAX
 29542 mov EAX,EBX
// tmp=tmp-malloc_header
 29544 sstack EBP:-2,EAX
 29548 rstack EAX,EBP:-2
// malloc_getAllocation arg #1 (float I)
 29552 push EAX
 29554 mov ECX,1
// malloc_getAllocation(...)
 29557 call 25644
 29560 add ESP,1
// tmp=malloc_getAllocation(tmp)
 29563 sstack EBP:-2,EAX
 29567 rstack EAX,EBP:-2
 29571 sstack EBP:-3,EAX
 29575 rstack EAX,EBP:-3
// allocation_get_size arg #1 (float* A)
 29579 push EAX
 29581 mov ECX,1
// allocation_get_size(...)
 29584 call 25572
 29587 add ESP,1
 29590 sstack EBP:-4,EAX
__1267:
 29594 rstack EAX,EBP:3
 29598 rstack EBX,EBP:-4
 29602 sub EBX,EAX
 29604 mov EAX,EBX
 29606 fsgn EAX,EAX
 29608 max EAX,0
// if (n<size)
 29611 cmp 0,EAX
 29614 jge 29625
 29617 rstack EAX,EBP:3
// size=n
 29621 sstack EBP:-4,EAX
__1268:
__1266:
 29625 rstack EAX,EBP:-3
// malloc_getDataFromAllocation arg #1 (float* A)
 29629 push EAX
 29631 mov ECX,1
// malloc_getDataFromAllocation(...)
 29634 call 25932
 29637 add ESP,1
// tmp=malloc_getDataFromAllocation(A)
 29640 sstack EBP:-2,EAX
 29644 rstack EAX,EBP:-4
 29648 push EAX
 29650 rstack EAX,EBP:-1
 29654 push EAX
 29656 rstack EAX,EBP:-2
 29660 push EAX
 29662 mov ECX,3
// malloc_memcopy(...)
 29665 call 29711
 29668 add ESP,3
 29671 rstack EAX,EBP:2
// free arg #1 (float* ptr)
 29675 push EAX
 29677 mov ECX,1
// free(...)
 29680 call 28980
 29683 add ESP,1
 29686 rstack EAX,EBP:-1
 29690 leave 
 29691 ret 
 29692 jmp 29701
__1269:
__1265:
__1271:
 29695 rstack EAX,EBP:-1
 29699 leave 
 29700 ret 
__1270:
__1263:
 29701 jmp 29709
__1272:
__1262:
__1274:
 29704 mov EAX,0
 29707 leave 
 29708 ret 
__1273:
__1260:
__1258:
 29709 leave 
 29710 ret 
malloc_memcopy:
// malloc_memcopy(from,to,n)
 29711 enter 1
__1276:
// init loop
 29714 sstack EBP:-1,0
__1278:
 29719 rstack EAX,EBP:-1
 29723 rstack EBX,EBP:4
 29727 sub EBX,EAX
 29729 mov EAX,EBX
 29731 fsgn EAX,EAX
// condition
 29733 max EAX,0
 29736 cmp 0,EAX
 29739 jz 29791
 29742 rstack EAX,EBP:2
 29746 rstack EBX,EBP:3
// *to=*from
 29750 mov #EBX,#EAX
 29752 rstack EAX,EBP:3
 29756 add EAX,1
 29759 mov EBX,EAX
// to=to+1
 29761 sstack EBP:3,EBX
 29765 rstack EAX,EBP:2
 29769 add EAX,1
 29772 mov EBX,EAX
// from=from+1
 29774 sstack EBP:2,EBX
 29778 rstack EAX,EBP:-1
// loop step
 29782 inc EAX
 29784 sstack EBP:-1,EAX
 29788 jmp 29719
__1277:
__1275:
 29791 leave 
 29792 ret 
str_alloc:
// str_alloc(str)
 29793 enter 2
__1280:
 29796 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 29800 push EAX
 29802 mov ECX,1
// strlen(...)
 29805 call 11121
 29808 add ESP,1
 29811 add EAX,1
 29814 sstack EBP:-1,EAX
 29818 rstack EAX,EBP:-1
// malloc arg #1 (float n)
 29822 push EAX
 29824 mov ECX,1
// malloc(...)
 29827 call 28486
 29830 add ESP,1
 29833 sstack EBP:-2,EAX
 29837 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 29841 push EAX
 29843 rstack EAX,EBP:-2
// strcpy arg #1 (char* dest)
 29847 push EAX
 29849 mov ECX,2
// strcpy(...)
 29852 call 10963
 29855 add ESP,2
 29858 rstack EAX,EBP:-2
 29862 leave 
 29863 ret 
__1279:
 29864 leave 
 29865 ret 
lfa_check:
// lfa_check(str)
 29866 enter 2
__1282:
// malloc_getAllocation arg #1 (float I)
 29869 push #66985
 29872 mov ECX,1
// malloc_getAllocation(...)
 29875 call 25644
 29878 add ESP,1
 29881 sstack EBP:-1,EAX
 29885 rstack EAX,EBP:-1
// allocation_get_size arg #1 (float* A)
 29889 push EAX
 29891 mov ECX,1
// allocation_get_size(...)
 29894 call 25572
 29897 add ESP,1
 29900 sstack EBP:-2,EAX
 29904 rstack EAX,EBP:-2
// printf arg #5 (unknown)
 29908 push EAX
 29910 rstack EAX,EBP:-1
// printf arg #4 (unknown)
 29914 push EAX
// printf arg #3 (unknown)
 29916 push #66985
 29919 rstack EAX,EBP:2
// printf arg #2 (unknown)
 29923 push EAX
// printf arg #1 (char* format)
 29925 push 29939
 29928 mov ECX,5
// printf(...)
 29931 call 21772
 29934 add ESP,5
__1281:
 29937 leave 
 29938 ret 
__1283:
 29939 db "%s lfAidx = %d, lfA = %d, lfAsize = %d
",0
ZMALLOC_CONSTANTS:
ZMALLOC_END:
libmarker12:
 29979 db 0
LIBNUMBER_CODE:
pow:
// pow(A,B)
 29980 enter -0
__1285:
 29983 rstack EAX,EBP:3
 29987 rstack EBX,EBP:2
 29991 fpwr EBX,EAX
 29993 mov EAX,EBX
 29995 leave 
 29996 ret 
__1284:
 29997 leave 
 29998 ret 
modulo:
// modulo(A,B)
 29999 enter -0
__1287:
 30002 rstack EAX,EBP:3
 30006 rstack EBX,EBP:2
 30010 mod EBX,EAX
 30012 sstack EBP:2,EBX
 30016 rstack EAX,EBP:2
 30020 leave 
 30021 ret 
__1286:
 30022 leave 
 30023 ret 
sqrt:
// sqrt(A)
 30024 enter -0
__1289:
 30027 rstack EAX,EBP:2
 30031 fpwr EAX,0.5
 30034 mov EBX,EAX
 30036 mov EAX,EBX
 30038 leave 
 30039 ret 
__1288:
 30040 leave 
 30041 ret 
cbrt:
// cbrt(A)
 30042 enter -0
__1291:
 30045 rstack EAX,EBP:2
 30049 fpwr EAX,0.33333333333333
 30052 mov EBX,EAX
 30054 mov EAX,EBX
 30056 leave 
 30057 ret 
__1290:
 30058 leave 
 30059 ret 
root:
// root(A,B)
 30060 enter -0
__1293:
 30063 rstack EAX,EBP:3
 30067 mov EBX,1
 30070 div EBX,EAX
 30072 rstack EAX,EBP:2
 30076 fpwr EAX,EBX
 30078 mov EBX,EAX
 30080 mov EAX,EBX
 30082 leave 
 30083 ret 
__1292:
 30084 leave 
 30085 ret 
e:
// e()
 30086 enter -0
__1295:
 30089 fe EAX
 30091 leave 
 30092 ret 
__1294:
 30093 leave 
 30094 ret 
exp:
// exp(A)
 30095 enter -0
__1297:
 30098 fpi EAX
 30100 rstack EBX,EBP:2
 30104 fpwr EAX,EBX
 30106 leave 
 30107 ret 
__1296:
 30108 leave 
 30109 ret 
ln:
// ln(A)
 30110 enter -0
__1299:
 30113 rstack EBX,EBP:2
 30117 mov EAX,EBX
 30119 fln EDX,EAX
 30121 mov EAX,EDX
 30123 leave 
 30124 ret 
__1298:
 30125 leave 
 30126 ret 
log2:
// log2(A)
 30127 enter -0
__1301:
 30130 rstack EBX,EBP:2
 30134 mov EAX,EBX
 30136 fln EDX,EAX
 30138 fln ECX,2
 30141 mov EBX,EDX
 30143 div EBX,ECX
 30145 mov EAX,EBX
 30147 leave 
 30148 ret 
__1300:
 30149 leave 
 30150 ret 
log10:
// log10(A)
 30151 enter -0
__1303:
 30154 flog10 EDX,EAX
 30156 mov EAX,EDX
 30158 leave 
 30159 ret 
__1302:
 30160 leave 
 30161 ret 
log:
// log(A,B)
 30162 enter -0
__1305:
 30165 rstack ESI,EBP:2
 30169 mov EAX,ESI
 30171 rstack ESI,EBP:3
 30175 mov EBX,ESI
 30177 fln EDX,EAX
 30179 fln ECX,EBX
 30181 div EDX,ECX
 30183 mov EAX,EDX
 30185 leave 
 30186 ret 
__1304:
 30187 leave 
 30188 ret 
abs:
// abs(A)
 30189 enter -0
__1307:
 30192 rstack EBX,EBP:2
 30196 mov EAX,EBX
 30198 fabs EDX,EAX
 30200 mov EAX,EDX
 30202 leave 
 30203 ret 
__1306:
 30204 leave 
 30205 ret 
ceil:
// ceil(A)
 30206 enter -0
__1309:
 30209 rstack EBX,EBP:2
 30213 mov EAX,EBX
 30215 fceil EAX
 30217 leave 
 30218 ret 
__1308:
 30219 leave 
 30220 ret 
floor:
// floor(A)
 30221 enter -0
__1311:
 30224 rstack EBX,EBP:2
 30228 mov EAX,EBX
 30230 fint EAX
 30232 leave 
 30233 ret 
__1310:
 30234 leave 
 30235 ret 
round:
// round(A)
 30236 enter -0
__1313:
 30239 rstack EBX,EBP:2
 30243 mov EAX,EBX
 30245 frnd EAX
 30247 leave 
 30248 ret 
__1312:
 30249 leave 
 30250 ret 
integer:
// integer(A)
 30251 enter -0
__1315:
 30254 rstack EBX,EBP:2
 30258 mov EAX,EBX
 30260 fint EAX
 30262 leave 
 30263 ret 
__1314:
 30264 leave 
 30265 ret 
frac:
// frac(A)
 30266 enter -0
__1317:
 30269 rstack EBX,EBP:2
 30273 mov EAX,EBX
 30275 ffrac EAX
 30277 leave 
 30278 ret 
__1316:
 30279 leave 
 30280 ret 
clamp:
// clamp(A,MinA,MaxA)
 30281 enter -0
__1319:
 30284 rstack EBX,EBP:2
 30288 mov EAX,EBX
 30290 rstack EBX,EBP:3
 30294 max EAX,EBX
 30296 rstack EBX,EBP:4
 30300 min EAX,EBX
 30302 leave 
 30303 ret 
__1318:
 30304 leave 
 30305 ret 
inrange:
// inrange(A,MinA,MaxA)
 30306 enter -0
__1321:
 30309 rstack EAX,EBP:2
 30313 rstack EBX,EBP:4
 30317 sub EBX,EAX
 30319 mov EAX,EBX
 30321 fsgn EAX,EAX
 30323 max EAX,0
 30326 rstack EBX,EBP:2
 30330 rstack ECX,EBP:3
 30334 sub ECX,EBX
 30336 mov EBX,ECX
 30338 neg EBX
 30340 fsgn EBX,EBX
 30342 max EBX,0
 30345 and EBX,EAX
 30347 mov EAX,EBX
 30349 leave 
 30350 ret 
__1320:
 30351 leave 
 30352 ret 
minimal:
// minimal(A,B)
 30353 enter -0
__1323:
 30356 rstack ECX,EBP:2
 30360 mov EAX,ECX
 30362 rstack ECX,EBP:3
 30366 mov EBX,ECX
 30368 min EAX,EBX
 30370 leave 
 30371 ret 
__1322:
 30372 leave 
 30373 ret 
maximal:
// maximal(A,B)
 30374 enter -0
__1325:
 30377 rstack ECX,EBP:2
 30381 mov EAX,ECX
 30383 rstack ECX,EBP:3
 30387 mov EBX,ECX
 30389 max EAX,EBX
 30391 leave 
 30392 ret 
__1324:
 30393 leave 
 30394 ret 
random:
// random()
 30395 enter -0
__1327:
 30398 rand EAX
 30400 leave 
 30401 ret 
__1326:
 30402 leave 
 30403 ret 
random1:
// random1(A)
 30404 enter -0
__1329:
 30407 rstack EBX,EBP:2
 30411 mov EAX,EBX
 30413 rand EDX
 30415 mul EDX,EAX
 30417 mov EAX,EDX
 30419 leave 
 30420 ret 
__1328:
 30421 leave 
 30422 ret 
random2:
// random2(A,B)
 30423 enter -0
__1331:
 30426 rstack ECX,EBP:2
 30430 mov EAX,ECX
 30432 rstack ECX,EBP:3
 30436 mov EBX,ECX
 30438 rand EDX
 30440 sub EBX,EAX
 30442 mul EDX,EBX
 30444 add EDX,EAX
 30446 mov EAX,EDX
 30448 leave 
 30449 ret 
__1330:
 30450 leave 
 30451 ret 
randint1:
// randint1(A)
 30452 enter -0
__1333:
 30455 rstack EBX,EBP:2
 30459 mov EAX,EBX
 30461 rand EDX
 30463 mul EDX,EAX
 30465 fint EDX
 30467 mov EAX,EDX
 30469 leave 
 30470 ret 
__1332:
 30471 leave 
 30472 ret 
randint2:
// randint2(A,B)
 30473 enter -0
__1335:
 30476 rstack ECX,EBP:2
 30480 mov EAX,ECX
 30482 rstack ECX,EBP:3
 30486 mov EBX,ECX
 30488 rand EDX
 30490 sub EBX,EAX
 30492 mul EDX,EBX
 30494 add EDX,EAX
 30496 fint EDX
 30498 mov EAX,EDX
 30500 leave 
 30501 ret 
__1334:
 30502 leave 
 30503 ret 
pi:
// pi()
 30504 enter -0
__1337:
 30507 fpi EAX
 30509 leave 
 30510 ret 
__1336:
 30511 leave 
 30512 ret 
toRad:
// toRad(N)
 30513 enter -0
__1339:
 30516 rstack ECX,EBP:2
 30520 mov EAX,ECX
 30522 fpi EBX
 30524 mul EAX,EBX
 30526 div EAX,180
 30529 leave 
 30530 ret 
__1338:
 30531 leave 
 30532 ret 
toDeg:
// toDeg(N)
 30533 enter -0
__1341:
 30536 rstack ECX,EBP:2
 30540 mov EAX,ECX
 30542 fpi EBX
 30544 mul EAX,180
 30547 div EAX,EBX
 30549 leave 
 30550 ret 
__1340:
 30551 leave 
 30552 ret 
sin:
// sin(N)
 30553 enter -0
__1343:
 30556 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30560 push EBX
 30562 mov ECX,1
// toRad(...)
 30565 call 30513
 30568 add ESP,1
 30571 fsin EAX,EAX
 30573 leave 
 30574 ret 
__1342:
 30575 leave 
 30576 ret 
cos:
// cos(N)
 30577 enter -0
__1345:
 30580 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30584 push EBX
 30586 mov ECX,1
// toRad(...)
 30589 call 30513
 30592 add ESP,1
 30595 fcos EAX,EAX
 30597 leave 
 30598 ret 
__1344:
 30599 leave 
 30600 ret 
tan:
// tan(N)
 30601 enter -0
__1347:
 30604 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30608 push EBX
 30610 mov ECX,1
// toRad(...)
 30613 call 30513
 30616 add ESP,1
 30619 ftan EAX,EAX
 30621 leave 
 30622 ret 
__1346:
 30623 leave 
 30624 ret 
cot:
// cot(N)
 30625 enter -0
__1349:
 30628 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30632 push EBX
 30634 mov ECX,1
// toRad(...)
 30637 call 30513
 30640 add ESP,1
 30643 ftan EAX,EAX
 30645 finv EAX
 30647 leave 
 30648 ret 
__1348:
 30649 leave 
 30650 ret 
sec:
// sec(N)
 30651 enter -0
__1351:
 30654 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30658 push EBX
 30660 mov ECX,1
// toRad(...)
 30663 call 30513
 30666 add ESP,1
 30669 fcos EAX,EAX
 30671 finv EAX
 30673 leave 
 30674 ret 
__1350:
 30675 leave 
 30676 ret 
csc:
// csc(N)
 30677 enter -0
__1353:
 30680 rstack EBX,EBP:2
// toRad arg #1 (float N)
 30684 push EBX
 30686 mov ECX,1
// toRad(...)
 30689 call 30513
 30692 add ESP,1
 30695 fsin EAX,EAX
 30697 finv EAX
 30699 leave 
 30700 ret 
__1352:
 30701 leave 
 30702 ret 
asin:
// asin(N)
 30703 enter -0
__1355:
 30706 rstack EBX,EBP:2
 30710 fasin EAX,EBX
// toDeg arg #1 (float N)
 30712 push EAX
 30714 mov ECX,1
// toDeg(...)
 30717 call 30533
 30720 add ESP,1
 30723 leave 
 30724 ret 
__1354:
 30725 leave 
 30726 ret 
acos:
// acos(N)
 30727 enter -0
__1357:
 30730 rstack EBX,EBP:2
 30734 facos EAX,EBX
// toDeg arg #1 (float N)
 30736 push EAX
 30738 mov ECX,1
// toDeg(...)
 30741 call 30533
 30744 add ESP,1
 30747 leave 
 30748 ret 
__1356:
 30749 leave 
 30750 ret 
atan:
// atan(N)
 30751 enter -0
__1359:
 30754 rstack EBX,EBP:2
 30758 fatan EAX,EBX
// toDeg arg #1 (float N)
 30760 push EAX
 30762 mov ECX,1
// toDeg(...)
 30765 call 30533
 30768 add ESP,1
 30771 leave 
 30772 ret 
__1358:
 30773 leave 
 30774 ret 
sinh:
// sinh(N)
 30775 enter -0
__1361:
 30778 fe EAX
 30780 rstack EBX,EBP:2
 30784 neg EBX
 30786 mov ECX,EBX
 30788 mov EBX,EAX
 30790 neg EBX
 30792 fpwr EBX,ECX
 30794 rstack ECX,EBP:2
 30798 mov EDX,EAX
 30800 fpwr EDX,ECX
 30802 add EDX,EBX
 30804 mov EBX,0.5
 30807 mul EBX,EDX
 30809 mov EAX,EBX
 30811 leave 
 30812 ret 
__1360:
 30813 leave 
 30814 ret 
cosh:
// cosh(N)
 30815 enter -0
__1363:
 30818 fe EAX
 30820 rstack EBX,EBP:2
 30824 neg EBX
 30826 mov ECX,EBX
 30828 mov EBX,EAX
 30830 fpwr EBX,ECX
 30832 rstack ECX,EBP:2
 30836 mov EDX,EAX
 30838 fpwr EDX,ECX
 30840 add EDX,EBX
 30842 mov EBX,0.5
 30845 mul EBX,EDX
 30847 mov EAX,EBX
 30849 leave 
 30850 ret 
__1362:
 30851 leave 
 30852 ret 
tanh:
// tanh(N)
 30853 enter -0
__1365:
 30856 fe EAX
 30858 rstack EBX,EBP:2
 30862 mov ECX,2
 30865 mul ECX,EBX
 30867 mov EBX,EAX
 30869 fpwr EBX,ECX
 30871 add EBX,1
 30874 rstack ECX,EBP:2
 30878 mov EDX,2
 30881 mul EDX,ECX
 30883 mov ECX,EAX
 30885 fpwr ECX,EDX
 30887 add ECX,-1
 30890 div ECX,EBX
 30892 mov EAX,ECX
 30894 leave 
 30895 ret 
__1364:
 30896 leave 
 30897 ret 
coth:
// coth(N)
 30898 enter -0
__1367:
 30901 fe EAX
 30903 rstack EBX,EBP:2
 30907 mov ECX,2
 30910 mul ECX,EBX
 30912 mov EBX,EAX
 30914 fpwr EBX,ECX
 30916 add EBX,-1
 30919 rstack ECX,EBP:2
 30923 mov EDX,2
 30926 mul EDX,ECX
 30928 mov ECX,EAX
 30930 fpwr ECX,EDX
 30932 add ECX,1
 30935 div ECX,EBX
 30937 mov EAX,ECX
 30939 leave 
 30940 ret 
__1366:
 30941 leave 
 30942 ret 
sech:
// sech(N)
 30943 enter -0
__1369:
 30946 fe EAX
 30948 rstack EBX,EBP:2
 30952 neg EBX
 30954 mov ECX,EBX
 30956 mov EBX,EAX
 30958 fpwr EBX,ECX
 30960 rstack ECX,EBP:2
 30964 mov EDX,EAX
 30966 fpwr EDX,ECX
 30968 add EDX,EBX
 30970 mov EBX,2
 30973 div EBX,EDX
 30975 mov EAX,EBX
 30977 leave 
 30978 ret 
__1368:
 30979 leave 
 30980 ret 
csch:
// csch(N)
 30981 enter -0
__1371:
 30984 fe EAX
 30986 rstack EBX,EBP:2
 30990 neg EBX
 30992 mov ECX,EBX
 30994 mov EBX,EAX
 30996 neg EBX
 30998 fpwr EBX,ECX
 31000 rstack ECX,EBP:2
 31004 mov EDX,EAX
 31006 fpwr EDX,ECX
 31008 add EDX,EBX
 31010 mov EBX,2
 31013 div EBX,EDX
 31015 mov EAX,EBX
 31017 leave 
 31018 ret 
__1370:
 31019 leave 
 31020 ret 
sinr:
// sinr(N)
 31021 enter -0
__1373:
 31024 rstack EBX,EBP:2
 31028 fsin EAX,EBX
 31030 leave 
 31031 ret 
__1372:
 31032 leave 
 31033 ret 
cosr:
// cosr(N)
 31034 enter -0
__1375:
 31037 rstack EBX,EBP:2
 31041 fcos EAX,EBX
 31043 leave 
 31044 ret 
__1374:
 31045 leave 
 31046 ret 
tanr:
// tanr(N)
 31047 enter -0
__1377:
 31050 rstack EBX,EBP:2
 31054 ftan EAX,EBX
 31056 leave 
 31057 ret 
__1376:
 31058 leave 
 31059 ret 
cotr:
// cotr(N)
 31060 enter -0
__1379:
 31063 rstack EBX,EBP:2
 31067 ftan EAX,EBX
 31069 finv EAX
 31071 leave 
 31072 ret 
__1378:
 31073 leave 
 31074 ret 
secr:
// secr(N)
 31075 enter -0
__1381:
 31078 rstack EBX,EBP:2
 31082 fcos EAX,EBX
 31084 finv EAX
 31086 leave 
 31087 ret 
__1380:
 31088 leave 
 31089 ret 
cscr:
// cscr(N)
 31090 enter -0
__1383:
 31093 rstack EBX,EBP:2
 31097 fsin EAX,EBX
 31099 finv EAX
 31101 leave 
 31102 ret 
__1382:
 31103 leave 
 31104 ret 
asinr:
// asinr(N)
 31105 enter -0
__1385:
 31108 rstack EBX,EBP:2
 31112 fasin EAX,EBX
 31114 leave 
 31115 ret 
__1384:
 31116 leave 
 31117 ret 
acosr:
// acosr(N)
 31118 enter -0
__1387:
 31121 rstack EBX,EBP:2
 31125 facos EAX,EBX
 31127 leave 
 31128 ret 
__1386:
 31129 leave 
 31130 ret 
atanr:
// atanr(N)
 31131 enter -0
__1389:
 31134 rstack EBX,EBP:2
 31138 fatan EAX,EBX
 31140 leave 
 31141 ret 
__1388:
 31142 leave 
 31143 ret 
ceil2:
// ceil2(A,B)
 31144 enter -0
__1391:
 31147 rstack ECX,EBP:2
 31151 mov EAX,ECX
 31153 rstack ECX,EBP:3
 31157 mov EBX,ECX
 31159 mov EDX,10
 31162 fpwr EBX,EDX
 31164 rstack ECX,EBP:3
 31168 div EAX,ECX
 31170 mov EDX,EAX
 31172 fceil EDX
 31174 mul EDX,EBX
 31176 mov EAX,EDX
 31178 leave 
 31179 ret 
__1390:
 31180 leave 
 31181 ret 
floor2:
// floor2(A,B)
 31182 enter -0
__1393:
 31185 rstack ECX,EBP:2
 31189 mov EAX,ECX
 31191 rstack ECX,EBP:3
 31195 mov EBX,ECX
 31197 mov EDX,10
 31200 fpwr EBX,EDX
 31202 rstack ECX,EBP:3
 31206 div EAX,ECX
 31208 mov EDX,EAX
 31210 fint EDX
 31212 mul EDX,EBX
 31214 mov EAX,EDX
 31216 leave 
 31217 ret 
__1392:
 31218 leave 
 31219 ret 
round2:
// round2(A,B)
 31220 enter -0
__1395:
 31223 rstack ECX,EBP:2
 31227 mov EAX,ECX
 31229 rstack ECX,EBP:3
 31233 mov EBX,ECX
 31235 mov EDX,10
 31238 fpwr EBX,EDX
 31240 rstack ECX,EBP:3
 31244 div EAX,ECX
 31246 mov EDX,EAX
 31248 frnd EDX
 31250 mul EDX,EBX
 31252 mov EAX,EDX
 31254 leave 
 31255 ret 
__1394:
 31256 leave 
 31257 ret 
LIBNUMBER_CONSTANTS:
LIBNUMBER_VARS:
LIBNUMBER_END:
ZVECTOR_CODE:
v_error:
// v_error(str)
 31258 enter -0
__1397:
 31261 rstack EAX,EBP:2
// printf arg #3 (unknown)
 31265 push EAX
// printf arg #2 (unknown)
 31267 push 900
// printf arg #1 (char* format)
 31270 push 31290
 31273 mov ECX,3
// printf(...)
 31276 call 21772
 31279 add ESP,3
 31282 mov ECX,0
// panic(...)
 31285 call 85274
__1396:
 31288 leave 
 31289 ret 
__1398:
 31290 db "%mVector error: %s
",0
v_warning:
// v_warning(str)
 31310 enter -0
__1400:
 31313 rstack EAX,EBP:2
// printf arg #3 (unknown)
 31317 push EAX
// printf arg #2 (unknown)
 31319 push 990
// printf arg #1 (char* format)
 31322 push 31336
 31325 mov ECX,3
// printf(...)
 31328 call 21772
 31331 add ESP,3
__1399:
 31334 leave 
 31335 ret 
__1401:
 31336 db "%mVector warning: %s
",0
sizeof_vector:
 31358 db 5
vector_constructor:
// vector_constructor(self,element_size)
 31359 enter -0
__1403:
// assert_arity arg #2 (float num_args)
 31362 push 2
// assert_arity arg #1 (float ecx_here)
 31365 push ECX
 31367 mov ECX,2
// assert_arity(...)
 31370 call 10245
 31373 add ESP,2
 31376 rstack EAX,EBP:2
 31380 add EAX,0
 31383 mov EBX,EAX
// self[0]=typeof_vector
 31385 mov #EBX,34535
 31388 rstack EAX,EBP:3
 31392 mov EBX,10
 31395 mul EBX,EAX
// malloc arg #1 (float n)
 31397 push EBX
 31399 mov ECX,1
// malloc(...)
 31402 call 28486
 31405 add ESP,1
 31408 rstack EBX,EBP:2
 31412 add EBX,1
 31415 mov ECX,EBX
// self[1]=malloc(10*element_size)
 31417 mov #ECX,EAX
 31419 rstack EAX,EBP:2
 31423 add EAX,2
 31426 mov EBX,EAX
// self[2]=0
 31428 mov #EBX,0
 31431 rstack EAX,EBP:2
 31435 add EAX,3
 31438 mov EBX,EAX
// self[3]=10
 31440 mov #EBX,10
 31443 rstack EAX,EBP:3
 31447 rstack EBX,EBP:2
 31451 add EBX,4
 31454 mov ECX,EBX
// self[4]=element_size
 31456 mov #ECX,EAX
__1402:
 31458 leave 
 31459 ret 
vector_copy_constructor:
// vector_copy_constructor(self,other)
 31460 enter 3
__1405:
// assert_type arg #2 (float t)
 31463 push 34535
 31466 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 31470 push EAX
 31472 mov ECX,2
// assert_type(...)
 31475 call 10123
 31478 add ESP,2
 31481 rstack EAX,EBP:3
 31485 add EAX,0
 31488 mov EBX,EAX
 31490 rstack EAX,EBP:2
 31494 add EAX,0
 31497 mov ECX,EAX
// self[0]=other[0]
 31499 mov #ECX,#EBX
 31501 rstack EAX,EBP:3
 31505 add EAX,1
 31508 mov EBX,EAX
 31510 rstack EAX,EBP:2
 31514 add EAX,1
 31517 mov ECX,EAX
// self[1]=other[1]
 31519 mov #ECX,#EBX
 31521 rstack EAX,EBP:3
 31525 add EAX,2
 31528 mov EBX,EAX
 31530 rstack EAX,EBP:2
 31534 add EAX,2
 31537 mov ECX,EAX
// self[2]=other[2]
 31539 mov #ECX,#EBX
 31541 rstack EAX,EBP:3
 31545 add EAX,3
 31548 mov EBX,EAX
 31550 rstack EAX,EBP:2
 31554 add EAX,3
 31557 mov ECX,EAX
// self[3]=other[3]
 31559 mov #ECX,#EBX
 31561 rstack EAX,EBP:3
 31565 add EAX,4
 31568 mov EBX,EAX
 31570 rstack EAX,EBP:2
 31574 add EAX,4
 31577 mov ECX,EAX
// self[4]=other[4]
 31579 mov #ECX,#EBX
 31581 rstack EAX,EBP:2
 31585 add EAX,4
 31588 mov EBX,EAX
 31590 rstack EAX,EBP:2
 31594 add EAX,2
 31597 mov ECX,EAX
 31599 mov EAX,#ECX
 31601 mul EAX,#EBX
 31603 sstack EBP:-1,EAX
 31607 rstack EAX,EBP:-1
// malloc arg #1 (float n)
 31611 push EAX
 31613 mov ECX,1
// malloc(...)
 31616 call 28486
 31619 add ESP,1
 31622 sstack EBP:-2,EAX
 31626 rstack EAX,EBP:2
 31630 add EAX,1
 31633 mov EBX,EAX
 31635 sstack EBP:-3,#EBX
 31639 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 31643 push EAX
 31645 rstack EAX,EBP:-3
// memcpy arg #2 (void* src)
 31649 push EAX
 31651 rstack EAX,EBP:-2
// memcpy arg #1 (void* dest)
 31655 push EAX
 31657 mov ECX,3
// memcpy(...)
 31660 call 10355
 31663 add ESP,3
 31666 rstack EAX,EBP:-2
 31670 rstack EBX,EBP:2
 31674 add EBX,1
 31677 mov ECX,EBX
// self[1]=newarray
 31679 mov #ECX,EAX
__1404:
 31681 leave 
 31682 ret 
vector_get_array:
// vector_get_array(self)
 31683 enter -0
__1407:
// assert_type arg #2 (float t)
 31686 push 34535
 31689 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31693 push EAX
 31695 mov ECX,2
// assert_type(...)
 31698 call 10123
 31701 add ESP,2
 31704 rstack EAX,EBP:2
 31708 add EAX,1
 31711 mov EBX,EAX
 31713 mov EAX,#EBX
 31715 leave 
 31716 ret 
__1406:
 31717 leave 
 31718 ret 
vector_get_size:
// vector_get_size(self)
 31719 enter -0
__1409:
// assert_type arg #2 (float t)
 31722 push 34535
 31725 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31729 push EAX
 31731 mov ECX,2
// assert_type(...)
 31734 call 10123
 31737 add ESP,2
 31740 rstack EAX,EBP:2
 31744 add EAX,2
 31747 mov EBX,EAX
 31749 mov EAX,#EBX
 31751 leave 
 31752 ret 
__1408:
 31753 leave 
 31754 ret 
vector_get_capacity:
// vector_get_capacity(self)
 31755 enter -0
__1411:
// assert_type arg #2 (float t)
 31758 push 34535
 31761 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31765 push EAX
 31767 mov ECX,2
// assert_type(...)
 31770 call 10123
 31773 add ESP,2
 31776 rstack EAX,EBP:2
 31780 add EAX,3
 31783 mov EBX,EAX
 31785 mov EAX,#EBX
 31787 leave 
 31788 ret 
__1410:
 31789 leave 
 31790 ret 
vector_get_element_size:
// vector_get_element_size(self)
 31791 enter -0
__1413:
// assert_type arg #2 (float t)
 31794 push 34535
 31797 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31801 push EAX
 31803 mov ECX,2
// assert_type(...)
 31806 call 10123
 31809 add ESP,2
 31812 rstack EAX,EBP:2
 31816 add EAX,4
 31819 mov EBX,EAX
 31821 mov EAX,#EBX
 31823 leave 
 31824 ret 
__1412:
 31825 leave 
 31826 ret 
vector_set_array:
// vector_set_array(self,n)
 31827 enter -0
__1415:
// assert_type arg #2 (float t)
 31830 push 34535
 31833 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31837 push EAX
 31839 mov ECX,2
// assert_type(...)
 31842 call 10123
 31845 add ESP,2
 31848 rstack EAX,EBP:3
 31852 rstack EBX,EBP:2
 31856 add EBX,1
 31859 mov ECX,EBX
// self[1]=n
 31861 mov #ECX,EAX
__1414:
 31863 leave 
 31864 ret 
vector_set_size:
// vector_set_size(self,n)
 31865 enter -0
__1417:
// assert_type arg #2 (float t)
 31868 push 34535
 31871 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31875 push EAX
 31877 mov ECX,2
// assert_type(...)
 31880 call 10123
 31883 add ESP,2
 31886 rstack EAX,EBP:3
 31890 rstack EBX,EBP:2
 31894 add EBX,2
 31897 mov ECX,EBX
// self[2]=n
 31899 mov #ECX,EAX
__1416:
 31901 leave 
 31902 ret 
vector_set_capacity:
// vector_set_capacity(self,n)
 31903 enter -0
__1419:
// assert_type arg #2 (float t)
 31906 push 34535
 31909 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31913 push EAX
 31915 mov ECX,2
// assert_type(...)
 31918 call 10123
 31921 add ESP,2
 31924 rstack EAX,EBP:3
 31928 rstack EBX,EBP:2
 31932 add EBX,3
 31935 mov ECX,EBX
// self[3]=n
 31937 mov #ECX,EAX
__1418:
 31939 leave 
 31940 ret 
vector_set_element_size:
// vector_set_element_size(self,n)
 31941 enter -0
__1421:
// assert_type arg #2 (float t)
 31944 push 34535
 31947 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31951 push EAX
 31953 mov ECX,2
// assert_type(...)
 31956 call 10123
 31959 add ESP,2
 31962 rstack EAX,EBP:3
 31966 rstack EBX,EBP:2
 31970 add EBX,4
 31973 mov ECX,EBX
// self[4]=n
 31975 mov #ECX,EAX
__1420:
 31977 leave 
 31978 ret 
vector_destructor:
// vector_destructor(self)
 31979 enter -0
__1423:
// assert_type arg #2 (float t)
 31982 push 34535
 31985 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 31989 push EAX
 31991 mov ECX,2
// assert_type(...)
 31994 call 10123
 31997 add ESP,2
 32000 rstack EAX,EBP:2
 32004 add EAX,1
 32007 mov EBX,EAX
// free arg #1 (float* ptr)
 32009 push #EBX
 32011 mov ECX,1
// free(...)
 32014 call 28980
 32017 add ESP,1
__1422:
 32020 leave 
 32021 ret 
vector_clear:
// vector_clear(self)
 32022 enter 1
__1425:
// assert_type arg #2 (float t)
 32025 push 34535
 32028 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32032 push EAX
 32034 mov ECX,2
// assert_type(...)
 32037 call 10123
 32040 add ESP,2
 32043 rstack EAX,EBP:2
 32047 add EAX,2
 32050 mov EBX,EAX
 32052 sstack EBP:-1,#EBX
// self_size=0
 32056 sstack EBP:-1,0
 32061 rstack EAX,EBP:-1
 32065 rstack EBX,EBP:2
 32069 add EBX,2
 32072 mov ECX,EBX
// self[2]=self_size
 32074 mov #ECX,EAX
__1424:
 32076 leave 
 32077 ret 
vector_push:
// vector_push(self,element)
 32078 enter 5
__1427:
// assert_arity arg #2 (float num_args)
 32081 push 2
// assert_arity arg #1 (float ecx_here)
 32084 push ECX
 32086 mov ECX,2
// assert_arity(...)
 32089 call 10245
 32092 add ESP,2
// assert_type arg #2 (float t)
 32095 push 34535
 32098 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32102 push EAX
 32104 mov ECX,2
// assert_type(...)
 32107 call 10123
 32110 add ESP,2
 32113 rstack EAX,EBP:2
 32117 add EAX,1
 32120 mov EBX,EAX
 32122 sstack EBP:-1,#EBX
 32126 rstack EAX,EBP:2
 32130 add EAX,2
 32133 mov EBX,EAX
 32135 sstack EBP:-2,#EBX
 32139 rstack EAX,EBP:2
 32143 add EAX,3
 32146 mov EBX,EAX
 32148 sstack EBP:-3,#EBX
 32152 rstack EAX,EBP:2
 32156 add EAX,4
 32159 mov EBX,EAX
 32161 sstack EBP:-4,#EBX
 32165 rstack EAX,EBP:-2
// self_size++
 32169 inc EAX
 32171 sstack EBP:-2,EAX
__1429:
 32175 rstack EAX,EBP:-2
 32179 rstack EBX,EBP:-3
 32183 sub EBX,EAX
 32185 mov EAX,EBX
 32187 neg EAX
 32189 fsgn EAX,EAX
 32191 max EAX,0
// if (self_size>self_capacity)
 32194 cmp 0,EAX
 32197 jge 32305
 32200 rstack EAX,EBP:-3
 32204 add EAX,1
 32207 mov EBX,EAX
 32209 sstack EBP:-5,EBX
 32213 rstack EAX,EBP:-5
 32217 mul EAX,1.5
 32220 mov EBX,EAX
// newsize=newsize*1.5
 32222 sstack EBP:-5,EBX
 32226 rstack EAX,EBP:-5
// ceil arg #1 (float A)
 32230 push EAX
 32232 mov ECX,1
// ceil(...)
 32235 call 30206
 32238 add ESP,1
// newsize=ceil(newsize)
 32241 sstack EBP:-5,EAX
 32245 rstack EAX,EBP:-5
 32249 push EAX
 32251 rstack EAX,EBP:2
 32255 push EAX
 32257 mov ECX,2
// vector_reserve(...)
 32260 call 34072
 32263 add ESP,2
// array=vector_reserve(self,newsize)
 32266 sstack EBP:-1,EAX
__1432:
 32270 rstack EAX,EBP:-1
 32274 mov EBX,0
 32277 sub EBX,EAX
 32279 fabs EBX,EBX
 32281 fsgn EBX,EBX
 32283 lneg EBX
// if (array==0)
 32285 cmp 0,EBX
 32288 jge 32305
// v_warning arg #1 (float str)
 32291 push 32415
 32294 mov ECX,1
// v_warning(...)
 32297 call 31310
 32300 add ESP,1
 32303 leave 
 32304 ret 
__1433:
__1431:
__1430:
__1428:
__1436:
 32305 rstack EAX,EBP:-4
 32309 mov EBX,1
 32312 sub EBX,EAX
 32314 fabs EBX,EBX
 32316 fsgn EBX,EBX
 32318 lneg EBX
// if (element_size==1)
 32320 cmp 0,EBX
 32323 jge 32352
 32326 rstack EAX,EBP:3
 32330 rstack EBX,EBP:-2
 32334 add EBX,-1
 32337 mov ECX,EBX
 32339 rstack EBX,EBP:-1
 32343 add EBX,ECX
 32345 mov ECX,EBX
// array[self_size-1]=element
 32347 mov #ECX,EAX
 32349 jmp 32398
__1438:
__1437:
__1440:
 32352 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 32356 push EAX
 32358 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 32362 push EAX
 32364 rstack EAX,EBP:-4
 32368 rstack EBX,EBP:-2
 32372 add EBX,-1
 32375 mov ECX,EBX
 32377 mul ECX,EAX
 32379 rstack EAX,EBP:-1
 32383 add EAX,ECX
 32385 mov EBX,EAX
// memcpy2 arg #1 (void* dest)
 32387 push EBX
 32389 mov ECX,3
// memcpy2(...)
 32392 call 11463
 32395 add ESP,3
__1439:
__1435:
 32398 rstack EAX,EBP:-2
 32402 rstack EBX,EBP:2
 32406 add EBX,2
 32409 mov ECX,EBX
// self[2]=self_size
 32411 mov #ECX,EAX
__1426:
 32413 leave 
 32414 ret 
__1434:
 32415 db "can't resize",0
vector_pop:
// vector_pop(self,element)
 32428 enter 5
__1442:
// assert_type arg #2 (float t)
 32431 push 34535
 32434 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32438 push EAX
 32440 mov ECX,2
// assert_type(...)
 32443 call 10123
 32446 add ESP,2
 32449 rstack EAX,EBP:2
 32453 add EAX,1
 32456 mov EBX,EAX
 32458 sstack EBP:-1,#EBX
 32462 rstack EAX,EBP:2
 32466 add EAX,2
 32469 mov EBX,EAX
 32471 sstack EBP:-2,#EBX
 32475 rstack EAX,EBP:2
 32479 add EAX,3
 32482 mov EBX,EAX
 32484 sstack EBP:-3,#EBX
 32488 rstack EAX,EBP:2
 32492 add EAX,4
 32495 mov EBX,EAX
 32497 sstack EBP:-4,#EBX
__1444:
 32501 rstack EAX,EBP:-2
 32505 mov EBX,0
 32508 sub EBX,EAX
 32510 fsgn EBX,EBX
 32512 inc EBX
 32514 max EBX,0
// if (self_size<=0)
 32517 cmp 0,EBX
 32520 jge 32535
// v_error arg #1 (float str)
 32523 push 32657
 32526 mov ECX,1
// v_error(...)
 32529 call 31258
 32532 add ESP,1
__1445:
__1443:
__1448:
 32535 rstack EAX,EBP:3
 32539 mov EBX,0
 32542 sub EBX,EAX
 32544 fabs EBX,EBX
 32546 fsgn EBX,EBX
// if (element!=0)
 32548 cmp 0,EBX
 32551 jge 32597
 32554 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 32558 push EAX
 32560 rstack EAX,EBP:-4
 32564 rstack EBX,EBP:-2
 32568 mul EBX,EAX
 32570 mov EAX,EBX
 32572 rstack EBX,EBP:-1
 32576 add EBX,EAX
 32578 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 32580 push EAX
 32582 rstack EAX,EBP:3
// memcpy2 arg #1 (void* dest)
 32586 push EAX
 32588 mov ECX,3
// memcpy2(...)
 32591 call 11463
 32594 add ESP,3
__1449:
__1447:
 32597 rstack EAX,EBP:-4
 32601 rstack EBX,EBP:-2
 32605 add EBX,-1
 32608 mov ECX,EBX
 32610 mul ECX,EAX
 32612 rstack EAX,EBP:-1
 32616 add EAX,ECX
 32618 mov EBX,EAX
 32620 sstack EBP:-5,#EBX
 32624 rstack EAX,EBP:-2
// self_size--
 32628 dec EAX
 32630 sstack EBP:-2,EAX
 32634 rstack EAX,EBP:-2
 32638 rstack EBX,EBP:2
 32642 add EBX,2
 32645 mov ECX,EBX
// self[2]=self_size
 32647 mov #ECX,EAX
 32649 rstack EAX,EBP:-5
 32653 leave 
 32654 ret 
__1441:
 32655 leave 
 32656 ret 
__1446:
 32657 db "size <= 0",0
vector_size:
// vector_size(self)
 32667 enter -0
__1451:
// assert_type arg #2 (float t)
 32670 push 34535
 32673 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32677 push EAX
 32679 mov ECX,2
// assert_type(...)
 32682 call 10123
 32685 add ESP,2
 32688 rstack EAX,EBP:2
 32692 add EAX,2
 32695 mov EBX,EAX
 32697 mov EAX,#EBX
 32699 leave 
 32700 ret 
__1450:
 32701 leave 
 32702 ret 
vector_disk_size:
// vector_disk_size(self)
 32703 enter -0
__1453:
// assert_type arg #2 (float t)
 32706 push 34535
 32709 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32713 push EAX
 32715 mov ECX,2
// assert_type(...)
 32718 call 10123
 32721 add ESP,2
 32724 rstack EAX,EBP:2
 32728 add EAX,4
 32731 mov EBX,EAX
 32733 rstack EAX,EBP:2
 32737 add EAX,2
 32740 mov ECX,EAX
 32742 mov EAX,#ECX
 32744 mul EAX,#EBX
 32746 leave 
 32747 ret 
__1452:
 32748 leave 
 32749 ret 
vector_get:
// vector_get(self,element,pos)
 32750 enter 5
__1455:
// assert_arity arg #2 (float num_args)
 32753 push 3
// assert_arity arg #1 (float ecx_here)
 32756 push ECX
 32758 mov ECX,2
// assert_arity(...)
 32761 call 10245
 32764 add ESP,2
// assert_type arg #2 (float t)
 32767 push 34535
 32770 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 32774 push EAX
 32776 mov ECX,2
// assert_type(...)
 32779 call 10123
 32782 add ESP,2
 32785 rstack EAX,EBP:2
 32789 add EAX,1
 32792 mov EBX,EAX
 32794 sstack EBP:-1,#EBX
 32798 rstack EAX,EBP:2
 32802 add EAX,2
 32805 mov EBX,EAX
 32807 sstack EBP:-2,#EBX
 32811 rstack EAX,EBP:2
 32815 add EAX,3
 32818 mov EBX,EAX
 32820 sstack EBP:-3,#EBX
 32824 rstack EAX,EBP:2
 32828 add EAX,4
 32831 mov EBX,EAX
 32833 sstack EBP:-4,#EBX
__1457:
 32837 rstack EAX,EBP:4
 32841 rstack EBX,EBP:-2
 32845 sub EBX,EAX
 32847 mov EAX,EBX
 32849 neg EAX
 32851 fsgn EAX,EAX
 32853 inc EAX
 32855 max EAX,0
 32858 rstack EBX,EBP:4
 32862 mov ECX,0
 32865 sub ECX,EBX
 32867 fsgn ECX,ECX
 32869 max ECX,0
 32872 or ECX,EAX
// if ((pos<0)||(pos>=self_size))
 32874 cmp 0,ECX
 32877 jge 32892
// v_error arg #1 (float str)
 32880 push 32986
 32883 mov ECX,1
// v_error(...)
 32886 call 31258
 32889 add ESP,1
__1458:
__1456:
__1461:
 32892 rstack EAX,EBP:3
 32896 mov EBX,0
 32899 sub EBX,EAX
 32901 fabs EBX,EBX
 32903 fsgn EBX,EBX
// if (element!=0)
 32905 cmp 0,EBX
 32908 jge 32954
 32911 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 32915 push EAX
 32917 rstack EAX,EBP:-4
 32921 rstack EBX,EBP:4
 32925 mul EBX,EAX
 32927 mov EAX,EBX
 32929 rstack EBX,EBP:-1
 32933 add EBX,EAX
 32935 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 32937 push EAX
 32939 rstack EAX,EBP:3
// memcpy2 arg #1 (void* dest)
 32943 push EAX
 32945 mov ECX,3
// memcpy2(...)
 32948 call 11463
 32951 add ESP,3
__1462:
__1460:
 32954 rstack EAX,EBP:-4
 32958 rstack EBX,EBP:4
 32962 mul EBX,EAX
 32964 mov EAX,EBX
 32966 rstack EBX,EBP:-1
 32970 add EBX,EAX
 32972 mov EAX,EBX
 32974 sstack EBP:-5,#EAX
 32978 rstack EAX,EBP:-5
 32982 leave 
 32983 ret 
__1454:
 32984 leave 
 32985 ret 
__1459:
 32986 db "pos out of range",0
vector_set:
// vector_set(self,element,pos)
 33003 enter 4
__1464:
// assert_arity arg #2 (float num_args)
 33006 push 3
// assert_arity arg #1 (float ecx_here)
 33009 push ECX
 33011 mov ECX,2
// assert_arity(...)
 33014 call 10245
 33017 add ESP,2
// assert_type arg #2 (float t)
 33020 push 34535
 33023 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 33027 push EAX
 33029 mov ECX,2
// assert_type(...)
 33032 call 10123
 33035 add ESP,2
 33038 rstack EAX,EBP:2
 33042 add EAX,1
 33045 mov EBX,EAX
 33047 sstack EBP:-1,#EBX
 33051 rstack EAX,EBP:2
 33055 add EAX,2
 33058 mov EBX,EAX
 33060 sstack EBP:-2,#EBX
 33064 rstack EAX,EBP:2
 33068 add EAX,3
 33071 mov EBX,EAX
 33073 sstack EBP:-3,#EBX
 33077 rstack EAX,EBP:2
 33081 add EAX,4
 33084 mov EBX,EAX
 33086 sstack EBP:-4,#EBX
__1466:
 33090 rstack EAX,EBP:4
 33094 rstack EBX,EBP:-2
 33098 sub EBX,EAX
 33100 mov EAX,EBX
 33102 fabs EAX,EAX
 33104 fsgn EAX,EAX
 33106 lneg EAX
// if (pos==self_size)
 33108 cmp 0,EAX
 33111 jge 33137
 33114 rstack EAX,EBP:3
// vector_push arg #2 (void* element)
 33118 push EAX
 33120 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 33124 push EAX
 33126 mov ECX,2
// vector_push(...)
 33129 call 32078
 33132 add ESP,2
 33135 leave 
 33136 ret 
__1467:
__1465:
__1469:
 33137 rstack EAX,EBP:4
 33141 rstack EBX,EBP:-2
 33145 sub EBX,EAX
 33147 mov EAX,EBX
 33149 neg EAX
 33151 fsgn EAX,EAX
 33153 inc EAX
 33155 max EAX,0
 33158 rstack EBX,EBP:4
 33162 mov ECX,0
 33165 sub ECX,EBX
 33167 fsgn ECX,ECX
 33169 max ECX,0
 33172 or ECX,EAX
// if ((pos<0)||(pos>=self_size))
 33174 cmp 0,ECX
 33177 jge 33192
// v_error arg #1 (float str)
 33180 push 32986
 33183 mov ECX,1
// v_error(...)
 33186 call 31258
 33189 add ESP,1
__1470:
__1468:
__1472:
 33192 rstack EAX,EBP:-4
 33196 mov EBX,1
 33199 sub EBX,EAX
 33201 fabs EBX,EBX
 33203 fsgn EBX,EBX
 33205 lneg EBX
// if (element_size==1)
 33207 cmp 0,EBX
 33210 jge 33234
 33213 rstack EAX,EBP:3
 33217 rstack EBX,EBP:4
 33221 rstack ECX,EBP:-1
 33225 add ECX,EBX
 33227 mov EBX,ECX
// array[pos]=element
 33229 mov #EBX,EAX
 33231 jmp 33277
__1474:
__1473:
__1476:
 33234 rstack EAX,EBP:-4
// memcpy2 arg #3 (float n)
 33238 push EAX
 33240 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 33244 push EAX
 33246 rstack EAX,EBP:-4
 33250 rstack EBX,EBP:4
 33254 mul EBX,EAX
 33256 mov EAX,EBX
 33258 rstack EBX,EBP:-1
 33262 add EBX,EAX
 33264 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 33266 push EAX
 33268 mov ECX,3
// memcpy2(...)
 33271 call 11463
 33274 add ESP,3
__1475:
__1471:
__1463:
 33277 leave 
 33278 ret 
vector_insert:
// vector_insert(self,element,pos)
 33279 enter 5
__1478:
// assert_arity arg #2 (float num_args)
 33282 push 3
// assert_arity arg #1 (float ecx_here)
 33285 push ECX
 33287 mov ECX,2
// assert_arity(...)
 33290 call 10245
 33293 add ESP,2
// assert_type arg #2 (float t)
 33296 push 34535
 33299 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 33303 push EAX
 33305 mov ECX,2
// assert_type(...)
 33308 call 10123
 33311 add ESP,2
 33314 rstack EAX,EBP:2
 33318 add EAX,2
 33321 mov EBX,EAX
 33323 sstack EBP:-1,#EBX
 33327 rstack EAX,EBP:2
 33331 add EAX,3
 33334 mov EBX,EAX
 33336 sstack EBP:-2,#EBX
 33340 rstack EAX,EBP:2
 33344 add EAX,4
 33347 mov EBX,EAX
 33349 sstack EBP:-3,#EBX
__1480:
 33353 rstack EAX,EBP:4
 33357 rstack EBX,EBP:-1
 33361 sub EBX,EAX
 33363 mov EAX,EBX
 33365 neg EAX
 33367 fsgn EAX,EAX
 33369 max EAX,0
 33372 rstack EBX,EBP:4
 33376 mov ECX,0
 33379 sub ECX,EBX
 33381 fsgn ECX,ECX
 33383 max ECX,0
 33386 or ECX,EAX
// if ((pos<0)||(pos>self_size))
 33388 cmp 0,ECX
 33391 jge 33406
// v_error arg #1 (float str)
 33394 push 32986
 33397 mov ECX,1
// v_error(...)
 33400 call 31258
 33403 add ESP,1
__1481:
__1479:
__1483:
 33406 rstack EAX,EBP:4
 33410 rstack EBX,EBP:-1
 33414 sub EBX,EAX
 33416 mov EAX,EBX
 33418 fabs EAX,EAX
 33420 fsgn EAX,EAX
 33422 lneg EAX
// if (pos==self_size)
 33424 cmp 0,EAX
 33427 jge 33451
 33430 rstack EAX,EBP:3
// vector_push arg #2 (void* element)
 33434 push EAX
 33436 rstack EAX,EBP:2
// vector_push arg #1 (void* self)
 33440 push EAX
 33442 mov ECX,2
// vector_push(...)
 33445 call 32078
 33448 add ESP,2
__1484:
__1482:
 33451 rstack EAX,EBP:-1
// self_size++
 33455 inc EAX
 33457 sstack EBP:-1,EAX
__1486:
 33461 rstack EAX,EBP:-1
 33465 rstack EBX,EBP:-2
 33469 sub EBX,EAX
 33471 mov EAX,EBX
 33473 neg EAX
 33475 fsgn EAX,EAX
 33477 max EAX,0
// if (self_size>self_capacity)
 33480 cmp 0,EAX
 33483 jge 33595
 33486 rstack EAX,EBP:-2
 33490 add EAX,1
 33493 mov EBX,EAX
 33495 sstack EBP:-4,EBX
 33499 rstack EAX,EBP:-4
 33503 mul EAX,1.5
 33506 mov EBX,EAX
// newsize=newsize*1.5
 33508 sstack EBP:-4,EBX
 33512 rstack EAX,EBP:-4
// ceil arg #1 (float A)
 33516 push EAX
 33518 mov ECX,1
// ceil(...)
 33521 call 30206
 33524 add ESP,1
// newsize=ceil(newsize)
 33527 sstack EBP:-4,EAX
 33531 rstack EAX,EBP:-4
 33535 push EAX
 33537 rstack EAX,EBP:2
 33541 push EAX
 33543 mov ECX,2
// vector_reserve(...)
 33546 call 34072
 33549 add ESP,2
// array=vector_reserve(self,newsize)
 33552 mov 66962,EAX
__1489:
 33555 rstack EAX,EBP:-4
 33559 push EAX
 33561 rstack EAX,EBP:2
 33565 push EAX
 33567 mov ECX,2
// vector_reserve(...)
 33570 call 34072
 33573 add ESP,2
 33576 mov EBX,0
 33579 sub EBX,EAX
 33581 fabs EBX,EBX
 33583 fsgn EBX,EBX
 33585 lneg EBX
// if (vector_reserve(self,newsize)==0)
 33587 cmp 0,EBX
 33590 jge 33595
 33593 leave 
 33594 ret 
__1490:
__1488:
__1487:
__1485:
 33595 rstack EAX,EBP:2
 33599 add EAX,1
 33602 mov EBX,EAX
 33604 sstack EBP:-5,#EBX
 33608 rstack EAX,EBP:4
 33612 neg EAX
 33614 mov EBX,EAX
 33616 add EBX,-1
 33619 rstack EAX,EBP:-1
 33623 add EAX,EBX
 33625 mov EBX,EAX
// memcpy2 arg #3 (float n)
 33627 push EBX
 33629 rstack EAX,EBP:-3
 33633 rstack EBX,EBP:4
 33637 mul EBX,EAX
 33639 mov EAX,EBX
 33641 rstack EBX,EBP:-5
 33645 add EBX,EAX
 33647 mov EAX,EBX
// memcpy2 arg #2 (void* src)
 33649 push EAX
 33651 rstack EAX,EBP:-3
 33655 rstack EBX,EBP:4
 33659 add EBX,1
 33662 mov ECX,EBX
 33664 mul ECX,EAX
 33666 rstack EAX,EBP:-5
 33670 add EAX,ECX
 33672 mov EBX,EAX
// memcpy2 arg #1 (void* dest)
 33674 push EBX
 33676 mov ECX,3
// memcpy2(...)
 33679 call 11463
 33682 add ESP,3
__1492:
 33685 rstack EAX,EBP:-3
 33689 mov EBX,1
 33692 sub EBX,EAX
 33694 fabs EBX,EBX
 33696 fsgn EBX,EBX
 33698 lneg EBX
// if (element_size==1)
 33700 cmp 0,EBX
 33703 jge 33727
 33706 rstack EAX,EBP:3
 33710 rstack EBX,EBP:4
 33714 rstack ECX,EBP:-5
 33718 add ECX,EBX
 33720 mov EBX,ECX
// array[pos]=element
 33722 mov #EBX,EAX
 33724 jmp 33770
__1494:
__1493:
__1496:
 33727 rstack EAX,EBP:-3
// memcpy2 arg #3 (float n)
 33731 push EAX
 33733 rstack EAX,EBP:3
// memcpy2 arg #2 (void* src)
 33737 push EAX
 33739 rstack EAX,EBP:-3
 33743 rstack EBX,EBP:4
 33747 mul EBX,EAX
 33749 mov EAX,EBX
 33751 rstack EBX,EBP:-5
 33755 add EBX,EAX
 33757 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 33759 push EAX
 33761 mov ECX,3
// memcpy2(...)
 33764 call 11463
 33767 add ESP,3
__1495:
__1491:
 33770 rstack EAX,EBP:-1
 33774 rstack EBX,EBP:2
 33778 add EBX,2
 33781 mov ECX,EBX
// self[2]=self_size
 33783 mov #ECX,EAX
__1477:
 33785 leave 
 33786 ret 
vector_remove:
// vector_remove(self,pos)
 33787 enter 4
__1498:
// assert_arity arg #2 (float num_args)
 33790 push 2
// assert_arity arg #1 (float ecx_here)
 33793 push ECX
 33795 mov ECX,2
// assert_arity(...)
 33798 call 10245
 33801 add ESP,2
// assert_type arg #2 (float t)
 33804 push 34535
 33807 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 33811 push EAX
 33813 mov ECX,2
// assert_type(...)
 33816 call 10123
 33819 add ESP,2
 33822 rstack EAX,EBP:2
 33826 add EAX,1
 33829 mov EBX,EAX
 33831 sstack EBP:-1,#EBX
 33835 rstack EAX,EBP:2
 33839 add EAX,2
 33842 mov EBX,EAX
 33844 sstack EBP:-2,#EBX
 33848 rstack EAX,EBP:2
 33852 add EAX,3
 33855 mov EBX,EAX
 33857 sstack EBP:-3,#EBX
 33861 rstack EAX,EBP:2
 33865 add EAX,4
 33868 mov EBX,EAX
 33870 sstack EBP:-4,#EBX
__1500:
 33874 rstack EAX,EBP:3
 33878 rstack EBX,EBP:-2
 33882 sub EBX,EAX
 33884 mov EAX,EBX
 33886 neg EAX
 33888 fsgn EAX,EAX
 33890 max EAX,0
 33893 rstack EBX,EBP:3
 33897 mov ECX,0
 33900 sub ECX,EBX
 33902 fsgn ECX,ECX
 33904 max ECX,0
 33907 or ECX,EAX
// if ((pos<0)||(pos>self_size))
 33909 cmp 0,ECX
 33912 jge 33927
// v_error arg #1 (float str)
 33915 push 32986
 33918 mov ECX,1
// v_error(...)
 33921 call 31258
 33924 add ESP,1
__1501:
__1499:
__1503:
 33927 rstack EAX,EBP:3
 33931 rstack EBX,EBP:-2
 33935 sub EBX,EAX
 33937 mov EAX,EBX
 33939 fabs EAX,EAX
 33941 fsgn EAX,EAX
 33943 lneg EAX
// if (pos==self_size)
 33945 cmp 0,EAX
 33948 jge 33971
// vector_pop arg #2 (void* element)
 33951 push 0
 33954 rstack EAX,EBP:2
// vector_pop arg #1 (void* self)
 33958 push EAX
 33960 mov ECX,2
// vector_pop(...)
 33963 call 32428
 33966 add ESP,2
 33969 leave 
 33970 ret 
__1504:
__1502:
 33971 rstack EAX,EBP:3
 33975 neg EAX
 33977 mov EBX,EAX
 33979 rstack EAX,EBP:-2
 33983 add EAX,EBX
 33985 mov EBX,EAX
// memcpy2 arg #3 (float n)
 33987 push EBX
 33989 rstack EAX,EBP:-4
 33993 rstack EBX,EBP:3
 33997 add EBX,1
 34000 mov ECX,EBX
 34002 mul ECX,EAX
 34004 rstack EAX,EBP:-1
 34008 add EAX,ECX
 34010 mov EBX,EAX
// memcpy2 arg #2 (void* src)
 34012 push EBX
 34014 rstack EAX,EBP:-4
 34018 rstack EBX,EBP:3
 34022 mul EBX,EAX
 34024 mov EAX,EBX
 34026 rstack EBX,EBP:-1
 34030 add EBX,EAX
 34032 mov EAX,EBX
// memcpy2 arg #1 (void* dest)
 34034 push EAX
 34036 mov ECX,3
// memcpy2(...)
 34039 call 11463
 34042 add ESP,3
 34045 rstack EAX,EBP:-2
// self_size--
 34049 dec EAX
 34051 sstack EBP:-2,EAX
 34055 rstack EAX,EBP:-2
 34059 rstack EBX,EBP:2
 34063 add EBX,2
 34066 mov ECX,EBX
// self[2]=self_size
 34068 mov #ECX,EAX
__1497:
 34070 leave 
 34071 ret 
vector_reserve:
// vector_reserve(self,newcap)
 34072 enter 6
__1506:
// assert_type arg #2 (float t)
 34075 push 34535
 34078 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 34082 push EAX
 34084 mov ECX,2
// assert_type(...)
 34087 call 10123
 34090 add ESP,2
 34093 rstack EAX,EBP:2
 34097 add EAX,1
 34100 mov EBX,EAX
 34102 sstack EBP:-1,#EBX
 34106 rstack EAX,EBP:2
 34110 add EAX,2
 34113 mov EBX,EAX
 34115 sstack EBP:-2,#EBX
 34119 rstack EAX,EBP:2
 34123 add EAX,3
 34126 mov EBX,EAX
 34128 sstack EBP:-3,#EBX
 34132 rstack EAX,EBP:2
 34136 add EAX,4
 34139 mov EBX,EAX
 34141 sstack EBP:-4,#EBX
 34145 rstack EAX,EBP:-1
 34149 sstack EBP:-5,EAX
 34153 rstack EAX,EBP:3
 34157 rstack EBX,EBP:-4
 34161 mul EBX,EAX
 34163 mov EAX,EBX
 34165 sstack EBP:-6,EAX
 34169 rstack EAX,EBP:3
 34173 rstack EBX,EBP:-4
 34177 mul EBX,EAX
 34179 mov EAX,EBX
// realloc arg #2 (float n)
 34181 push EAX
 34183 rstack EAX,EBP:-1
// realloc arg #1 (float* ptr)
 34187 push EAX
 34189 mov ECX,2
// realloc(...)
 34192 call 29470
 34195 add ESP,2
// array=realloc(array,element_size*newcap)
 34198 sstack EBP:-1,EAX
__1508:
 34202 rstack EAX,EBP:-1
 34206 mov EBX,0
 34209 sub EBX,EAX
 34211 fabs EBX,EBX
 34213 fsgn EBX,EBX
 34215 lneg EBX
// if (array==0)
 34217 cmp 0,EBX
 34220 jge 34240
// v_warning arg #1 (float str)
 34223 push 34301
 34226 mov ECX,1
// v_warning(...)
 34229 call 31310
 34232 add ESP,1
 34235 mov EAX,0
 34238 leave 
 34239 ret 
__1509:
__1507:
 34240 rstack EAX,EBP:3
// self_capacity=newcap
 34244 sstack EBP:-3,EAX
 34248 rstack EAX,EBP:-1
 34252 rstack EBX,EBP:2
 34256 add EBX,1
 34259 mov ECX,EBX
// self[1]=array
 34261 mov #ECX,EAX
 34263 rstack EAX,EBP:-2
 34267 rstack EBX,EBP:2
 34271 add EBX,2
 34274 mov ECX,EBX
// self[2]=self_size
 34276 mov #ECX,EAX
 34278 rstack EAX,EBP:-3
 34282 rstack EBX,EBP:2
 34286 add EBX,3
 34289 mov ECX,EBX
// self[3]=self_capacity
 34291 mov #ECX,EAX
 34293 rstack EAX,EBP:-1
 34297 leave 
 34298 ret 
__1505:
 34299 leave 
 34300 ret 
__1510:
 34301 db "could not reserve",0
vector_resize:
// vector_resize(self,newsize)
 34319 enter 5
__1512:
// assert_type arg #2 (float t)
 34322 push 34535
 34325 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 34329 push EAX
 34331 mov ECX,2
// assert_type(...)
 34334 call 10123
 34337 add ESP,2
 34340 rstack EAX,EBP:2
 34344 add EAX,1
 34347 mov EBX,EAX
 34349 sstack EBP:-1,#EBX
 34353 rstack EAX,EBP:2
 34357 add EAX,2
 34360 mov EBX,EAX
 34362 sstack EBP:-2,#EBX
 34366 rstack EAX,EBP:2
 34370 add EAX,3
 34373 mov EBX,EAX
 34375 sstack EBP:-3,#EBX
 34379 rstack EAX,EBP:2
 34383 add EAX,4
 34386 mov EBX,EAX
 34388 sstack EBP:-4,#EBX
 34392 rstack EAX,EBP:3
 34396 rstack EBX,EBP:-4
 34400 mul EBX,EAX
 34402 mov EAX,EBX
 34404 sstack EBP:-5,EAX
__1514:
 34408 rstack EAX,EBP:-5
 34412 rstack EBX,EBP:-3
 34416 sub EBX,EAX
 34418 mov EAX,EBX
 34420 neg EAX
 34422 fsgn EAX,EAX
 34424 max EAX,0
// if (new_memsize>self_capacity)
 34427 cmp 0,EAX
 34430 jge 34458
 34433 rstack EAX,EBP:3
// vector_reserve arg #2 (float newcap)
 34437 push EAX
 34439 rstack EAX,EBP:2
// vector_reserve arg #1 (void* self)
 34443 push EAX
 34445 mov ECX,2
// vector_reserve(...)
 34448 call 34072
 34451 add ESP,2
// array=vector_reserve(self,newsize)
 34454 sstack EBP:-1,EAX
__1515:
__1513:
__1517:
 34458 rstack EAX,EBP:-1
// if (array)
 34462 cmp 0,EAX
 34465 jge 34491
 34468 rstack EAX,EBP:3
// self_size=newsize
 34472 sstack EBP:-2,EAX
 34476 rstack EAX,EBP:-2
 34480 rstack EBX,EBP:2
 34484 add EBX,2
 34487 mov ECX,EBX
// self[2]=self_size
 34489 mov #ECX,EAX
__1518:
__1516:
 34491 rstack EAX,EBP:-1
 34495 leave 
 34496 ret 
__1511:
 34497 leave 
 34498 ret 
vector_array:
// vector_array(self)
 34499 enter -0
__1520:
// assert_type arg #2 (float t)
 34502 push 34535
 34505 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 34509 push EAX
 34511 mov ECX,2
// assert_type(...)
 34514 call 10123
 34517 add ESP,2
 34520 rstack EAX,EBP:2
 34524 add EAX,1
 34527 mov EBX,EAX
 34529 mov EAX,#EBX
 34531 leave 
 34532 ret 
__1519:
 34533 leave 
 34534 ret 
ZVECTOR_CONSTANTS:
typeof_vector:
 34535 db "vector"
 34541 db 0
ZVECTOR_VARS:
ZVECTOR_END:
libmarker13:
 34542 db 0
initInterrupts:
// initInterrupts(IT,first,size,handler,flags)
 34543 enter 1
__1522:
 34546 rstack EAX,EBP:4
 34550 cpuset 52,EAX
 34553 rstack EAX,EBP:2
 34557 lidtr EAX
 34559 rstack EAX,EBP:3
// init loop
 34563 sstack EBP:-1,EAX
__1524:
 34567 rstack EAX,EBP:-1
 34571 rstack EBX,EBP:4
 34575 sub EBX,EAX
 34577 mov EAX,EBX
 34579 fsgn EAX,EAX
// condition
 34581 max EAX,0
 34584 cmp 0,EAX
 34587 jz 34636
 34590 rstack EAX,EBP:6
 34594 push EAX
 34596 rstack EAX,EBP:5
 34600 push EAX
 34602 rstack EAX,EBP:-1
 34606 push EAX
 34608 rstack EAX,EBP:2
 34612 push EAX
 34614 mov ECX,4
// addInterruptHandler(...)
 34617 call 34638
 34620 add ESP,4
 34623 rstack EAX,EBP:-1
// loop step
 34627 inc EAX
 34629 sstack EBP:-1,EAX
 34633 jmp 34567
__1523:
__1521:
 34636 leave 
 34637 ret 
addInterruptHandler:
// addInterruptHandler(IT,num,func,flags)
 34638 enter 1
__1526:
 34641 rstack EAX,EBP:3
 34645 mov EBX,4
 34648 mul EBX,EAX
 34650 rstack EAX,EBP:2
 34654 add EAX,EBX
 34656 mov EBX,EAX
 34658 sstack EBP:-1,EBX
 34662 rstack EAX,EBP:4
 34666 rstack EBX,EBP:-1
 34670 add EBX,0
 34673 mov ECX,EBX
// pint[0]=func
 34675 mov #ECX,EAX
 34677 rstack EAX,EBP:-1
 34681 add EAX,1
 34684 mov EBX,EAX
// pint[1]=0
 34686 mov #EBX,0
 34689 rstack EAX,EBP:-1
 34693 add EAX,2
 34696 mov EBX,EAX
// pint[2]=0
 34698 mov #EBX,0
 34701 rstack EAX,EBP:5
 34705 rstack EBX,EBP:-1
 34709 add EBX,3
 34712 mov ECX,EBX
// pint[3]=flags
 34714 mov #ECX,EAX
__1525:
 34716 leave 
 34717 ret 
numInts:
 34718 db 0
 34719 alloc 128
intHandlersStart:
intHandlersEnd:
 34847 alloc 128
extendedModeEnable:
// extendedModeEnable()
 34975 enter -0
__1528:
 34978 stef 
__1527:
 34979 leave 
 34980 ret 
extendedModeDisable:
// extendedModeDisable()
 34981 enter -0
__1530:
 34984 clef 
__1529:
 34985 leave 
 34986 ret 
interruptsEnable:
// interruptsEnable()
 34987 enter -0
__1532:
 34990 sti 
__1531:
 34991 leave 
 34992 ret 
interruptsDisable:
// interruptsDisable()
 34993 enter -0
__1534:
 34996 cli 
__1533:
 34997 leave 
 34998 ret 
intnum_to_str:
// intnum_to_str(num)
 34999 enter -0
__1536:
__1538:
 35002 rstack EAX,EBP:2
 35006 mov EBX,0
 35009 sub EBX,EAX
 35011 fsgn EBX,EBX
 35013 max EBX,0
// if (num<0)
 35016 cmp 0,EBX
 35019 jge 35027
 35022 mov EAX,35101
 35025 leave 
 35026 ret 
__1539:
__1537:
__1541:
 35027 rstack EAX,EBP:2
 35031 mov EBX,31
 35034 sub EBX,EAX
 35036 neg EBX
 35038 fsgn EBX,EBX
 35040 max EBX,0
// if (num>31)
 35043 cmp 0,EBX
 35046 jge 35054
 35049 mov EAX,35101
 35052 leave 
 35053 ret 
__1542:
__1540:
 35054 rstack EAX,EBP:2
 35058 add EAX,35069
 35061 mov EBX,EAX
 35063 mov EAX,#EBX
 35065 leave 
 35066 ret 
__1535:
 35067 leave 
 35068 ret 
intnames:
 35069 db 35116
 35070 db 35122
 35071 db 35127
 35072 db 35152
 35073 db 35169
 35074 db 35184
 35075 db 35209
 35076 db 35242
 35077 db 35266
 35078 db 35279
 35079 db 35320
 35080 db 35342
 35081 db 35383
 35082 db 35423
 35083 db 35447
 35084 db 35490
 35085 db 35101
 35086 db 35514
 35087 db 35101
 35088 db 35101
 35089 db 35101
 35090 db 35101
 35091 db 35101
 35092 db 35549
 35093 db 35101
 35094 db 35101
 35095 db 35101
 35096 db 35101
 35097 db 35578
 35098 db 35600
 35099 db 35623
 35100 db 35640
str_int_default:
 35101 db "User interrupt",0
str_int0:
 35116 db "Reset",0
str_int1:
 35122 db "Halt",0
str_int2:
 35127 db "End of program execution",0
str_int3:
 35152 db "Division by zero",0
str_int4:
 35169 db "Unknown opcode",0
str_int5:
 35184 db "Internal processor error",0
str_int6:
 35209 db "Stack error (overflow/underflow)",0
str_int7:
 35242 db "Memory read/write fault",0
str_int8:
 35266 db "MemBus fault",0
str_int9:
 35279 db "Write access violation (page protection)",0
str_int10:
 35320 db "Port read/write fault",0
str_int11:
 35342 db "Page acccess violation (page protection)",0
str_int12:
 35383 db "Read access violation (page protection)",0
str_int13:
 35423 db "General processor fault",0
str_int14:
 35447 db "Execute access violation (page protection)",0
str_int15:
 35490 db "Address space violation",0
str_int17:
 35514 db "Frame instruction limit (GPU only)",0
str_int23:
 35549 db "String read error (GPU only)",0
str_int28:
 35578 db "Page read access trap",0
str_int29:
 35600 db "Page write access trap",0
str_int30:
 35623 db "Page access trap",0
str_int31:
 35640 db "Debug trap",0
libmarker14:
 35651 db 0
LIBKEYBOARD_CODE:
setKeyboard:
// setKeyboard(ptr)
 35652 enter -0
__1544:
 35655 rstack EAX,EBP:2
// ptrKB=ptr
 35659 mov #66987,EAX
__1543:
 35662 leave 
 35663 ret 
isPrint1:
// isPrint1(c)
 35664 enter -0
__1546:
 35667 rstack EAX,EBP:2
 35671 mov EBX,127
 35674 sub EBX,EAX
 35676 fsgn EBX,EBX
 35678 max EBX,0
 35681 rstack EAX,EBP:2
 35685 mov ECX,31
 35688 sub ECX,EAX
 35690 neg ECX
 35692 fsgn ECX,ECX
 35694 max ECX,0
 35697 and ECX,EBX
 35699 mov EAX,ECX
 35701 leave 
 35702 ret 
__1545:
 35703 leave 
 35704 ret 
readKey:
// readKey()
 35705 enter 1
__1548:
 35708 mov EAX,#66987
 35711 add EAX,1
 35714 sstack EBP:-1,#EAX
 35718 mov EAX,#66987
// *ptrKB=0
 35721 mov #EAX,0
 35724 rstack EAX,EBP:-1
 35728 leave 
 35729 ret 
__1547:
 35730 leave 
 35731 ret 
hasKey:
// hasKey()
 35732 enter -0
__1550:
 35735 mov EAX,#66987
 35738 mov EAX,#EAX
 35740 leave 
 35741 ret 
__1549:
 35742 leave 
 35743 ret 
readKB:
// readKB(func)
 35744 enter -0
__1552:
__1554:
 35747 mov ECX,0
// hasKey(...)
 35750 call 35732
// if (hasKey()
 35753 cmp 0,EAX
 35756 jz 35782
 35759 mov ECX,0
// readKey(...)
 35762 call 35705
 35765 push EAX
 35767 mov ECX,1
 35770 rstack EAX,EBP:2
// func(...)
 35774 call EAX
 35776 add ESP,1
 35779 jmp 35747
__1553:
__1551:
 35782 leave 
 35783 ret 
waitKey:
// waitKey()
 35784 enter -0
__1556:
__1558:
 35787 mov ECX,0
// hasKey(...)
 35790 call 35732
 35793 lneg EAX
// if (!hasKey()
 35795 cmp 0,EAX
 35798 jz 35805
 35801 nop 
 35802 jmp 35787
__1557:
 35805 mov ECX,0
// readKey(...)
 35808 call 35705
 35811 leave 
 35812 ret 
__1555:
 35813 leave 
 35814 ret 
readKeyTimed_delay_time:
 35815 db 0.5
readKeyTimed_repeat_time:
 35816 db 0.1
readKeyTimed_keyState:
 35817 db 0
readKeyTimed_lastSeen:
 35818 db 0
readKeyTimed_lastKey:
 35819 db 0
readKeyTimed:
// readKeyTimed()
 35820 enter 2
__1560:
__1562:
 35823 mov EAX,0
 35826 add EAX,#66987
// if (ptrKB[0])
 35829 cmp 0,#EAX
 35832 jge 36055
 35835 mov EAX,0
 35838 add EAX,#66987
 35841 mov EBX,#EAX
 35843 add EBX,#66987
 35846 sstack EBP:-2,#EBX
__1565:
 35850 rstack EAX,EBP:-2
 35854 mov EBX,#35819
 35857 sub EBX,EAX
 35859 fabs EBX,EBX
 35861 fsgn EBX,EBX
 35863 mov EAX,0
 35866 sub EAX,#35817
 35869 fabs EAX,EAX
 35871 fsgn EAX,EAX
 35873 lneg EAX
 35875 or EAX,EBX
// if ((readKeyTimed_keyState==0)||(C!=readKeyTimed_lastKey))
 35877 cmp 0,EAX
 35880 jge 35905
 35883 timer EAX
// readKeyTimed_lastSeen=EAX
 35885 mov #35818,EAX
 35888 rstack EAX,EBP:-2
// readKeyTimed_lastKey=C
 35892 mov #35819,EAX
// readKeyTimed_keyState=1
 35895 mov #35817,1
 35899 rstack EAX,EBP:-2
 35903 leave 
 35904 ret 
__1566:
__1564:
__1568:
 35905 mov EAX,1
 35908 sub EAX,#35817
 35911 fabs EAX,EAX
 35913 fsgn EAX,EAX
 35915 lneg EAX
// if (readKeyTimed_keyState==1)
 35917 cmp 0,EAX
 35920 jge 35982
 35923 timer EAX
// T=EAX
 35925 sstack EBP:-1,EAX
__1571:
 35929 mov EAX,#35818
 35932 neg EAX
 35934 rstack EBX,EBP:-1
 35938 add EBX,EAX
 35940 mov EAX,EBX
 35942 mov EBX,#35815
 35945 sub EBX,EAX
 35947 neg EBX
 35949 fsgn EBX,EBX
 35951 max EBX,0
// if ((T-readKeyTimed_lastSeen)>readKeyTimed_delay_time)
 35954 cmp 0,EBX
 35957 jge 35977
 35960 rstack EAX,EBP:-1
// readKeyTimed_lastSeen=T
 35964 mov #35818,EAX
// readKeyTimed_keyState=2
 35967 mov #35817,2
 35971 rstack EAX,EBP:-2
 35975 leave 
 35976 ret 
__1572:
__1570:
 35977 mov EAX,0
 35980 leave 
 35981 ret 
__1569:
__1567:
__1574:
 35982 mov EAX,2
 35985 sub EAX,#35817
 35988 fabs EAX,EAX
 35990 fsgn EAX,EAX
 35992 lneg EAX
// if (readKeyTimed_keyState==2)
 35994 cmp 0,EAX
 35997 jge 36055
 36000 timer EAX
// T=EAX
 36002 sstack EBP:-1,EAX
__1577:
 36006 mov EAX,#35818
 36009 neg EAX
 36011 rstack EBX,EBP:-1
 36015 add EBX,EAX
 36017 mov EAX,EBX
 36019 mov EBX,#35816
 36022 sub EBX,EAX
 36024 neg EBX
 36026 fsgn EBX,EBX
 36028 max EBX,0
// if ((T-readKeyTimed_lastSeen)>readKeyTimed_repeat_time)
 36031 cmp 0,EBX
 36034 jge 36050
 36037 rstack EAX,EBP:-1
// readKeyTimed_lastSeen=T
 36041 mov #35818,EAX
 36044 rstack EAX,EBP:-2
 36048 leave 
 36049 ret 
__1578:
__1576:
 36050 mov EAX,0
 36053 leave 
 36054 ret 
__1575:
__1573:
__1563:
__1561:
// readKeyTimed_keyState=0
 36055 mov #35817,0
 36059 mov EAX,0
 36062 leave 
 36063 ret 
__1559:
 36064 leave 
 36065 ret 
strLinebuff:
 36066 alloc 64
readline:
// readline()
 36130 enter 2
__1580:
 36133 mov ECX,0
// waitKey(...)
 36136 call 35784
 36139 sstack EBP:-1,EAX
 36143 sstack EBP:-2,36066
__1582:
 36148 rstack EAX,EBP:-2
 36152 mov EBX,36129
 36155 sub EBX,EAX
 36157 fsgn EBX,EBX
 36159 max EBX,0
 36162 rstack EAX,EBP:-1
 36166 mov ECX,10
 36169 sub ECX,EAX
 36171 fabs ECX,ECX
 36173 fsgn ECX,ECX
 36175 and ECX,EBX
// if ((C!=10)&&(P<strLinebuff+63)
 36177 cmp 0,ECX
 36180 jz 36214
 36183 rstack EAX,EBP:-1
 36187 rstack EBX,EBP:-2
 36191 mov ECX,EBX
 36193 inc EBX
 36195 sstack EBP:-2,EBX
// *P++=C
 36199 mov #ECX,EAX
 36201 mov ECX,0
// waitKey(...)
 36204 call 35784
// C=waitKey()
 36207 sstack EBP:-1,EAX
 36211 jmp 36148
__1581:
 36214 rstack EAX,EBP:-2
// *P=0
 36218 mov #EAX,0
 36221 mov EAX,36066
 36224 leave 
 36225 ret 
__1579:
 36226 leave 
 36227 ret 
LIBKEYBOARD_CONSTANTS:
LIBKEYBOARD_VARS:
LIBKEYBOARD_END:
libmarker15:
 36228 db 0
initPaging:
// initPaging(PT,size,flags,runlevel)
 36229 enter 1
__1584:
 36232 rstack EAX,EBP:3
 36236 push EAX
 36238 rstack EAX,EBP:2
 36242 push EAX
 36244 mov ECX,2
// setPageTable(...)
 36247 call 36335
 36250 add ESP,2
// init loop
 36253 sstack EBP:-1,-1
__1586:
 36258 rstack EAX,EBP:-1
 36262 rstack EBX,EBP:3
 36266 sub EBX,EAX
 36268 mov EAX,EBX
 36270 fsgn EAX,EAX
// condition
 36272 max EAX,0
 36275 cmp 0,EAX
 36278 jz 36333
 36281 rstack EAX,EBP:5
 36285 push EAX
 36287 rstack EAX,EBP:4
 36291 push EAX
 36293 rstack EAX,EBP:-1
 36297 push EAX
 36299 rstack EAX,EBP:-1
 36303 push EAX
 36305 rstack EAX,EBP:2
 36309 push EAX
 36311 mov ECX,5
// mapPage(...)
 36314 call 36932
 36317 add ESP,5
 36320 rstack EAX,EBP:-1
// loop step
 36324 inc EAX
 36326 sstack EBP:-1,EAX
 36330 jmp 36258
__1585:
__1583:
 36333 leave 
 36334 ret 
setPageTable:
// setPageTable(PT,size)
 36335 enter -0
__1588:
 36338 rstack EAX,EBP:2
 36342 cpuset 37,EAX
 36345 rstack EAX,EBP:3
 36349 cpuset 38,EAX
__1587:
 36352 leave 
 36353 ret 
getPage:
// getPage(PT,page)
 36354 enter -0
__1590:
 36357 rstack EAX,EBP:3
 36361 add EAX,1
 36364 mov EBX,EAX
// page=page+1
 36366 sstack EBP:3,EBX
 36370 rstack EAX,EBP:3
 36374 mul EAX,2
 36377 mov EBX,EAX
// page=page*2
 36379 sstack EBP:3,EBX
 36383 rstack EAX,EBP:3
 36387 rstack EBX,EBP:2
 36391 add EBX,EAX
 36393 mov EAX,EBX
// page=PT+page
 36395 sstack EBP:3,EAX
 36399 rstack EAX,EBP:3
 36403 leave 
 36404 ret 
__1589:
 36405 leave 
 36406 ret 
setPageFlags:
// setPageFlags(page,flags)
 36407 enter 1
__1592:
 36410 rstack EAX,EBP:2
 36414 sstack EBP:-1,#EAX
 36418 rstack EAX,EBP:-1
 36422 div EAX,256
 36425 mov EBX,EAX
// runlevel=runlevel/256
 36427 sstack EBP:-1,EBX
 36431 rstack EAX,EBP:-1
 36435 fint EAX
 36437 sstack EBP:-1,EAX
 36441 rstack EAX,EBP:-1
 36445 mov EBX,256
 36448 mul EBX,EAX
 36450 rstack EAX,EBP:3
 36454 add EAX,EBX
 36456 mov EBX,EAX
 36458 rstack EAX,EBP:2
// *page=flags+256*runlevel
 36462 mov #EAX,EBX
__1591:
 36464 leave 
 36465 ret 
getPageFlags:
// getPageFlags(page)
 36466 enter 1
__1594:
 36469 rstack EAX,EBP:2
 36473 sstack EBP:-1,#EAX
 36477 rstack EAX,EBP:-1
 36481 mod EAX,256
 36484 mov EBX,EAX
// flags=flags%256
 36486 sstack EBP:-1,EBX
 36490 rstack EAX,EBP:-1
 36494 fint EAX
 36496 sstack EBP:-1,EAX
 36500 rstack EAX,EBP:-1
 36504 leave 
 36505 ret 
__1593:
 36506 leave 
 36507 ret 
setPageRunLevel:
// setPageRunLevel(page,level)
 36508 enter 1
__1596:
 36511 rstack EAX,EBP:2
 36515 sstack EBP:-1,#EAX
 36519 rstack EAX,EBP:-1
 36523 mod EAX,256
 36526 mov EBX,EAX
// flags=flags%256
 36528 sstack EBP:-1,EBX
 36532 rstack EAX,EBP:-1
 36536 fint EAX
 36538 sstack EBP:-1,EAX
 36542 rstack EAX,EBP:3
 36546 mov EBX,256
 36549 mul EBX,EAX
 36551 rstack EAX,EBP:-1
 36555 add EAX,EBX
 36557 mov EBX,EAX
 36559 rstack EAX,EBP:2
// *page=flags+256*level
 36563 mov #EAX,EBX
__1595:
 36565 leave 
 36566 ret 
getPageRunlevel:
// getPageRunlevel(page)
 36567 enter 1
__1598:
 36570 rstack EAX,EBP:2
 36574 sstack EBP:-1,#EAX
 36578 rstack EAX,EBP:-1
 36582 div EAX,256
 36585 mov EBX,EAX
// runlevel=runlevel/256
 36587 sstack EBP:-1,EBX
 36591 rstack EAX,EBP:-1
 36595 fint EAX
 36597 sstack EBP:-1,EAX
 36601 rstack EAX,EBP:-1
 36605 leave 
 36606 ret 
__1597:
 36607 leave 
 36608 ret 
setPageMapping:
// setPageMapping(page,phys)
 36609 enter -0
__1600:
 36612 rstack EAX,EBP:3
 36616 rstack EBX,EBP:2
 36620 add EBX,1
 36623 mov ECX,EBX
// page[1]=phys
 36625 mov #ECX,EAX
__1599:
 36627 leave 
 36628 ret 
getPageMapping:
// getPageMapping(page)
 36629 enter -0
__1602:
 36632 rstack EAX,EBP:2
 36636 add EAX,1
 36639 mov EBX,EAX
 36641 mov EAX,#EBX
 36643 leave 
 36644 ret 
__1601:
 36645 leave 
 36646 ret 
reportPage:
// reportPage(pageTable,pageID)
 36647 enter 4
__1604:
 36650 rstack EAX,EBP:3
// getPage arg #2 (float page)
 36654 push EAX
 36656 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 36660 push EAX
 36662 mov ECX,2
// getPage(...)
 36665 call 36354
 36668 add ESP,2
 36671 sstack EBP:-1,EAX
 36675 rstack EAX,EBP:-1
// getPageFlags arg #1 (float page)
 36679 push EAX
 36681 mov ECX,1
// getPageFlags(...)
 36684 call 36466
 36687 add ESP,1
 36690 sstack EBP:-2,EAX
 36694 rstack EAX,EBP:-1
// getPageRunlevel arg #1 (float page)
 36698 push EAX
 36700 mov ECX,1
// getPageRunlevel(...)
 36703 call 36567
 36706 add ESP,1
 36709 sstack EBP:-3,EAX
 36713 rstack EAX,EBP:-1
// getPageMapping arg #1 (float page)
 36717 push EAX
 36719 mov ECX,1
// getPageMapping(...)
 36722 call 36629
 36725 add ESP,1
 36728 sstack EBP:-4,EAX
 36732 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 36736 push EAX
 36738 rstack EAX,EBP:3
// printf arg #2 (unknown)
 36742 push EAX
// printf arg #1 (char* format)
 36744 push 36823
 36747 mov ECX,3
// printf(...)
 36750 call 21772
 36753 add ESP,3
 36756 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 36760 push EAX
 36762 rstack EAX,EBP:3
// printf arg #2 (unknown)
 36766 push EAX
// printf arg #1 (char* format)
 36768 push 36840
 36771 mov ECX,3
// printf(...)
 36774 call 21772
 36777 add ESP,3
 36780 rstack EAX,EBP:-3
// printf arg #3 (unknown)
 36784 push EAX
 36786 rstack EAX,EBP:3
// printf arg #2 (unknown)
 36790 push EAX
// printf arg #1 (char* format)
 36792 push 36806
 36795 mov ECX,3
// printf(...)
 36798 call 21772
 36801 add ESP,3
__1603:
 36804 leave 
 36805 ret 
__1607:
 36806 db "P%d: level = %d
",0
__1605:
 36823 db "P%d: phys  = %d
",0
__1606:
 36840 db "P%d: flags = %d
",0
toPage:
// toPage(addr)
 36857 enter -0
__1609:
 36860 rstack EAX,EBP:2
 36864 div EAX,128
 36867 mov EBX,EAX
// addr=addr/128
 36869 sstack EBP:2,EBX
 36873 rstack EAX,EBP:2
 36877 fint EAX
 36879 sstack EBP:2,EAX
 36883 rstack EAX,EBP:2
 36887 leave 
 36888 ret 
__1608:
 36889 leave 
 36890 ret 
copyPage:
// copyPage(pageto,pagefrom)
 36891 enter -0
__1611:
 36894 rstack EAX,EBP:3
 36898 mov EBX,EAX
 36900 inc EAX
 36902 sstack EBP:3,EAX
 36906 rstack EAX,EBP:2
 36910 mov ECX,EAX
 36912 inc EAX
 36914 sstack EBP:2,EAX
// *pageto++=*pagefrom++
 36918 mov #ECX,#EBX
 36920 rstack EAX,EBP:3
 36924 rstack EBX,EBP:2
// *pageto=*pagefrom
 36928 mov #EBX,#EAX
__1610:
 36930 leave 
 36931 ret 
mapPage:
// mapPage(PT,virt,phys,flags,runlevel)
 36932 enter 1
__1613:
 36935 rstack EAX,EBP:3
// getPage arg #2 (float page)
 36939 push EAX
 36941 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 36945 push EAX
 36947 mov ECX,2
// getPage(...)
 36950 call 36354
 36953 add ESP,2
 36956 sstack EBP:-1,EAX
 36960 rstack EAX,EBP:4
// setPageMapping arg #2 (float phys)
 36964 push EAX
 36966 rstack EAX,EBP:-1
// setPageMapping arg #1 (float page)
 36970 push EAX
 36972 mov ECX,2
// setPageMapping(...)
 36975 call 36609
 36978 add ESP,2
 36981 rstack EAX,EBP:5
// setPageFlags arg #2 (float flags)
 36985 push EAX
 36987 rstack EAX,EBP:-1
// setPageFlags arg #1 (float page)
 36991 push EAX
 36993 mov ECX,2
// setPageFlags(...)
 36996 call 36407
 36999 add ESP,2
 37002 rstack EAX,EBP:6
// setPageRunLevel arg #2 (float level)
 37006 push EAX
 37008 rstack EAX,EBP:-1
// setPageRunLevel arg #1 (float page)
 37012 push EAX
 37014 mov ECX,2
// setPageRunLevel(...)
 37017 call 36508
 37020 add ESP,2
__1612:
 37023 leave 
 37024 ret 
setMemoryRunlevel:
// setMemoryRunlevel(PT,from,to,level)
 37025 enter 4
__1615:
 37028 rstack EAX,EBP:3
// toPage arg #1 (float addr)
 37032 push EAX
 37034 mov ECX,1
// toPage(...)
 37037 call 36857
 37040 add ESP,1
 37043 sstack EBP:-1,EAX
 37047 rstack EAX,EBP:4
// toPage arg #1 (float addr)
 37051 push EAX
 37053 mov ECX,1
// toPage(...)
 37056 call 36857
 37059 add ESP,1
 37062 sstack EBP:-2,EAX
 37066 rstack EAX,EBP:-1
// init loop
 37070 sstack EBP:-3,EAX
__1617:
 37074 rstack EAX,EBP:-3
 37078 rstack EBX,EBP:-2
 37082 sub EBX,EAX
 37084 mov EAX,EBX
 37086 fsgn EAX,EAX
// condition
 37088 max EAX,0
 37091 cmp 0,EAX
 37094 jz 37156
 37097 rstack EAX,EBP:-3
// getPage arg #2 (float page)
 37101 push EAX
 37103 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 37107 push EAX
 37109 mov ECX,2
// getPage(...)
 37112 call 36354
 37115 add ESP,2
 37118 sstack EBP:-4,EAX
 37122 rstack EAX,EBP:5
// setPageRunLevel arg #2 (float level)
 37126 push EAX
 37128 rstack EAX,EBP:-4
// setPageRunLevel arg #1 (float page)
 37132 push EAX
 37134 mov ECX,2
// setPageRunLevel(...)
 37137 call 36508
 37140 add ESP,2
 37143 rstack EAX,EBP:-3
// loop step
 37147 inc EAX
 37149 sstack EBP:-3,EAX
 37153 jmp 37074
__1616:
__1614:
 37156 leave 
 37157 ret 
setMemoryMapping:
// setMemoryMapping(PT,from,to,target)
 37158 enter 7
__1619:
 37161 rstack EAX,EBP:3
 37165 sstack EBP:-1,EAX
 37169 rstack EAX,EBP:4
 37173 sstack EBP:-2,EAX
 37177 rstack EAX,EBP:5
 37181 sstack EBP:-3,EAX
 37185 rstack EAX,EBP:-1
 37189 neg EAX
 37191 mov EBX,EAX
 37193 rstack EAX,EBP:-3
 37197 add EAX,EBX
 37199 mov EBX,EAX
 37201 sstack EBP:-4,EBX
 37205 rstack EAX,EBP:-1
// init loop
 37209 sstack EBP:-5,EAX
__1621:
 37213 rstack EAX,EBP:-5
 37217 rstack EBX,EBP:-2
 37221 sub EBX,EAX
 37223 mov EAX,EBX
 37225 fsgn EAX,EAX
 37227 inc EAX
// condition
 37229 max EAX,0
 37232 cmp 0,EAX
 37235 jz 37313
 37238 rstack EAX,EBP:-5
// getPage arg #2 (float page)
 37242 push EAX
 37244 rstack EAX,EBP:2
// getPage arg #1 (float PT)
 37248 push EAX
 37250 mov ECX,2
// getPage(...)
 37253 call 36354
 37256 add ESP,2
 37259 sstack EBP:-6,EAX
 37263 rstack EAX,EBP:-4
 37267 rstack EBX,EBP:-5
 37271 add EBX,EAX
 37273 mov EAX,EBX
 37275 sstack EBP:-7,EAX
 37279 rstack EAX,EBP:-7
// setPageMapping arg #2 (float phys)
 37283 push EAX
 37285 rstack EAX,EBP:-6
// setPageMapping arg #1 (float page)
 37289 push EAX
 37291 mov ECX,2
// setPageMapping(...)
 37294 call 36609
 37297 add ESP,2
 37300 rstack EAX,EBP:-5
// loop step
 37304 inc EAX
 37306 sstack EBP:-5,EAX
 37310 jmp 37213
__1620:
__1618:
 37313 leave 
 37314 ret 
pagingEnable:
// pagingEnable()
 37315 enter -0
__1623:
 37318 stm 
__1622:
 37319 leave 
 37320 ret 
pagingDisable:
// pagingDisable()
 37321 enter -0
__1625:
 37324 clm 
__1624:
 37325 leave 
 37326 ret 
libmarker17:
 37327 db 0
typeof_shell2:
 37328 db "shell2",0
sizeof_shell2:
 37335 db 180
sizeof_shell2_text:
 37336 db 80
sizeof_shell2_cd:
 37337 db 80
init_shell2:
// init_shell2()
 37338 enter 1
__1627:
// malloc arg #1 (float n)
 37341 push #37335
 37344 mov ECX,1
// malloc(...)
 37347 call 28486
 37350 add ESP,1
 37353 sstack EBP:-1,EAX
 37357 rstack EAX,EBP:-1
 37361 push EAX
 37363 mov ECX,1
// shell2_constructor(...)
 37366 call 37380
 37369 add ESP,1
 37372 rstack EAX,EBP:-1
 37376 leave 
 37377 ret 
__1626:
 37378 leave 
 37379 ret 
shell2_constructor:
// shell2_constructor(self)
 37380 enter 2
__1629:
 37383 rstack EAX,EBP:2
 37387 add EAX,0
 37390 mov EBX,EAX
// self[0]=typeof_shell2
 37392 mov #EBX,37328
 37395 rstack EAX,EBP:2
 37399 add EAX,1
 37402 mov EBX,EAX
// self[1]=0
 37404 mov #EBX,0
// malloc arg #1 (float n)
 37407 push #31358
 37410 mov ECX,1
// malloc(...)
 37413 call 28486
 37416 add ESP,1
 37419 sstack EBP:-1,EAX
// vector_constructor arg #2 (float element_size)
 37423 push 10
 37426 rstack EAX,EBP:-1
// vector_constructor arg #1 (void* self)
 37430 push EAX
 37432 mov ECX,2
// vector_constructor(...)
 37435 call 31359
 37438 add ESP,2
 37441 rstack EAX,EBP:-1
 37445 rstack EBX,EBP:2
 37449 add EBX,2
 37452 mov ECX,EBX
// self[2]=V
 37454 mov #ECX,EAX
 37456 rstack EAX,EBP:2
 37460 add EAX,3
 37463 mov EBX,EAX
// self[3]=0
 37465 mov #EBX,0
 37468 rstack EAX,EBP:2
 37472 add EAX,4
 37475 mov EBX,EAX
// self[4]=0
 37477 mov #EBX,0
// malloc arg #1 (float n)
 37480 push #31358
 37483 mov ECX,1
// malloc(...)
 37486 call 28486
 37489 add ESP,1
 37492 sstack EBP:-2,EAX
// vector_constructor arg #2 (float element_size)
 37496 push 4
 37499 rstack EAX,EBP:-2
// vector_constructor arg #1 (void* self)
 37503 push EAX
 37505 mov ECX,2
// vector_constructor(...)
 37508 call 31359
 37511 add ESP,2
 37514 rstack EAX,EBP:-2
 37518 rstack EBX,EBP:2
 37522 add EBX,5
 37525 mov ECX,EBX
// self[5]=V2
 37527 mov #ECX,EAX
 37529 rstack EAX,EBP:2
 37533 add EAX,10
 37536 mov EBX,EAX
// self[10]=0
 37538 mov #EBX,0
 37541 rstack EAX,EBP:2
 37545 add EAX,100
 37548 mov EBX,EAX
// self[100]=0
 37550 mov #EBX,0
 37553 push 38252
 37556 push 38532
 37559 push 38291
 37562 push 40503
 37565 rstack EAX,EBP:2
 37569 push EAX
 37571 mov ECX,5
// shell2_add_command(...)
 37574 call 38989
 37577 add ESP,5
 37580 push 0
 37583 push 38278
 37586 push 38552
 37589 push 41024
 37592 rstack EAX,EBP:2
 37596 push EAX
 37598 mov ECX,5
// shell2_add_command(...)
 37601 call 38989
 37604 add ESP,5
 37607 push 0
 37610 push 38556
 37613 push 38747
 37616 push 41050
 37619 rstack EAX,EBP:2
 37623 push EAX
 37625 mov ECX,5
// shell2_add_command(...)
 37628 call 38989
 37631 add ESP,5
 37634 push 38046
 37637 push 38404
 37640 push 38683
 37643 push 41713
 37646 rstack EAX,EBP:2
 37650 push EAX
 37652 mov ECX,5
// shell2_add_command(...)
 37655 call 38989
 37658 add ESP,5
 37661 push 38637
 37664 push 38122
 37667 push 38368
 37670 push 55727
 37673 rstack EAX,EBP:2
 37677 push EAX
 37679 mov ECX,5
// shell2_add_command(...)
 37682 call 38989
 37685 add ESP,5
 37688 push 0
 37691 push 38220
 37694 push 38676
 37697 push 56038
 37700 rstack EAX,EBP:2
 37704 push EAX
 37706 mov ECX,5
// shell2_add_command(...)
 37709 call 38989
 37712 add ESP,5
 37715 push 38602
 37718 push 38191
 37721 push 38033
 37724 push 56517
 37727 rstack EAX,EBP:2
 37731 push EAX
 37733 mov ECX,5
// shell2_add_command(...)
 37736 call 38989
 37739 add ESP,5
 37742 push 0
 37745 push 38014
 37748 push 38679
 37751 push 56906
 37754 rstack EAX,EBP:2
 37758 push EAX
 37760 mov ECX,5
// shell2_add_command(...)
 37763 call 38989
 37766 add ESP,5
 37769 push 38162
 37772 push 38690
 37775 push 38628
 37778 push 58181
 37781 rstack EAX,EBP:2
 37785 push EAX
 37787 mov ECX,5
// shell2_add_command(...)
 37790 call 38989
 37793 add ESP,5
 37796 push 38715
 37799 push 38103
 37802 push 38040
 37805 push 58943
 37808 rstack EAX,EBP:2
 37812 push EAX
 37814 mov ECX,5
// shell2_add_command(...)
 37817 call 38989
 37820 add ESP,5
 37823 push 38077
 37826 push 38384
 37829 push 38072
 37832 push 59362
 37835 rstack EAX,EBP:2
 37839 push EAX
 37841 mov ECX,5
// shell2_add_command(...)
 37844 call 38989
 37847 add ESP,5
 37850 push 38142
 37853 push 38296
 37856 push 38214
 37859 push 57937
 37862 rstack EAX,EBP:2
 37866 push EAX
 37868 mov ECX,5
// shell2_add_command(...)
 37871 call 38989
 37874 add ESP,5
 37877 push 38572
 37880 push 38486
 37883 push 38209
 37886 push 62366
 37889 rstack EAX,EBP:2
 37893 push EAX
 37895 mov ECX,5
// shell2_add_command(...)
 37898 call 38989
 37901 add ESP,5
 37904 push 38446
 37907 push 38426
 37910 push 38423
 37913 push 60819
 37916 rstack EAX,EBP:2
 37920 push EAX
 37922 mov ECX,5
// shell2_add_command(...)
 37925 call 38989
 37928 add ESP,5
 37931 push 0
 37934 push 38508
 37937 push 38274
 37940 push 58132
 37943 rstack EAX,EBP:2
 37947 push EAX
 37949 mov ECX,5
// shell2_add_command(...)
 37952 call 38989
 37955 add ESP,5
 37958 push 0
 37961 push 38237
 37964 push 38374
 37967 push 63068
 37970 rstack EAX,EBP:2
 37974 push EAX
 37976 mov ECX,5
// shell2_add_command(...)
 37979 call 38989
 37982 add ESP,5
 37985 push 38315
 37988 push 38350
 37991 push 38632
 37994 push 63154
 37997 rstack EAX,EBP:2
 38001 push EAX
 38003 mov ECX,5
// shell2_add_command(...)
 38006 call 38989
 38009 add ESP,5
__1628:
 38012 leave 
 38013 ret 
__1649:
 38014 db "lists current dirs",0
__1645:
 38033 db "format",0
__1653:
 38040 db "write",0
__1639:
 38046 db "usage: device [list/info]",0
__1656:
 38072 db "read",0
__1658:
 38077 db "usage: read [-f filename]",0
__1654:
 38103 db "write text to file",0
__1641:
 38122 db "assign drive letter",0
__1661:
 38142 db "usage: mkdir [name]",0
__1652:
 38162 db "usage: mem [from] [numBytes]",0
__1646:
 38191 db "installs lightfs3",0
__1662:
 38209 db "diag",0
__1659:
 38214 db "mkdir",0
__1644:
 38220 db "change directory",0
__1671:
 38237 db "test overstack",0
__1632:
 38252 db "usage: help (command)",0
__1668:
 38274 db "del",0
__1634:
 38278 db "clear screen",0
__1630:
 38291 db "help",0
__1660:
 38296 db "create a directory",0
__1674:
 38315 db "usage: dump [deviceNum] [filename]",0
__1673:
 38350 db "write dev to file",0
__1640:
 38368 db "mount",0
__1670:
 38374 db "overstack",0
__1657:
 38384 db "read text from file",0
__1638:
 38404 db "enumerates devices",0
__1665:
 38423 db "fs",0
__1666:
 38426 db "filesystem settings",0
__1667:
 38446 db "usage: fs [blocks/cache [on/off/reset]]",0
__1663:
 38486 db "run system diagnostic",0
__1669:
 38508 db "delete a file or folder",0
__1631:
 38532 db "helps with commands",0
__1633:
 38552 db "cls",0
__1636:
 38556 db "print a message",0
__1664:
 38572 db "usage: diag [stack/heap/disk]",0
__1647:
 38602 db "usage: format [deviceNum]",0
__1650:
 38628 db "mem",0
__1672:
 38632 db "dump",0
__1642:
 38637 db "usage: mount [deviceNum] [driveLetter]",0
__1643:
 38676 db "cd",0
__1648:
 38679 db "dir",0
__1637:
 38683 db "device",0
__1651:
 38690 db "displays memory contents",0
__1655:
 38715 db "usage: write [-f filename] text",0
__1635:
 38747 db "echo",0
shell2_open:
// shell2_open(self)
 38752 enter 1
__1676:
// assert_type arg #2 (float t)
 38755 push 37328
 38758 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 38762 push EAX
 38764 mov ECX,2
// assert_type(...)
 38767 call 10123
 38770 add ESP,2
 38773 mov ECX,0
// screen_clear(...)
 38776 call 17985
// setPrintCursor arg #2 (float y)
 38779 push 0
// setPrintCursor arg #1 (float x)
 38782 push 0
 38785 mov ECX,2
// setPrintCursor(...)
 38788 call 17225
 38791 add ESP,2
 38794 rstack EAX,EBP:2
// printf arg #2 (unknown)
 38798 push EAX
// printf arg #1 (char* format)
 38800 push 38953
 38803 mov ECX,2
// printf(...)
 38806 call 21772
 38809 add ESP,2
 38812 sstack EBP:-1,0
 38817 mov EAX,SS:EBP
 38820 add EAX,-1
// EBcb_device_bind_addr arg #4 (float res)
 38823 push EAX
// EBcb_device_bind_addr arg #3 (float user)
 38825 push 1
// EBcb_device_bind_addr arg #2 (float type)
 38828 push 15
// EBcb_device_bind_addr arg #1 (float this)
 38831 push 66989
 38834 mov ECX,4
// EBcb_device_bind_addr(...)
 38837 call 21124
 38840 add ESP,4
__1679:
 38843 rstack EAX,EBP:-1
 38847 lneg EAX
 38849 mov EBX,EAX
// if (!EB_Kb)
 38851 cmp 0,EBX
 38854 jge 38871
// printf arg #1 (char* format)
 38857 push 38965
 38860 mov ECX,1
// printf(...)
 38863 call 21772
 38866 add ESP,1
 38869 leave 
 38870 ret 
__1680:
__1678:
 38871 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 38875 push EAX
// printf arg #1 (char* format)
 38877 push 38931
 38880 mov ECX,2
// printf(...)
 38883 call 21772
 38886 add ESP,2
 38889 rstack EAX,EBP:-1
// setKeyboard arg #1 (float ptr)
 38893 push EAX
 38895 mov ECX,1
// setKeyboard(...)
 38898 call 35652
 38901 add ESP,1
__1684:
// if (1
 38904 cmp 0,1
 38908 jz 38929
 38911 rstack EAX,EBP:2
 38915 push EAX
 38917 mov ECX,1
// shell2_waitInput(...)
 38920 call 39264
 38923 add ESP,1
 38926 jmp 38904
__1683:
__1675:
 38929 leave 
 38930 ret 
__1682:
 38931 db "found keyboard at %d
",0
__1677:
 38953 db "shell = %d
",0
__1681:
 38965 db "no keyboard, quitting.
",0
shell2_add_command:
// shell2_add_command(self,func,str_cmd,str_desc,str_help)
 38989 enter 5
__1686:
// assert_type arg #2 (float t)
 38992 push 37328
 38995 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 38999 push EAX
 39001 mov ECX,2
// assert_type(...)
 39004 call 10123
 39007 add ESP,2
 39010 rstack EAX,EBP:3
// entry[0]=func
 39014 sstack EBP:-4,EAX
 39018 rstack EAX,EBP:4
// entry[1]=str_cmd
 39022 sstack EBP:-3,EAX
 39026 rstack EAX,EBP:5
// entry[2]=str_desc
 39030 sstack EBP:-2,EAX
 39034 rstack EAX,EBP:6
// entry[3]=str_help
 39038 sstack EBP:-1,EAX
 39042 rstack EAX,EBP:2
 39046 add EAX,5
 39049 mov EBX,EAX
 39051 sstack EBP:-5,#EBX
 39055 mov EAX,SS:EBP
 39058 add EAX,-4
// vector_push arg #2 (void* element)
 39061 push EAX
 39063 rstack EAX,EBP:-5
// vector_push arg #1 (void* self)
 39067 push EAX
 39069 mov ECX,2
// vector_push(...)
 39072 call 32078
 39075 add ESP,2
__1685:
 39078 leave 
 39079 ret 
shell2_lookup_command:
// shell2_lookup_command(self,str_cmd,entry)
 39080 enter 4
__1688:
// assert_type arg #2 (float t)
 39083 push 37328
 39086 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 39090 push EAX
 39092 mov ECX,2
// assert_type(...)
 39095 call 10123
 39098 add ESP,2
 39101 rstack EAX,EBP:2
 39105 add EAX,5
 39108 mov EBX,EAX
 39110 sstack EBP:-1,#EBX
 39114 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 39118 push EAX
 39120 mov ECX,1
// vector_size(...)
 39123 call 32667
 39126 add ESP,1
 39129 sstack EBP:-2,EAX
// init loop
 39133 sstack EBP:-3,0
__1690:
 39138 rstack EAX,EBP:-3
 39142 rstack EBX,EBP:-2
 39146 sub EBX,EAX
 39148 mov EAX,EBX
 39150 fsgn EAX,EAX
// condition
 39152 max EAX,0
 39155 cmp 0,EAX
 39158 jz 39257
 39161 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 39165 push EAX
 39167 rstack EAX,EBP:4
// vector_get arg #2 (void* element)
 39171 push EAX
 39173 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 39177 push EAX
 39179 mov ECX,3
// vector_get(...)
 39182 call 32750
 39185 add ESP,3
 39188 rstack EAX,EBP:4
 39192 add EAX,1
 39195 mov EBX,EAX
 39197 sstack EBP:-4,#EBX
__1692:
 39201 rstack EAX,EBP:3
// strcmp arg #2 (char* dest)
 39205 push EAX
 39207 rstack EAX,EBP:-4
// strcmp arg #1 (char* src)
 39211 push EAX
 39213 mov ECX,2
// strcmp(...)
 39216 call 10763
 39219 add ESP,2
 39222 mov EBX,0
 39225 sub EBX,EAX
 39227 fabs EBX,EBX
 39229 fsgn EBX,EBX
 39231 lneg EBX
// if (strcmp(e_str,str_cmd)==0)
 39233 cmp 0,EBX
 39236 jge 39244
 39239 mov EAX,1
 39242 leave 
 39243 ret 
__1693:
__1691:
 39244 rstack EAX,EBP:-3
// loop step
 39248 inc EAX
 39250 sstack EBP:-3,EAX
 39254 jmp 39138
__1689:
 39257 mov EAX,0
 39260 leave 
 39261 ret 
__1687:
 39262 leave 
 39263 ret 
shell2_waitInput:
// shell2_waitInput(self)
 39264 enter 2
__1695:
// assert_type arg #2 (float t)
 39267 push 37328
 39270 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 39274 push EAX
 39276 mov ECX,2
// assert_type(...)
 39279 call 10123
 39282 add ESP,2
 39285 rstack EAX,EBP:2
 39289 push EAX
 39291 mov ECX,1
// shell2_print_prompt(...)
 39294 call 39380
 39297 add ESP,1
 39300 mov ECX,0
// screen_cursor_enable(...)
 39303 call 17999
__1697:
// if (1
 39306 cmp 0,1
 39310 jz 39378
// screen_set_cursor_pos_xy arg #2 (float y)
 39313 push #66680
// screen_set_cursor_pos_xy arg #1 (float x)
 39316 push #66679
 39319 mov ECX,2
// screen_set_cursor_pos_xy(...)
 39322 call 18049
 39325 add ESP,2
 39328 mov ECX,0
// waitKey(...)
 39331 call 35784
 39334 sstack EBP:-1,EAX
 39338 rstack EAX,EBP:-1
 39342 push EAX
 39344 rstack EAX,EBP:2
 39348 push EAX
 39350 mov ECX,2
// shell2_process_key(...)
 39353 call 39475
 39356 add ESP,2
 39359 sstack EBP:-2,EAX
__1699:
 39363 rstack EAX,EBP:-2
// if (R)
 39367 cmp 0,EAX
 39370 jge 39375
 39373 leave 
 39374 ret 
__1700:
__1698:
 39375 jmp 39306
__1696:
__1694:
 39378 leave 
 39379 ret 
shell2_print_prompt:
// shell2_print_prompt(self)
 39380 enter 2
__1702:
// assert_type arg #2 (float t)
 39383 push 37328
 39386 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 39390 push EAX
 39392 mov ECX,2
// assert_type(...)
 39395 call 10123
 39398 add ESP,2
 39401 rstack EAX,EBP:2
 39405 add EAX,100
 39408 mov EBX,EAX
 39410 sstack EBP:-1,EBX
 39414 rstack EAX,EBP:2
 39418 add EAX,4
 39421 mov EBX,EAX
 39423 sstack EBP:-2,#EBX
__1704:
 39427 rstack EAX,EBP:-2
// if (cd_len)
 39431 cmp 0,EAX
 39434 jge 39455
 39437 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 39441 push EAX
// printf arg #1 (char* format)
 39443 push 39469
 39446 mov ECX,2
// printf(...)
 39449 call 21772
 39452 add ESP,2
__1705:
__1703:
// printf arg #1 (char* format)
 39455 push 39472
 39458 mov ECX,1
// printf(...)
 39461 call 21772
 39464 add ESP,1
__1701:
 39467 leave 
 39468 ret 
__1706:
 39469 db "%s",0
__1707:
 39472 db "> ",0
shell2_process_key:
// shell2_process_key(self,K)
 39475 enter 2
__1709:
// assert_type arg #2 (float t)
 39478 push 37328
 39481 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 39485 push EAX
 39487 mov ECX,2
// assert_type(...)
 39490 call 10123
 39493 add ESP,2
__1711:
 39496 rstack EAX,EBP:3
 39500 mov EBX,10
 39503 sub EBX,EAX
 39505 fabs EBX,EBX
 39507 fsgn EBX,EBX
 39509 lneg EBX
// if (K==10)
 39511 cmp 0,EBX
 39514 jge 39587
 39517 mov ECX,0
// screen_cursor_disable(...)
 39520 call 18013
// printf arg #1 (char* format)
 39523 push 25879
 39526 mov ECX,1
// printf(...)
 39529 call 21772
 39532 add ESP,1
 39535 rstack EAX,EBP:2
 39539 push EAX
 39541 mov ECX,1
// shell2_process_command(...)
 39544 call 39835
 39547 add ESP,1
// text_len=0
 39550 sstack EBP:-1,0
 39555 rstack EAX,EBP:-2
 39559 add EAX,0
 39562 mov EBX,EAX
// text_ptr[0]=0
 39564 mov #EBX,0
 39567 rstack EAX,EBP:-1
 39571 rstack EBX,EBP:2
 39575 add EBX,1
 39578 mov ECX,EBX
// self[1]=text_len
 39580 mov #ECX,EAX
 39582 mov EAX,1
 39585 leave 
 39586 ret 
__1712:
__1710:
__1714:
 39587 rstack EAX,EBP:3
 39591 mov EBX,127
 39594 sub EBX,EAX
 39596 fabs EBX,EBX
 39598 fsgn EBX,EBX
 39600 lneg EBX
// if (K==127)
 39602 cmp 0,EBX
 39605 jge 39702
 39608 rstack EAX,EBP:2
 39612 add EAX,1
 39615 mov EBX,EAX
// text_len=self[1]
 39617 sstack EBP:-1,#EBX
 39621 rstack EAX,EBP:2
 39625 add EAX,10
 39628 mov EBX,EAX
// text_ptr=self+10
 39630 sstack EBP:-2,EBX
__1717:
 39634 rstack EAX,EBP:-1
 39638 mov EBX,0
 39641 sub EBX,EAX
 39643 neg EBX
 39645 fsgn EBX,EBX
 39647 max EBX,0
// if (text_len>0)
 39650 cmp 0,EBX
 39653 jge 39687
 39656 rstack EAX,EBP:-1
// text_len--
 39660 dec EAX
 39662 sstack EBP:-1,EAX
 39666 rstack EAX,EBP:-1
 39670 rstack EBX,EBP:-2
 39674 add EBX,EAX
 39676 mov EAX,EBX
// text_ptr[text_len]=0
 39678 mov #EAX,0
 39681 mov ECX,0
// screenEraseChar(...)
 39684 call 17896
__1718:
__1716:
 39687 rstack EAX,EBP:-1
 39691 rstack EBX,EBP:2
 39695 add EBX,1
 39698 mov ECX,EBX
// self[1]=text_len
 39700 mov #ECX,EAX
__1715:
__1713:
__1720:
 39702 rstack EAX,EBP:3
// isPrint1 arg #1 (char c)
 39706 push EAX
 39708 mov ECX,1
// isPrint1(...)
 39711 call 35664
 39714 add ESP,1
// if (isPrint1(K))
 39717 cmp 0,EAX
 39720 jge 39825
 39723 rstack EAX,EBP:3
// printf arg #2 (unknown)
 39727 push EAX
// printf arg #1 (char* format)
 39729 push 39832
 39732 mov ECX,2
// printf(...)
 39735 call 21772
 39738 add ESP,2
 39741 rstack EAX,EBP:2
 39745 add EAX,1
 39748 mov EBX,EAX
// text_len=self[1]
 39750 sstack EBP:-1,#EBX
 39754 rstack EAX,EBP:2
 39758 add EAX,10
 39761 mov EBX,EAX
// text_ptr=self+10
 39763 sstack EBP:-2,EBX
 39767 rstack EAX,EBP:3
 39771 rstack EBX,EBP:-1
 39775 rstack ECX,EBP:-2
 39779 add ECX,EBX
 39781 mov EBX,ECX
// text_ptr[text_len]=K
 39783 mov #EBX,EAX
 39785 rstack EAX,EBP:-1
// text_len++
 39789 inc EAX
 39791 sstack EBP:-1,EAX
 39795 rstack EAX,EBP:-1
 39799 rstack EBX,EBP:-2
 39803 add EBX,EAX
 39805 mov EAX,EBX
// text_ptr[text_len]=0
 39807 mov #EAX,0
 39810 rstack EAX,EBP:-1
 39814 rstack EBX,EBP:2
 39818 add EBX,1
 39821 mov ECX,EBX
// self[1]=text_len
 39823 mov #ECX,EAX
__1721:
__1719:
 39825 mov EAX,0
 39828 leave 
 39829 ret 
__1708:
 39830 leave 
 39831 ret 
__1722:
 39832 db "%c",0
shell2_process_command:
// shell2_process_command(self)
 39835 enter 128
__1724:
// assert_type arg #2 (float t)
 39838 push 37328
 39841 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 39845 push EAX
 39847 mov ECX,2
// assert_type(...)
 39850 call 10123
 39853 add ESP,2
 39856 rstack EAX,EBP:2
 39860 add EAX,10
 39863 mov EBX,EAX
 39865 sstack EBP:-1,EBX
 39869 rstack EAX,EBP:-1
// strcpy arg #2 (char* src)
 39873 push EAX
 39875 mov EAX,SS:EBP
 39878 add EAX,-121
// strcpy arg #1 (char* dest)
 39881 push EAX
 39883 mov ECX,2
// strcpy(...)
 39886 call 10963
 39889 add ESP,2
// explode arg #2 (char* del)
 39892 push 27824
 39895 mov EAX,SS:EBP
 39898 add EAX,-121
// explode arg #1 (char* str)
 39901 push EAX
 39903 mov ECX,2
// explode(...)
 39906 call 11982
 39909 add ESP,2
 39912 sstack EBP:-122,EAX
 39916 rstack EAX,EBP:-122
// strlen arg #1 (char* str)
 39920 push EAX
 39922 mov ECX,1
// strlen(...)
 39925 call 11121
 39928 add ESP,1
 39931 sstack EBP:-123,EAX
__1726:
 39935 mov EAX,SS:EBP
 39938 add EAX,-127
// shell2_lookup_command arg #3 (float entry)
 39941 push EAX
 39943 rstack EAX,EBP:-122
 39947 add EAX,0
 39950 mov EBX,EAX
// shell2_lookup_command arg #2 (float str_cmd)
 39952 push #EBX
 39954 rstack EAX,EBP:2
// shell2_lookup_command arg #1 (float self)
 39958 push EAX
 39960 mov ECX,3
// shell2_lookup_command(...)
 39963 call 39080
 39966 add ESP,3
// if (shell2_lookup_command(self,argv[0],cmd_entry))
 39969 cmp 0,EAX
 39972 jge 40016
 39975 rstack EAX,EBP:-127
 39979 sstack EBP:-128,EAX
 39983 rstack EAX,EBP:-122
 39987 push EAX
 39989 rstack EAX,EBP:-123
 39993 push EAX
 39995 rstack EAX,EBP:2
 39999 push EAX
 40001 mov ECX,3
 40004 rstack EAX,EBP:-128
// cmd_func(...)
 40008 call EAX
 40010 add ESP,3
 40013 jmp 40031
__1728:
__1727:
__1730:
// printf arg #2 (unknown)
 40016 push 822
// printf arg #1 (char* format)
 40019 push 40033
 40022 mov ECX,2
// printf(...)
 40025 call 21772
 40028 add ESP,2
__1729:
__1725:
__1723:
 40031 leave 
 40032 ret 
__1731:
 40033 db "%mcommand not found
",0
shell2_associate_fs3_with_letter:
// shell2_associate_fs3_with_letter(self,fs3,letter)
 40054 enter 12
__1733:
// assert_type arg #2 (float t)
 40057 push 37328
 40060 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 40064 push EAX
 40066 mov ECX,2
// assert_type(...)
 40069 call 10123
 40072 add ESP,2
 40075 mov EAX,SS:EBP
 40078 add EAX,-10
 40081 add EAX,1
 40084 sstack EBP:-11,EAX
 40088 rstack EAX,EBP:3
// entry[0]=fs3
 40092 sstack EBP:-10,EAX
// strncpy arg #3 (float n)
 40096 push 8
 40099 rstack EAX,EBP:4
// strncpy arg #2 (char* src)
 40103 push EAX
 40105 rstack EAX,EBP:-11
// strncpy arg #1 (char* dest)
 40109 push EAX
 40111 mov ECX,3
// strncpy(...)
 40114 call 11009
 40117 add ESP,3
 40120 rstack EAX,EBP:2
 40124 add EAX,2
 40127 mov EBX,EAX
 40129 sstack EBP:-12,#EBX
 40133 mov EAX,SS:EBP
 40136 add EAX,-10
// vector_push arg #2 (void* element)
 40139 push EAX
 40141 rstack EAX,EBP:-12
// vector_push arg #1 (void* self)
 40145 push EAX
 40147 mov ECX,2
// vector_push(...)
 40150 call 32078
 40153 add ESP,2
__1732:
 40156 leave 
 40157 ret 
shell2_set_fs_by_drive_letter:
// shell2_set_fs_by_drive_letter(self,letter)
 40158 enter 14
__1735:
// assert_type arg #2 (float t)
 40161 push 37328
 40164 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 40168 push EAX
 40170 mov ECX,2
// assert_type(...)
 40173 call 10123
 40176 add ESP,2
 40179 rstack EAX,EBP:2
 40183 add EAX,3
 40186 mov EBX,EAX
// self[3]=0
 40188 mov #EBX,0
 40191 rstack EAX,EBP:2
 40195 add EAX,2
 40198 mov EBX,EAX
 40200 sstack EBP:-1,#EBX
 40204 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 40208 push EAX
 40210 mov ECX,1
// vector_size(...)
 40213 call 32667
 40216 add ESP,1
 40219 sstack EBP:-2,EAX
// init loop
 40223 sstack EBP:-3,0
__1737:
 40228 rstack EAX,EBP:-3
 40232 rstack EBX,EBP:-2
 40236 sub EBX,EAX
 40238 mov EAX,EBX
 40240 fsgn EAX,EAX
// condition
 40242 max EAX,0
 40245 cmp 0,EAX
 40248 jz 40364
 40251 mov EAX,SS:EBP
 40254 add EAX,-13
 40257 add EAX,1
 40260 sstack EBP:-14,EAX
 40264 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 40268 push EAX
 40270 mov EAX,SS:EBP
 40273 add EAX,-13
// vector_get arg #2 (void* element)
 40276 push EAX
 40278 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 40282 push EAX
 40284 mov ECX,3
// vector_get(...)
 40287 call 32750
 40290 add ESP,3
__1739:
 40293 rstack EAX,EBP:-14
// strcmp arg #2 (char* dest)
 40297 push EAX
 40299 rstack EAX,EBP:3
// strcmp arg #1 (char* src)
 40303 push EAX
 40305 mov ECX,2
// strcmp(...)
 40308 call 10763
 40311 add ESP,2
 40314 mov EBX,0
 40317 sub EBX,EAX
 40319 fabs EBX,EBX
 40321 fsgn EBX,EBX
 40323 lneg EBX
// if (strcmp(letter,e_letter)==0)
 40325 cmp 0,EBX
 40328 jge 40351
 40331 rstack EAX,EBP:-13
 40335 rstack EBX,EBP:2
 40339 add EBX,3
 40342 mov ECX,EBX
// self[3]=entry[0]
 40344 mov #ECX,EAX
 40346 mov EAX,1
 40349 leave 
 40350 ret 
__1740:
__1738:
 40351 rstack EAX,EBP:-3
// loop step
 40355 inc EAX
 40357 sstack EBP:-3,EAX
 40361 jmp 40228
__1736:
 40364 rstack EAX,EBP:3
// printf arg #2 (unknown)
 40368 push EAX
// printf arg #1 (char* format)
 40370 push 40389
 40373 mov ECX,2
// printf(...)
 40376 call 21772
 40379 add ESP,2
 40382 mov EAX,0
 40385 leave 
 40386 ret 
__1734:
 40387 leave 
 40388 ret 
__1741:
 40389 db "fs not found for letter %s
",0
shell2_set_cd:
// shell2_set_cd(self,dir)
 40417 enter 1
__1743:
// assert_type arg #2 (float t)
 40420 push 37328
 40423 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 40427 push EAX
 40429 mov ECX,2
// assert_type(...)
 40432 call 10123
 40435 add ESP,2
 40438 rstack EAX,EBP:2
 40442 add EAX,100
 40445 mov EBX,EAX
 40447 sstack EBP:-1,EBX
// strncpy arg #3 (float n)
 40451 push #37337
 40454 rstack EAX,EBP:3
// strncpy arg #2 (char* src)
 40458 push EAX
 40460 rstack EAX,EBP:-1
// strncpy arg #1 (char* dest)
 40464 push EAX
 40466 mov ECX,3
// strncpy(...)
 40469 call 11009
 40472 add ESP,3
 40475 rstack EAX,EBP:-1
// strlen arg #1 (char* str)
 40479 push EAX
 40481 mov ECX,1
// strlen(...)
 40484 call 11121
 40487 add ESP,1
 40490 rstack EBX,EBP:2
 40494 add EBX,4
 40497 mov ECX,EBX
// self[4]=strlen(cd_str)
 40499 mov #ECX,EAX
__1742:
 40501 leave 
 40502 ret 
cmdHelp:
// cmdHelp(shell,argc,argv)
 40503 enter 9
__1745:
// assert_type arg #2 (float t)
 40506 push 37328
 40509 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 40513 push EAX
 40515 mov ECX,2
// assert_type(...)
 40518 call 10123
 40521 add ESP,2
__1747:
 40524 rstack EAX,EBP:3
 40528 mov EBX,1
 40531 sub EBX,EAX
 40533 neg EBX
 40535 fsgn EBX,EBX
 40537 max EBX,0
// if (argc>1)
 40540 cmp 0,EBX
 40543 jge 40575
 40546 rstack EAX,EBP:4
 40550 add EAX,1
 40553 mov EBX,EAX
 40555 push #EBX
 40557 rstack EAX,EBP:2
 40561 push EAX
 40563 mov ECX,2
// cmdHelp2(...)
 40566 call 40759
 40569 add ESP,2
 40572 jmp 40751
__1749:
__1748:
__1751:
 40575 rstack EAX,EBP:2
 40579 add EAX,5
 40582 mov EBX,EAX
 40584 sstack EBP:-1,#EBX
 40588 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 40592 push EAX
 40594 mov ECX,1
// vector_size(...)
 40597 call 32667
 40600 add ESP,1
 40603 sstack EBP:-2,EAX
// init loop
 40607 sstack EBP:-3,0
__1753:
 40612 rstack EAX,EBP:-3
 40616 rstack EBX,EBP:-2
 40620 sub EBX,EAX
 40622 mov EAX,EBX
 40624 fsgn EAX,EAX
// condition
 40626 max EAX,0
 40629 cmp 0,EAX
 40632 jz 40751
 40635 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 40639 push EAX
 40641 mov EAX,SS:EBP
 40644 add EAX,-7
// vector_get arg #2 (void* element)
 40647 push EAX
 40649 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 40653 push EAX
 40655 mov ECX,3
// vector_get(...)
 40658 call 32750
 40661 add ESP,3
 40664 rstack EAX,EBP:-6
 40668 sstack EBP:-8,EAX
 40672 rstack EAX,EBP:-5
 40676 sstack EBP:-9,EAX
 40680 rstack EAX,EBP:-8
// printf arg #2 (unknown)
 40684 push EAX
// printf arg #1 (char* format)
 40686 push 39469
 40689 mov ECX,2
// printf(...)
 40692 call 21772
 40695 add ESP,2
__1755:
 40698 rstack EAX,EBP:-9
// if (e_desc)
 40702 cmp 0,EAX
 40705 jge 40726
 40708 rstack EAX,EBP:-9
// printf arg #2 (unknown)
 40712 push EAX
// printf arg #1 (char* format)
 40714 push 40753
 40717 mov ECX,2
// printf(...)
 40720 call 21772
 40723 add ESP,2
__1756:
__1754:
// printf arg #1 (char* format)
 40726 push 25879
 40729 mov ECX,1
// printf(...)
 40732 call 21772
 40735 add ESP,1
 40738 rstack EAX,EBP:-3
// loop step
 40742 inc EAX
 40744 sstack EBP:-3,EAX
 40748 jmp 40612
__1752:
__1750:
__1746:
__1744:
 40751 leave 
 40752 ret 
__1757:
 40753 db " - %s",0
cmdHelp2:
// cmdHelp2(shell,str_cmd)
 40759 enter 9
__1759:
// assert_type arg #2 (float t)
 40762 push 37328
 40765 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 40769 push EAX
 40771 mov ECX,2
// assert_type(...)
 40774 call 10123
 40777 add ESP,2
 40780 rstack EAX,EBP:2
 40784 add EAX,5
 40787 mov EBX,EAX
 40789 sstack EBP:-1,#EBX
 40793 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 40797 push EAX
 40799 mov ECX,1
// vector_size(...)
 40802 call 32667
 40805 add ESP,1
 40808 sstack EBP:-2,EAX
// init loop
 40812 sstack EBP:-3,0
__1761:
 40817 rstack EAX,EBP:-3
 40821 rstack EBX,EBP:-2
 40825 sub EBX,EAX
 40827 mov EAX,EBX
 40829 fsgn EAX,EAX
// condition
 40831 max EAX,0
 40834 cmp 0,EAX
 40837 jz 40979
 40840 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 40844 push EAX
 40846 mov EAX,SS:EBP
 40849 add EAX,-7
// vector_get arg #2 (void* element)
 40852 push EAX
 40854 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 40858 push EAX
 40860 mov ECX,3
// vector_get(...)
 40863 call 32750
 40866 add ESP,3
 40869 rstack EAX,EBP:-6
 40873 sstack EBP:-8,EAX
__1763:
 40877 rstack EAX,EBP:3
// strcmp arg #2 (char* dest)
 40881 push EAX
 40883 rstack EAX,EBP:-8
// strcmp arg #1 (char* src)
 40887 push EAX
 40889 mov ECX,2
// strcmp(...)
 40892 call 10763
 40895 add ESP,2
 40898 mov EBX,0
 40901 sub EBX,EAX
 40903 fabs EBX,EBX
 40905 fsgn EBX,EBX
 40907 lneg EBX
// if (strcmp(e_str,str_cmd)==0)
 40909 cmp 0,EBX
 40912 jge 40966
 40915 rstack EAX,EBP:-4
 40919 sstack EBP:-9,EAX
__1766:
 40923 rstack EAX,EBP:-9
// if (e_help)
 40927 cmp 0,EAX
 40930 jge 40954
 40933 rstack EAX,EBP:-9
// printf arg #2 (unknown)
 40937 push EAX
// printf arg #1 (char* format)
 40939 push 40981
 40942 mov ECX,2
// printf(...)
 40945 call 21772
 40948 add ESP,2
 40951 jmp 40966
__1769:
__1767:
__1771:
// printf arg #1 (char* format)
 40954 push 40985
 40957 mov ECX,1
// printf(...)
 40960 call 21772
 40963 add ESP,1
__1770:
__1765:
__1764:
__1762:
 40966 rstack EAX,EBP:-3
// loop step
 40970 inc EAX
 40972 sstack EBP:-3,EAX
 40976 jmp 40817
__1760:
__1758:
 40979 leave 
 40980 ret 
__1768:
 40981 db "%s
",0
__1772:
 40985 db "no help is available for this command
",0
cmdCls:
// cmdCls(shell)
 41024 enter -0
__1774:
 41027 mov ECX,0
// screen_clear(...)
 41030 call 17985
// setPrintCursor arg #2 (float y)
 41033 push 0
// setPrintCursor arg #1 (float x)
 41036 push 0
 41039 mov ECX,2
// setPrintCursor(...)
 41042 call 17225
 41045 add ESP,2
__1773:
 41048 leave 
 41049 ret 
cmdEcho:
// cmdEcho(shell,argc,argv)
 41050 enter 1
__1776:
// init loop
 41053 sstack EBP:-1,1
__1778:
 41058 rstack EAX,EBP:-1
 41062 rstack EBX,EBP:3
 41066 sub EBX,EAX
 41068 mov EAX,EBX
 41070 fsgn EAX,EAX
// condition
 41072 max EAX,0
 41075 cmp 0,EAX
 41078 jz 41120
 41081 rstack EAX,EBP:-1
 41085 rstack EBX,EBP:4
 41089 add EBX,EAX
 41091 mov EAX,EBX
// printf arg #2 (unknown)
 41093 push #EAX
// printf arg #1 (char* format)
 41095 push 41134
 41098 mov ECX,2
// printf(...)
 41101 call 21772
 41104 add ESP,2
 41107 rstack EAX,EBP:-1
// loop step
 41111 inc EAX
 41113 sstack EBP:-1,EAX
 41117 jmp 41058
__1777:
// printf arg #1 (char* format)
 41120 push 25879
 41123 mov ECX,1
// printf(...)
 41126 call 21772
 41129 add ESP,1
__1775:
 41132 leave 
 41133 ret 
__1779:
 41134 db "%s ",0
printBytemap:
// printBytemap(ptr,sizeX,sizeY)
 41138 enter 18
__1781:
 41141 sstack EBP:-1,0
 41146 sstack EBP:-2,999999
 41151 sstack EBP:-3,90090
 41156 sstack EBP:-4,929929
 41161 sstack EBP:-5,808808
 41166 sstack EBP:-6,9009
 41171 sstack EBP:-7,900900
 41176 rstack EAX,EBP:-1
 41180 sstack EBP:-8,EAX
 41184 rstack EAX,EBP:-2
 41188 sstack EBP:-9,EAX
 41192 rstack EAX,EBP:-3
 41196 sstack EBP:-10,EAX
 41200 rstack EAX,EBP:-4
 41204 sstack EBP:-11,EAX
 41208 rstack EAX,EBP:-5
 41212 sstack EBP:-12,EAX
 41216 rstack EAX,EBP:-6
 41220 sstack EBP:-13,EAX
// init loop
 41224 sstack EBP:-15,0
__1783:
 41229 rstack EAX,EBP:-15
 41233 rstack EBX,EBP:3
 41237 add EBX,2
 41240 mov ECX,EBX
 41242 sub ECX,EAX
 41244 fsgn ECX,ECX
// condition
 41246 max ECX,0
 41249 cmp 0,ECX
 41252 jz 41280
// printf arg #1 (char* format)
 41255 push 41705
 41258 mov ECX,1
// printf(...)
 41261 call 21772
 41264 add ESP,1
 41267 rstack EAX,EBP:-15
// loop step
 41271 inc EAX
 41273 sstack EBP:-15,EAX
 41277 jmp 41229
__1782:
// printf arg #1 (char* format)
 41280 push 25879
 41283 mov ECX,1
// printf(...)
 41286 call 21772
 41289 add ESP,1
// init loop
 41292 sstack EBP:-14,0
__1786:
 41297 rstack EAX,EBP:-14
 41301 rstack EBX,EBP:4
 41305 sub EBX,EAX
 41307 mov EAX,EBX
 41309 fsgn EAX,EAX
// condition
 41311 max EAX,0
 41314 cmp 0,EAX
 41317 jz 41635
// printf arg #1 (char* format)
 41320 push 41707
 41323 mov ECX,1
// printf(...)
 41326 call 21772
 41329 add ESP,1
// init loop
 41332 sstack EBP:-15,0
__1789:
 41337 rstack EAX,EBP:-15
 41341 rstack EBX,EBP:3
 41345 sub EBX,EAX
 41347 mov EAX,EBX
 41349 fsgn EAX,EAX
// condition
 41351 max EAX,0
 41354 cmp 0,EAX
 41357 jz 41598
 41360 rstack EAX,EBP:2
 41364 mov EBX,EAX
 41366 inc EAX
 41368 sstack EBP:2,EAX
 41372 sstack EBP:-16,#EBX
 41376 rstack EAX,EBP:-16
// floor arg #1 (float A)
 41380 push EAX
 41382 mov ECX,1
// floor(...)
 41385 call 30221
 41388 add ESP,1
 41391 neg EAX
 41393 rstack EBX,EBP:-16
 41397 add EBX,EAX
 41399 mov EAX,EBX
 41401 sstack EBP:-17,EAX
 41405 rstack EAX,EBP:-7
 41409 sstack EBP:-18,EAX
__1791:
 41413 rstack EAX,EBP:-16
 41417 mov EBX,0
 41420 sub EBX,EAX
 41422 fabs EBX,EBX
 41424 fsgn EBX,EBX
 41426 lneg EBX
// if (byte==0)
 41428 cmp 0,EBX
 41431 jge 41445
 41434 rstack EAX,EBP:-8
// col=col_zero
 41438 sstack EBP:-18,EAX
 41442 jmp 41567
__1793:
__1792:
__1795:
__1797:
 41445 rstack EAX,EBP:-17
// if (fl)
 41449 cmp 0,EAX
 41452 jge 41497
__1800:
 41455 rstack EAX,EBP:-16
 41459 mov EBX,10000
 41462 sub EBX,EAX
 41464 fsgn EBX,EBX
 41466 max EBX,0
// if (byte<10000)
 41469 cmp 0,EBX
 41472 jge 41486
 41475 rstack EAX,EBP:-11
// col=col_num_float_low
 41479 sstack EBP:-18,EAX
 41483 jmp 41494
__1802:
__1801:
__1804:
 41486 rstack EAX,EBP:-12
// col=col_num_float_high
 41490 sstack EBP:-18,EAX
__1803:
__1799:
 41494 jmp 41567
__1805:
__1798:
__1807:
__1809:
 41497 rstack EAX,EBP:-16
 41501 mov EBX,0
 41504 sub EBX,EAX
 41506 fsgn EBX,EBX
 41508 max EBX,0
// if (byte<0)
 41511 cmp 0,EBX
 41514 jge 41528
 41517 rstack EAX,EBP:-10
// col=col_num_negative
 41521 sstack EBP:-18,EAX
 41525 jmp 41567
__1811:
__1810:
__1813:
__1815:
 41528 rstack EAX,EBP:-16
 41532 mov EBX,10000
 41535 sub EBX,EAX
 41537 fsgn EBX,EBX
 41539 max EBX,0
// if (byte<10000)
 41542 cmp 0,EBX
 41545 jge 41559
 41548 rstack EAX,EBP:-9
// col=col_num_low
 41552 sstack EBP:-18,EAX
 41556 jmp 41567
__1817:
__1816:
__1819:
 41559 rstack EAX,EBP:-13
// col=col_num_high
 41563 sstack EBP:-18,EAX
__1818:
__1814:
__1812:
__1808:
__1806:
__1796:
__1794:
__1790:
 41567 rstack EAX,EBP:-18
// printf arg #2 (unknown)
 41571 push EAX
// printf arg #1 (char* format)
 41573 push 41709
 41576 mov ECX,2
// printf(...)
 41579 call 21772
 41582 add ESP,2
 41585 rstack EAX,EBP:-15
// loop step
 41589 inc EAX
 41591 sstack EBP:-15,EAX
 41595 jmp 41337
__1788:
// printf arg #1 (char* format)
 41598 push 41707
 41601 mov ECX,1
// printf(...)
 41604 call 21772
 41607 add ESP,1
// printf arg #1 (char* format)
 41610 push 25879
 41613 mov ECX,1
// printf(...)
 41616 call 21772
 41619 add ESP,1
 41622 rstack EAX,EBP:-14
// loop step
 41626 inc EAX
 41628 sstack EBP:-14,EAX
 41632 jmp 41297
__1785:
// init loop
 41635 sstack EBP:-15,0
__1822:
 41640 rstack EAX,EBP:-15
 41644 rstack EBX,EBP:3
 41648 add EBX,2
 41651 mov ECX,EBX
 41653 sub ECX,EAX
 41655 fsgn ECX,ECX
// condition
 41657 max ECX,0
 41660 cmp 0,ECX
 41663 jz 41691
// printf arg #1 (char* format)
 41666 push 41705
 41669 mov ECX,1
// printf(...)
 41672 call 21772
 41675 add ESP,1
 41678 rstack EAX,EBP:-15
// loop step
 41682 inc EAX
 41684 sstack EBP:-15,EAX
 41688 jmp 41640
__1821:
// printf arg #1 (char* format)
 41691 push 25879
 41694 mov ECX,1
// printf(...)
 41697 call 21772
 41700 add ESP,1
__1780:
 41703 leave 
 41704 ret 
__1784:
 41705 db "_",0
__1787:
 41707 db "|",0
__1820:
 41709 db "%m ",0
cmdDevice:
// cmdDevice(shell,argc,argv)
 41713 enter 7
__1824:
__1826:
 41716 rstack EAX,EBP:3
 41720 mov EBX,1
 41723 sub EBX,EAX
 41725 neg EBX
 41727 fsgn EBX,EBX
 41729 max EBX,0
// if (argc>1)
 41732 cmp 0,EBX
 41735 jge 42209
__1830:
// strcmp arg #2 (char* dest)
 41738 push 42276
 41741 rstack EAX,EBP:4
 41745 add EAX,1
 41748 mov EBX,EAX
// strcmp arg #1 (char* src)
 41750 push #EBX
 41752 mov ECX,2
// strcmp(...)
 41755 call 10763
 41758 add ESP,2
 41761 mov EBX,0
 41764 sub EBX,EAX
 41766 fabs EBX,EBX
 41768 fsgn EBX,EBX
 41770 lneg EBX
// if (strcmp(argv[1],"list")==0)
 41772 cmp 0,EBX
 41775 jge 41912
// printf arg #1 (char* format)
 41778 push 42257
 41781 mov ECX,1
// printf(...)
 41784 call 21772
 41787 add ESP,1
// init loop
 41790 sstack EBP:-7,0
__1834:
 41795 rstack EAX,EBP:-7
 41799 mov EBX,9
 41802 sub EBX,EAX
 41804 fsgn EBX,EBX
// condition
 41806 max EBX,0
 41809 cmp 0,EBX
 41812 jz 41912
 41815 rstack EAX,EBP:-7
// EBcb_get_entry arg #2 (float num)
 41819 push EAX
// EBcb_get_entry arg #1 (float this)
 41821 push 66989
 41824 mov ECX,2
// EBcb_get_entry(...)
 41827 call 19801
 41830 add ESP,2
// devEntry=EBcb_get_entry(EBcb_1,I)
 41833 sstack EBP:-2,EAX
 41837 rstack EAX,EBP:-2
// EBcb_entry_get_type arg #1 (float this)
 41841 push EAX
 41843 mov ECX,1
// EBcb_entry_get_type(...)
 41846 call 19621
 41849 add ESP,1
// devType=EBcb_entry_get_type(devEntry)
 41852 sstack EBP:-3,EAX
 41856 rstack EAX,EBP:-3
// udhTypeToString arg #1 (float type)
 41860 push EAX
 41862 mov ECX,1
// udhTypeToString(...)
 41865 call 18978
 41868 add ESP,1
// typeString=udhTypeToString(devType)
 41871 sstack EBP:-4,EAX
 41875 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 41879 push EAX
 41881 rstack EAX,EBP:-7
// printf arg #2 (unknown)
 41885 push EAX
// printf arg #1 (char* format)
 41887 push 42281
 41890 mov ECX,3
// printf(...)
 41893 call 21772
 41896 add ESP,3
 41899 rstack EAX,EBP:-7
// loop step
 41903 inc EAX
 41905 sstack EBP:-7,EAX
 41909 jmp 41795
__1833:
__1831:
__1829:
__1838:
// strcmp arg #2 (char* dest)
 41912 push 42252
 41915 rstack EAX,EBP:4
 41919 add EAX,1
 41922 mov EBX,EAX
// strcmp arg #1 (char* src)
 41924 push #EBX
 41926 mov ECX,2
// strcmp(...)
 41929 call 10763
 41932 add ESP,2
 41935 mov EBX,0
 41938 sub EBX,EAX
 41940 fabs EBX,EBX
 41942 fsgn EBX,EBX
 41944 lneg EBX
// if (strcmp(argv[1],"info")==0)
 41946 cmp 0,EBX
 41949 jge 42206
__1841:
 41952 rstack EAX,EBP:3
 41956 mov EBX,2
 41959 sub EBX,EAX
 41961 neg EBX
 41963 fsgn EBX,EBX
 41965 max EBX,0
// if (argc>2)
 41968 cmp 0,EBX
 41971 jge 42180
 41974 rstack EAX,EBP:4
 41978 add EAX,2
 41981 mov EBX,EAX
// str2num arg #1 (char* str)
 41983 push #EBX
 41985 mov ECX,1
// str2num(...)
 41988 call 12270
 41991 add ESP,1
// devNum=str2num(argv[2])
 41994 sstack EBP:-1,EAX
 41998 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 42002 push EAX
// EBcb_get_entry arg #1 (float this)
 42004 push 66989
 42007 mov ECX,2
// EBcb_get_entry(...)
 42010 call 19801
 42013 add ESP,2
// devEntry=EBcb_get_entry(EBcb_1,devNum)
 42016 sstack EBP:-2,EAX
 42020 rstack EAX,EBP:-2
// EBcb_entry_get_type arg #1 (float this)
 42024 push EAX
 42026 mov ECX,1
// EBcb_entry_get_type(...)
 42029 call 19621
 42032 add ESP,1
// devType=EBcb_entry_get_type(devEntry)
 42035 sstack EBP:-3,EAX
 42039 rstack EAX,EBP:-3
// udhTypeToString arg #1 (float type)
 42043 push EAX
 42045 mov ECX,1
// udhTypeToString(...)
 42048 call 18978
 42051 add ESP,1
// typeString=udhTypeToString(devType)
 42054 sstack EBP:-4,EAX
 42058 rstack EAX,EBP:-2
// EBcb_entry_get_addr arg #1 (float this)
 42062 push EAX
 42064 mov ECX,1
// EBcb_entry_get_addr(...)
 42067 call 19657
 42070 add ESP,1
// devAddr=EBcb_entry_get_addr(devEntry)
 42073 sstack EBP:-5,EAX
 42077 rstack EAX,EBP:-2
// EBcb_entry_get_size arg #1 (float this)
 42081 push EAX
 42083 mov ECX,1
// EBcb_entry_get_size(...)
 42086 call 19639
 42089 add ESP,1
// devSize=EBcb_entry_get_size(devEntry)
 42092 sstack EBP:-6,EAX
 42096 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 42100 push EAX
 42102 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 42106 push EAX
// printf arg #1 (char* format)
 42108 push 42281
 42111 mov ECX,3
// printf(...)
 42114 call 21772
 42117 add ESP,3
 42120 rstack EAX,EBP:-6
// printf arg #3 (unknown)
 42124 push EAX
 42126 rstack EAX,EBP:-5
// printf arg #2 (unknown)
 42130 push EAX
// printf arg #1 (char* format)
 42132 push 42237
 42135 mov ECX,3
// printf(...)
 42138 call 21772
 42141 add ESP,3
// printf arg #1 (char* format)
 42144 push 42267
 42147 mov ECX,1
// printf(...)
 42150 call 21772
 42153 add ESP,1
// printBytemap arg #3 (float sizeY)
 42156 push 5
// printBytemap arg #2 (float sizeX)
 42159 push 20
 42162 rstack EAX,EBP:-5
// printBytemap arg #1 (float ptr)
 42166 push EAX
 42168 mov ECX,3
// printBytemap(...)
 42171 call 41138
 42174 add ESP,3
 42177 jmp 42206
__1845:
__1842:
__1847:
 42180 rstack EAX,EBP:4
 42184 add EAX,0
 42187 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 42189 push #EBX
 42191 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 42195 push EAX
 42197 mov ECX,2
// cmdHelp2(...)
 42200 call 40759
 42203 add ESP,2
__1846:
__1840:
__1839:
__1837:
 42206 jmp 42235
__1848:
__1827:
__1850:
 42209 rstack EAX,EBP:4
 42213 add EAX,0
 42216 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 42218 push #EBX
 42220 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 42224 push EAX
 42226 mov ECX,2
// cmdHelp2(...)
 42229 call 40759
 42232 add ESP,2
__1849:
__1825:
__1823:
 42235 leave 
 42236 ret 
__1843:
 42237 db "@ %d, size %d
",0
__1836:
 42252 db "info",0
__1832:
 42257 db "devices:
",0
__1844:
 42267 db "memory:
",0
__1828:
 42276 db "list",0
__1835:
 42281 db "dev %d: %s
",0
fs_marker1:
 42293 db 0
typeof_file_handle:
 42294 db "file_handle",0
check_canary:
// check_canary(this,canary)
 42306 enter -0
__1852:
 42309 rstack EAX,EBP:3
// assert_type arg #2 (float t)
 42313 push EAX
 42315 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 42319 push EAX
 42321 mov ECX,2
// assert_type(...)
 42324 call 10123
 42327 add ESP,2
__1851:
 42330 leave 
 42331 ret 
sizeof_file_handle:
 42332 db 3
file_handle_constructor:
// file_handle_constructor(this)
 42333 enter -0
__1854:
 42336 rstack EAX,EBP:2
 42340 add EAX,0
 42343 mov EBX,EAX
// this[0]=typeof_file_handle
 42345 mov #EBX,42294
 42348 rstack EAX,EBP:2
 42352 add EAX,1
 42355 mov EBX,EAX
// this[1]=0
 42357 mov #EBX,0
 42360 rstack EAX,EBP:2
 42364 add EAX,2
 42367 mov EBX,EAX
// this[2]=0
 42369 mov #EBX,0
__1853:
 42372 leave 
 42373 ret 
file_handle_copy_constructor:
// file_handle_copy_constructor(this,that)
 42374 enter -0
__1856:
 42377 rstack EAX,EBP:3
 42381 add EAX,0
 42384 mov EBX,EAX
 42386 rstack EAX,EBP:2
 42390 add EAX,0
 42393 mov ECX,EAX
// this[0]=that[0]
 42395 mov #ECX,#EBX
 42397 rstack EAX,EBP:3
 42401 add EAX,1
 42404 mov EBX,EAX
 42406 rstack EAX,EBP:2
 42410 add EAX,1
 42413 mov ECX,EAX
// this[1]=that[1]
 42415 mov #ECX,#EBX
 42417 rstack EAX,EBP:3
 42421 add EAX,2
 42424 mov EBX,EAX
 42426 rstack EAX,EBP:2
 42430 add EAX,2
 42433 mov ECX,EAX
// this[2]=that[2]
 42435 mov #ECX,#EBX
// check_canary arg #2 (float canary)
 42437 push 42294
 42440 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42444 push EAX
 42446 mov ECX,2
// check_canary(...)
 42449 call 42306
 42452 add ESP,2
__1855:
 42455 leave 
 42456 ret 
file_handle_destructor:
// file_handle_destructor(this)
 42457 enter -0
__1858:
// check_canary arg #2 (float canary)
 42460 push 42294
 42463 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42467 push EAX
 42469 mov ECX,2
// check_canary(...)
 42472 call 42306
 42475 add ESP,2
__1857:
 42478 leave 
 42479 ret 
file_handle_get_canary:
// file_handle_get_canary(this)
 42480 enter -0
__1860:
// check_canary arg #2 (float canary)
 42483 push 42294
 42486 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42490 push EAX
 42492 mov ECX,2
// check_canary(...)
 42495 call 42306
 42498 add ESP,2
 42501 rstack EAX,EBP:2
 42505 add EAX,0
 42508 mov EBX,EAX
 42510 mov EAX,#EBX
 42512 leave 
 42513 ret 
__1859:
 42514 leave 
 42515 ret 
file_handle_get_rw_ptr:
// file_handle_get_rw_ptr(this)
 42516 enter -0
__1862:
// check_canary arg #2 (float canary)
 42519 push 42294
 42522 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42526 push EAX
 42528 mov ECX,2
// check_canary(...)
 42531 call 42306
 42534 add ESP,2
 42537 rstack EAX,EBP:2
 42541 add EAX,1
 42544 mov EBX,EAX
 42546 mov EAX,#EBX
 42548 leave 
 42549 ret 
__1861:
 42550 leave 
 42551 ret 
file_handle_get_imp:
// file_handle_get_imp(this)
 42552 enter -0
__1864:
// check_canary arg #2 (float canary)
 42555 push 42294
 42558 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42562 push EAX
 42564 mov ECX,2
// check_canary(...)
 42567 call 42306
 42570 add ESP,2
 42573 rstack EAX,EBP:2
 42577 add EAX,2
 42580 mov EBX,EAX
 42582 mov EAX,#EBX
 42584 leave 
 42585 ret 
__1863:
 42586 leave 
 42587 ret 
file_handle_set_canary:
// file_handle_set_canary(this,N)
 42588 enter -0
__1866:
// check_canary arg #2 (float canary)
 42591 push 42294
 42594 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42598 push EAX
 42600 mov ECX,2
// check_canary(...)
 42603 call 42306
 42606 add ESP,2
 42609 rstack EAX,EBP:3
 42613 rstack EBX,EBP:2
 42617 add EBX,0
 42620 mov ECX,EBX
// this[0]=N
 42622 mov #ECX,EAX
__1865:
 42624 leave 
 42625 ret 
file_handle_set_rw_ptr:
// file_handle_set_rw_ptr(this,N)
 42626 enter -0
__1868:
// check_canary arg #2 (float canary)
 42629 push 42294
 42632 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42636 push EAX
 42638 mov ECX,2
// check_canary(...)
 42641 call 42306
 42644 add ESP,2
 42647 rstack EAX,EBP:3
 42651 rstack EBX,EBP:2
 42655 add EBX,1
 42658 mov ECX,EBX
// this[1]=N
 42660 mov #ECX,EAX
__1867:
 42662 leave 
 42663 ret 
file_handle_set_imp:
// file_handle_set_imp(this,N)
 42664 enter -0
__1870:
// check_canary arg #2 (float canary)
 42667 push 42294
 42670 rstack EAX,EBP:2
// check_canary arg #1 (float this)
 42674 push EAX
 42676 mov ECX,2
// check_canary(...)
 42679 call 42306
 42682 add ESP,2
 42685 rstack EAX,EBP:3
 42689 rstack EBX,EBP:2
 42693 add EBX,2
 42696 mov ECX,EBX
// this[2]=N
 42698 mov #ECX,EAX
__1869:
 42700 leave 
 42701 ret 
translate_fopen_mode:
// translate_fopen_mode(mode,read,write,keepdata,from,newfile)
 42702 enter -0
__1872:
__1875:
// strcmp arg #2 (char* dest)
 42705 push 43181
 42708 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 42712 push EAX
 42714 mov ECX,2
// strcmp(...)
 42717 call 10763
 42720 add ESP,2
 42723 mov EBX,0
 42726 sub EBX,EAX
 42728 fabs EBX,EBX
 42730 fsgn EBX,EBX
 42732 lneg EBX
// if (strcmp(mode,"r")==0)
 42734 cmp 0,EBX
 42737 jge 42777
 42740 rstack EAX,EBP:3
// *read=1
 42744 mov #EAX,1
 42747 rstack EAX,EBP:4
// *write=0
 42751 mov #EAX,0
 42754 rstack EAX,EBP:5
// *keepdata=1
 42758 mov #EAX,1
 42761 rstack EAX,EBP:6
// *from=0
 42765 mov #EAX,0
 42768 rstack EAX,EBP:7
// *newfile=0
 42772 mov #EAX,0
 42775 leave 
 42776 ret 
__1876:
__1874:
__1879:
// strcmp arg #2 (char* dest)
 42777 push 43179
 42780 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 42784 push EAX
 42786 mov ECX,2
// strcmp(...)
 42789 call 10763
 42792 add ESP,2
 42795 mov EBX,0
 42798 sub EBX,EAX
 42800 fabs EBX,EBX
 42802 fsgn EBX,EBX
 42804 lneg EBX
// if (strcmp(mode,"w")==0)
 42806 cmp 0,EBX
 42809 jge 42849
 42812 rstack EAX,EBP:3
// *read=0
 42816 mov #EAX,0
 42819 rstack EAX,EBP:4
// *write=1
 42823 mov #EAX,1
 42826 rstack EAX,EBP:5
// *keepdata=0
 42830 mov #EAX,0
 42833 rstack EAX,EBP:6
// *from=0
 42837 mov #EAX,0
 42840 rstack EAX,EBP:7
// *newfile=1
 42844 mov #EAX,1
 42847 leave 
 42848 ret 
__1880:
__1878:
__1883:
// strcmp arg #2 (char* dest)
 42849 push 43188
 42852 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 42856 push EAX
 42858 mov ECX,2
// strcmp(...)
 42861 call 10763
 42864 add ESP,2
 42867 mov EBX,0
 42870 sub EBX,EAX
 42872 fabs EBX,EBX
 42874 fsgn EBX,EBX
 42876 lneg EBX
// if (strcmp(mode,"r+")==0)
 42878 cmp 0,EBX
 42881 jge 42921
 42884 rstack EAX,EBP:3
// *read=1
 42888 mov #EAX,1
 42891 rstack EAX,EBP:4
// *write=1
 42895 mov #EAX,1
 42898 rstack EAX,EBP:5
// *keepdata=1
 42902 mov #EAX,1
 42905 rstack EAX,EBP:6
// *from=0
 42909 mov #EAX,0
 42912 rstack EAX,EBP:7
// *newfile=0
 42916 mov #EAX,0
 42919 leave 
 42920 ret 
__1884:
__1882:
__1887:
// strcmp arg #2 (char* dest)
 42921 push 43185
 42924 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 42928 push EAX
 42930 mov ECX,2
// strcmp(...)
 42933 call 10763
 42936 add ESP,2
 42939 mov EBX,0
 42942 sub EBX,EAX
 42944 fabs EBX,EBX
 42946 fsgn EBX,EBX
 42948 lneg EBX
// if (strcmp(mode,"w+")==0)
 42950 cmp 0,EBX
 42953 jge 42993
 42956 rstack EAX,EBP:3
// *read=1
 42960 mov #EAX,1
 42963 rstack EAX,EBP:4
// *write=1
 42967 mov #EAX,1
 42970 rstack EAX,EBP:5
// *keepdata=0
 42974 mov #EAX,0
 42977 rstack EAX,EBP:6
// *from=0
 42981 mov #EAX,0
 42984 rstack EAX,EBP:7
// *newfile=1
 42988 mov #EAX,1
 42991 leave 
 42992 ret 
__1888:
__1886:
__1891:
// strcmp arg #2 (char* dest)
 42993 push 43183
 42996 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 43000 push EAX
 43002 mov ECX,2
// strcmp(...)
 43005 call 10763
 43008 add ESP,2
 43011 mov EBX,0
 43014 sub EBX,EAX
 43016 fabs EBX,EBX
 43018 fsgn EBX,EBX
 43020 lneg EBX
// if (strcmp(mode,"a")==0)
 43022 cmp 0,EBX
 43025 jge 43065
 43028 rstack EAX,EBP:3
// *read=0
 43032 mov #EAX,0
 43035 rstack EAX,EBP:4
// *write=1
 43039 mov #EAX,1
 43042 rstack EAX,EBP:5
// *keepdata=1
 43046 mov #EAX,1
 43049 rstack EAX,EBP:6
// *from=1
 43053 mov #EAX,1
 43056 rstack EAX,EBP:7
// *newfile=1
 43060 mov #EAX,1
 43063 leave 
 43064 ret 
__1892:
__1890:
__1895:
// strcmp arg #2 (char* dest)
 43065 push 43176
 43068 rstack EAX,EBP:2
// strcmp arg #1 (char* src)
 43072 push EAX
 43074 mov ECX,2
// strcmp(...)
 43077 call 10763
 43080 add ESP,2
 43083 mov EBX,0
 43086 sub EBX,EAX
 43088 fabs EBX,EBX
 43090 fsgn EBX,EBX
 43092 lneg EBX
// if (strcmp(mode,"a+")==0)
 43094 cmp 0,EBX
 43097 jge 43137
 43100 rstack EAX,EBP:3
// *read=1
 43104 mov #EAX,1
 43107 rstack EAX,EBP:4
// *write=1
 43111 mov #EAX,1
 43114 rstack EAX,EBP:5
// *keepdata=1
 43118 mov #EAX,1
 43121 rstack EAX,EBP:6
// *from=1
 43125 mov #EAX,1
 43128 rstack EAX,EBP:7
// *newfile=1
 43132 mov #EAX,1
 43135 leave 
 43136 ret 
__1896:
__1894:
 43137 rstack EAX,EBP:3
// *read=0
 43141 mov #EAX,0
 43144 rstack EAX,EBP:4
// *write=0
 43148 mov #EAX,0
 43151 rstack EAX,EBP:5
// *keepdata=0
 43155 mov #EAX,0
 43158 rstack EAX,EBP:6
// *from=0
 43162 mov #EAX,0
 43165 rstack EAX,EBP:7
// *newfile=0
 43169 mov #EAX,0
 43172 leave 
 43173 ret 
__1871:
 43174 leave 
 43175 ret 
__1893:
 43176 db "a+",0
__1877:
 43179 db "w",0
__1873:
 43181 db "r",0
__1889:
 43183 db "a",0
__1885:
 43185 db "w+",0
__1881:
 43188 db "r+",0
filepath_legal:
// filepath_legal(filename)
 43191 enter 2
__1898:
 43194 sstack EBP:-1,0
__1900:
 43199 rstack EAX,EBP:-1
 43203 rstack EBX,EBP:2
 43207 add EBX,EAX
 43209 mov EAX,EBX
 43211 mov EBX,0
 43214 sub EBX,#EAX
 43216 fabs EBX,EBX
 43218 fsgn EBX,EBX
// if (filename[I]!=0
 43220 cmp 0,EBX
 43223 jz 43296
 43226 rstack EAX,EBP:-1
 43230 rstack EBX,EBP:2
 43234 add EBX,EAX
 43236 mov EAX,EBX
 43238 sstack EBP:-2,#EAX
 43242 rstack EAX,EBP:-1
// I++
 43246 inc EAX
 43248 sstack EBP:-1,EAX
__1902:
 43252 rstack EAX,EBP:-2
 43256 mov EBX,47
 43259 sub EBX,EAX
 43261 fabs EBX,EBX
 43263 fsgn EBX,EBX
 43265 rstack EAX,EBP:-2
// isAlpha arg #1 (char C)
 43269 push EAX
 43271 mov ECX,1
// isAlpha(...)
 43274 call 15387
 43277 add ESP,1
 43280 and EAX,EBX
// if (isalpha(C)&&(C!='/'))
 43282 cmp 0,EAX
 43285 jge 43293
 43288 mov EAX,0
 43291 leave 
 43292 ret 
__1903:
__1901:
 43293 jmp 43199
__1899:
 43296 mov EAX,1
 43299 leave 
 43300 ret 
__1897:
 43301 leave 
 43302 ret 
filepath_abs:
// filepath_abs(current_path,filename)
 43303 enter 3
__1905:
__1907:
 43306 rstack EAX,EBP:2
 43310 lneg EAX
 43312 mov EBX,EAX
// if (!current_path)
 43314 cmp 0,EBX
 43317 jge 43337
// printf arg #1 (char* format)
 43320 push 43539
 43323 mov ECX,1
// printf(...)
 43326 call 21772
 43329 add ESP,1
 43332 mov EAX,0
 43335 leave 
 43336 ret 
__1908:
__1906:
__1911:
 43337 rstack EAX,EBP:3
 43341 lneg EAX
 43343 mov EBX,EAX
// if (!filename)
 43345 cmp 0,EBX
 43348 jge 43368
// printf arg #1 (char* format)
 43351 push 43522
 43354 mov ECX,1
// printf(...)
 43357 call 21772
 43360 add ESP,1
 43363 mov EAX,0
 43366 leave 
 43367 ret 
__1912:
__1910:
// cstr_find_first_of arg #2 (char C)
 43368 push 58
 43371 rstack EAX,EBP:3
// cstr_find_first_of arg #1 (char* S)
 43375 push EAX
 43377 mov ECX,2
// cstr_find_first_of(...)
 43380 call 16712
 43383 add ESP,2
 43386 sstack EBP:-1,EAX
__1915:
 43390 rstack EAX,EBP:-1
 43394 mov EBX,-1
 43397 sub EBX,EAX
 43399 fabs EBX,EBX
 43401 fsgn EBX,EBX
// if (I!=-1)
 43403 cmp 0,EBX
 43406 jge 43415
 43409 rstack EAX,EBP:3
 43413 leave 
 43414 ret 
__1916:
__1914:
__1918:
 43415 rstack EAX,EBP:3
 43419 add EAX,0
 43422 mov EBX,EAX
 43424 mov EAX,47
 43427 sub EAX,#EBX
 43429 fabs EAX,EAX
 43431 fsgn EAX,EAX
 43433 lneg EAX
// if (filename[0]=='/')
 43435 cmp 0,EAX
 43438 jge 43447
 43441 rstack EAX,EBP:3
 43445 leave 
 43446 ret 
__1919:
__1917:
 43447 rstack EAX,EBP:3
// concat arg #2 (unknown)
 43451 push EAX
 43453 rstack EAX,EBP:2
// concat arg #1 (unknown)
 43457 push EAX
 43459 mov ECX,2
// concat(...)
 43462 call 16186
 43465 add ESP,2
 43468 sstack EBP:-2,EAX
 43472 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 43476 push EAX
 43478 mov ECX,1
// strlen(...)
 43481 call 11121
 43484 add ESP,1
 43487 sstack EBP:-3,EAX
// stack_return arg #3 (float num_args)
 43491 push 2
 43494 rstack EAX,EBP:-3
 43498 add EAX,1
 43501 mov EBX,EAX
// stack_return arg #2 (float size)
 43503 push EBX
 43505 rstack EAX,EBP:-2
// stack_return arg #1 (float ptr)
 43509 push EAX
 43511 mov ECX,3
// stack_return(...)
 43514 call 11897
 43517 add ESP,3
__1904:
 43520 leave 
 43521 ret 
__1913:
 43522 db "filename is null",0
__1909:
 43539 db "current_path is null",0
filepath_decimate:
// filepath_decimate(filename,folders,name,is_abs)
 43560 enter 5
__1921:
 43563 rstack EAX,EBP:3
// *folders=0
 43567 mov #EAX,0
 43570 rstack EAX,EBP:4
// *name=0
 43574 mov #EAX,0
 43577 rstack EAX,EBP:5
// *is_abs=0
 43581 mov #EAX,0
 43584 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 43588 push EAX
 43590 mov ECX,1
// strlen(...)
 43593 call 11121
 43596 add ESP,1
 43599 sstack EBP:-1,EAX
 43603 sstack EBP:-2,1
 43608 rstack EAX,EBP:-1
 43612 mov EBX,12
 43615 add EBX,EAX
// malloc arg #1 (float n)
 43617 push EBX
 43619 mov ECX,1
// malloc(...)
 43622 call 28486
 43625 add ESP,1
 43628 sstack EBP:-3,EAX
 43632 rstack EAX,EBP:2
// strcpy arg #2 (char* src)
 43636 push EAX
 43638 rstack EAX,EBP:-3
 43642 add EAX,11
 43645 mov EBX,EAX
// strcpy arg #1 (char* dest)
 43647 push EBX
 43649 mov ECX,2
// strcpy(...)
 43652 call 10963
 43655 add ESP,2
 43658 rstack EAX,EBP:-3
 43662 add EAX,11
 43665 mov EBX,EAX
// filename=dir_arr+11
 43667 sstack EBP:2,EBX
 43671 sstack EBP:-4,0
__1923:
 43676 rstack EAX,EBP:-1
 43680 add EAX,-1
 43683 mov EBX,EAX
 43685 rstack EAX,EBP:2
 43689 add EAX,EBX
 43691 mov EBX,EAX
 43693 mov EAX,47
 43696 sub EAX,#EBX
 43698 fabs EAX,EAX
 43700 fsgn EAX,EAX
 43702 lneg EAX
// if (filename[len-1]=='/')
 43704 cmp 0,EAX
 43707 jge 43735
// is_file=0
 43710 sstack EBP:-2,0
 43715 rstack EAX,EBP:-1
 43719 add EAX,-1
 43722 mov EBX,EAX
 43724 rstack EAX,EBP:2
 43728 add EAX,EBX
 43730 mov EBX,EAX
// filename[len-1]=0
 43732 mov #EBX,0
__1924:
__1922:
__1926:
 43735 rstack EAX,EBP:2
 43739 add EAX,0
 43742 mov EBX,EAX
 43744 mov EAX,47
 43747 sub EAX,#EBX
 43749 fabs EAX,EAX
 43751 fsgn EAX,EAX
 43753 lneg EAX
// if (filename[0]=='/')
 43755 cmp 0,EAX
 43758 jge 43778
 43761 rstack EAX,EBP:5
// *is_abs=1
 43765 mov #EAX,1
 43768 rstack EAX,EBP:2
// filename++
 43772 inc EAX
 43774 sstack EBP:2,EAX
__1927:
__1925:
 43778 sstack EBP:-5,0
fp_dec_loop:
// cstr_find_first_of arg #2 (char C)
 43783 push 47
 43786 rstack EAX,EBP:2
// cstr_find_first_of arg #1 (char* S)
 43790 push EAX
 43792 mov ECX,2
// cstr_find_first_of(...)
 43795 call 16712
 43798 add ESP,2
// I=cstr_find_first_of(filename,'/')
 43801 sstack EBP:-5,EAX
__1929:
 43805 rstack EAX,EBP:-5
 43809 mov EBX,-1
 43812 sub EBX,EAX
 43814 fabs EBX,EBX
 43816 fsgn EBX,EBX
 43818 lneg EBX
// if (I==-1)
 43820 cmp 0,EBX
 43823 jge 43905
__1932:
 43826 rstack EAX,EBP:-2
// if (is_file)
 43830 cmp 0,EAX
 43833 jge 43849
 43836 rstack EAX,EBP:2
 43840 rstack EBX,EBP:4
// *name=filename
 43844 mov #EBX,EAX
 43846 jmp 43887
__1934:
__1933:
__1936:
 43849 rstack EAX,EBP:2
 43853 rstack EBX,EBP:-4
 43857 rstack ECX,EBP:-3
 43861 add ECX,EBX
 43863 mov EBX,ECX
// dir_arr[dir_arr_I]=filename
 43865 mov #EBX,EAX
 43867 rstack EAX,EBP:-4
// dir_arr_I++
 43871 inc EAX
 43873 sstack EBP:-4,EAX
 43877 rstack EAX,EBP:-5
// I++
 43881 inc EAX
 43883 sstack EBP:-5,EAX
__1935:
__1931:
 43887 rstack EAX,EBP:-4
 43891 rstack EBX,EBP:-3
 43895 add EBX,EAX
 43897 mov EAX,EBX
// dir_arr[dir_arr_I]=0
 43899 mov #EAX,0
 43902 jmp 43972
__1937:
__1930:
__1939:
 43905 rstack EAX,EBP:-5
 43909 rstack EBX,EBP:2
 43913 add EBX,EAX
 43915 mov EAX,EBX
// filename[I]=0
 43917 mov #EAX,0
 43920 rstack EAX,EBP:2
 43924 rstack EBX,EBP:-4
 43928 rstack ECX,EBP:-3
 43932 add ECX,EBX
 43934 mov EBX,ECX
// dir_arr[dir_arr_I]=filename
 43936 mov #EBX,EAX
 43938 rstack EAX,EBP:-4
// dir_arr_I++
 43942 inc EAX
 43944 sstack EBP:-4,EAX
 43948 rstack EAX,EBP:-5
 43952 add EAX,1
 43955 mov EBX,EAX
 43957 rstack EAX,EBP:2
 43961 add EAX,EBX
 43963 mov EBX,EAX
// filename=filename+I+1
 43965 sstack EBP:2,EBX
 43969 jmp 43783
__1938:
__1928:
 43972 rstack EAX,EBP:-3
 43976 rstack EBX,EBP:3
// *folders=dir_arr
 43980 mov #EBX,EAX
__1920:
 43982 leave 
 43983 ret 
filepath_extension:
// filepath_extension(filename)
 43984 enter 1
__1941:
// cstr_find_last_of arg #2 (char C)
 43987 push 46
 43990 rstack EAX,EBP:2
// cstr_find_last_of arg #1 (char* S)
 43994 push EAX
 43996 mov ECX,2
// cstr_find_last_of(...)
 43999 call 16821
 44002 add ESP,2
 44005 sstack EBP:-1,EAX
__1943:
 44009 rstack EAX,EBP:-1
 44013 mov EBX,-1
 44016 sub EBX,EAX
 44018 fabs EBX,EBX
 44020 fsgn EBX,EBX
 44022 lneg EBX
// if (I==-1)
 44024 cmp 0,EBX
 44027 jge 44038
 44030 mov EAX,0
 44033 leave 
 44034 ret 
 44035 jmp 44059
__1945:
__1944:
__1947:
 44038 rstack EAX,EBP:-1
 44042 add EAX,1
 44045 mov EBX,EAX
 44047 rstack EAX,EBP:2
 44051 add EAX,EBX
 44053 mov EBX,EAX
 44055 mov EAX,EBX
 44057 leave 
 44058 ret 
__1946:
__1942:
__1940:
 44059 leave 
 44060 ret 
filepath_base:
// filepath_base(filename)
 44061 enter 4
__1949:
 44064 mov EAX,SS:EBP
 44067 add EAX,-3
// filepath_decimate arg #4 (float* is_abs)
 44070 push EAX
 44072 mov EAX,SS:EBP
 44075 add EAX,-2
// filepath_decimate arg #3 (char* name)
 44078 push EAX
 44080 mov EAX,SS:EBP
 44083 add EAX,-1
// filepath_decimate arg #2 (float* folders)
 44086 push EAX
 44088 rstack EAX,EBP:2
// filepath_decimate arg #1 (char* filename)
 44092 push EAX
 44094 mov ECX,4
// filepath_decimate(...)
 44097 call 43560
 44100 add ESP,4
// cstr_find_last_of arg #2 (char C)
 44103 push 46
 44106 rstack EAX,EBP:-2
// cstr_find_last_of arg #1 (char* S)
 44110 push EAX
 44112 mov ECX,2
// cstr_find_last_of(...)
 44115 call 16821
 44118 add ESP,2
 44121 sstack EBP:-4,EAX
__1951:
 44125 rstack EAX,EBP:-4
 44129 mov EBX,-1
 44132 sub EBX,EAX
 44134 fabs EBX,EBX
 44136 fsgn EBX,EBX
 44138 lneg EBX
// if (I==-1)
 44140 cmp 0,EBX
 44143 jge 44155
 44146 rstack EAX,EBP:-2
 44150 leave 
 44151 ret 
 44152 jmp 44176
__1953:
__1952:
__1955:
 44155 rstack EAX,EBP:-4
 44159 rstack EBX,EBP:-2
 44163 add EBX,EAX
 44165 mov EAX,EBX
// name[I]=0
 44167 mov #EAX,0
 44170 rstack EAX,EBP:-2
 44174 leave 
 44175 ret 
__1954:
__1950:
__1948:
 44176 leave 
 44177 ret 
filepath_drive:
// filepath_drive(filename,driveletter)
 44178 enter 1
__1957:
// cstr_find_first_of arg #2 (char C)
 44181 push 47
 44184 rstack EAX,EBP:2
// cstr_find_first_of arg #1 (char* S)
 44188 push EAX
 44190 mov ECX,2
// cstr_find_first_of(...)
 44193 call 16712
 44196 add ESP,2
 44199 sstack EBP:-1,EAX
__1959:
 44203 rstack EAX,EBP:-1
 44207 mov EBX,1
 44210 sub EBX,EAX
 44212 neg EBX
 44214 fsgn EBX,EBX
 44216 inc EBX
 44218 max EBX,0
 44221 rstack EAX,EBP:-1
 44225 mov ECX,-1
 44228 sub ECX,EAX
 44230 fabs ECX,ECX
 44232 fsgn ECX,ECX
 44234 and ECX,EBX
// if ((I!=-1)&&(I>=1))
 44236 cmp 0,ECX
 44239 jge 44339
 44242 rstack EAX,EBP:-1
 44246 add EAX,-1
 44249 mov EBX,EAX
// I=I-1
 44251 sstack EBP:-1,EBX
__1962:
 44255 rstack EAX,EBP:-1
 44259 rstack EBX,EBP:2
 44263 add EBX,EAX
 44265 mov EAX,EBX
 44267 mov EBX,58
 44270 sub EBX,#EAX
 44272 fabs EBX,EBX
 44274 fsgn EBX,EBX
 44276 lneg EBX
// if (filename[I]==':')
 44278 cmp 0,EBX
 44281 jge 44331
 44284 rstack EAX,EBP:3
 44288 add EAX,0
 44291 mov EBX,EAX
// driveletter[0]=0
 44293 mov #EBX,0
 44296 rstack EAX,EBP:-1
// strncpy arg #3 (float n)
 44300 push EAX
 44302 rstack EAX,EBP:2
// strncpy arg #2 (char* src)
 44306 push EAX
 44308 rstack EAX,EBP:3
// strncpy arg #1 (char* dest)
 44312 push EAX
 44314 mov ECX,3
// strncpy(...)
 44317 call 11009
 44320 add ESP,3
 44323 mov EAX,1
 44326 leave 
 44327 ret 
 44328 jmp 44336
__1964:
__1963:
__1966:
 44331 mov EAX,0
 44334 leave 
 44335 ret 
__1965:
__1961:
 44336 jmp 44344
__1967:
__1960:
__1969:
 44339 mov EAX,0
 44342 leave 
 44343 ret 
__1968:
__1958:
__1956:
 44344 leave 
 44345 ret 
filepath_no_drive:
// filepath_no_drive(filename)
 44346 enter 1
__1971:
// cstr_find_first_of arg #2 (char C)
 44349 push 58
 44352 rstack EAX,EBP:2
// cstr_find_first_of arg #1 (char* S)
 44356 push EAX
 44358 mov ECX,2
// cstr_find_first_of(...)
 44361 call 16712
 44364 add ESP,2
 44367 sstack EBP:-1,EAX
__1973:
 44371 rstack EAX,EBP:-1
 44375 mov EBX,-1
 44378 sub EBX,EAX
 44380 fabs EBX,EBX
 44382 fsgn EBX,EBX
// if (I!=-1)
 44384 cmp 0,EBX
 44387 jge 44411
 44390 rstack EAX,EBP:-1
 44394 add EAX,1
 44397 mov EBX,EAX
 44399 rstack EAX,EBP:2
 44403 add EAX,EBX
 44405 mov EBX,EAX
// filename=filename+I+1
 44407 sstack EBP:2,EBX
__1974:
__1972:
 44411 rstack EAX,EBP:2
 44415 leave 
 44416 ret 
__1970:
 44417 leave 
 44418 ret 
fs_marker2:
 44419 db 0
typeof_fs3:
 44420 db "fs3_cb",0
sizeof_fs3:
 44427 db 5
init_fs3:
// init_fs3()
 44428 enter 1
__1976:
// malloc arg #1 (float n)
 44431 push #44427
 44434 mov ECX,1
// malloc(...)
 44437 call 28486
 44440 add ESP,1
 44443 sstack EBP:-1,EAX
 44447 rstack EAX,EBP:-1
 44451 add EAX,0
 44454 mov EBX,EAX
// fs3[0]=typeof_fs3
 44456 mov #EBX,44420
 44459 rstack EAX,EBP:-1
 44463 add EAX,1
 44466 mov EBX,EAX
// fs3[1]=0
 44468 mov #EBX,0
 44471 rstack EAX,EBP:-1
 44475 add EAX,2
 44478 mov EBX,EAX
// fs3[2]=0
 44480 mov #EBX,0
 44483 rstack EAX,EBP:-1
 44487 add EAX,3
 44490 mov EBX,EAX
// fs3[3]=0
 44492 mov #EBX,0
 44495 rstack EAX,EBP:-1
 44499 add EAX,4
 44502 mov EBX,EAX
// fs3[4]=0
 44504 mov #EBX,0
 44507 rstack EAX,EBP:-1
 44511 push EAX
 44513 mov ECX,1
// fs3_init_file_table(...)
 44516 call 54634
 44519 add ESP,1
 44522 rstack EAX,EBP:-1
 44526 leave 
 44527 ret 
__1975:
 44528 leave 
 44529 ret 
str_lightfs3:
 44530 db "lightfs3",0
fs3_disk_format:
// fs3_disk_format(fs3,disk_addr,disk_size,block_size)
 44539 enter 27
__1978:
// assert_type arg #2 (float t)
 44542 push 44420
 44545 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 44549 push EAX
 44551 mov ECX,2
// assert_type(...)
 44554 call 10123
 44557 add ESP,2
 44560 rstack EAX,EBP:3
 44564 rstack EBX,EBP:2
 44568 add EBX,1
 44571 mov ECX,EBX
// fs3[1]=disk_addr
 44573 mov #ECX,EAX
 44575 rstack EAX,EBP:4
 44579 rstack EBX,EBP:2
 44583 add EBX,2
 44586 mov ECX,EBX
// fs3[2]=disk_size
 44588 mov #ECX,EAX
 44590 sstack EBP:-21,2
 44595 rstack EAX,EBP:-21
 44599 rstack EBX,EBP:5
 44603 add EBX,EAX
 44605 mov EAX,EBX
 44607 rstack EBX,EBP:4
 44611 add EBX,-20
 44614 mov ECX,EBX
 44616 div ECX,EAX
 44618 sstack EBP:-22,ECX
 44622 rstack EAX,EBP:-22
// floor arg #1 (float A)
 44626 push EAX
 44628 mov ECX,1
// floor(...)
 44631 call 30221
 44634 add ESP,1
// num_blocks=floor(num_blocks)
 44637 sstack EBP:-22,EAX
 44641 sstack EBP:-23,20
 44646 rstack EAX,EBP:-21
 44650 rstack EBX,EBP:-22
 44654 mul EBX,EAX
 44656 mov EAX,EBX
 44658 sstack EBP:-24,EAX
 44662 rstack EAX,EBP:-24
 44666 rstack EBX,EBP:-23
 44670 add EBX,EAX
 44672 mov EAX,EBX
 44674 sstack EBP:-25,EAX
 44678 sstack EBP:-26,2
// strlen arg #1 (char* str)
 44683 push 44530
 44686 mov ECX,1
// strlen(...)
 44689 call 11121
 44692 add ESP,1
 44695 sstack EBP:-27,EAX
 44699 rstack EAX,EBP:-27
 44703 add EAX,1
 44706 mov EBX,EAX
// memcpy arg #3 (float n)
 44708 push EBX
// memcpy arg #2 (void* src)
 44710 push 44530
 44713 mov EAX,SS:EBP
 44716 add EAX,-20
// memcpy arg #1 (void* dest)
 44719 push EAX
 44721 mov ECX,3
// memcpy(...)
 44724 call 10355
 44727 add ESP,3
 44730 rstack EAX,EBP:4
// fs_header[11]=disk_size
 44734 sstack EBP:-9,EAX
 44738 rstack EAX,EBP:5
// fs_header[12]=block_size
 44742 sstack EBP:-8,EAX
 44746 rstack EAX,EBP:-22
// fs_header[13]=num_blocks
 44750 sstack EBP:-7,EAX
 44754 rstack EAX,EBP:-23
// fs_header[14]=dptr_block_map
 44758 sstack EBP:-6,EAX
 44762 rstack EAX,EBP:-25
// fs_header[15]=dptr_file_blocks
 44766 sstack EBP:-5,EAX
 44770 rstack EAX,EBP:-26
// fs_header[16]=max_file_index
 44774 sstack EBP:-4,EAX
 44778 push 20
 44781 mov EAX,SS:EBP
 44784 add EAX,-20
 44787 push EAX
 44789 push 0
 44792 rstack EAX,EBP:2
 44796 push EAX
 44798 mov ECX,4
// fs3_low_write(...)
 44801 call 46116
 44804 add ESP,4
 44807 rstack EAX,EBP:-24
 44811 push EAX
 44813 rstack EAX,EBP:-23
 44817 push EAX
 44819 rstack EAX,EBP:2
 44823 push EAX
 44825 mov ECX,3
// fs3_low_write_0(...)
 44828 call 46205
 44831 add ESP,3
 44834 rstack EAX,EBP:2
 44838 push EAX
 44840 mov ECX,1
// fs3_create_root_dir(...)
 44843 call 45057
 44846 add ESP,1
__1977:
 44849 leave 
 44850 ret 
fs3_load_fs_descriptor:
// fs3_load_fs_descriptor(fs3,devAdr)
 44851 enter 11
__1980:
// assert_type arg #2 (float t)
 44854 push 44420
 44857 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 44861 push EAX
 44863 mov ECX,2
// assert_type(...)
 44866 call 10123
 44869 add ESP,2
 44872 rstack EAX,EBP:3
 44876 rstack EBX,EBP:2
 44880 add EBX,1
 44883 mov ECX,EBX
// fs3[1]=devAdr
 44885 mov #ECX,EAX
 44887 push 1
 44890 mov EAX,SS:EBP
 44893 add EAX,-1
 44896 push EAX
 44898 push 11
 44901 rstack EAX,EBP:2
 44905 push EAX
 44907 mov ECX,4
// fs3_low_read(...)
 44910 call 46027
 44913 add ESP,4
 44916 rstack EAX,EBP:-1
 44920 rstack EBX,EBP:2
 44924 add EBX,2
 44927 mov ECX,EBX
// fs3[2]=size
 44929 mov #ECX,EAX
 44931 push 10
 44934 mov EAX,SS:EBP
 44937 add EAX,-11
 44940 push EAX
 44942 push 0
 44945 rstack EAX,EBP:2
 44949 push EAX
 44951 mov ECX,4
// fs3_low_read(...)
 44954 call 46027
 44957 add ESP,4
__1983:
// strcmp arg #2 (char* dest)
 44960 push 45048
 44963 mov EAX,SS:EBP
 44966 add EAX,-11
// strcmp arg #1 (char* src)
 44969 push EAX
 44971 mov ECX,2
// strcmp(...)
 44974 call 10763
 44977 add ESP,2
 44980 mov EBX,0
 44983 sub EBX,EAX
 44985 fabs EBX,EBX
 44987 fsgn EBX,EBX
// if (strcmp(buff,"lightfs3")!=0)
 44989 cmp 0,EBX
 44992 jge 45015
// printf arg #2 (unknown)
 44995 push 811
// printf arg #1 (char* format)
 44998 push 45022
 45001 mov ECX,2
// printf(...)
 45004 call 21772
 45007 add ESP,2
 45010 mov EAX,0
 45013 leave 
 45014 ret 
__1984:
__1982:
 45015 mov EAX,1
 45018 leave 
 45019 ret 
__1979:
 45020 leave 
 45021 ret 
__1985:
 45022 db "%mnot a lightfs3 volume!
",0
__1981:
 45048 db "lightfs3",0
fs3_create_root_dir:
// fs3_create_root_dir(fs3)
 45057 enter 3
__1987:
// assert_type arg #2 (float t)
 45060 push 44420
 45063 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45067 push EAX
 45069 mov ECX,2
// assert_type(...)
 45072 call 10123
 45075 add ESP,2
// header[0]=0
 45078 sstack EBP:-2,0
// header[1]=0
 45083 sstack EBP:-1,0
 45088 push 1
 45091 push 2
 45094 rstack EAX,EBP:2
 45098 push EAX
 45100 mov ECX,3
// fs3_open_file_index(...)
 45103 call 49374
 45106 add ESP,3
 45109 sstack EBP:-3,EAX
 45113 rstack EAX,EBP:-3
 45117 push EAX
 45119 push 2
 45122 mov EAX,SS:EBP
 45125 add EAX,-2
 45128 push EAX
 45130 mov ECX,3
// fwrite(...)
 45133 call 52831
 45136 add ESP,3
 45139 rstack EAX,EBP:-3
 45143 push EAX
 45145 mov ECX,1
// fclose(...)
 45148 call 53739
 45151 add ESP,1
__1986:
 45154 leave 
 45155 ret 
fs_marker3:
 45156 db 0
fs3_find_first_file_block:
// fs3_find_first_file_block(fs3,file_index,fblock)
 45157 enter 5
__1989:
// assert_type arg #2 (float t)
 45160 push 44420
 45163 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45167 push EAX
 45169 mov ECX,2
// assert_type(...)
 45172 call 10123
 45175 add ESP,2
 45178 push 1
 45181 mov EAX,SS:EBP
 45184 add EAX,-1
 45187 push EAX
 45189 push 14
 45192 rstack EAX,EBP:2
 45196 push EAX
 45198 mov ECX,4
// fs3_low_read(...)
 45201 call 46027
 45204 add ESP,4
 45207 push 1
 45210 mov EAX,SS:EBP
 45213 add EAX,-2
 45216 push EAX
 45218 push 13
 45221 rstack EAX,EBP:2
 45225 push EAX
 45227 mov ECX,4
// fs3_low_read(...)
 45230 call 46027
 45233 add ESP,4
// init loop
 45236 sstack EBP:-3,0
__1991:
 45241 rstack EAX,EBP:-3
 45245 rstack EBX,EBP:-2
 45249 sub EBX,EAX
 45251 mov EAX,EBX
 45253 fsgn EAX,EAX
// condition
 45255 max EAX,0
 45258 cmp 0,EAX
 45261 jz 45371
 45264 rstack EAX,EBP:-3
 45268 mov EBX,2
 45271 mul EBX,EAX
 45273 rstack EAX,EBP:-1
 45277 add EAX,EBX
 45279 mov EBX,EAX
 45281 sstack EBP:-4,EBX
 45285 push 2
 45288 rstack EAX,EBP:4
 45292 push EAX
 45294 rstack EAX,EBP:-4
 45298 push EAX
 45300 rstack EAX,EBP:2
 45304 push EAX
 45306 mov ECX,4
// fs3_low_read(...)
 45309 call 46027
 45312 add ESP,4
 45315 rstack EAX,EBP:4
 45319 add EAX,0
 45322 mov EBX,EAX
 45324 sstack EBP:-5,#EBX
__1993:
 45328 rstack EAX,EBP:-5
 45332 rstack EBX,EBP:3
 45336 sub EBX,EAX
 45338 mov EAX,EBX
 45340 fabs EAX,EAX
 45342 fsgn EAX,EAX
 45344 lneg EAX
// if (fb_index==file_index)
 45346 cmp 0,EAX
 45349 jge 45358
 45352 rstack EAX,EBP:-3
 45356 leave 
 45357 ret 
__1994:
__1992:
 45358 rstack EAX,EBP:-3
// loop step
 45362 inc EAX
 45364 sstack EBP:-3,EAX
 45368 jmp 45241
__1990:
 45371 mov EAX,-1
 45374 leave 
 45375 ret 
__1988:
 45376 leave 
 45377 ret 
fs3_get_max_file_index:
// fs3_get_max_file_index(fs3)
 45378 enter 1
__1996:
// assert_type arg #2 (float t)
 45381 push 44420
 45384 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45388 push EAX
 45390 mov ECX,2
// assert_type(...)
 45393 call 10123
 45396 add ESP,2
 45399 push 1
 45402 mov EAX,SS:EBP
 45405 add EAX,-1
 45408 push EAX
 45410 push 16
 45413 rstack EAX,EBP:2
 45417 push EAX
 45419 mov ECX,4
// fs3_low_read(...)
 45422 call 46027
 45425 add ESP,4
 45428 rstack EAX,EBP:-1
 45432 leave 
 45433 ret 
__1995:
 45434 leave 
 45435 ret 
fs3_set_max_file_index:
// fs3_set_max_file_index(fs3,file_index)
 45436 enter -0
__1998:
// assert_type arg #2 (float t)
 45439 push 44420
 45442 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45446 push EAX
 45448 mov ECX,2
// assert_type(...)
 45451 call 10123
 45454 add ESP,2
 45457 push 1
 45460 mov EAX,SS:EBP
 45463 add EAX,3
 45466 push EAX
 45468 push 16
 45471 rstack EAX,EBP:2
 45475 push EAX
 45477 mov ECX,4
// fs3_low_write(...)
 45480 call 46116
 45483 add ESP,4
__1997:
 45486 leave 
 45487 ret 
fs3_get_block_map:
// fs3_get_block_map(fs3)
 45488 enter 1
__2000:
// assert_type arg #2 (float t)
 45491 push 44420
 45494 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45498 push EAX
 45500 mov ECX,2
// assert_type(...)
 45503 call 10123
 45506 add ESP,2
 45509 push 1
 45512 mov EAX,SS:EBP
 45515 add EAX,-1
 45518 push EAX
 45520 push 14
 45523 rstack EAX,EBP:2
 45527 push EAX
 45529 mov ECX,4
// fs3_low_read(...)
 45532 call 46027
 45535 add ESP,4
 45538 rstack EAX,EBP:-1
 45542 leave 
 45543 ret 
__1999:
 45544 leave 
 45545 ret 
fs3_get_block_size:
// fs3_get_block_size(fs3)
 45546 enter 1
__2002:
// assert_type arg #2 (float t)
 45549 push 44420
 45552 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45556 push EAX
 45558 mov ECX,2
// assert_type(...)
 45561 call 10123
 45564 add ESP,2
 45567 push 1
 45570 mov EAX,SS:EBP
 45573 add EAX,-1
 45576 push EAX
 45578 push 12
 45581 rstack EAX,EBP:2
 45585 push EAX
 45587 mov ECX,4
// fs3_low_read(...)
 45590 call 46027
 45593 add ESP,4
 45596 rstack EAX,EBP:-1
 45600 leave 
 45601 ret 
__2001:
 45602 leave 
 45603 ret 
fs3_get_fblocks:
// fs3_get_fblocks(fs3)
 45604 enter 1
__2004:
// assert_type arg #2 (float t)
 45607 push 44420
 45610 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45614 push EAX
 45616 mov ECX,2
// assert_type(...)
 45619 call 10123
 45622 add ESP,2
 45625 push 1
 45628 mov EAX,SS:EBP
 45631 add EAX,-1
 45634 push EAX
 45636 push 15
 45639 rstack EAX,EBP:2
 45643 push EAX
 45645 mov ECX,4
// fs3_low_read(...)
 45648 call 46027
 45651 add ESP,4
 45654 rstack EAX,EBP:-1
 45658 leave 
 45659 ret 
__2003:
 45660 leave 
 45661 ret 
fs3_low_new:
// fs3_low_new(fs3,file_idx)
 45662 enter 7
__2006:
// assert_type arg #2 (float t)
 45665 push 44420
 45668 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45672 push EAX
 45674 mov ECX,2
// assert_type(...)
 45677 call 10123
 45680 add ESP,2
 45683 push 1
 45686 mov EAX,SS:EBP
 45689 add EAX,-1
 45692 push EAX
 45694 push 14
 45697 rstack EAX,EBP:2
 45701 push EAX
 45703 mov ECX,4
// fs3_low_read(...)
 45706 call 46027
 45709 add ESP,4
 45712 push 1
 45715 mov EAX,SS:EBP
 45718 add EAX,-2
 45721 push EAX
 45723 push 13
 45726 rstack EAX,EBP:2
 45730 push EAX
 45732 mov ECX,4
// fs3_low_read(...)
 45735 call 46027
 45738 add ESP,4
// init loop
 45741 sstack EBP:-3,0
__2008:
 45746 rstack EAX,EBP:-3
 45750 rstack EBX,EBP:-2
 45754 sub EBX,EAX
 45756 mov EAX,EBX
 45758 fsgn EAX,EAX
// condition
 45760 max EAX,0
 45763 cmp 0,EAX
 45766 jz 45915
 45769 rstack EAX,EBP:-3
 45773 mov EBX,2
 45776 mul EBX,EAX
 45778 rstack EAX,EBP:-1
 45782 add EAX,EBX
 45784 mov EBX,EAX
 45786 sstack EBP:-6,EBX
 45790 push 2
 45793 mov EAX,SS:EBP
 45796 add EAX,-5
 45799 push EAX
 45801 rstack EAX,EBP:-6
 45805 push EAX
 45807 rstack EAX,EBP:2
 45811 push EAX
 45813 mov ECX,4
// fs3_low_read(...)
 45816 call 46027
 45819 add ESP,4
 45822 rstack EAX,EBP:-5
 45826 sstack EBP:-7,EAX
__2010:
 45830 rstack EAX,EBP:-7
 45834 mov EBX,0
 45837 sub EBX,EAX
 45839 fabs EBX,EBX
 45841 fsgn EBX,EBX
 45843 lneg EBX
// if (fb_index==0)
 45845 cmp 0,EBX
 45848 jge 45902
 45851 rstack EAX,EBP:3
// fblock[0]=file_idx
 45855 sstack EBP:-5,EAX
// fblock[1]=-1
 45859 sstack EBP:-4,-1
 45864 push 2
 45867 mov EAX,SS:EBP
 45870 add EAX,-5
 45873 push EAX
 45875 rstack EAX,EBP:-6
 45879 push EAX
 45881 rstack EAX,EBP:2
 45885 push EAX
 45887 mov ECX,4
// fs3_low_write(...)
 45890 call 46116
 45893 add ESP,4
 45896 rstack EAX,EBP:-3
 45900 leave 
 45901 ret 
__2011:
__2009:
 45902 rstack EAX,EBP:-3
// loop step
 45906 inc EAX
 45908 sstack EBP:-3,EAX
 45912 jmp 45746
__2007:
 45915 mov EAX,-1
 45918 leave 
 45919 ret 
__2005:
 45920 leave 
 45921 ret 
fs3_get_disk_adr:
// fs3_get_disk_adr(fs3,block_num,ptr)
 45922 enter 3
__2013:
// assert_type arg #2 (float t)
 45925 push 44420
 45928 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 45932 push EAX
 45934 mov ECX,2
// assert_type(...)
 45937 call 10123
 45940 add ESP,2
 45943 rstack EAX,EBP:2
// fs3_get_fblocks arg #1 (float fs3)
 45947 push EAX
 45949 mov ECX,1
// fs3_get_fblocks(...)
 45952 call 45604
 45955 add ESP,1
 45958 sstack EBP:-1,EAX
 45962 rstack EAX,EBP:2
// fs3_get_block_size arg #1 (float fs3)
 45966 push EAX
 45968 mov ECX,1
// fs3_get_block_size(...)
 45971 call 45546
 45974 add ESP,1
 45977 sstack EBP:-2,EAX
 45981 rstack EAX,EBP:-2
 45985 rstack EBX,EBP:4
 45989 mod EBX,EAX
 45991 mov EAX,EBX
 45993 rstack EBX,EBP:3
 45997 rstack ECX,EBP:-2
 46001 mul ECX,EBX
 46003 mov EBX,ECX
 46005 add EBX,EAX
 46007 rstack EAX,EBP:-1
 46011 add EAX,EBX
 46013 mov EBX,EAX
 46015 sstack EBP:-3,EBX
 46019 rstack EAX,EBP:-3
 46023 leave 
 46024 ret 
__2012:
 46025 leave 
 46026 ret 
fs3_low_read:
// fs3_low_read(fs3,disk_ptr,to,size)
 46027 enter 3
__2015:
// assert_type arg #2 (float t)
 46030 push 44420
 46033 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 46037 push EAX
 46039 mov ECX,2
// assert_type(...)
 46042 call 10123
 46045 add ESP,2
 46048 rstack EAX,EBP:2
 46052 add EAX,1
 46055 mov EBX,EAX
 46057 sstack EBP:-1,#EBX
 46061 rstack EAX,EBP:3
 46065 rstack EBX,EBP:-1
 46069 add EBX,EAX
 46071 mov EAX,EBX
 46073 sstack EBP:-2,EAX
 46077 sstack EBP:-3,119
 46082 rstack EAX,EBP:5
// memcpy arg #3 (float n)
 46086 push EAX
 46088 rstack EAX,EBP:-2
// memcpy arg #2 (void* src)
 46092 push EAX
 46094 rstack EAX,EBP:4
// memcpy arg #1 (void* dest)
 46098 push EAX
 46100 mov ECX,3
// memcpy(...)
 46103 call 10355
 46106 add ESP,3
 46109 mov EAX,1
 46112 leave 
 46113 ret 
__2014:
 46114 leave 
 46115 ret 
fs3_low_write:
// fs3_low_write(fs3,disk_ptr,from,size)
 46116 enter 3
__2017:
// assert_type arg #2 (float t)
 46119 push 44420
 46122 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 46126 push EAX
 46128 mov ECX,2
// assert_type(...)
 46131 call 10123
 46134 add ESP,2
 46137 sstack EBP:-1,505
 46142 rstack EAX,EBP:2
 46146 add EAX,1
 46149 mov EBX,EAX
 46151 sstack EBP:-2,#EBX
 46155 rstack EAX,EBP:3
 46159 rstack EBX,EBP:-2
 46163 add EBX,EAX
 46165 mov EAX,EBX
 46167 sstack EBP:-3,EAX
 46171 rstack EAX,EBP:5
// memcpy arg #3 (float n)
 46175 push EAX
 46177 rstack EAX,EBP:4
// memcpy arg #2 (void* src)
 46181 push EAX
 46183 rstack EAX,EBP:-3
// memcpy arg #1 (void* dest)
 46187 push EAX
 46189 mov ECX,3
// memcpy(...)
 46192 call 10355
 46195 add ESP,3
 46198 mov EAX,1
 46201 leave 
 46202 ret 
__2016:
 46203 leave 
 46204 ret 
fs3_low_write_0:
// fs3_low_write_0(fs3,disk_ptr,count)
 46205 enter 3
__2019:
// assert_type arg #2 (float t)
 46208 push 44420
 46211 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 46215 push EAX
 46217 mov ECX,2
// assert_type(...)
 46220 call 10123
 46223 add ESP,2
 46226 rstack EAX,EBP:2
 46230 add EAX,1
 46233 mov EBX,EAX
 46235 sstack EBP:-1,#EBX
 46239 rstack EAX,EBP:3
 46243 rstack EBX,EBP:-1
 46247 add EBX,EAX
 46249 mov EAX,EBX
 46251 sstack EBP:-2,EAX
// init loop
 46255 sstack EBP:-3,0
__2021:
 46260 rstack EAX,EBP:-3
 46264 rstack EBX,EBP:4
 46268 sub EBX,EAX
 46270 mov EAX,EBX
 46272 fsgn EAX,EAX
// condition
 46274 max EAX,0
 46277 cmp 0,EAX
 46280 jz 46311
 46283 rstack EAX,EBP:-3
 46287 rstack EBX,EBP:-2
 46291 add EBX,EAX
 46293 mov EAX,EBX
// abs_ptr[I]=0
 46295 mov #EAX,0
 46298 rstack EAX,EBP:-3
// loop step
 46302 inc EAX
 46304 sstack EBP:-3,EAX
 46308 jmp 46260
__2020:
 46311 mov EAX,1
 46314 leave 
 46315 ret 
__2018:
 46316 leave 
 46317 ret 
fs3_erase_block_chain:
// fs3_erase_block_chain(fs3,block_id)
 46318 enter 7
__2023:
__2025:
 46321 rstack EAX,EBP:3
 46325 mov EBX,0
 46328 sub EBX,EAX
 46330 fabs EBX,EBX
 46332 fsgn EBX,EBX
 46334 lneg EBX
// if (block_id==0)
 46336 cmp 0,EBX
 46339 jge 46347
 46342 mov EAX,0
 46345 leave 
 46346 ret 
__2026:
__2024:
// assert_type arg #2 (float t)
 46347 push 44420
 46350 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 46354 push EAX
 46356 mov ECX,2
// assert_type(...)
 46359 call 10123
 46362 add ESP,2
// fs3_low_read arg #4 (float size)
 46365 push 1
 46368 mov EAX,SS:EBP
 46371 add EAX,-1
// fs3_low_read arg #3 (float to)
 46374 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 46376 push 13
 46379 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 46383 push EAX
 46385 mov ECX,4
// fs3_low_read(...)
 46388 call 46027
 46391 add ESP,4
// fs3_low_read arg #4 (float size)
 46394 push 1
 46397 mov EAX,SS:EBP
 46400 add EAX,-2
// fs3_low_read arg #3 (float to)
 46403 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 46405 push 14
 46408 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 46412 push EAX
 46414 mov ECX,4
// fs3_low_read(...)
 46417 call 46027
 46420 add ESP,4
 46423 rstack EAX,EBP:-1
 46427 mul EAX,2
 46430 mov EBX,EAX
 46432 sstack EBP:-3,EBX
 46436 rstack EAX,EBP:-3
// malloc arg #1 (float n)
 46440 push EAX
 46442 mov ECX,1
// malloc(...)
 46445 call 28486
 46448 add ESP,1
 46451 sstack EBP:-4,EAX
 46455 rstack EAX,EBP:-3
// fs3_low_read arg #4 (float size)
 46459 push EAX
 46461 rstack EAX,EBP:-4
// fs3_low_read arg #3 (float to)
 46465 push EAX
 46467 rstack EAX,EBP:-2
// fs3_low_read arg #2 (float disk_ptr)
 46471 push EAX
 46473 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 46477 push EAX
 46479 mov ECX,4
// fs3_low_read(...)
 46482 call 46027
 46485 add ESP,4
__2028:
 46488 rstack EAX,EBP:3
 46492 rstack EBX,EBP:-1
 46496 add EBX,-1
 46499 mov ECX,EBX
 46501 sub ECX,EAX
 46503 fsgn ECX,ECX
 46505 max ECX,0
 46508 rstack EAX,EBP:3
 46512 mov EBX,-1
 46515 sub EBX,EAX
 46517 neg EBX
 46519 fsgn EBX,EBX
 46521 max EBX,0
 46524 and EBX,ECX
// if ((block_id>-1)&&(block_id<(num_blocks-1)))
 46526 cmp 0,EBX
 46529 jge 46537
 46532 mov EAX,0
 46535 leave 
 46536 ret 
__2029:
__2027:
__2031:
 46537 rstack EAX,EBP:3
 46541 rstack EBX,EBP:-1
 46545 add EBX,-1
 46548 mov ECX,EBX
 46550 sub ECX,EAX
 46552 fsgn ECX,ECX
 46554 max ECX,0
 46557 rstack EAX,EBP:3
 46561 mov EBX,-1
 46564 sub EBX,EAX
 46566 neg EBX
 46568 fsgn EBX,EBX
 46570 max EBX,0
 46573 and EBX,ECX
// if ((block_id>-1)&&(block_id<(num_blocks-1))
 46575 cmp 0,EBX
 46578 jz 46663
 46581 rstack EAX,EBP:3
 46585 mul EAX,2
 46588 mov EBX,EAX
 46590 rstack EAX,EBP:-4
 46594 add EAX,EBX
 46596 mov EBX,EAX
// B=blockmap+block_id*2
 46598 sstack EBP:-5,EBX
 46602 rstack EAX,EBP:-5
 46606 add EAX,0
 46609 mov EBX,EAX
// Buser=B[0]
 46611 sstack EBP:-6,#EBX
 46615 rstack EAX,EBP:-5
 46619 add EAX,1
 46622 mov EBX,EAX
// Bnext=B[1]
 46624 sstack EBP:-7,#EBX
 46628 rstack EAX,EBP:-5
 46632 add EAX,0
 46635 mov EBX,EAX
// B[0]=0
 46637 mov #EBX,0
 46640 rstack EAX,EBP:-5
 46644 add EAX,1
 46647 mov EBX,EAX
// B[1]=-1
 46649 mov #EBX,-1
 46652 rstack EAX,EBP:-7
// block_id=Bnext
 46656 sstack EBP:3,EAX
 46660 jmp 46537
__2030:
 46663 rstack EAX,EBP:-3
// fs3_low_write arg #4 (float size)
 46667 push EAX
 46669 rstack EAX,EBP:-4
// fs3_low_write arg #3 (float from)
 46673 push EAX
 46675 rstack EAX,EBP:-2
// fs3_low_write arg #2 (float disk_ptr)
 46679 push EAX
 46681 rstack EAX,EBP:2
// fs3_low_write arg #1 (float fs3)
 46685 push EAX
 46687 mov ECX,4
// fs3_low_write(...)
 46690 call 46116
 46693 add ESP,4
__2022:
 46696 leave 
 46697 ret 
fs_marker4:
 46698 db 0
fs3_entry_size:
 46699 db 40
fs3_name_size:
 46700 db 32
fs3_make_dir_entry:
// fs3_make_dir_entry(buff,file_index,type,size,cap,name)
 46701 enter 1
__2033:
 46704 rstack EAX,EBP:3
 46708 rstack EBX,EBP:2
 46712 add EBX,0
 46715 mov ECX,EBX
// buff[0]=file_index
 46717 mov #ECX,EAX
 46719 rstack EAX,EBP:4
 46723 rstack EBX,EBP:2
 46727 add EBX,1
 46730 mov ECX,EBX
// buff[1]=type
 46732 mov #ECX,EAX
 46734 rstack EAX,EBP:5
 46738 rstack EBX,EBP:2
 46742 add EBX,2
 46745 mov ECX,EBX
// buff[2]=size
 46747 mov #ECX,EAX
 46749 rstack EAX,EBP:6
 46753 rstack EBX,EBP:2
 46757 add EBX,3
 46760 mov ECX,EBX
// buff[3]=cap
 46762 mov #ECX,EAX
 46764 rstack EAX,EBP:7
// strlen arg #1 (char* str)
 46768 push EAX
 46770 mov ECX,1
// strlen(...)
 46773 call 11121
 46776 add ESP,1
 46779 sstack EBP:-1,EAX
__2035:
 46783 rstack EAX,EBP:-1
 46787 mov EBX,#46700
 46790 sub EBX,EAX
 46792 neg EBX
 46794 fsgn EBX,EBX
 46796 inc EBX
 46798 max EBX,0
// if (len>=fs3_name_size)
 46801 cmp 0,EBX
 46804 jge 46817
 46807 mov EAX,#46700
 46810 add EAX,-1
// len=fs3_name_size-1
 46813 sstack EBP:-1,EAX
__2036:
__2034:
 46817 rstack EAX,EBP:-1
// strncpy arg #3 (float n)
 46821 push EAX
 46823 rstack EAX,EBP:7
// strncpy arg #2 (char* src)
 46827 push EAX
 46829 rstack EAX,EBP:2
 46833 add EAX,4
 46836 mov EBX,EAX
// strncpy arg #1 (char* dest)
 46838 push EBX
 46840 mov ECX,3
// strncpy(...)
 46843 call 11009
 46846 add ESP,3
__2032:
 46849 leave 
 46850 ret 
fs3_dir_add_entry:
// fs3_dir_add_entry(fs3,fh_dir,entry)
 46851 enter 3
__2038:
// assert_type arg #2 (float t)
 46854 push 44420
 46857 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 46861 push EAX
 46863 mov ECX,2
// assert_type(...)
 46866 call 10123
 46869 add ESP,2
 46872 push 0
 46875 push 0
 46878 rstack EAX,EBP:3
 46882 push EAX
 46884 mov ECX,3
// fseek(...)
 46887 call 52453
 46890 add ESP,3
 46893 rstack EAX,EBP:3
 46897 push EAX
 46899 push 1
 46902 mov EAX,SS:EBP
 46905 add EAX,-1
 46908 push EAX
 46910 mov ECX,3
// fread(...)
 46913 call 52657
 46916 add ESP,3
 46919 rstack EAX,EBP:-1
 46923 mul EAX,#46699
 46926 mov EBX,EAX
 46928 mov EAX,1
 46931 add EAX,EBX
 46933 sstack EBP:-2,EAX
 46937 push 0
 46940 rstack EAX,EBP:-2
 46944 push EAX
 46946 rstack EAX,EBP:3
 46950 push EAX
 46952 mov ECX,3
// fseek(...)
 46955 call 52453
 46958 add ESP,3
 46961 rstack EAX,EBP:3
 46965 push EAX
 46967 push #46699
 46970 rstack EAX,EBP:4
 46974 push EAX
 46976 mov ECX,3
// fwrite(...)
 46979 call 52831
 46982 add ESP,3
 46985 rstack EAX,EBP:-1
// n_entries++
 46989 inc EAX
 46991 sstack EBP:-1,EAX
 46995 push 0
 46998 push 0
 47001 rstack EAX,EBP:3
 47005 push EAX
 47007 mov ECX,3
// fseek(...)
 47010 call 52453
 47013 add ESP,3
 47016 rstack EAX,EBP:3
 47020 push EAX
 47022 push 1
 47025 mov EAX,SS:EBP
 47028 add EAX,-1
 47031 push EAX
 47033 mov ECX,3
// fwrite(...)
 47036 call 52831
 47039 add ESP,3
 47042 push 0
 47045 push 0
 47048 rstack EAX,EBP:3
 47052 push EAX
 47054 mov ECX,3
// fseek(...)
 47057 call 52453
 47060 add ESP,3
 47063 rstack EAX,EBP:3
 47067 push EAX
 47069 push 1
 47072 mov EAX,SS:EBP
 47075 add EAX,-3
 47078 push EAX
 47080 mov ECX,3
// fread(...)
 47083 call 52657
 47086 add ESP,3
 47089 mov EAX,1
 47092 leave 
 47093 ret 
__2037:
 47094 leave 
 47095 ret 
fs3_new_abs:
// fs3_new_abs(self,fh_dir,name,type)
 47096 enter 43
__2040:
// assert_type arg #2 (float t)
 47099 push 44420
 47102 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 47106 push EAX
 47108 mov ECX,2
// assert_type(...)
 47111 call 10123
 47114 add ESP,2
 47117 rstack EAX,EBP:2
// fs3_get_max_file_index arg #1 (float fs3)
 47121 push EAX
 47123 mov ECX,1
// fs3_get_max_file_index(...)
 47126 call 45378
 47129 add ESP,1
 47132 sstack EBP:-1,EAX
__2042:
 47136 rstack EAX,EBP:-1
 47140 mov EBX,-1
 47143 sub EBX,EAX
 47145 fabs EBX,EBX
 47147 fsgn EBX,EBX
 47149 lneg EBX
// if (file_index==-1)
 47151 cmp 0,EBX
 47154 jge 47162
 47157 mov EAX,-1
 47160 leave 
 47161 ret 
__2043:
__2041:
 47162 rstack EAX,EBP:-1
// file_index++
 47166 inc EAX
 47168 sstack EBP:-1,EAX
 47172 rstack EAX,EBP:-1
// fs3_low_new arg #2 (float file_idx)
 47176 push EAX
 47178 rstack EAX,EBP:2
// fs3_low_new arg #1 (float fs3)
 47182 push EAX
 47184 mov ECX,2
// fs3_low_new(...)
 47187 call 45662
 47190 add ESP,2
 47193 sstack EBP:-2,EAX
__2045:
 47197 rstack EAX,EBP:-2
 47201 mov EBX,-1
 47204 sub EBX,EAX
 47206 fabs EBX,EBX
 47208 fsgn EBX,EBX
 47210 lneg EBX
// if (hasBlock==-1)
 47212 cmp 0,EBX
 47215 jge 47223
 47218 mov EAX,-1
 47221 leave 
 47222 ret 
__2046:
__2044:
 47223 rstack EAX,EBP:-1
// fs3_set_max_file_index arg #2 (float file_index)
 47227 push EAX
 47229 rstack EAX,EBP:2
// fs3_set_max_file_index arg #1 (float fs3)
 47233 push EAX
 47235 mov ECX,2
// fs3_set_max_file_index(...)
 47238 call 45436
 47241 add ESP,2
 47244 rstack EAX,EBP:4
// fs3_make_dir_entry arg #6 (float name)
 47248 push EAX
// fs3_make_dir_entry arg #5 (float cap)
 47250 push 0
// fs3_make_dir_entry arg #4 (float size)
 47253 push 0
// fs3_make_dir_entry arg #3 (float type)
 47256 push 0
 47259 rstack EAX,EBP:-1
// fs3_make_dir_entry arg #2 (float file_index)
 47263 push EAX
 47265 mov EAX,SS:EBP
 47268 add EAX,-42
// fs3_make_dir_entry arg #1 (float buff)
 47271 push EAX
 47273 mov ECX,6
// fs3_make_dir_entry(...)
 47276 call 46701
 47279 add ESP,6
 47282 sstack EBP:-43,EAX
__2048:
 47286 rstack EAX,EBP:-43
 47290 lneg EAX
 47292 mov EBX,EAX
// if (!res)
 47294 cmp 0,EBX
 47297 jge 47305
 47300 mov EAX,-1
 47303 leave 
 47304 ret 
__2049:
__2047:
 47305 mov EAX,SS:EBP
 47308 add EAX,-42
// fs3_dir_add_entry arg #3 (float entry)
 47311 push EAX
 47313 rstack EAX,EBP:3
// fs3_dir_add_entry arg #2 (float fh_dir)
 47317 push EAX
 47319 rstack EAX,EBP:2
// fs3_dir_add_entry arg #1 (float fs3)
 47323 push EAX
 47325 mov ECX,3
// fs3_dir_add_entry(...)
 47328 call 46851
 47331 add ESP,3
// res=fs3_dir_add_entry(self,fh_dir,buff)
 47334 sstack EBP:-43,EAX
__2051:
 47338 rstack EAX,EBP:-43
 47342 lneg EAX
 47344 mov EBX,EAX
// if (!res)
 47346 cmp 0,EBX
 47349 jge 47357
 47352 mov EAX,-1
 47355 leave 
 47356 ret 
__2052:
__2050:
 47357 rstack EAX,EBP:-1
 47361 leave 
 47362 ret 
__2039:
 47363 leave 
 47364 ret 
fs3_dir_read_entry:
// fs3_dir_read_entry(fs3,fh_dir,I,buff)
 47365 enter 1
__2054:
// assert_type arg #2 (float t)
 47368 push 44420
 47371 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 47375 push EAX
 47377 mov ECX,2
// assert_type(...)
 47380 call 10123
 47383 add ESP,2
// assert_type arg #2 (float t)
 47386 push 42294
 47389 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 47393 push EAX
 47395 mov ECX,2
// assert_type(...)
 47398 call 10123
 47401 add ESP,2
 47404 rstack EAX,EBP:4
 47408 push EAX
 47410 rstack EAX,EBP:3
 47414 push EAX
 47416 rstack EAX,EBP:2
 47420 push EAX
 47422 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 47425 call 47608
 47428 add ESP,3
 47431 sstack EBP:-1,EAX
__2056:
 47435 rstack EAX,EBP:-1
 47439 mov EBX,-1
 47442 sub EBX,EAX
 47444 fabs EBX,EBX
 47446 fsgn EBX,EBX
// if (fptr_entry!=-1)
 47448 cmp 0,EBX
 47451 jge 47507
 47454 push 0
 47457 rstack EAX,EBP:-1
 47461 push EAX
 47463 rstack EAX,EBP:3
 47467 push EAX
 47469 mov ECX,3
// fseek(...)
 47472 call 52453
 47475 add ESP,3
 47478 rstack EAX,EBP:3
 47482 push EAX
 47484 push #46699
 47487 rstack EAX,EBP:5
 47491 push EAX
 47493 mov ECX,3
// fread(...)
 47496 call 52657
 47499 add ESP,3
 47502 mov EAX,1
 47505 leave 
 47506 ret 
__2057:
__2055:
 47507 mov EAX,0
 47510 leave 
 47511 ret 
__2053:
 47512 leave 
 47513 ret 
fs3_dir_get_num_entries:
// fs3_dir_get_num_entries(fs3,fh_dir)
 47514 enter 1
__2059:
// assert_type arg #2 (float t)
 47517 push 44420
 47520 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 47524 push EAX
 47526 mov ECX,2
// assert_type(...)
 47529 call 10123
 47532 add ESP,2
// assert_type arg #2 (float t)
 47535 push 42294
 47538 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 47542 push EAX
 47544 mov ECX,2
// assert_type(...)
 47547 call 10123
 47550 add ESP,2
 47553 push 0
 47556 push 0
 47559 rstack EAX,EBP:3
 47563 push EAX
 47565 mov ECX,3
// fseek(...)
 47568 call 52453
 47571 add ESP,3
 47574 rstack EAX,EBP:3
 47578 push EAX
 47580 push 1
 47583 mov EAX,SS:EBP
 47586 add EAX,-1
 47589 push EAX
 47591 mov ECX,3
// fread(...)
 47594 call 52657
 47597 add ESP,3
 47600 rstack EAX,EBP:-1
 47604 leave 
 47605 ret 
__2058:
 47606 leave 
 47607 ret 
fs3_dir_get_entry_ptr:
// fs3_dir_get_entry_ptr(fs3,fh_dir,I)
 47608 enter 2
__2061:
// assert_type arg #2 (float t)
 47611 push 44420
 47614 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 47618 push EAX
 47620 mov ECX,2
// assert_type(...)
 47623 call 10123
 47626 add ESP,2
// assert_type arg #2 (float t)
 47629 push 42294
 47632 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 47636 push EAX
 47638 mov ECX,2
// assert_type(...)
 47641 call 10123
 47644 add ESP,2
 47647 rstack EAX,EBP:3
// fs3_dir_get_num_entries arg #2 (float fh_dir)
 47651 push EAX
 47653 rstack EAX,EBP:2
// fs3_dir_get_num_entries arg #1 (float fs3)
 47657 push EAX
 47659 mov ECX,2
// fs3_dir_get_num_entries(...)
 47662 call 47514
 47665 add ESP,2
 47668 sstack EBP:-1,EAX
__2063:
 47672 rstack EAX,EBP:4
 47676 rstack EBX,EBP:-1
 47680 sub EBX,EAX
 47682 mov EAX,EBX
 47684 neg EAX
 47686 fsgn EAX,EAX
 47688 inc EAX
 47690 max EAX,0
// if (I>=n_entries)
 47693 cmp 0,EAX
 47696 jge 47704
 47699 mov EAX,-1
 47702 leave 
 47703 ret 
__2064:
__2062:
 47704 rstack EAX,EBP:4
 47708 mul EAX,#46699
 47711 mov EBX,EAX
 47713 mov EAX,1
 47716 add EAX,EBX
 47718 sstack EBP:-2,EAX
 47722 rstack EAX,EBP:-2
 47726 leave 
 47727 ret 
__2060:
 47728 leave 
 47729 ret 
fs3_dir_erase_entry:
// fs3_dir_erase_entry(fs3,fh_dir,entry_id)
 47730 enter 8
__2066:
// assert_type arg #2 (float t)
 47733 push 44420
 47736 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 47740 push EAX
 47742 mov ECX,2
// assert_type(...)
 47745 call 10123
 47748 add ESP,2
// assert_type arg #2 (float t)
 47751 push 42294
 47754 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 47758 push EAX
 47760 mov ECX,2
// assert_type(...)
 47763 call 10123
 47766 add ESP,2
 47769 rstack EAX,EBP:3
// fs3_dir_get_num_entries arg #2 (float fh_dir)
 47773 push EAX
 47775 rstack EAX,EBP:2
// fs3_dir_get_num_entries arg #1 (float fs3)
 47779 push EAX
 47781 mov ECX,2
// fs3_dir_get_num_entries(...)
 47784 call 47514
 47787 add ESP,2
 47790 sstack EBP:-1,EAX
__2068:
 47794 rstack EAX,EBP:4
 47798 rstack EBX,EBP:-1
 47802 sub EBX,EAX
 47804 mov EAX,EBX
 47806 neg EAX
 47808 fsgn EAX,EAX
 47810 inc EAX
 47812 max EAX,0
// if (entry_id>=n_entries)
 47815 cmp 0,EAX
 47818 jge 47826
 47821 mov EAX,-1
 47824 leave 
 47825 ret 
__2069:
__2067:
 47826 rstack EAX,EBP:4
 47830 mul EAX,#46699
 47833 mov EBX,EAX
 47835 mov EAX,1
 47838 add EAX,EBX
 47840 sstack EBP:-2,EAX
 47844 rstack EAX,EBP:-2
 47848 add EAX,#46699
 47851 mov EBX,EAX
 47853 sstack EBP:-3,EBX
 47857 rstack EAX,EBP:-2
 47861 neg EAX
 47863 mov EBX,EAX
 47865 add EBX,-1
 47868 rstack EAX,EBP:-1
 47872 add EAX,EBX
 47874 mov EBX,EAX
 47876 sstack EBP:-4,EBX
 47880 rstack EAX,EBP:-4
 47884 mul EAX,#46699
 47887 mov EBX,EAX
 47889 sstack EBP:-5,EBX
 47893 rstack EAX,EBP:-5
// malloc arg #1 (float n)
 47897 push EAX
 47899 mov ECX,1
// malloc(...)
 47902 call 28486
 47905 add ESP,1
 47908 sstack EBP:-6,EAX
 47912 push 0
 47915 rstack EAX,EBP:-3
 47919 push EAX
 47921 rstack EAX,EBP:3
 47925 push EAX
 47927 mov ECX,3
// fseek(...)
 47930 call 52453
 47933 add ESP,3
 47936 rstack EAX,EBP:3
 47940 push EAX
 47942 rstack EAX,EBP:-5
 47946 push EAX
 47948 rstack EAX,EBP:-6
 47952 push EAX
 47954 mov ECX,3
// fread(...)
 47957 call 52657
 47960 add ESP,3
 47963 push 0
 47966 rstack EAX,EBP:-2
 47970 push EAX
 47972 rstack EAX,EBP:3
 47976 push EAX
 47978 mov ECX,3
// fseek(...)
 47981 call 52453
 47984 add ESP,3
 47987 rstack EAX,EBP:3
 47991 push EAX
 47993 rstack EAX,EBP:-5
 47997 push EAX
 47999 rstack EAX,EBP:-6
 48003 push EAX
 48005 mov ECX,3
// fwrite(...)
 48008 call 52831
 48011 add ESP,3
 48014 rstack EAX,EBP:-1
// n_entries--
 48018 dec EAX
 48020 sstack EBP:-1,EAX
 48024 rstack EAX,EBP:-1
 48028 add EAX,-1
 48031 mov EBX,EAX
 48033 mul EBX,#46699
 48036 mov EAX,1
 48039 add EAX,EBX
 48041 sstack EBP:-7,EAX
 48045 push 0
 48048 rstack EAX,EBP:-7
 48052 push EAX
 48054 rstack EAX,EBP:3
 48058 push EAX
 48060 mov ECX,3
// fseek(...)
 48063 call 52453
 48066 add ESP,3
 48069 sstack EBP:-8,0
 48074 rstack EAX,EBP:3
 48078 push EAX
 48080 push 1
 48083 mov EAX,SS:EBP
 48086 add EAX,-8
 48089 push EAX
 48091 mov ECX,3
// fwrite(...)
 48094 call 52831
 48097 add ESP,3
 48100 push 0
 48103 push 0
 48106 rstack EAX,EBP:3
 48110 push EAX
 48112 mov ECX,3
// fseek(...)
 48115 call 52453
 48118 add ESP,3
 48121 rstack EAX,EBP:3
 48125 push EAX
 48127 push 1
 48130 mov EAX,SS:EBP
 48133 add EAX,-1
 48136 push EAX
 48138 mov ECX,3
// fwrite(...)
 48141 call 52831
 48144 add ESP,3
__2065:
 48147 leave 
 48148 ret 
fs3_dir_get_filename:
// fs3_dir_get_filename(fs3,fh_dir,I,res_str)
 48149 enter 2
__2071:
// assert_type arg #2 (float t)
 48152 push 44420
 48155 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 48159 push EAX
 48161 mov ECX,2
// assert_type(...)
 48164 call 10123
 48167 add ESP,2
// assert_type arg #2 (float t)
 48170 push 42294
 48173 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 48177 push EAX
 48179 mov ECX,2
// assert_type(...)
 48182 call 10123
 48185 add ESP,2
 48188 rstack EAX,EBP:4
// fs3_dir_get_entry_ptr arg #3 (float I)
 48192 push EAX
 48194 rstack EAX,EBP:3
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 48198 push EAX
 48200 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 48204 push EAX
 48206 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 48209 call 47608
 48212 add ESP,3
 48215 sstack EBP:-1,EAX
__2073:
 48219 rstack EAX,EBP:-1
 48223 mov EBX,-1
 48226 sub EBX,EAX
 48228 fabs EBX,EBX
 48230 fsgn EBX,EBX
 48232 lneg EBX
// if (dptr_entry==-1)
 48234 cmp 0,EBX
 48237 jge 48245
 48240 mov EAX,0
 48243 leave 
 48244 ret 
__2074:
__2072:
 48245 rstack EAX,EBP:-1
 48249 add EAX,4
 48252 mov EBX,EAX
 48254 sstack EBP:-2,EBX
 48258 push 0
 48261 rstack EAX,EBP:-2
 48265 push EAX
 48267 rstack EAX,EBP:3
 48271 push EAX
 48273 mov ECX,3
// fseek(...)
 48276 call 52453
 48279 add ESP,3
 48282 rstack EAX,EBP:3
 48286 push EAX
 48288 push #46700
 48291 rstack EAX,EBP:5
 48295 push EAX
 48297 mov ECX,3
// fread(...)
 48300 call 52657
 48303 add ESP,3
 48306 mov EAX,1
 48309 leave 
 48310 ret 
__2070:
 48311 leave 
 48312 ret 
fs3_print_file_handle:
// fs3_print_file_handle(fs3,file_handle)
 48313 enter 3
__2076:
 48316 rstack EAX,EBP:3
// printf arg #2 (unknown)
 48320 push EAX
// printf arg #1 (char* format)
 48322 push 48462
 48325 mov ECX,2
// printf(...)
 48328 call 21772
 48331 add ESP,2
 48334 rstack EAX,EBP:3
// file_handle_get_imp arg #1 (float this)
 48338 push EAX
 48340 mov ECX,1
// file_handle_get_imp(...)
 48343 call 42552
 48346 add ESP,1
 48349 sstack EBP:-1,EAX
 48353 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 48357 push EAX
// printf arg #1 (char* format)
 48359 push 48453
 48362 mov ECX,2
// printf(...)
 48365 call 21772
 48368 add ESP,2
// assert_type arg #2 (float t)
 48371 push 51527
 48374 rstack EAX,EBP:-1
// assert_type arg #1 (float self)
 48378 push EAX
 48380 mov ECX,2
// assert_type(...)
 48383 call 10123
 48386 add ESP,2
 48389 rstack EAX,EBP:-1
 48393 add EAX,4
 48396 mov EBX,EAX
 48398 sstack EBP:-2,#EBX
 48402 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 48406 push EAX
// printf arg #1 (char* format)
 48408 push 48479
 48411 mov ECX,2
// printf(...)
 48414 call 21772
 48417 add ESP,2
 48420 rstack EAX,EBP:-1
 48424 add EAX,5
 48427 mov EBX,EAX
 48429 sstack EBP:-3,#EBX
 48433 rstack EAX,EBP:-3
// printf arg #2 (unknown)
 48437 push EAX
// printf arg #1 (char* format)
 48439 push 48495
 48442 mov ECX,2
// printf(...)
 48445 call 21772
 48448 add ESP,2
__2075:
 48451 leave 
 48452 ret 
__2078:
 48453 db "imp: %d
",0
__2077:
 48462 db "file_handle: %d
",0
__2079:
 48479 db "file_index: %d
",0
__2080:
 48495 db "block: %d
",0
fs3_print_entry:
// fs3_print_entry(fs3,fh_dir,I)
 48506 enter 7
__2082:
// malloc arg #1 (float n)
 48509 push #46699
 48512 mov ECX,1
// malloc(...)
 48515 call 28486
 48518 add ESP,1
 48521 sstack EBP:-1,EAX
 48525 rstack EAX,EBP:4
// fs3_dir_get_entry_ptr arg #3 (float I)
 48529 push EAX
 48531 rstack EAX,EBP:3
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 48535 push EAX
 48537 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 48541 push EAX
 48543 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 48546 call 47608
 48549 add ESP,3
 48552 sstack EBP:-2,EAX
__2084:
 48556 rstack EAX,EBP:-2
 48560 mov EBX,-1
 48563 sub EBX,EAX
 48565 fabs EBX,EBX
 48567 fsgn EBX,EBX
 48569 lneg EBX
// if (dptr_entry==-1)
 48571 cmp 0,EBX
 48574 jge 48582
 48577 mov EAX,-1
 48580 leave 
 48581 ret 
__2085:
__2083:
 48582 push 0
 48585 rstack EAX,EBP:-2
 48589 push EAX
 48591 rstack EAX,EBP:3
 48595 push EAX
 48597 mov ECX,3
// fseek(...)
 48600 call 52453
 48603 add ESP,3
 48606 rstack EAX,EBP:3
 48610 push EAX
 48612 push #46699
 48615 rstack EAX,EBP:-1
 48619 push EAX
 48621 mov ECX,3
// fread(...)
 48624 call 52657
 48627 add ESP,3
 48630 rstack EAX,EBP:-1
 48634 add EAX,0
 48637 mov EBX,EAX
 48639 sstack EBP:-3,#EBX
 48643 rstack EAX,EBP:-1
 48647 add EAX,1
 48650 mov EBX,EAX
 48652 sstack EBP:-4,#EBX
 48656 rstack EAX,EBP:-1
 48660 add EAX,2
 48663 mov EBX,EAX
 48665 sstack EBP:-5,#EBX
 48669 rstack EAX,EBP:-1
 48673 add EAX,3
 48676 mov EBX,EAX
 48678 sstack EBP:-6,#EBX
 48682 rstack EAX,EBP:-1
 48686 add EAX,4
 48689 mov EBX,EAX
 48691 sstack EBP:-7,EBX
// printf arg #1 (char* format)
 48695 push 48936
 48698 mov ECX,1
// printf(...)
 48701 call 21772
 48704 add ESP,1
 48707 rstack EAX,EBP:3
// fs3_print_file_handle arg #2 (float file_handle)
 48711 push EAX
 48713 rstack EAX,EBP:2
// fs3_print_file_handle arg #1 (float fs3)
 48717 push EAX
 48719 mov ECX,2
// fs3_print_file_handle(...)
 48722 call 48313
 48725 add ESP,2
 48728 rstack EAX,EBP:4
// printf arg #3 (unknown)
 48732 push EAX
 48734 rstack EAX,EBP:3
// printf arg #2 (unknown)
 48738 push EAX
// printf arg #1 (char* format)
 48740 push 48895
 48743 mov ECX,3
// printf(...)
 48746 call 21772
 48749 add ESP,3
 48752 rstack EAX,EBP:-3
// printf arg #2 (unknown)
 48756 push EAX
// printf arg #1 (char* format)
 48758 push 48844
 48761 mov ECX,2
// printf(...)
 48764 call 21772
 48767 add ESP,2
 48770 rstack EAX,EBP:-4
// printf arg #2 (unknown)
 48774 push EAX
// printf arg #1 (char* format)
 48776 push 48949
 48779 mov ECX,2
// printf(...)
 48782 call 21772
 48785 add ESP,2
 48788 rstack EAX,EBP:-5
// printf arg #2 (unknown)
 48792 push EAX
// printf arg #1 (char* format)
 48794 push 48884
 48797 mov ECX,2
// printf(...)
 48800 call 21772
 48803 add ESP,2
 48806 rstack EAX,EBP:-6
// printf arg #2 (unknown)
 48810 push EAX
// printf arg #1 (char* format)
 48812 push 48861
 48815 mov ECX,2
// printf(...)
 48818 call 21772
 48821 add ESP,2
 48824 rstack EAX,EBP:-7
// printf arg #2 (unknown)
 48828 push EAX
// printf arg #1 (char* format)
 48830 push 48871
 48833 mov ECX,2
// printf(...)
 48836 call 21772
 48839 add ESP,2
__2081:
 48842 leave 
 48843 ret 
__2088:
 48844 db "file_index = %d
",0
__2091:
 48861 db "cap = %d
",0
__2092:
 48871 db "name = [%s]
",0
__2090:
 48884 db "size = %d
",0
__2087:
 48895 db "fs3 entry:
fh_dir = %d
entry index = %d
",0
__2086:
 48936 db "fs3 fh_dir:
",0
__2089:
 48949 db "type = %d
",0
fs3_dir_get_filesize:
// fs3_dir_get_filesize(fs3,fh_dir,I)
 48960 enter 3
__2094:
// assert_type arg #2 (float t)
 48963 push 44420
 48966 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 48970 push EAX
 48972 mov ECX,2
// assert_type(...)
 48975 call 10123
 48978 add ESP,2
// assert_type arg #2 (float t)
 48981 push 42294
 48984 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 48988 push EAX
 48990 mov ECX,2
// assert_type(...)
 48993 call 10123
 48996 add ESP,2
 48999 sstack EBP:-1,-1
 49004 rstack EAX,EBP:4
// fs3_dir_get_entry_ptr arg #3 (float I)
 49008 push EAX
 49010 rstack EAX,EBP:3
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 49014 push EAX
 49016 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 49020 push EAX
 49022 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 49025 call 47608
 49028 add ESP,3
 49031 sstack EBP:-2,EAX
__2096:
 49035 rstack EAX,EBP:-2
 49039 mov EBX,-1
 49042 sub EBX,EAX
 49044 fabs EBX,EBX
 49046 fsgn EBX,EBX
 49048 lneg EBX
// if (dptr_entry==-1)
 49050 cmp 0,EBX
 49053 jge 49061
 49056 mov EAX,-1
 49059 leave 
 49060 ret 
__2097:
__2095:
 49061 rstack EAX,EBP:-2
 49065 add EAX,2
 49068 mov EBX,EAX
 49070 sstack EBP:-3,EBX
 49074 push 0
 49077 rstack EAX,EBP:-3
 49081 push EAX
 49083 rstack EAX,EBP:3
 49087 push EAX
 49089 mov ECX,3
// fseek(...)
 49092 call 52453
 49095 add ESP,3
 49098 rstack EAX,EBP:3
 49102 push EAX
 49104 push 1
 49107 mov EAX,SS:EBP
 49110 add EAX,-1
 49113 push EAX
 49115 mov ECX,3
// fread(...)
 49118 call 52657
 49121 add ESP,3
 49124 rstack EAX,EBP:-1
 49128 leave 
 49129 ret 
__2093:
 49130 leave 
 49131 ret 
fs3_dir_find_fidx:
// fs3_dir_find_fidx(fs3,fh_dir,file_index)
 49132 enter 5
__2099:
// assert_type arg #2 (float t)
 49135 push 44420
 49138 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 49142 push EAX
 49144 mov ECX,2
// assert_type(...)
 49147 call 10123
 49150 add ESP,2
// assert_type arg #2 (float t)
 49153 push 42294
 49156 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 49160 push EAX
 49162 mov ECX,2
// assert_type(...)
 49165 call 10123
 49168 add ESP,2
 49171 rstack EAX,EBP:3
// fs3_dir_get_num_entries arg #2 (float fh_dir)
 49175 push EAX
 49177 rstack EAX,EBP:2
// fs3_dir_get_num_entries arg #1 (float fs3)
 49181 push EAX
 49183 mov ECX,2
// fs3_dir_get_num_entries(...)
 49186 call 47514
 49189 add ESP,2
 49192 sstack EBP:-1,EAX
// init loop
 49196 sstack EBP:-2,0
__2101:
 49201 rstack EAX,EBP:-2
 49205 rstack EBX,EBP:-1
 49209 sub EBX,EAX
 49211 mov EAX,EBX
 49213 fsgn EAX,EAX
// condition
 49215 max EAX,0
 49218 cmp 0,EAX
 49221 jz 49366
 49224 rstack EAX,EBP:-2
// fs3_dir_get_entry_ptr arg #3 (float I)
 49228 push EAX
 49230 rstack EAX,EBP:3
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 49234 push EAX
 49236 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 49240 push EAX
 49242 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 49245 call 47608
 49248 add ESP,3
 49251 sstack EBP:-3,EAX
 49255 rstack EAX,EBP:-3
 49259 add EAX,0
 49262 mov EBX,EAX
 49264 sstack EBP:-4,EBX
 49268 sstack EBP:-5,0
 49273 push 0
 49276 rstack EAX,EBP:-4
 49280 push EAX
 49282 rstack EAX,EBP:3
 49286 push EAX
 49288 mov ECX,3
// fseek(...)
 49291 call 52453
 49294 add ESP,3
 49297 rstack EAX,EBP:3
 49301 push EAX
 49303 push 1
 49306 mov EAX,SS:EBP
 49309 add EAX,-5
 49312 push EAX
 49314 mov ECX,3
// fread(...)
 49317 call 52657
 49320 add ESP,3
__2103:
 49323 rstack EAX,EBP:-5
 49327 rstack EBX,EBP:4
 49331 sub EBX,EAX
 49333 mov EAX,EBX
 49335 fabs EAX,EAX
 49337 fsgn EAX,EAX
 49339 lneg EAX
// if (e_fidx==file_index)
 49341 cmp 0,EAX
 49344 jge 49353
 49347 rstack EAX,EBP:-2
 49351 leave 
 49352 ret 
__2104:
__2102:
 49353 rstack EAX,EBP:-2
// loop step
 49357 inc EAX
 49359 sstack EBP:-2,EAX
 49363 jmp 49201
__2100:
 49366 mov EAX,-1
 49369 leave 
 49370 ret 
__2098:
 49371 leave 
 49372 ret 
fs_marker5:
 49373 db 0
fs3_open_file_index:
// fs3_open_file_index(fs3,file_index,new_allowed)
 49374 enter 4
__2106:
// assert_type arg #2 (float t)
 49377 push 44420
 49380 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 49384 push EAX
 49386 mov ECX,2
// assert_type(...)
 49389 call 10123
 49392 add ESP,2
// malloc arg #1 (float n)
 49395 push 2
 49398 mov ECX,1
// malloc(...)
 49401 call 28486
 49404 add ESP,1
 49407 sstack EBP:-1,EAX
 49411 rstack EAX,EBP:-1
// fs3_find_first_file_block arg #3 (float fblock)
 49415 push EAX
 49417 rstack EAX,EBP:3
// fs3_find_first_file_block arg #2 (float file_index)
 49421 push EAX
 49423 rstack EAX,EBP:2
// fs3_find_first_file_block arg #1 (float fs3)
 49427 push EAX
 49429 mov ECX,3
// fs3_find_first_file_block(...)
 49432 call 45157
 49435 add ESP,3
 49438 sstack EBP:-2,EAX
__2108:
 49442 rstack EAX,EBP:-2
 49446 mov EBX,-1
 49449 sub EBX,EAX
 49451 fabs EBX,EBX
 49453 fsgn EBX,EBX
 49455 lneg EBX
// if (block_num==-1)
 49457 cmp 0,EBX
 49460 jge 49498
__2111:
 49463 rstack EAX,EBP:4
// if (new_allowed)
 49467 cmp 0,EAX
 49470 jge 49498
 49473 rstack EAX,EBP:3
// fs3_low_new arg #2 (float file_idx)
 49477 push EAX
 49479 rstack EAX,EBP:2
// fs3_low_new arg #1 (float fs3)
 49483 push EAX
 49485 mov ECX,2
// fs3_low_new(...)
 49488 call 45662
 49491 add ESP,2
// block_num=fs3_low_new(fs3,file_index)
 49494 sstack EBP:-2,EAX
__2112:
__2110:
__2109:
__2107:
__2114:
 49498 rstack EAX,EBP:-2
 49502 mov EBX,-1
 49505 sub EBX,EAX
 49507 fabs EBX,EBX
 49509 fsgn EBX,EBX
// if (block_num!=-1)
 49511 cmp 0,EBX
 49514 jge 49672
// malloc arg #1 (float n)
 49517 push #42332
 49520 mov ECX,1
// malloc(...)
 49523 call 28486
 49526 add ESP,1
 49529 sstack EBP:-3,EAX
 49533 rstack EAX,EBP:-3
// file_handle_constructor arg #1 (float this)
 49537 push EAX
 49539 mov ECX,1
// file_handle_constructor(...)
 49542 call 42333
 49545 add ESP,1
// malloc arg #1 (float n)
 49548 push #51543
 49551 mov ECX,1
// malloc(...)
 49554 call 28486
 49557 add ESP,1
 49560 sstack EBP:-4,EAX
 49564 push 0
 49567 rstack EAX,EBP:-2
 49571 push EAX
 49573 rstack EAX,EBP:3
 49577 push EAX
 49579 rstack EAX,EBP:2
 49583 push EAX
 49585 rstack EAX,EBP:-4
 49589 push EAX
 49591 mov ECX,5
// fs3_fh_constructor(...)
 49594 call 51544
 49597 add ESP,5
 49600 rstack EAX,EBP:-4
// file_handle_set_imp arg #2 (float N)
 49604 push EAX
 49606 rstack EAX,EBP:-3
// file_handle_set_imp arg #1 (float this)
 49610 push EAX
 49612 mov ECX,2
// file_handle_set_imp(...)
 49615 call 42664
 49618 add ESP,2
 49621 rstack EAX,EBP:-1
// free arg #1 (float* ptr)
 49625 push EAX
 49627 mov ECX,1
// free(...)
 49630 call 28980
 49633 add ESP,1
 49636 rstack EAX,EBP:-3
 49640 push EAX
 49642 rstack EAX,EBP:3
 49646 push EAX
 49648 rstack EAX,EBP:2
 49652 push EAX
 49654 mov ECX,3
// fs3_add_file_to_FT(...)
 49657 call 54706
 49660 add ESP,3
 49663 rstack EAX,EBP:-3
 49667 leave 
 49668 ret 
 49669 jmp 49692
__2116:
__2115:
__2118:
 49672 rstack EAX,EBP:-1
// free arg #1 (float* ptr)
 49676 push EAX
 49678 mov ECX,1
// free(...)
 49681 call 28980
 49684 add ESP,1
 49687 mov EAX,0
 49690 leave 
 49691 ret 
__2117:
__2113:
__2105:
 49692 leave 
 49693 ret 
fs3_open_or_lookup_file_index:
// fs3_open_or_lookup_file_index(fs3,file_index,new_allowed)
 49694 enter 1
__2120:
 49697 rstack EAX,EBP:3
 49701 push EAX
 49703 rstack EAX,EBP:2
 49707 push EAX
 49709 mov ECX,2
// fs3_FT_get_file(...)
 49712 call 54813
 49715 add ESP,2
 49718 sstack EBP:-1,EAX
__2122:
 49722 rstack EAX,EBP:-1
 49726 lneg EAX
 49728 mov EBX,EAX
// if (!res)
 49730 cmp 0,EBX
 49733 jge 49767
 49736 rstack EAX,EBP:4
// fs3_open_file_index arg #3 (float new_allowed)
 49740 push EAX
 49742 rstack EAX,EBP:3
// fs3_open_file_index arg #2 (float file_index)
 49746 push EAX
 49748 rstack EAX,EBP:2
// fs3_open_file_index arg #1 (float fs3)
 49752 push EAX
 49754 mov ECX,3
// fs3_open_file_index(...)
 49757 call 49374
 49760 add ESP,3
// res=fs3_open_file_index(fs3,file_index,new_allowed)
 49763 sstack EBP:-1,EAX
__2123:
__2121:
 49767 rstack EAX,EBP:-1
 49771 leave 
 49772 ret 
__2119:
 49773 leave 
 49774 ret 
fs3_open_root_dir:
// fs3_open_root_dir(fs3)
 49775 enter 1
__2125:
// fs3_open_file_index arg #3 (float new_allowed)
 49778 push 0
// fs3_open_file_index arg #2 (float file_index)
 49781 push 2
 49784 rstack EAX,EBP:2
// fs3_open_file_index arg #1 (float fs3)
 49788 push EAX
 49790 mov ECX,3
// fs3_open_file_index(...)
 49793 call 49374
 49796 add ESP,3
 49799 sstack EBP:-1,EAX
__2127:
 49803 rstack EAX,EBP:-1
 49807 lneg EAX
 49809 mov EBX,EAX
// if (!fh)
 49811 cmp 0,EBX
 49814 jge 49817
__2128:
__2126:
 49817 rstack EAX,EBP:-1
 49821 leave 
 49822 ret 
__2124:
 49823 leave 
 49824 ret 
fs3_find_file:
// fs3_find_file(fs3,filename,new_allowed,ret_backlink)
 49825 enter 2
__2130:
 49828 rstack EAX,EBP:2
// fs3_open_root_dir arg #1 (float fs3)
 49832 push EAX
 49834 mov ECX,1
// fs3_open_root_dir(...)
 49837 call 49775
 49840 add ESP,1
 49843 sstack EBP:-1,EAX
 49847 rstack EAX,EBP:5
 49851 push EAX
 49853 rstack EAX,EBP:4
 49857 push EAX
 49859 rstack EAX,EBP:-1
 49863 push EAX
 49865 rstack EAX,EBP:3
 49869 push EAX
 49871 rstack EAX,EBP:2
 49875 push EAX
 49877 mov ECX,5
// fs3_find_file_helper(...)
 49880 call 49919
 49883 add ESP,5
 49886 sstack EBP:-2,EAX
__2132:
 49890 rstack EAX,EBP:-2
 49894 mov EBX,-1
 49897 sub EBX,EAX
 49899 fabs EBX,EBX
 49901 fsgn EBX,EBX
 49903 lneg EBX
// if (res==-1)
 49905 cmp 0,EBX
 49908 jge 49911
__2133:
__2131:
 49911 rstack EAX,EBP:-2
 49915 leave 
 49916 ret 
__2129:
 49917 leave 
 49918 ret 
fs3_find_file_helper:
// fs3_find_file_helper(fs3,filename,fh_dir,new_allowed,ret_backlink)
 49919 enter 13
__2135:
// assert_arity arg #2 (float num_args)
 49922 push 5
// assert_arity arg #1 (float ecx_here)
 49925 push ECX
 49927 mov ECX,2
// assert_arity(...)
 49930 call 10245
 49933 add ESP,2
// assert_type arg #2 (float t)
 49936 push 44420
 49939 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 49943 push EAX
 49945 mov ECX,2
// assert_type(...)
 49948 call 10123
 49951 add ESP,2
// assert_type arg #2 (float t)
 49954 push 42294
 49957 rstack EAX,EBP:4
// assert_type arg #1 (float self)
 49961 push EAX
 49963 mov ECX,2
// assert_type(...)
 49966 call 10123
 49969 add ESP,2
 49972 sstack EBP:-1,-1
 49977 rstack EAX,EBP:6
// *ret_backlink=-1
 49981 mov #EAX,-1
__2138:
// strcmp arg #2 (char* dest)
 49984 push 50588
 49987 rstack EAX,EBP:3
// strcmp arg #1 (char* src)
 49991 push EAX
 49993 mov ECX,2
// strcmp(...)
 49996 call 10763
 49999 add ESP,2
 50002 mov EBX,0
 50005 sub EBX,EAX
 50007 fabs EBX,EBX
 50009 fsgn EBX,EBX
 50011 lneg EBX
// if (strcmp(filename,"/")==0)
 50013 cmp 0,EBX
 50016 jge 50027
// res=2
 50019 sstack EBP:-1,2
 50024 jmp 50580
__2139:
__2137:
 50027 mov EAX,SS:EBP
 50030 add EAX,-4
// filepath_decimate arg #4 (float* is_abs)
 50033 push EAX
 50035 mov EAX,SS:EBP
 50038 add EAX,-3
// filepath_decimate arg #3 (char* name)
 50041 push EAX
 50043 mov EAX,SS:EBP
 50046 add EAX,-2
// filepath_decimate arg #2 (float* folders)
 50049 push EAX
 50051 rstack EAX,EBP:3
// filepath_decimate arg #1 (char* filename)
 50055 push EAX
 50057 mov ECX,4
// filepath_decimate(...)
 50060 call 43560
 50063 add ESP,4
 50066 rstack EAX,EBP:-2
// strlen arg #1 (char* str)
 50070 push EAX
 50072 mov ECX,1
// strlen(...)
 50075 call 11121
 50078 add ESP,1
 50081 sstack EBP:-5,EAX
__2141:
 50085 rstack EAX,EBP:-3
 50089 mov EBX,0
 50092 sub EBX,EAX
 50094 fabs EBX,EBX
 50096 fsgn EBX,EBX
 50098 lneg EBX
// if (name==0)
 50100 cmp 0,EBX
 50103 jge 50137
 50106 rstack EAX,EBP:-5
 50110 add EAX,-1
 50113 mov EBX,EAX
 50115 rstack EAX,EBP:-2
 50119 add EAX,EBX
 50121 mov EBX,EAX
// name=folders[num_folders-1]
 50123 sstack EBP:-3,#EBX
 50127 rstack EAX,EBP:-5
// num_folders--
 50131 dec EAX
 50133 sstack EBP:-5,EAX
__2142:
__2140:
__2144:
 50137 rstack EAX,EBP:-5
// if (num_folders)
 50141 cmp 0,EAX
 50144 jge 50413
 50147 rstack EAX,EBP:-2
 50151 add EAX,0
 50154 mov EBX,EAX
// strlen arg #1 (char* str)
 50156 push #EBX
 50158 mov ECX,1
// strlen(...)
 50161 call 11121
 50164 add ESP,1
 50167 sstack EBP:-10,EAX
 50171 rstack EAX,EBP:-2
 50175 add EAX,0
 50178 mov EBX,EAX
 50180 sstack EBP:-11,#EBX
 50184 rstack EAX,EBP:-10
 50188 add EAX,1
 50191 mov EBX,EAX
 50193 rstack EAX,EBP:3
 50197 add EAX,EBX
 50199 mov EBX,EAX
 50201 sstack EBP:-12,EBX
 50205 rstack EAX,EBP:4
 50209 push EAX
 50211 rstack EAX,EBP:-11
 50215 push EAX
 50217 rstack EAX,EBP:2
 50221 push EAX
 50223 mov ECX,3
// fs3_find_file_in_folder(...)
 50226 call 50885
 50229 add ESP,3
// folder_index=fs3_find_file_in_folder(fs3,first_folder,fh_dir)
 50232 sstack EBP:-6,EAX
 50236 rstack EAX,EBP:-6
 50240 rstack EBX,EBP:6
// *ret_backlink=folder_index
 50244 mov #EBX,EAX
__2147:
 50246 rstack EAX,EBP:-6
 50250 mov EBX,-1
 50253 sub EBX,EAX
 50255 fabs EBX,EBX
 50257 fsgn EBX,EBX
 50259 lneg EBX
// if (folder_index==-1)
 50261 cmp 0,EBX
 50264 jge 50275
// res=-1
 50267 sstack EBP:-1,-1
 50272 jmp 50580
__2148:
__2146:
// fs3_open_file_index arg #3 (float new_allowed)
 50275 push 0
 50278 rstack EAX,EBP:-6
// fs3_open_file_index arg #2 (float file_index)
 50282 push EAX
 50284 rstack EAX,EBP:2
// fs3_open_file_index arg #1 (float fs3)
 50288 push EAX
 50290 mov ECX,3
// fs3_open_file_index(...)
 50293 call 49374
 50296 add ESP,3
// fh_dir2=fs3_open_file_index(fs3,folder_index,0)
 50299 sstack EBP:-7,EAX
__2150:
 50303 rstack EAX,EBP:-7
 50307 mov EBX,0
 50310 sub EBX,EAX
 50312 fabs EBX,EBX
 50314 fsgn EBX,EBX
 50316 lneg EBX
// if (fh_dir2==0)
 50318 cmp 0,EBX
 50321 jge 50335
// res=-1
 50324 sstack EBP:-1,-1
 50329 jmp 50580
 50332 jmp 50335
__2152:
__2151:
__2154:
__2153:
__2149:
 50335 rstack EAX,EBP:6
// fs3_find_file_helper arg #5 (float ret_backlink)
 50339 push EAX
 50341 rstack EAX,EBP:5
// fs3_find_file_helper arg #4 (float new_allowed)
 50345 push EAX
 50347 rstack EAX,EBP:-7
// fs3_find_file_helper arg #3 (float fh_dir)
 50351 push EAX
 50353 rstack EAX,EBP:-12
// fs3_find_file_helper arg #2 (float filename)
 50357 push EAX
 50359 rstack EAX,EBP:2
// fs3_find_file_helper arg #1 (float fs3)
 50363 push EAX
 50365 mov ECX,5
// fs3_find_file_helper(...)
 50368 call 49919
 50371 add ESP,5
// file_index=fs3_find_file_helper(fs3,path_rest,fh_dir2,new_allowed,ret_backlink)
 50374 sstack EBP:-8,EAX
__2156:
 50378 rstack EAX,EBP:-8
 50382 mov EBX,-1
 50385 sub EBX,EAX
 50387 fabs EBX,EBX
 50389 fsgn EBX,EBX
 50391 lneg EBX
// if (file_index==-1)
 50393 cmp 0,EBX
 50396 jge 50399
__2157:
__2155:
 50399 rstack EAX,EBP:-8
// res=file_index
 50403 sstack EBP:-1,EAX
 50407 jmp 50580
 50410 jmp 50580
__2158:
__2145:
__2160:
 50413 rstack EAX,EBP:4
 50417 push EAX
 50419 rstack EAX,EBP:-3
 50423 push EAX
 50425 rstack EAX,EBP:2
 50429 push EAX
 50431 mov ECX,3
// fs3_find_file_in_folder(...)
 50434 call 50885
 50437 add ESP,3
// file_index=fs3_find_file_in_folder(fs3,name,fh_dir)
 50440 sstack EBP:-8,EAX
__2162:
 50444 rstack EAX,EBP:-8
 50448 mov EBX,-1
 50451 sub EBX,EAX
 50453 fabs EBX,EBX
 50455 fsgn EBX,EBX
 50457 lneg EBX
// if (file_index==-1)
 50459 cmp 0,EBX
 50462 jge 50527
__2165:
 50465 rstack EAX,EBP:5
// if (new_allowed)
 50469 cmp 0,EAX
 50472 jge 50506
 50475 rstack EAX,EBP:-3
// fs3_new_abs arg #3 (float name)
 50479 push EAX
 50481 rstack EAX,EBP:4
// fs3_new_abs arg #2 (float fh_dir)
 50485 push EAX
 50487 rstack EAX,EBP:2
// fs3_new_abs arg #1 (float self)
 50491 push EAX
 50493 mov ECX,3
// fs3_new_abs(...)
 50496 call 47096
 50499 add ESP,3
// file_index=fs3_new_abs(fs3,fh_dir,name)
 50502 sstack EBP:-8,EAX
__2166:
__2164:
__2168:
 50506 rstack EAX,EBP:-8
 50510 mov EBX,-1
 50513 sub EBX,EAX
 50515 fabs EBX,EBX
 50517 fsgn EBX,EBX
 50519 lneg EBX
// if (file_index==-1)
 50521 cmp 0,EBX
 50524 jge 50527
__2169:
__2167:
__2163:
__2161:
 50527 rstack EAX,EBP:4
// file_handle_get_imp arg #1 (float this)
 50531 push EAX
 50533 mov ECX,1
// file_handle_get_imp(...)
 50536 call 42552
 50539 add ESP,1
 50542 sstack EBP:-13,EAX
 50546 rstack EAX,EBP:-13
 50550 add EAX,4
 50553 mov EBX,EAX
// folder_index=fh_imp[4]
 50555 sstack EBP:-6,#EBX
 50559 rstack EAX,EBP:-6
 50563 rstack EBX,EBP:6
// *ret_backlink=folder_index
 50567 mov #EBX,EAX
 50569 rstack EAX,EBP:-8
// res=file_index
 50573 sstack EBP:-1,EAX
 50577 jmp 50580
__2159:
__2143:
fs3_ffh_end:
 50580 rstack EAX,EBP:-1
 50584 leave 
 50585 ret 
__2134:
 50586 leave 
 50587 ret 
__2136:
 50588 db "/",0
fs3_find_entry_in_folder:
// fs3_find_entry_in_folder(fs3,filename,fh_dir)
 50590 enter 45
__2171:
// assert_type arg #2 (float t)
 50593 push 44420
 50596 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 50600 push EAX
 50602 mov ECX,2
// assert_type(...)
 50605 call 10123
 50608 add ESP,2
 50611 sstack EBP:-2,-1
 50616 push 0
 50619 push 0
 50622 rstack EAX,EBP:4
 50626 push EAX
 50628 mov ECX,3
// fseek(...)
 50631 call 52453
 50634 add ESP,3
// res=fseek(fh_dir,0,0)
 50637 sstack EBP:-1,EAX
__2173:
 50641 rstack EAX,EBP:-1
 50645 lneg EAX
 50647 mov EBX,EAX
// if (!res)
 50649 cmp 0,EBX
 50652 jge 50655
__2174:
__2172:
 50655 rstack EAX,EBP:4
 50659 push EAX
 50661 push 1
 50664 mov EAX,SS:EBP
 50667 add EAX,-2
 50670 push EAX
 50672 mov ECX,3
// fread(...)
 50675 call 52657
 50678 add ESP,3
// res=fread(&num_entries,1,fh_dir)
 50681 sstack EBP:-1,EAX
__2176:
 50685 rstack EAX,EBP:-1
 50689 lneg EAX
 50691 mov EBX,EAX
// if (!res)
 50693 cmp 0,EBX
 50696 jge 50699
__2177:
__2175:
// init loop
 50699 sstack EBP:-3,0
__2179:
 50704 rstack EAX,EBP:-3
 50708 rstack EBX,EBP:-2
 50712 sub EBX,EAX
 50714 mov EAX,EBX
 50716 fsgn EAX,EAX
// condition
 50718 max EAX,0
 50721 cmp 0,EAX
 50724 jz 50878
 50727 rstack EAX,EBP:-3
// fs3_dir_get_entry_ptr arg #3 (float I)
 50731 push EAX
 50733 rstack EAX,EBP:4
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 50737 push EAX
 50739 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 50743 push EAX
 50745 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 50748 call 47608
 50751 add ESP,3
 50754 sstack EBP:-4,EAX
 50758 push 0
 50761 rstack EAX,EBP:-4
 50765 push EAX
 50767 rstack EAX,EBP:4
 50771 push EAX
 50773 mov ECX,3
// fseek(...)
 50776 call 52453
 50779 add ESP,3
 50782 rstack EAX,EBP:4
 50786 push EAX
 50788 push 40
 50791 mov EAX,SS:EBP
 50794 add EAX,-44
 50797 push EAX
 50799 mov ECX,3
// fread(...)
 50802 call 52657
 50805 add ESP,3
 50808 mov EAX,SS:EBP
 50811 add EAX,-44
 50814 add EAX,4
 50817 sstack EBP:-45,EAX
__2181:
 50821 rstack EAX,EBP:3
// strcmp arg #2 (char* dest)
 50825 push EAX
 50827 rstack EAX,EBP:-45
// strcmp arg #1 (char* src)
 50831 push EAX
 50833 mov ECX,2
// strcmp(...)
 50836 call 10763
 50839 add ESP,2
 50842 mov EBX,0
 50845 sub EBX,EAX
 50847 fabs EBX,EBX
 50849 fsgn EBX,EBX
 50851 lneg EBX
// if (strcmp(e_name,filename)==0)
 50853 cmp 0,EBX
 50856 jge 50865
 50859 rstack EAX,EBP:-3
 50863 leave 
 50864 ret 
__2182:
__2180:
 50865 rstack EAX,EBP:-3
// loop step
 50869 inc EAX
 50871 sstack EBP:-3,EAX
 50875 jmp 50704
__2178:
 50878 mov EAX,-1
 50881 leave 
 50882 ret 
__2170:
 50883 leave 
 50884 ret 
fs3_find_file_in_folder:
// fs3_find_file_in_folder(fs3,filename,fh_dir)
 50885 enter 4
__2184:
// assert_type arg #2 (float t)
 50888 push 44420
 50891 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 50895 push EAX
 50897 mov ECX,2
// assert_type(...)
 50900 call 10123
 50903 add ESP,2
 50906 rstack EAX,EBP:4
// fs3_find_entry_in_folder arg #3 (float fh_dir)
 50910 push EAX
 50912 rstack EAX,EBP:3
// fs3_find_entry_in_folder arg #2 (float filename)
 50916 push EAX
 50918 rstack EAX,EBP:2
// fs3_find_entry_in_folder arg #1 (float fs3)
 50922 push EAX
 50924 mov ECX,3
// fs3_find_entry_in_folder(...)
 50927 call 50590
 50930 add ESP,3
 50933 sstack EBP:-1,EAX
__2186:
 50937 rstack EAX,EBP:-1
 50941 mov EBX,-1
 50944 sub EBX,EAX
 50946 fabs EBX,EBX
 50948 fsgn EBX,EBX
// if (entry_idx!=-1)
 50950 cmp 0,EBX
 50953 jge 51054
 50956 rstack EAX,EBP:-1
// fs3_dir_get_entry_ptr arg #3 (float I)
 50960 push EAX
 50962 rstack EAX,EBP:4
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 50966 push EAX
 50968 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 50972 push EAX
 50974 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 50977 call 47608
 50980 add ESP,3
 50983 sstack EBP:-2,EAX
 50987 rstack EAX,EBP:-2
 50991 sstack EBP:-3,EAX
 50995 push 0
 50998 rstack EAX,EBP:-3
 51002 push EAX
 51004 rstack EAX,EBP:4
 51008 push EAX
 51010 mov ECX,3
// fseek(...)
 51013 call 52453
 51016 add ESP,3
 51019 rstack EAX,EBP:4
 51023 push EAX
 51025 push 1
 51028 mov EAX,SS:EBP
 51031 add EAX,-4
 51034 push EAX
 51036 mov ECX,3
// fread(...)
 51039 call 52657
 51042 add ESP,3
 51045 rstack EAX,EBP:-4
 51049 leave 
 51050 ret 
 51051 jmp 51059
__2188:
__2187:
__2190:
 51054 mov EAX,-1
 51057 leave 
 51058 ret 
__2189:
__2185:
__2183:
 51059 leave 
 51060 ret 
fs3_from_filepath:
// fs3_from_filepath(shell,filepath)
 51061 enter 12
__2192:
 51064 mov EAX,SS:EBP
 51067 add EAX,-10
// filepath_drive arg #2 (float driveletter)
 51070 push EAX
 51072 rstack EAX,EBP:3
// filepath_drive arg #1 (float filename)
 51076 push EAX
 51078 mov ECX,2
// filepath_drive(...)
 51081 call 44178
 51084 add ESP,2
 51087 sstack EBP:-11,EAX
__2194:
 51091 rstack EAX,EBP:-11
// if (res)
 51095 cmp 0,EAX
 51098 jge 51137
 51101 mov EAX,SS:EBP
 51104 add EAX,-10
 51107 push EAX
 51109 rstack EAX,EBP:2
 51113 push EAX
 51115 mov ECX,2
// shell2_get_fs3(...)
 51118 call 51144
 51121 add ESP,2
 51124 sstack EBP:-12,EAX
 51128 rstack EAX,EBP:-12
 51132 leave 
 51133 ret 
 51134 jmp 51142
__2196:
__2195:
__2198:
 51137 mov EAX,0
 51140 leave 
 51141 ret 
__2197:
__2193:
__2191:
 51142 leave 
 51143 ret 
shell2_get_fs3:
// shell2_get_fs3(shell,letter)
 51144 enter 14
__2200:
// assert_type arg #2 (float t)
 51147 push 37328
 51150 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 51154 push EAX
 51156 mov ECX,2
// assert_type(...)
 51159 call 10123
 51162 add ESP,2
 51165 rstack EAX,EBP:2
 51169 add EAX,2
 51172 mov EBX,EAX
 51174 sstack EBP:-1,#EBX
 51178 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 51182 push EAX
 51184 mov ECX,1
// vector_size(...)
 51187 call 32667
 51190 add ESP,1
 51193 sstack EBP:-2,EAX
// init loop
 51197 sstack EBP:-3,0
__2202:
 51202 rstack EAX,EBP:-3
 51206 rstack EBX,EBP:-2
 51210 sub EBX,EAX
 51212 mov EAX,EBX
 51214 fsgn EAX,EAX
// condition
 51216 max EAX,0
 51219 cmp 0,EAX
 51222 jz 51324
 51225 mov EAX,SS:EBP
 51228 add EAX,-13
 51231 add EAX,1
 51234 sstack EBP:-14,EAX
 51238 rstack EAX,EBP:-3
// vector_get arg #3 (float pos)
 51242 push EAX
 51244 mov EAX,SS:EBP
 51247 add EAX,-13
// vector_get arg #2 (void* element)
 51250 push EAX
 51252 rstack EAX,EBP:-1
// vector_get arg #1 (void* self)
 51256 push EAX
 51258 mov ECX,3
// vector_get(...)
 51261 call 32750
 51264 add ESP,3
__2204:
 51267 rstack EAX,EBP:-14
// strcmp arg #2 (char* dest)
 51271 push EAX
 51273 rstack EAX,EBP:3
// strcmp arg #1 (char* src)
 51277 push EAX
 51279 mov ECX,2
// strcmp(...)
 51282 call 10763
 51285 add ESP,2
 51288 mov EBX,0
 51291 sub EBX,EAX
 51293 fabs EBX,EBX
 51295 fsgn EBX,EBX
 51297 lneg EBX
// if (strcmp(letter,e_letter)==0)
 51299 cmp 0,EBX
 51302 jge 51311
 51305 rstack EAX,EBP:-13
 51309 leave 
 51310 ret 
__2205:
__2203:
 51311 rstack EAX,EBP:-3
// loop step
 51315 inc EAX
 51317 sstack EBP:-3,EAX
 51321 jmp 51202
__2201:
 51324 mov EAX,0
 51327 leave 
 51328 ret 
__2199:
 51329 leave 
 51330 ret 
fs3_file_set_backlink:
// fs3_file_set_backlink(fh,backlink,fs3)
 51331 enter 3
__2207:
// assert_type arg #2 (float t)
 51334 push 42294
 51337 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 51341 push EAX
 51343 mov ECX,2
// assert_type(...)
 51346 call 10123
 51349 add ESP,2
// assert_type arg #2 (float t)
 51352 push 44420
 51355 rstack EAX,EBP:4
// assert_type arg #1 (float self)
 51359 push EAX
 51361 mov ECX,2
// assert_type(...)
 51364 call 10123
 51367 add ESP,2
 51370 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 51374 push EAX
 51376 mov ECX,1
// file_handle_get_imp(...)
 51379 call 42552
 51382 add ESP,1
 51385 sstack EBP:-1,EAX
 51389 rstack EAX,EBP:3
 51393 rstack EBX,EBP:-1
 51397 add EBX,9
 51400 mov ECX,EBX
// fp_imp[9]=backlink
 51402 mov #ECX,EAX
 51404 rstack EAX,EBP:-1
 51408 add EAX,4
 51411 mov EBX,EAX
 51413 sstack EBP:-2,#EBX
 51417 rstack EAX,EBP:-2
 51421 push EAX
 51423 rstack EAX,EBP:3
 51427 push EAX
 51429 rstack EAX,EBP:4
 51433 push EAX
 51435 mov ECX,3
// fs3_backlink_read_size(...)
 51438 call 55525
 51441 add ESP,3
 51444 sstack EBP:-3,EAX
 51448 rstack EAX,EBP:-3
 51452 rstack EBX,EBP:-1
 51456 add EBX,2
 51459 mov ECX,EBX
// fp_imp[2]=size
 51461 mov #ECX,EAX
__2206:
 51463 leave 
 51464 ret 
fs3_file_get_backlink:
// fs3_file_get_backlink(fh)
 51465 enter 2
__2209:
// assert_type arg #2 (float t)
 51468 push 42294
 51471 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 51475 push EAX
 51477 mov ECX,2
// assert_type(...)
 51480 call 10123
 51483 add ESP,2
 51486 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 51490 push EAX
 51492 mov ECX,1
// file_handle_get_imp(...)
 51495 call 42552
 51498 add ESP,1
 51501 sstack EBP:-1,EAX
 51505 rstack EAX,EBP:-1
 51509 add EAX,9
 51512 mov EBX,EAX
 51514 sstack EBP:-2,#EBX
 51518 rstack EAX,EBP:-2
 51522 leave 
 51523 ret 
__2208:
 51524 leave 
 51525 ret 
fs_marker6:
 51526 db 0
typeof_fs3_fh:
 51527 db "fs3_file_handle",0
sizeof_fs3_fh:
 51543 db 43
fs3_fh_constructor:
// fs3_fh_constructor(self,fs3,file_index,fblock,backlink)
 51544 enter -0
__2211:
// assert_arity arg #2 (float num_args)
 51547 push 5
// assert_arity arg #1 (float ecx_here)
 51550 push ECX
 51552 mov ECX,2
// assert_arity(...)
 51555 call 10245
 51558 add ESP,2
 51561 rstack EAX,EBP:2
 51565 add EAX,0
 51568 mov EBX,EAX
// self[0]=typeof_fs3_fh
 51570 mov #EBX,51527
 51573 rstack EAX,EBP:3
 51577 rstack EBX,EBP:2
 51581 add EBX,1
 51584 mov ECX,EBX
// self[1]=fs3
 51586 mov #ECX,EAX
 51588 rstack EAX,EBP:2
 51592 add EAX,2
 51595 mov EBX,EAX
// self[2]=0
 51597 mov #EBX,0
 51600 rstack EAX,EBP:2
 51604 add EAX,3
 51607 mov EBX,EAX
// self[3]=0
 51609 mov #EBX,0
 51612 rstack EAX,EBP:4
 51616 rstack EBX,EBP:2
 51620 add EBX,4
 51623 mov ECX,EBX
// self[4]=file_index
 51625 mov #ECX,EAX
 51627 rstack EAX,EBP:5
 51631 rstack EBX,EBP:2
 51635 add EBX,5
 51638 mov ECX,EBX
// self[5]=fblock
 51640 mov #ECX,EAX
 51642 rstack EAX,EBP:5
 51646 rstack EBX,EBP:2
 51650 add EBX,6
 51653 mov ECX,EBX
// self[6]=fblock
 51655 mov #ECX,EAX
 51657 rstack EAX,EBP:2
 51661 add EAX,7
 51664 mov EBX,EAX
// self[7]=0
 51666 mov #EBX,0
 51669 rstack EAX,EBP:2
 51673 add EAX,8
 51676 mov EBX,EAX
// self[8]=0
 51678 mov #EBX,0
 51681 rstack EAX,EBP:6
 51685 rstack EBX,EBP:2
 51689 add EBX,9
 51692 mov ECX,EBX
// self[9]=backlink
 51694 mov #ECX,EAX
 51696 rstack EAX,EBP:2
 51700 add EAX,10
 51703 mov EBX,EAX
// self[10]=0
 51705 mov #EBX,0
 51708 rstack EAX,EBP:2
 51712 add EAX,11
 51715 mov EBX,EAX
// self[11]=0
 51717 mov #EBX,0
__2210:
 51720 leave 
 51721 ret 
print_file_handle:
// print_file_handle(fh)
 51722 enter 1
__2213:
// assert_type arg #2 (float t)
 51725 push 42294
 51728 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 51732 push EAX
 51734 mov ECX,2
// assert_type(...)
 51737 call 10123
 51740 add ESP,2
 51743 rstack EAX,EBP:2
// printf arg #2 (unknown)
 51747 push EAX
// printf arg #1 (char* format)
 51749 push 48462
 51752 mov ECX,2
// printf(...)
 51755 call 21772
 51758 add ESP,2
 51761 rstack EAX,EBP:2
 51765 add EAX,1
 51768 mov EBX,EAX
// printf arg #2 (unknown)
 51770 push #EBX
// printf arg #1 (char* format)
 51772 push 52272
 51775 mov ECX,2
// printf(...)
 51778 call 21772
 51781 add ESP,2
 51784 rstack EAX,EBP:2
 51788 add EAX,2
 51791 mov EBX,EAX
// printf arg #2 (unknown)
 51793 push #EBX
// printf arg #1 (char* format)
 51795 push 52110
 51798 mov ECX,2
// printf(...)
 51801 call 21772
 51804 add ESP,2
 51807 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 51811 push EAX
 51813 mov ECX,1
// file_handle_get_imp(...)
 51816 call 42552
 51819 add ESP,1
 51822 sstack EBP:-1,EAX
 51826 rstack EAX,EBP:-1
 51830 add EAX,1
 51833 mov EBX,EAX
// printf arg #2 (unknown)
 51835 push #EBX
// printf arg #1 (char* format)
 51837 push 52099
 51840 mov ECX,2
// printf(...)
 51843 call 21772
 51846 add ESP,2
 51849 rstack EAX,EBP:-1
 51853 add EAX,2
 51856 mov EBX,EAX
// printf arg #2 (unknown)
 51858 push #EBX
// printf arg #1 (char* format)
 51860 push 52234
 51863 mov ECX,2
// printf(...)
 51866 call 21772
 51869 add ESP,2
 51872 rstack EAX,EBP:-1
 51876 add EAX,3
 51879 mov EBX,EAX
// printf arg #2 (unknown)
 51881 push #EBX
// printf arg #1 (char* format)
 51883 push 52196
 51886 mov ECX,2
// printf(...)
 51889 call 21772
 51892 add ESP,2
 51895 rstack EAX,EBP:-1
 51899 add EAX,4
 51902 mov EBX,EAX
// printf arg #2 (unknown)
 51904 push #EBX
// printf arg #1 (char* format)
 51906 push 52285
 51909 mov ECX,2
// printf(...)
 51912 call 21772
 51915 add ESP,2
 51918 rstack EAX,EBP:-1
 51922 add EAX,5
 51925 mov EBX,EAX
// printf arg #2 (unknown)
 51927 push #EBX
// printf arg #1 (char* format)
 51929 push 52120
 51932 mov ECX,2
// printf(...)
 51935 call 21772
 51938 add ESP,2
 51941 rstack EAX,EBP:-1
 51945 add EAX,6
 51948 mov EBX,EAX
// printf arg #2 (unknown)
 51950 push #EBX
// printf arg #1 (char* format)
 51952 push 52253
 51955 mov ECX,2
// printf(...)
 51958 call 21772
 51961 add ESP,2
 51964 rstack EAX,EBP:-1
 51968 add EAX,7
 51971 mov EBX,EAX
// printf arg #2 (unknown)
 51973 push #EBX
// printf arg #1 (char* format)
 51975 push 52215
 51978 mov ECX,2
// printf(...)
 51981 call 21772
 51984 add ESP,2
 51987 rstack EAX,EBP:-1
 51991 add EAX,8
 51994 mov EBX,EAX
// printf arg #2 (unknown)
 51996 push #EBX
// printf arg #1 (char* format)
 51998 push 52177
 52001 mov ECX,2
// printf(...)
 52004 call 21772
 52007 add ESP,2
 52010 rstack EAX,EBP:-1
 52014 add EAX,9
 52017 mov EBX,EAX
// printf arg #2 (unknown)
 52019 push #EBX
// printf arg #1 (char* format)
 52021 push 52139
 52024 mov ECX,2
// printf(...)
 52027 call 21772
 52030 add ESP,2
 52033 rstack EAX,EBP:-1
 52037 add EAX,10
 52040 mov EBX,EAX
// printf arg #2 (unknown)
 52042 push #EBX
// printf arg #1 (char* format)
 52044 push 52158
 52047 mov ECX,2
// printf(...)
 52050 call 21772
 52053 add ESP,2
 52056 rstack EAX,EBP:-1
 52060 add EAX,11
 52063 mov EBX,EAX
// printf arg #2 (unknown)
 52065 push EBX
// printf arg #1 (char* format)
 52067 push 52081
 52070 mov ECX,2
// printf(...)
 52073 call 21772
 52076 add ESP,2
__2212:
 52079 leave 
 52080 ret 
__2226:
 52081 db "  filename: [%s]
",0
__2216:
 52099 db "  fs3: %d
",0
__2215:
 52110 db " imp: %d
",0
__2220:
 52120 db "  first block: %d
",0
__2224:
 52139 db "  backlink:    %d
",0
__2225:
 52158 db "  reserved 3:  %d
",0
__2223:
 52177 db "  reserved 2:  %d
",0
__2218:
 52196 db "  file cap:    %d
",0
__2222:
 52215 db "  reserved 1:  %d
",0
__2217:
 52234 db "  file size:   %d
",0
__2221:
 52253 db "  cur block:   %d
",0
__2214:
 52272 db " rw ptr: %d
",0
__2219:
 52285 db "  file_index:  %d
",0
fs3_fh_set_filename:
// fs3_fh_set_filename(self,filename)
 52304 enter -0
__2228:
// assert_type arg #2 (float t)
 52307 push 51527
 52310 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 52314 push EAX
 52316 mov ECX,2
// assert_type(...)
 52319 call 10123
 52322 add ESP,2
// strncpy arg #3 (float n)
 52325 push 31
 52328 rstack EAX,EBP:3
// strncpy arg #2 (char* src)
 52332 push EAX
 52334 rstack EAX,EBP:2
 52338 add EAX,11
 52341 mov EBX,EAX
// strncpy arg #1 (char* dest)
 52343 push EBX
 52345 mov ECX,3
// strncpy(...)
 52348 call 11009
 52351 add ESP,3
__2227:
 52354 leave 
 52355 ret 
fs3_fh_get_filename:
// fs3_fh_get_filename(self)
 52356 enter -0
__2230:
// assert_type arg #2 (float t)
 52359 push 51527
 52362 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 52366 push EAX
 52368 mov ECX,2
// assert_type(...)
 52371 call 10123
 52374 add ESP,2
 52377 rstack EAX,EBP:2
 52381 add EAX,11
 52384 mov EBX,EAX
 52386 mov EAX,EBX
 52388 leave 
 52389 ret 
__2229:
 52390 leave 
 52391 ret 
fsize:
// fsize(fp)
 52392 enter 2
__2232:
// assert_type arg #2 (float t)
 52395 push 42294
 52398 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 52402 push EAX
 52404 mov ECX,2
// assert_type(...)
 52407 call 10123
 52410 add ESP,2
 52413 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 52417 push EAX
 52419 mov ECX,1
// file_handle_get_imp(...)
 52422 call 42552
 52425 add ESP,1
 52428 sstack EBP:-1,EAX
 52432 rstack EAX,EBP:-1
 52436 add EAX,2
 52439 mov EBX,EAX
 52441 sstack EBP:-2,#EBX
 52445 rstack EAX,EBP:-2
 52449 leave 
 52450 ret 
__2231:
 52451 leave 
 52452 ret 
fseek:
// fseek(fp,offs,whence)
 52453 enter 4
__2234:
// assert_type arg #2 (float t)
 52456 push 42294
 52459 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 52463 push EAX
 52465 mov ECX,2
// assert_type(...)
 52468 call 10123
 52471 add ESP,2
 52474 rstack EAX,EBP:2
// file_handle_get_imp arg #1 (float this)
 52478 push EAX
 52480 mov ECX,1
// file_handle_get_imp(...)
 52483 call 42552
 52486 add ESP,1
 52489 sstack EBP:-1,EAX
 52493 rstack EAX,EBP:2
// file_handle_get_rw_ptr arg #1 (float this)
 52497 push EAX
 52499 mov ECX,1
// file_handle_get_rw_ptr(...)
 52502 call 42516
 52505 add ESP,1
 52508 sstack EBP:-2,EAX
__2236:
 52512 rstack EAX,EBP:4
 52516 mov EBX,0
 52519 sub EBX,EAX
 52521 fabs EBX,EBX
 52523 fsgn EBX,EBX
 52525 lneg EBX
// if (whence==0)
 52527 cmp 0,EBX
 52530 jge 52541
 52533 rstack EAX,EBP:3
// offs_final=offs
 52537 sstack EBP:-3,EAX
__2237:
__2235:
__2239:
 52541 rstack EAX,EBP:4
 52545 mov EBX,1
 52548 sub EBX,EAX
 52550 fabs EBX,EBX
 52552 fsgn EBX,EBX
 52554 lneg EBX
// if (whence==1)
 52556 cmp 0,EBX
 52559 jge 52578
 52562 rstack EAX,EBP:-2
 52566 rstack EBX,EBP:3
 52570 add EBX,EAX
 52572 mov EAX,EBX
// offs_final=offs+rw_ptr_cur
 52574 sstack EBP:-3,EAX
__2240:
__2238:
__2242:
 52578 rstack EAX,EBP:4
 52582 mov EBX,2
 52585 sub EBX,EAX
 52587 fabs EBX,EBX
 52589 fsgn EBX,EBX
 52591 lneg EBX
// if (whence==2)
 52593 cmp 0,EBX
 52596 jge 52628
 52599 rstack EAX,EBP:-1
 52603 add EAX,2
 52606 mov EBX,EAX
 52608 sstack EBP:-4,#EBX
 52612 rstack EAX,EBP:-4
 52616 rstack EBX,EBP:3
 52620 add EBX,EAX
 52622 mov EAX,EBX
// offs_final=offs+size
 52624 sstack EBP:-3,EAX
__2243:
__2241:
 52628 rstack EAX,EBP:-3
// file_handle_set_rw_ptr arg #2 (float N)
 52632 push EAX
 52634 rstack EAX,EBP:2
// file_handle_set_rw_ptr arg #1 (float this)
 52638 push EAX
 52640 mov ECX,2
// file_handle_set_rw_ptr(...)
 52643 call 42626
 52646 add ESP,2
 52649 rstack EAX,EBP:-3
 52653 leave 
 52654 ret 
__2233:
 52655 leave 
 52656 ret 
fread:
// fread(to,size,fp)
 52657 enter 5
__2245:
// assert_type arg #2 (float t)
 52660 push 42294
 52663 rstack EAX,EBP:4
// assert_type arg #1 (float self)
 52667 push EAX
 52669 mov ECX,2
// assert_type(...)
 52672 call 10123
 52675 add ESP,2
 52678 rstack EAX,EBP:4
// file_handle_get_imp arg #1 (float this)
 52682 push EAX
 52684 mov ECX,1
// file_handle_get_imp(...)
 52687 call 42552
 52690 add ESP,1
 52693 sstack EBP:-1,EAX
// assert_type arg #2 (float t)
 52697 push 51527
 52700 rstack EAX,EBP:-1
// assert_type arg #1 (float self)
 52704 push EAX
 52706 mov ECX,2
// assert_type(...)
 52709 call 10123
 52712 add ESP,2
 52715 rstack EAX,EBP:4
// file_handle_get_rw_ptr arg #1 (float this)
 52719 push EAX
 52721 mov ECX,1
// file_handle_get_rw_ptr(...)
 52724 call 42516
 52727 add ESP,1
 52730 sstack EBP:-2,EAX
 52734 rstack EAX,EBP:-1
 52738 add EAX,6
 52741 mov EBX,EAX
 52743 sstack EBP:-3,#EBX
 52747 rstack EAX,EBP:-1
 52751 add EAX,1
 52754 mov EBX,EAX
 52756 sstack EBP:-4,#EBX
 52760 rstack EAX,EBP:-2
// fs3_get_disk_adr arg #3 (float ptr)
 52764 push EAX
 52766 rstack EAX,EBP:-3
// fs3_get_disk_adr arg #2 (float block_num)
 52770 push EAX
 52772 rstack EAX,EBP:-4
// fs3_get_disk_adr arg #1 (float fs3)
 52776 push EAX
 52778 mov ECX,3
// fs3_get_disk_adr(...)
 52781 call 45922
 52784 add ESP,3
 52787 sstack EBP:-5,EAX
 52791 rstack EAX,EBP:3
// fs3_low_read arg #4 (float size)
 52795 push EAX
 52797 rstack EAX,EBP:2
// fs3_low_read arg #3 (float to)
 52801 push EAX
 52803 rstack EAX,EBP:-5
// fs3_low_read arg #2 (float disk_ptr)
 52807 push EAX
 52809 rstack EAX,EBP:-4
// fs3_low_read arg #1 (float fs3)
 52813 push EAX
 52815 mov ECX,4
// fs3_low_read(...)
 52818 call 46027
 52821 add ESP,4
 52824 mov EAX,1
 52827 leave 
 52828 ret 
__2244:
 52829 leave 
 52830 ret 
fwrite:
// fwrite(from,size,fp)
 52831 enter 10
__2247:
// assert_type arg #2 (float t)
 52834 push 42294
 52837 rstack EAX,EBP:4
// assert_type arg #1 (float self)
 52841 push EAX
 52843 mov ECX,2
// assert_type(...)
 52846 call 10123
 52849 add ESP,2
 52852 rstack EAX,EBP:4
// file_handle_get_imp arg #1 (float this)
 52856 push EAX
 52858 mov ECX,1
// file_handle_get_imp(...)
 52861 call 42552
 52864 add ESP,1
 52867 sstack EBP:-1,EAX
// assert_type arg #2 (float t)
 52871 push 51527
 52874 rstack EAX,EBP:-1
// assert_type arg #1 (float self)
 52878 push EAX
 52880 mov ECX,2
// assert_type(...)
 52883 call 10123
 52886 add ESP,2
 52889 rstack EAX,EBP:4
// file_handle_get_rw_ptr arg #1 (float this)
 52893 push EAX
 52895 mov ECX,1
// file_handle_get_rw_ptr(...)
 52898 call 42516
 52901 add ESP,1
 52904 sstack EBP:-2,EAX
 52908 rstack EAX,EBP:-1
 52912 add EAX,6
 52915 mov EBX,EAX
 52917 sstack EBP:-3,#EBX
 52921 rstack EAX,EBP:-1
 52925 add EAX,1
 52928 mov EBX,EAX
 52930 sstack EBP:-4,#EBX
 52934 rstack EAX,EBP:-2
// fs3_get_disk_adr arg #3 (float ptr)
 52938 push EAX
 52940 rstack EAX,EBP:-3
// fs3_get_disk_adr arg #2 (float block_num)
 52944 push EAX
 52946 rstack EAX,EBP:-4
// fs3_get_disk_adr arg #1 (float fs3)
 52950 push EAX
 52952 mov ECX,3
// fs3_get_disk_adr(...)
 52955 call 45922
 52958 add ESP,3
 52961 sstack EBP:-5,EAX
 52965 rstack EAX,EBP:3
// fs3_low_write arg #4 (float size)
 52969 push EAX
 52971 rstack EAX,EBP:2
// fs3_low_write arg #3 (float from)
 52975 push EAX
 52977 rstack EAX,EBP:-5
// fs3_low_write arg #2 (float disk_ptr)
 52981 push EAX
 52983 rstack EAX,EBP:-4
// fs3_low_write arg #1 (float fs3)
 52987 push EAX
 52989 mov ECX,4
// fs3_low_write(...)
 52992 call 46116
 52995 add ESP,4
 52998 sstack EBP:-6,EAX
 53002 rstack EAX,EBP:3
 53006 rstack EBX,EBP:-2
// rw_ptr_cur+=size
 53010 add EBX,EAX
 53012 sstack EBP:-2,EBX
 53016 rstack EAX,EBP:-2
// file_handle_set_rw_ptr arg #2 (float N)
 53020 push EAX
 53022 rstack EAX,EBP:4
// file_handle_set_rw_ptr arg #1 (float this)
 53026 push EAX
 53028 mov ECX,2
// file_handle_set_rw_ptr(...)
 53031 call 42626
 53034 add ESP,2
 53037 rstack EAX,EBP:-1
 53041 add EAX,2
 53044 mov EBX,EAX
 53046 sstack EBP:-7,#EBX
__2249:
 53050 rstack EAX,EBP:-2
 53054 rstack EBX,EBP:-7
 53058 sub EBX,EAX
 53060 mov EAX,EBX
 53062 neg EAX
 53064 fsgn EAX,EAX
 53066 max EAX,0
// if (rw_ptr_cur>filesize)
 53069 cmp 0,EAX
 53072 jge 53183
 53075 rstack EAX,EBP:-2
// filesize=rw_ptr_cur
 53079 sstack EBP:-7,EAX
 53083 rstack EAX,EBP:-7
 53087 rstack EBX,EBP:-1
 53091 add EBX,2
 53094 mov ECX,EBX
// fp_imp[2]=filesize
 53096 mov #ECX,EAX
 53098 rstack EAX,EBP:-1
 53102 add EAX,9
 53105 mov EBX,EAX
 53107 sstack EBP:-8,#EBX
 53111 rstack EAX,EBP:-1
 53115 add EAX,4
 53118 mov EBX,EAX
 53120 sstack EBP:-9,#EBX
 53124 rstack EAX,EBP:-1
 53128 add EAX,11
 53131 mov EBX,EAX
 53133 sstack EBP:-10,EBX
__2252:
 53137 rstack EAX,EBP:-8
// if (backlink)
 53141 cmp 0,EAX
 53144 jge 53183
 53147 rstack EAX,EBP:-7
 53151 push EAX
 53153 rstack EAX,EBP:-9
 53157 push EAX
 53159 rstack EAX,EBP:-8
 53163 push EAX
 53165 rstack EAX,EBP:-4
 53169 push EAX
 53171 mov ECX,4
// fs3_backlink_write_size(...)
 53174 call 55273
 53177 add ESP,4
 53180 jmp 53183
__2254:
__2253:
__2256:
__2255:
__2251:
__2250:
__2248:
 53183 rstack EAX,EBP:-6
 53187 leave 
 53188 ret 
__2246:
 53189 leave 
 53190 ret 
fopen:
// fopen(shell,filepath,mode)
 53191 enter 14
__2258:
// assert_type arg #2 (float t)
 53194 push 37328
 53197 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 53201 push EAX
 53203 mov ECX,2
// assert_type(...)
 53206 call 10123
 53209 add ESP,2
 53212 rstack EAX,EBP:2
 53216 add EAX,100
 53219 mov EBX,EAX
 53221 sstack EBP:-1,EBX
 53225 rstack EAX,EBP:3
// filepath_abs arg #2 (char* filename)
 53229 push EAX
 53231 rstack EAX,EBP:-1
// filepath_abs arg #1 (float current_path)
 53235 push EAX
 53237 mov ECX,2
// filepath_abs(...)
 53240 call 43303
 53243 add ESP,2
 53246 sstack EBP:-2,EAX
__2260:
 53250 rstack EAX,EBP:-2
 53254 lneg EAX
 53256 mov EBX,EAX
// if (!filename)
 53258 cmp 0,EBX
 53261 jge 53269
 53264 mov EAX,0
 53267 leave 
 53268 ret 
__2261:
__2259:
 53269 rstack EAX,EBP:-2
// fs3_from_filepath arg #2 (float filepath)
 53273 push EAX
 53275 rstack EAX,EBP:2
// fs3_from_filepath arg #1 (float shell)
 53279 push EAX
 53281 mov ECX,2
// fs3_from_filepath(...)
 53284 call 51061
 53287 add ESP,2
 53290 sstack EBP:-3,EAX
 53294 rstack EAX,EBP:-2
// filepath_no_drive arg #1 (float filename)
 53298 push EAX
 53300 mov ECX,1
// filepath_no_drive(...)
 53303 call 44346
 53306 add ESP,1
// filename=filepath_no_drive(filename)
 53309 sstack EBP:-2,EAX
 53313 sstack EBP:-4,0
 53318 sstack EBP:-5,0
 53323 sstack EBP:-6,0
 53328 sstack EBP:-7,0
 53333 sstack EBP:-8,0
 53338 mov EAX,SS:EBP
 53341 add EAX,-8
// translate_fopen_mode arg #6 (float* newfile)
 53344 push EAX
 53346 mov EAX,SS:EBP
 53349 add EAX,-7
// translate_fopen_mode arg #5 (float* from)
 53352 push EAX
 53354 mov EAX,SS:EBP
 53357 add EAX,-6
// translate_fopen_mode arg #4 (float* keepdata)
 53360 push EAX
 53362 mov EAX,SS:EBP
 53365 add EAX,-4
// translate_fopen_mode arg #3 (float* write)
 53368 push EAX
 53370 mov EAX,SS:EBP
 53373 add EAX,-5
// translate_fopen_mode arg #2 (float* read)
 53376 push EAX
 53378 rstack EAX,EBP:4
// translate_fopen_mode arg #1 (char* mode)
 53382 push EAX
 53384 mov ECX,6
// translate_fopen_mode(...)
 53387 call 42702
 53390 add ESP,6
 53393 sstack EBP:-9,0
 53398 mov EAX,SS:EBP
 53401 add EAX,-9
// fs3_find_file arg #4 (float ret_backlink)
 53404 push EAX
 53406 rstack EAX,EBP:-8
// fs3_find_file arg #3 (float new_allowed)
 53410 push EAX
 53412 rstack EAX,EBP:-2
// fs3_find_file arg #2 (float filename)
 53416 push EAX
 53418 rstack EAX,EBP:-3
// fs3_find_file arg #1 (float fs3)
 53422 push EAX
 53424 mov ECX,4
// fs3_find_file(...)
 53427 call 49825
 53430 add ESP,4
 53433 sstack EBP:-10,EAX
__2263:
 53437 rstack EAX,EBP:-10
 53441 mov EBX,-1
 53444 sub EBX,EAX
 53446 fabs EBX,EBX
 53448 fsgn EBX,EBX
 53450 lneg EBX
// if (f_index==-1)
 53452 cmp 0,EBX
 53455 jge 53463
 53458 mov EAX,0
 53461 leave 
 53462 ret 
__2264:
__2262:
 53463 sstack EBP:-11,0
 53468 rstack EAX,EBP:-10
 53472 push EAX
 53474 rstack EAX,EBP:-3
 53478 push EAX
 53480 mov ECX,2
// fs3_FT_get_file(...)
 53483 call 54813
 53486 add ESP,2
 53489 sstack EBP:-13,EAX
__2266:
 53493 rstack EAX,EBP:-13
// if (res)
 53497 cmp 0,EAX
 53500 jge 53514
 53503 rstack EAX,EBP:-13
// fh=res
 53507 sstack EBP:-11,EAX
 53511 jmp 53668
__2268:
__2267:
__2270:
 53514 rstack EAX,EBP:-8
// fs3_open_file_index arg #3 (float new_allowed)
 53518 push EAX
 53520 rstack EAX,EBP:-10
// fs3_open_file_index arg #2 (float file_index)
 53524 push EAX
 53526 rstack EAX,EBP:-3
// fs3_open_file_index arg #1 (float fs3)
 53530 push EAX
 53532 mov ECX,3
// fs3_open_file_index(...)
 53535 call 49374
 53538 add ESP,3
// fh=fs3_open_file_index(fs3,f_index,newfile)
 53541 sstack EBP:-11,EAX
__2272:
 53545 rstack EAX,EBP:-11
 53549 lneg EAX
 53551 mov EBX,EAX
// if (!fh)
 53553 cmp 0,EBX
 53556 jge 53564
 53559 mov EAX,0
 53562 leave 
 53563 ret 
__2273:
__2271:
__2275:
 53564 rstack EAX,EBP:-9
// if (backlink)
 53568 cmp 0,EAX
 53571 jge 53604
 53574 rstack EAX,EBP:-3
// fs3_file_set_backlink arg #3 (float fs3)
 53578 push EAX
 53580 rstack EAX,EBP:-9
// fs3_file_set_backlink arg #2 (float backlink)
 53584 push EAX
 53586 rstack EAX,EBP:-11
// fs3_file_set_backlink arg #1 (float fh)
 53590 push EAX
 53592 mov ECX,3
// fs3_file_set_backlink(...)
 53595 call 51331
 53598 add ESP,3
 53601 jmp 53628
__2277:
__2276:
__2279:
__2281:
 53604 rstack EAX,EBP:-10
 53608 mov EBX,2
 53611 sub EBX,EAX
 53613 fabs EBX,EBX
 53615 fsgn EBX,EBX
// if (f_index!=2)
 53617 cmp 0,EBX
 53620 jge 53628
 53623 mov EAX,0
 53626 leave 
 53627 ret 
__2282:
__2280:
__2278:
__2274:
 53628 rstack EAX,EBP:-11
// file_handle_get_imp arg #1 (float this)
 53632 push EAX
 53634 mov ECX,1
// file_handle_get_imp(...)
 53637 call 42552
 53640 add ESP,1
 53643 sstack EBP:-14,EAX
 53647 rstack EAX,EBP:-2
// fs3_fh_set_filename arg #2 (float filename)
 53651 push EAX
 53653 rstack EAX,EBP:-14
// fs3_fh_set_filename arg #1 (float self)
 53657 push EAX
 53659 mov ECX,2
// fs3_fh_set_filename(...)
 53662 call 52304
 53665 add ESP,2
__2269:
__2265:
__2284:
 53668 rstack EAX,EBP:-7
// if (from)
 53672 cmp 0,EAX
 53675 jge 53706
// fseek arg #3 (float whence)
 53678 push 2
// fseek arg #2 (float offs)
 53681 push 0
 53684 rstack EAX,EBP:-11
// fseek arg #1 (float fp)
 53688 push EAX
 53690 mov ECX,3
// fseek(...)
 53693 call 52453
 53696 add ESP,3
// seekpos=fseek(fh,0,2)
 53699 sstack EBP:-12,EAX
 53703 jmp 53731
__2286:
__2285:
__2288:
// fseek arg #3 (float whence)
 53706 push 0
// fseek arg #2 (float offs)
 53709 push 0
 53712 rstack EAX,EBP:-11
// fseek arg #1 (float fp)
 53716 push EAX
 53718 mov ECX,3
// fseek(...)
 53721 call 52453
 53724 add ESP,3
// seekpos=fseek(fh,0,0)
 53727 sstack EBP:-12,EAX
__2287:
__2283:
 53731 rstack EAX,EBP:-11
 53735 leave 
 53736 ret 
__2257:
 53737 leave 
 53738 ret 
fclose:
// fclose(shell,fh)
 53739 enter -0
__2290:
 53742 rstack EAX,EBP:3
 53746 add EAX,0
 53749 mov EBX,EAX
// fh[0]=0
 53751 mov #EBX,0
 53754 mov EAX,1
 53757 leave 
 53758 ret 
__2289:
 53759 leave 
 53760 ret 
fs3_get_parent_dir:
// fs3_get_parent_dir(fs3,fh)
 53761 enter 3
__2292:
// assert_type arg #2 (float t)
 53764 push 42294
 53767 rstack EAX,EBP:3
// assert_type arg #1 (float self)
 53771 push EAX
 53773 mov ECX,2
// assert_type(...)
 53776 call 10123
 53779 add ESP,2
 53782 rstack EAX,EBP:3
// file_handle_get_imp arg #1 (float this)
 53786 push EAX
 53788 mov ECX,1
// file_handle_get_imp(...)
 53791 call 42552
 53794 add ESP,1
 53797 sstack EBP:-1,EAX
 53801 rstack EAX,EBP:-1
 53805 add EAX,9
 53808 mov EBX,EAX
 53810 sstack EBP:-2,#EBX
// fs3_open_or_lookup_file_index arg #3 (float new_allowed)
 53814 push 0
 53817 rstack EAX,EBP:-2
// fs3_open_or_lookup_file_index arg #2 (float file_index)
 53821 push EAX
 53823 rstack EAX,EBP:2
// fs3_open_or_lookup_file_index arg #1 (float fs3)
 53827 push EAX
 53829 mov ECX,3
// fs3_open_or_lookup_file_index(...)
 53832 call 49694
 53835 add ESP,3
 53838 sstack EBP:-3,EAX
 53842 rstack EAX,EBP:-3
 53846 leave 
 53847 ret 
__2291:
 53848 leave 
 53849 ret 
fs3_mkdir:
// fs3_mkdir(shell,filepath)
 53850 enter 12
__2294:
// fopen arg #3 (float mode)
 53853 push 43179
 53856 rstack EAX,EBP:3
// fopen arg #2 (float filepath)
 53860 push EAX
 53862 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 53866 push EAX
 53868 mov ECX,3
// fopen(...)
 53871 call 53191
 53874 add ESP,3
 53877 sstack EBP:-1,EAX
// assert_type arg #2 (float t)
 53881 push 37328
 53884 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 53888 push EAX
 53890 mov ECX,2
// assert_type(...)
 53893 call 10123
 53896 add ESP,2
 53899 rstack EAX,EBP:2
 53903 add EAX,100
 53906 mov EBX,EAX
 53908 sstack EBP:-2,EBX
 53912 rstack EAX,EBP:3
// filepath_abs arg #2 (char* filename)
 53916 push EAX
 53918 rstack EAX,EBP:-2
// filepath_abs arg #1 (float current_path)
 53922 push EAX
 53924 mov ECX,2
// filepath_abs(...)
 53927 call 43303
 53930 add ESP,2
 53933 sstack EBP:-3,EAX
 53937 rstack EAX,EBP:-3
// fs3_from_filepath arg #2 (float filepath)
 53941 push EAX
 53943 rstack EAX,EBP:2
// fs3_from_filepath arg #1 (float shell)
 53947 push EAX
 53949 mov ECX,2
// fs3_from_filepath(...)
 53952 call 51061
 53955 add ESP,2
 53958 sstack EBP:-4,EAX
// assert_type arg #2 (float t)
 53962 push 44420
 53965 rstack EAX,EBP:-4
// assert_type arg #1 (float self)
 53969 push EAX
 53971 mov ECX,2
// assert_type(...)
 53974 call 10123
 53977 add ESP,2
// malloc arg #1 (float n)
 53980 push 2
 53983 mov ECX,1
// malloc(...)
 53986 call 28486
 53989 add ESP,1
 53992 sstack EBP:-5,EAX
 53996 rstack EAX,EBP:-5
 54000 add EAX,0
 54003 mov EBX,EAX
// buff[0]=0
 54005 mov #EBX,0
 54008 rstack EAX,EBP:-5
 54012 add EAX,1
 54015 mov EBX,EAX
// buff[1]=0
 54017 mov #EBX,0
 54020 rstack EAX,EBP:-1
// fwrite arg #3 (float fp)
 54024 push EAX
// fwrite arg #2 (float size)
 54026 push 2
 54029 rstack EAX,EBP:-5
// fwrite arg #1 (float from)
 54033 push EAX
 54035 mov ECX,3
// fwrite(...)
 54038 call 52831
 54041 add ESP,3
 54044 rstack EAX,EBP:-1
// fs3_get_parent_dir arg #2 (float fh)
 54048 push EAX
 54050 rstack EAX,EBP:-4
// fs3_get_parent_dir arg #1 (float fs3)
 54054 push EAX
 54056 mov ECX,2
// fs3_get_parent_dir(...)
 54059 call 53761
 54062 add ESP,2
 54065 sstack EBP:-6,EAX
__2296:
 54069 rstack EAX,EBP:-6
 54073 lneg EAX
 54075 mov EBX,EAX
// if (!fh_dir)
 54077 cmp 0,EBX
 54080 jge 54100
// printf arg #1 (char* format)
 54083 push 54269
 54086 mov ECX,1
// printf(...)
 54089 call 21772
 54092 add ESP,1
 54095 mov EAX,0
 54098 leave 
 54099 ret 
__2297:
__2295:
 54100 rstack EAX,EBP:-1
// file_handle_get_imp arg #1 (float this)
 54104 push EAX
 54106 mov ECX,1
// file_handle_get_imp(...)
 54109 call 42552
 54112 add ESP,1
 54115 sstack EBP:-7,EAX
 54119 rstack EAX,EBP:-7
 54123 add EAX,4
 54126 mov EBX,EAX
 54128 sstack EBP:-8,#EBX
 54132 rstack EAX,EBP:-8
// fs3_dir_find_fidx arg #3 (float file_index)
 54136 push EAX
 54138 rstack EAX,EBP:-6
// fs3_dir_find_fidx arg #2 (float fh_dir)
 54142 push EAX
 54144 rstack EAX,EBP:-4
// fs3_dir_find_fidx arg #1 (float fs3)
 54148 push EAX
 54150 mov ECX,3
// fs3_dir_find_fidx(...)
 54153 call 49132
 54156 add ESP,3
 54159 sstack EBP:-9,EAX
 54163 rstack EAX,EBP:-9
// fs3_dir_get_entry_ptr arg #3 (float I)
 54167 push EAX
 54169 rstack EAX,EBP:-6
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 54173 push EAX
 54175 rstack EAX,EBP:-4
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 54179 push EAX
 54181 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 54184 call 47608
 54187 add ESP,3
 54190 sstack EBP:-10,EAX
 54194 rstack EAX,EBP:-10
 54198 add EAX,1
 54201 mov EBX,EAX
 54203 sstack EBP:-11,EBX
 54207 sstack EBP:-12,1
// fseek arg #3 (float whence)
 54212 push 0
 54215 rstack EAX,EBP:-11
// fseek arg #2 (float offs)
 54219 push EAX
 54221 rstack EAX,EBP:-6
// fseek arg #1 (float fp)
 54225 push EAX
 54227 mov ECX,3
// fseek(...)
 54230 call 52453
 54233 add ESP,3
 54236 rstack EAX,EBP:-6
// fwrite arg #3 (float fp)
 54240 push EAX
// fwrite arg #2 (float size)
 54242 push 1
 54245 mov EAX,SS:EBP
 54248 add EAX,-12
// fwrite arg #1 (float from)
 54251 push EAX
 54253 mov ECX,3
// fwrite(...)
 54256 call 52831
 54259 add ESP,3
 54262 mov EAX,1
 54265 leave 
 54266 ret 
__2293:
 54267 leave 
 54268 ret 
__2298:
 54269 db "no parent dir
",0
fs3_delFile:
// fs3_delFile(shell,filepath)
 54284 enter 7
__2300:
// printf arg #1 (char* format)
 54287 push 54605
 54290 mov ECX,1
// printf(...)
 54293 call 21772
 54296 add ESP,1
 54299 mov EAX,0
 54302 leave 
 54303 ret 
// assert_type arg #2 (float t)
 54304 push 37328
 54307 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 54311 push EAX
 54313 mov ECX,2
// assert_type(...)
 54316 call 10123
 54319 add ESP,2
 54322 rstack EAX,EBP:2
 54326 add EAX,3
 54329 mov EBX,EAX
 54331 sstack EBP:-1,#EBX
// assert_type arg #2 (float t)
 54335 push 44420
 54338 rstack EAX,EBP:-1
// assert_type arg #1 (float self)
 54342 push EAX
 54344 mov ECX,2
// assert_type(...)
 54347 call 10123
 54350 add ESP,2
// fopen arg #3 (float mode)
 54353 push 43179
 54356 rstack EAX,EBP:3
// fopen arg #2 (float filepath)
 54360 push EAX
 54362 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 54366 push EAX
 54368 mov ECX,3
// fopen(...)
 54371 call 53191
 54374 add ESP,3
 54377 sstack EBP:-2,EAX
__2303:
 54381 rstack EAX,EBP:-2
 54385 lneg EAX
 54387 mov EBX,EAX
// if (!fh)
 54389 cmp 0,EBX
 54392 jge 54400
 54395 mov EAX,-1
 54398 leave 
 54399 ret 
__2304:
__2302:
 54400 rstack EAX,EBP:-2
// print_file_handle arg #1 (float fh)
 54404 push EAX
 54406 mov ECX,1
// print_file_handle(...)
 54409 call 51722
 54412 add ESP,1
 54415 rstack EAX,EBP:-2
// file_handle_get_imp arg #1 (float this)
 54419 push EAX
 54421 mov ECX,1
// file_handle_get_imp(...)
 54424 call 42552
 54427 add ESP,1
 54430 sstack EBP:-3,EAX
// assert_type arg #2 (float t)
 54434 push 51527
 54437 rstack EAX,EBP:-3
// assert_type arg #1 (float self)
 54441 push EAX
 54443 mov ECX,2
// assert_type(...)
 54446 call 10123
 54449 add ESP,2
 54452 rstack EAX,EBP:-3
 54456 add EAX,5
 54459 mov EBX,EAX
 54461 sstack EBP:-4,#EBX
 54465 rstack EAX,EBP:-4
// fs3_erase_block_chain arg #2 (float block_id)
 54469 push EAX
 54471 rstack EAX,EBP:-1
// fs3_erase_block_chain arg #1 (float fs3)
 54475 push EAX
 54477 mov ECX,2
// fs3_erase_block_chain(...)
 54480 call 46318
 54483 add ESP,2
 54486 rstack EAX,EBP:-3
// fs3_fh_get_filename arg #1 (float self)
 54490 push EAX
 54492 mov ECX,1
// fs3_fh_get_filename(...)
 54495 call 52356
 54498 add ESP,1
 54501 sstack EBP:-5,EAX
 54505 rstack EAX,EBP:-5
// fs3_open_or_lookup_file_index arg #2 (float file_index)
 54509 push EAX
 54511 rstack EAX,EBP:-1
// fs3_open_or_lookup_file_index arg #1 (float fs3)
 54515 push EAX
 54517 mov ECX,2
// fs3_open_or_lookup_file_index(...)
 54520 call 49694
 54523 add ESP,2
 54526 sstack EBP:-6,EAX
 54530 rstack EAX,EBP:-6
// fs3_find_entry_in_folder arg #3 (float fh_dir)
 54534 push EAX
 54536 rstack EAX,EBP:-5
// fs3_find_entry_in_folder arg #2 (float filename)
 54540 push EAX
 54542 rstack EAX,EBP:-1
// fs3_find_entry_in_folder arg #1 (float fs3)
 54546 push EAX
 54548 mov ECX,3
// fs3_find_entry_in_folder(...)
 54551 call 50590
 54554 add ESP,3
 54557 sstack EBP:-7,EAX
 54561 rstack EAX,EBP:-7
// fs3_dir_erase_entry arg #3 (float entry_id)
 54565 push EAX
 54567 rstack EAX,EBP:-6
// fs3_dir_erase_entry arg #2 (float fh_dir)
 54571 push EAX
 54573 rstack EAX,EBP:-1
// fs3_dir_erase_entry arg #1 (float fs3)
 54577 push EAX
 54579 mov ECX,3
// fs3_dir_erase_entry(...)
 54582 call 47730
 54585 add ESP,3
 54588 rstack EAX,EBP:-2
// fclose arg #1 (float shell)
 54592 push EAX
 54594 mov ECX,1
// fclose(...)
 54597 call 53739
 54600 add ESP,1
__2299:
 54603 leave 
 54604 ret 
__2301:
 54605 db "delFile is WIP, do not use
",0
fs_marker7:
 54633 db 0
fs3_init_file_table:
// fs3_init_file_table(fs3)
 54634 enter 1
__2306:
// assert_type arg #2 (float t)
 54637 push 44420
 54640 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 54644 push EAX
 54646 mov ECX,2
// assert_type(...)
 54649 call 10123
 54652 add ESP,2
// malloc arg #1 (float n)
 54655 push #31358
 54658 mov ECX,1
// malloc(...)
 54661 call 28486
 54664 add ESP,1
 54667 sstack EBP:-1,EAX
// vector_constructor arg #2 (float element_size)
 54671 push 2
 54674 rstack EAX,EBP:-1
// vector_constructor arg #1 (void* self)
 54678 push EAX
 54680 mov ECX,2
// vector_constructor(...)
 54683 call 31359
 54686 add ESP,2
 54689 rstack EAX,EBP:-1
 54693 rstack EBX,EBP:2
 54697 add EBX,3
 54700 mov ECX,EBX
// fs3[3]=FT
 54702 mov #ECX,EAX
__2305:
 54704 leave 
 54705 ret 
fs3_add_file_to_FT:
// fs3_add_file_to_FT(fs3,file_index,file_handle)
 54706 enter 4
__2308:
// assert_type arg #2 (float t)
 54709 push 44420
 54712 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 54716 push EAX
 54718 mov ECX,2
// assert_type(...)
 54721 call 10123
 54724 add ESP,2
 54727 rstack EAX,EBP:2
 54731 add EAX,4
 54734 mov EBX,EAX
 54736 sstack EBP:-1,#EBX
__2310:
 54740 rstack EAX,EBP:-1
 54744 lneg EAX
 54746 mov EBX,EAX
// if (!cache_mode)
 54748 cmp 0,EBX
 54751 jge 54759
 54754 mov EAX,0
 54757 leave 
 54758 ret 
__2311:
__2309:
 54759 rstack EAX,EBP:2
 54763 add EAX,3
 54766 mov EBX,EAX
 54768 sstack EBP:-2,#EBX
 54772 rstack EAX,EBP:3
// entry[0]=file_index
 54776 sstack EBP:-4,EAX
 54780 rstack EAX,EBP:4
// entry[1]=file_handle
 54784 sstack EBP:-3,EAX
 54788 mov EAX,SS:EBP
 54791 add EAX,-4
// vector_push arg #2 (void* element)
 54794 push EAX
 54796 rstack EAX,EBP:-2
// vector_push arg #1 (void* self)
 54800 push EAX
 54802 mov ECX,2
// vector_push(...)
 54805 call 32078
 54808 add ESP,2
__2307:
 54811 leave 
 54812 ret 
fs3_FT_get_file:
// fs3_FT_get_file(fs3,file_index)
 54813 enter 6
__2313:
// assert_type arg #2 (float t)
 54816 push 44420
 54819 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 54823 push EAX
 54825 mov ECX,2
// assert_type(...)
 54828 call 10123
 54831 add ESP,2
 54834 rstack EAX,EBP:2
 54838 add EAX,4
 54841 mov EBX,EAX
 54843 sstack EBP:-1,#EBX
__2315:
 54847 rstack EAX,EBP:-1
 54851 lneg EAX
 54853 mov EBX,EAX
// if (!cache_mode)
 54855 cmp 0,EBX
 54858 jge 54866
 54861 mov EAX,0
 54864 leave 
 54865 ret 
__2316:
__2314:
 54866 rstack EAX,EBP:2
 54870 add EAX,3
 54873 mov EBX,EAX
 54875 sstack EBP:-2,#EBX
 54879 rstack EAX,EBP:-2
// vector_size arg #1 (void* self)
 54883 push EAX
 54885 mov ECX,1
// vector_size(...)
 54888 call 32667
 54891 add ESP,1
 54894 sstack EBP:-5,EAX
// init loop
 54898 sstack EBP:-6,0
__2318:
 54903 rstack EAX,EBP:-6
 54907 rstack EBX,EBP:-5
 54911 sub EBX,EAX
 54913 mov EAX,EBX
 54915 fsgn EAX,EAX
// condition
 54917 max EAX,0
 54920 cmp 0,EAX
 54923 jz 54998
 54926 rstack EAX,EBP:-6
// vector_get arg #3 (float pos)
 54930 push EAX
 54932 mov EAX,SS:EBP
 54935 add EAX,-4
// vector_get arg #2 (void* element)
 54938 push EAX
 54940 rstack EAX,EBP:-2
// vector_get arg #1 (void* self)
 54944 push EAX
 54946 mov ECX,3
// vector_get(...)
 54949 call 32750
 54952 add ESP,3
__2320:
 54955 rstack EAX,EBP:-4
 54959 rstack EBX,EBP:3
 54963 sub EBX,EAX
 54965 mov EAX,EBX
 54967 fabs EAX,EAX
 54969 fsgn EAX,EAX
 54971 lneg EAX
// if (entry[0]==file_index)
 54973 cmp 0,EAX
 54976 jge 54985
 54979 rstack EAX,EBP:-3
 54983 leave 
 54984 ret 
__2321:
__2319:
 54985 rstack EAX,EBP:-6
// loop step
 54989 inc EAX
 54991 sstack EBP:-6,EAX
 54995 jmp 54903
__2317:
 54998 mov EAX,0
 55001 leave 
 55002 ret 
__2312:
 55003 leave 
 55004 ret 
fs3_FT_erase_file:
// fs3_FT_erase_file(fs3,file_index,file_handle)
 55005 enter 6
__2323:
// assert_type arg #2 (float t)
 55008 push 44420
 55011 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 55015 push EAX
 55017 mov ECX,2
// assert_type(...)
 55020 call 10123
 55023 add ESP,2
 55026 rstack EAX,EBP:2
 55030 add EAX,4
 55033 mov EBX,EAX
 55035 sstack EBP:-1,#EBX
__2325:
 55039 rstack EAX,EBP:-1
 55043 lneg EAX
 55045 mov EBX,EAX
// if (!cache_mode)
 55047 cmp 0,EBX
 55050 jge 55058
 55053 mov EAX,0
 55056 leave 
 55057 ret 
__2326:
__2324:
 55058 rstack EAX,EBP:2
 55062 add EAX,3
 55065 mov EBX,EAX
 55067 sstack EBP:-2,#EBX
 55071 rstack EAX,EBP:-2
// vector_size arg #1 (void* self)
 55075 push EAX
 55077 mov ECX,1
// vector_size(...)
 55080 call 32667
 55083 add ESP,1
 55086 sstack EBP:-5,EAX
 55090 sstack EBP:-6,0
__2328:
 55095 rstack EAX,EBP:-6
 55099 rstack EBX,EBP:-5
 55103 sub EBX,EAX
 55105 mov EAX,EBX
 55107 fsgn EAX,EAX
 55109 max EAX,0
// if (I<size
 55112 cmp 0,EAX
 55115 jz 55271
 55118 rstack EAX,EBP:-6
// vector_get arg #3 (float pos)
 55122 push EAX
 55124 mov EAX,SS:EBP
 55127 add EAX,-4
// vector_get arg #2 (void* element)
 55130 push EAX
 55132 rstack EAX,EBP:-2
// vector_get arg #1 (void* self)
 55136 push EAX
 55138 mov ECX,3
// vector_get(...)
 55141 call 32750
 55144 add ESP,3
__2330:
 55147 rstack EAX,EBP:-4
 55151 rstack EBX,EBP:3
 55155 sub EBX,EAX
 55157 mov EAX,EBX
 55159 fabs EAX,EAX
 55161 fsgn EAX,EAX
 55163 rstack EBX,EBP:3
 55167 mov ECX,0
 55170 sub ECX,EBX
 55172 fabs ECX,ECX
 55174 fsgn ECX,ECX
 55176 and ECX,EAX
// if ((file_index!=0)&&(entry[0]!=file_index))
 55178 cmp 0,ECX
 55181 jge 55197
 55184 rstack EAX,EBP:-6
// I++
 55188 inc EAX
 55190 sstack EBP:-6,EAX
 55194 jmp 55095
__2331:
__2329:
__2333:
 55197 rstack EAX,EBP:-3
 55201 rstack EBX,EBP:4
 55205 sub EBX,EAX
 55207 mov EAX,EBX
 55209 fabs EAX,EAX
 55211 fsgn EAX,EAX
 55213 rstack EBX,EBP:4
 55217 mov ECX,0
 55220 sub ECX,EBX
 55222 fabs ECX,ECX
 55224 fsgn ECX,ECX
 55226 and ECX,EAX
// if ((file_handle!=0)&&(entry[1]!=file_handle))
 55228 cmp 0,ECX
 55231 jge 55247
 55234 rstack EAX,EBP:-6
// I++
 55238 inc EAX
 55240 sstack EBP:-6,EAX
 55244 jmp 55095
__2334:
__2332:
 55247 rstack EAX,EBP:-6
// vector_remove arg #2 (float pos)
 55251 push EAX
 55253 rstack EAX,EBP:-2
// vector_remove arg #1 (void* self)
 55257 push EAX
 55259 mov ECX,2
// vector_remove(...)
 55262 call 33787
 55265 add ESP,2
 55268 jmp 55095
__2327:
__2322:
 55271 leave 
 55272 ret 
fs3_backlink_write_size:
// fs3_backlink_write_size(fs3,backlink,file_index,size)
 55273 enter 4
__2336:
// assert_type arg #2 (float t)
 55276 push 44420
 55279 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 55283 push EAX
 55285 mov ECX,2
// assert_type(...)
 55288 call 10123
 55291 add ESP,2
// fs3_open_or_lookup_file_index arg #3 (float new_allowed)
 55294 push 0
 55297 rstack EAX,EBP:3
// fs3_open_or_lookup_file_index arg #2 (float file_index)
 55301 push EAX
 55303 rstack EAX,EBP:2
// fs3_open_or_lookup_file_index arg #1 (float fs3)
 55307 push EAX
 55309 mov ECX,3
// fs3_open_or_lookup_file_index(...)
 55312 call 49694
 55315 add ESP,3
 55318 sstack EBP:-1,EAX
 55322 rstack EAX,EBP:4
// fs3_dir_find_fidx arg #3 (float file_index)
 55326 push EAX
 55328 rstack EAX,EBP:-1
// fs3_dir_find_fidx arg #2 (float fh_dir)
 55332 push EAX
 55334 rstack EAX,EBP:2
// fs3_dir_find_fidx arg #1 (float fs3)
 55338 push EAX
 55340 mov ECX,3
// fs3_dir_find_fidx(...)
 55343 call 49132
 55346 add ESP,3
 55349 sstack EBP:-2,EAX
__2338:
 55353 rstack EAX,EBP:-2
 55357 mov EBX,-1
 55360 sub EBX,EAX
 55362 fabs EBX,EBX
 55364 fsgn EBX,EBX
// if (entry_idx!=-1)
 55366 cmp 0,EBX
 55369 jge 55469
 55372 rstack EAX,EBP:-2
// fs3_dir_get_entry_ptr arg #3 (float I)
 55376 push EAX
 55378 rstack EAX,EBP:-1
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 55382 push EAX
 55384 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 55388 push EAX
 55390 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 55393 call 47608
 55396 add ESP,3
 55399 sstack EBP:-3,EAX
 55403 rstack EAX,EBP:-3
 55407 add EAX,2
 55410 mov EBX,EAX
 55412 sstack EBP:-4,EBX
// fseek arg #3 (float whence)
 55416 push 0
 55419 rstack EAX,EBP:-4
// fseek arg #2 (float offs)
 55423 push EAX
 55425 rstack EAX,EBP:-1
// fseek arg #1 (float fp)
 55429 push EAX
 55431 mov ECX,3
// fseek(...)
 55434 call 52453
 55437 add ESP,3
 55440 rstack EAX,EBP:-1
// fwrite arg #3 (float fp)
 55444 push EAX
// fwrite arg #2 (float size)
 55446 push 1
 55449 mov EAX,SS:EBP
 55452 add EAX,5
// fwrite arg #1 (float from)
 55455 push EAX
 55457 mov ECX,3
// fwrite(...)
 55460 call 52831
 55463 add ESP,3
 55466 jmp 55487
__2340:
__2339:
__2342:
 55469 rstack EAX,EBP:4
// printf arg #2 (unknown)
 55473 push EAX
// printf arg #1 (char* format)
 55475 push 55489
 55478 mov ECX,2
// printf(...)
 55481 call 21772
 55484 add ESP,2
__2341:
__2337:
__2335:
 55487 leave 
 55488 ret 
__2343:
 55489 db "backlink_ws: no entry for index %d
",0
fs3_backlink_read_size:
// fs3_backlink_read_size(fs3,backlink,file_index)
 55525 enter 5
__2345:
// assert_type arg #2 (float t)
 55528 push 44420
 55531 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 55535 push EAX
 55537 mov ECX,2
// assert_type(...)
 55540 call 10123
 55543 add ESP,2
// fs3_open_or_lookup_file_index arg #3 (float new_allowed)
 55546 push 0
 55549 rstack EAX,EBP:3
// fs3_open_or_lookup_file_index arg #2 (float file_index)
 55553 push EAX
 55555 rstack EAX,EBP:2
// fs3_open_or_lookup_file_index arg #1 (float fs3)
 55559 push EAX
 55561 mov ECX,3
// fs3_open_or_lookup_file_index(...)
 55564 call 49694
 55567 add ESP,3
 55570 sstack EBP:-2,EAX
 55574 rstack EAX,EBP:4
// fs3_dir_find_fidx arg #3 (float file_index)
 55578 push EAX
 55580 rstack EAX,EBP:-2
// fs3_dir_find_fidx arg #2 (float fh_dir)
 55584 push EAX
 55586 rstack EAX,EBP:2
// fs3_dir_find_fidx arg #1 (float fs3)
 55590 push EAX
 55592 mov ECX,3
// fs3_dir_find_fidx(...)
 55595 call 49132
 55598 add ESP,3
 55601 sstack EBP:-3,EAX
__2347:
 55605 rstack EAX,EBP:-3
 55609 mov EBX,-1
 55612 sub EBX,EAX
 55614 fabs EBX,EBX
 55616 fsgn EBX,EBX
// if (entry_idx!=-1)
 55618 cmp 0,EBX
 55621 jge 55718
 55624 rstack EAX,EBP:-3
// fs3_dir_get_entry_ptr arg #3 (float I)
 55628 push EAX
 55630 rstack EAX,EBP:-2
// fs3_dir_get_entry_ptr arg #2 (float fh_dir)
 55634 push EAX
 55636 rstack EAX,EBP:2
// fs3_dir_get_entry_ptr arg #1 (float fs3)
 55640 push EAX
 55642 mov ECX,3
// fs3_dir_get_entry_ptr(...)
 55645 call 47608
 55648 add ESP,3
 55651 sstack EBP:-4,EAX
 55655 rstack EAX,EBP:-4
 55659 add EAX,2
 55662 mov EBX,EAX
 55664 sstack EBP:-5,EBX
// fseek arg #3 (float whence)
 55668 push 0
 55671 rstack EAX,EBP:-5
// fseek arg #2 (float offs)
 55675 push EAX
 55677 rstack EAX,EBP:-2
// fseek arg #1 (float fp)
 55681 push EAX
 55683 mov ECX,3
// fseek(...)
 55686 call 52453
 55689 add ESP,3
 55692 rstack EAX,EBP:-2
// fread arg #3 (float fp)
 55696 push EAX
// fread arg #2 (float size)
 55698 push 1
 55701 mov EAX,SS:EBP
 55704 add EAX,-1
// fread arg #1 (float to)
 55707 push EAX
 55709 mov ECX,3
// fread(...)
 55712 call 52657
 55715 add ESP,3
__2348:
__2346:
 55718 rstack EAX,EBP:-1
 55722 leave 
 55723 ret 
__2344:
 55724 leave 
 55725 ret 
fs_marker8:
 55726 db 0
cmdMount:
// cmdMount(shell,argc,argv)
 55727 enter 7
__2350:
// assert_type arg #2 (float t)
 55730 push 37328
 55733 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 55737 push EAX
 55739 mov ECX,2
// assert_type(...)
 55742 call 10123
 55745 add ESP,2
__2352:
 55748 rstack EAX,EBP:3
 55752 mov EBX,2
 55755 sub EBX,EAX
 55757 neg EBX
 55759 fsgn EBX,EBX
 55761 max EBX,0
// if (argc>2)
 55764 cmp 0,EBX
 55767 jge 55977
 55770 rstack EAX,EBP:4
 55774 add EAX,1
 55777 mov EBX,EAX
// str2num arg #1 (char* str)
 55779 push #EBX
 55781 mov ECX,1
// str2num(...)
 55784 call 12270
 55787 add ESP,1
 55790 sstack EBP:-1,EAX
 55794 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 55798 push EAX
// EBcb_get_entry arg #1 (float this)
 55800 push 66989
 55803 mov ECX,2
// EBcb_get_entry(...)
 55806 call 19801
 55809 add ESP,2
 55812 sstack EBP:-2,EAX
 55816 rstack EAX,EBP:-2
// EBcb_entry_get_type arg #1 (float this)
 55820 push EAX
 55822 mov ECX,1
// EBcb_entry_get_type(...)
 55825 call 19621
 55828 add ESP,1
 55831 sstack EBP:-3,EAX
 55835 rstack EAX,EBP:-3
// udhTypeToString arg #1 (float type)
 55839 push EAX
 55841 mov ECX,1
// udhTypeToString(...)
 55844 call 18978
 55847 add ESP,1
 55850 sstack EBP:-4,EAX
 55854 rstack EAX,EBP:-2
// EBcb_entry_get_addr arg #1 (float this)
 55858 push EAX
 55860 mov ECX,1
// EBcb_entry_get_addr(...)
 55863 call 19657
 55866 add ESP,1
 55869 sstack EBP:-5,EAX
 55873 rstack EAX,EBP:4
 55877 add EAX,2
 55880 mov EBX,EAX
 55882 sstack EBP:-6,#EBX
 55886 rstack EAX,EBP:-6
// printf arg #4 (unknown)
 55890 push EAX
 55892 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 55896 push EAX
 55898 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 55902 push EAX
// printf arg #1 (char* format)
 55904 push 56005
 55907 mov ECX,4
// printf(...)
 55910 call 21772
 55913 add ESP,4
 55916 mov ECX,0
// init_fs3(...)
 55919 call 44428
 55922 sstack EBP:-7,EAX
 55926 rstack EAX,EBP:-5
// fs3_load_fs_descriptor arg #2 (float devAdr)
 55930 push EAX
 55932 rstack EAX,EBP:-7
// fs3_load_fs_descriptor arg #1 (float fs3)
 55936 push EAX
 55938 mov ECX,2
// fs3_load_fs_descriptor(...)
 55941 call 44851
 55944 add ESP,2
 55947 rstack EAX,EBP:-6
// shell2_associate_fs3_with_letter arg #3 (float letter)
 55951 push EAX
 55953 rstack EAX,EBP:-7
// shell2_associate_fs3_with_letter arg #2 (float fs3)
 55957 push EAX
 55959 rstack EAX,EBP:2
// shell2_associate_fs3_with_letter arg #1 (float self)
 55963 push EAX
 55965 mov ECX,3
// shell2_associate_fs3_with_letter(...)
 55968 call 40054
 55971 add ESP,3
 55974 jmp 56003
__2355:
__2353:
__2357:
 55977 rstack EAX,EBP:4
 55981 add EAX,0
 55984 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 55986 push #EBX
 55988 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 55992 push EAX
 55994 mov ECX,2
// cmdHelp2(...)
 55997 call 40759
 56000 add ESP,2
__2356:
__2351:
__2349:
 56003 leave 
 56004 ret 
__2354:
 56005 db "mounting device %d
(%s) as %s:/
",0
cmdCD:
// cmdCD(shell,argc,argv)
 56038 enter 5
__2359:
// assert_type arg #2 (float t)
 56041 push 37328
 56044 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 56048 push EAX
 56050 mov ECX,2
// assert_type(...)
 56053 call 10123
 56056 add ESP,2
// malloc arg #1 (float n)
 56059 push 10
 56062 mov ECX,1
// malloc(...)
 56065 call 28486
 56068 add ESP,1
 56071 sstack EBP:-1,EAX
// malloc arg #1 (float n)
 56075 push 10
 56078 mov ECX,1
// malloc(...)
 56081 call 28486
 56084 add ESP,1
 56087 sstack EBP:-2,EAX
// malloc arg #1 (float n)
 56091 push 80
 56094 mov ECX,1
// malloc(...)
 56097 call 28486
 56100 add ESP,1
 56103 sstack EBP:-3,EAX
 56107 rstack EAX,EBP:2
 56111 add EAX,100
 56114 mov EBX,EAX
 56116 sstack EBP:-4,EBX
 56120 rstack EAX,EBP:4
 56124 add EAX,1
 56127 mov EBX,EAX
 56129 sstack EBP:-5,#EBX
__2361:
 56133 rstack EAX,EBP:3
 56137 mov EBX,1
 56140 sub EBX,EAX
 56142 neg EBX
 56144 fsgn EBX,EBX
 56146 max EBX,0
// if (argc>1)
 56149 cmp 0,EBX
 56152 jge 56407
__2364:
 56155 rstack EAX,EBP:-2
// filepath_drive arg #2 (float driveletter)
 56159 push EAX
 56161 rstack EAX,EBP:-5
// filepath_drive arg #1 (float filename)
 56165 push EAX
 56167 mov ECX,2
// filepath_drive(...)
 56170 call 44178
 56173 add ESP,2
// if (filepath_drive(str_arg,new_drivepath))
 56176 cmp 0,EAX
 56179 jge 56350
 56182 rstack EAX,EBP:-1
 56186 add EAX,0
 56189 mov EBX,EAX
// old_drivepath[0]=0
 56191 mov #EBX,0
 56194 rstack EAX,EBP:-1
// filepath_drive arg #2 (float driveletter)
 56198 push EAX
 56200 rstack EAX,EBP:-4
// filepath_drive arg #1 (float filename)
 56204 push EAX
 56206 mov ECX,2
// filepath_drive(...)
 56209 call 44178
 56212 add ESP,2
__2367:
 56215 rstack EAX,EBP:-2
// strcmp arg #2 (char* dest)
 56219 push EAX
 56221 rstack EAX,EBP:-1
// strcmp arg #1 (char* src)
 56225 push EAX
 56227 mov ECX,2
// strcmp(...)
 56230 call 10763
 56233 add ESP,2
 56236 mov EBX,0
 56239 sub EBX,EAX
 56241 fabs EBX,EBX
 56243 fsgn EBX,EBX
// if (strcmp(old_drivepath,new_drivepath)!=0)
 56245 cmp 0,EBX
 56248 jge 56326
__2370:
 56251 rstack EAX,EBP:-2
// shell2_set_fs_by_drive_letter arg #2 (float letter)
 56255 push EAX
 56257 rstack EAX,EBP:2
// shell2_set_fs_by_drive_letter arg #1 (float self)
 56261 push EAX
 56263 mov ECX,2
// shell2_set_fs_by_drive_letter(...)
 56266 call 40158
 56269 add ESP,2
// if (shell2_set_fs_by_drive_letter(shell,new_drivepath))
 56272 cmp 0,EAX
 56275 jge 56302
 56278 rstack EAX,EBP:-5
// shell2_set_cd arg #2 (float dir)
 56282 push EAX
 56284 rstack EAX,EBP:2
// shell2_set_cd arg #1 (float self)
 56288 push EAX
 56290 mov ECX,2
// shell2_set_cd(...)
 56293 call 40417
 56296 add ESP,2
 56299 jmp 56323
__2372:
__2371:
__2374:
 56302 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 56306 push EAX
// printf arg #1 (char* format)
 56308 push 56480
 56311 mov ECX,2
// printf(...)
 56314 call 21772
 56317 add ESP,2
 56320 jmp 56433
__2373:
__2369:
 56323 jmp 56347
__2376:
__2368:
__2378:
 56326 rstack EAX,EBP:-5
// shell2_set_cd arg #2 (float dir)
 56330 push EAX
 56332 rstack EAX,EBP:2
// shell2_set_cd arg #1 (float self)
 56336 push EAX
 56338 mov ECX,2
// shell2_set_cd(...)
 56341 call 40417
 56344 add ESP,2
__2377:
__2366:
 56347 jmp 56404
__2379:
__2365:
__2381:
 56350 rstack EAX,EBP:-5
// snprintf arg #5 (unknown)
 56354 push EAX
 56356 rstack EAX,EBP:-4
// snprintf arg #4 (unknown)
 56360 push EAX
// snprintf arg #3 (float format)
 56362 push 56511
// snprintf arg #2 (float n)
 56365 push 80
 56368 rstack EAX,EBP:-3
// snprintf arg #1 (float buff)
 56372 push EAX
 56374 mov ECX,5
// snprintf(...)
 56377 call 23922
 56380 add ESP,5
 56383 rstack EAX,EBP:-3
// shell2_set_cd arg #2 (float dir)
 56387 push EAX
 56389 rstack EAX,EBP:2
// shell2_set_cd arg #1 (float self)
 56393 push EAX
 56395 mov ECX,2
// shell2_set_cd(...)
 56398 call 40417
 56401 add ESP,2
__2380:
__2363:
 56404 jmp 56433
__2383:
__2362:
__2385:
 56407 rstack EAX,EBP:4
 56411 add EAX,0
 56414 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 56416 push #EBX
 56418 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 56422 push EAX
 56424 mov ECX,2
// cmdHelp2(...)
 56427 call 40759
 56430 add ESP,2
__2384:
__2360:
cmdCD_end:
 56433 rstack EAX,EBP:-1
// free arg #1 (float* ptr)
 56437 push EAX
 56439 mov ECX,1
// free(...)
 56442 call 28980
 56445 add ESP,1
 56448 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 56452 push EAX
 56454 mov ECX,1
// free(...)
 56457 call 28980
 56460 add ESP,1
 56463 rstack EAX,EBP:-3
// free arg #1 (float* ptr)
 56467 push EAX
 56469 mov ECX,1
// free(...)
 56472 call 28980
 56475 add ESP,1
__2358:
 56478 leave 
 56479 ret 
__2375:
 56480 db "drive %s not mounted (no fs)!
",0
__2382:
 56511 db "%s%s/",0
cmdFormat:
// cmdFormat(shell,argc,argv)
 56517 enter 8
__2387:
// assert_type arg #2 (float t)
 56520 push 37328
 56523 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 56527 push EAX
 56529 mov ECX,2
// assert_type(...)
 56532 call 10123
 56535 add ESP,2
__2389:
 56538 rstack EAX,EBP:3
 56542 mov EBX,1
 56545 sub EBX,EAX
 56547 neg EBX
 56549 fsgn EBX,EBX
 56551 max EBX,0
// if (argc>1)
 56554 cmp 0,EBX
 56557 jge 56799
 56560 rstack EAX,EBP:4
 56564 add EAX,1
 56567 mov EBX,EAX
// str2num arg #1 (char* str)
 56569 push #EBX
 56571 mov ECX,1
// str2num(...)
 56574 call 12270
 56577 add ESP,1
 56580 sstack EBP:-1,EAX
 56584 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 56588 push EAX
// EBcb_get_entry arg #1 (float this)
 56590 push 66989
 56593 mov ECX,2
// EBcb_get_entry(...)
 56596 call 19801
 56599 add ESP,2
 56602 sstack EBP:-2,EAX
 56606 rstack EAX,EBP:-2
// EBcb_entry_get_type arg #1 (float this)
 56610 push EAX
 56612 mov ECX,1
// EBcb_entry_get_type(...)
 56615 call 19621
 56618 add ESP,1
 56621 sstack EBP:-3,EAX
 56625 rstack EAX,EBP:-3
// udhTypeToString arg #1 (float type)
 56629 push EAX
 56631 mov ECX,1
// udhTypeToString(...)
 56634 call 18978
 56637 add ESP,1
 56640 sstack EBP:-4,EAX
 56644 rstack EAX,EBP:-2
// EBcb_entry_get_addr arg #1 (float this)
 56648 push EAX
 56650 mov ECX,1
// EBcb_entry_get_addr(...)
 56653 call 19657
 56656 add ESP,1
 56659 sstack EBP:-5,EAX
 56663 rstack EAX,EBP:-2
// EBcb_entry_get_size arg #1 (float this)
 56667 push EAX
 56669 mov ECX,1
// EBcb_entry_get_size(...)
 56672 call 19639
 56675 add ESP,1
 56678 sstack EBP:-6,EAX
 56682 sstack EBP:-7,300
 56687 rstack EAX,EBP:-5
// printf arg #4 (unknown)
 56691 push EAX
 56693 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 56697 push EAX
 56699 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 56703 push EAX
// printf arg #1 (char* format)
 56705 push 56862
 56708 mov ECX,4
// printf(...)
 56711 call 21772
 56714 add ESP,4
 56717 rstack EAX,EBP:-6
// printf arg #2 (unknown)
 56721 push EAX
// printf arg #1 (char* format)
 56723 push 56827
 56726 mov ECX,2
// printf(...)
 56729 call 21772
 56732 add ESP,2
 56735 rstack EAX,EBP:-7
// printf arg #2 (unknown)
 56739 push EAX
// printf arg #1 (char* format)
 56741 push 56845
 56744 mov ECX,2
// printf(...)
 56747 call 21772
 56750 add ESP,2
 56753 mov ECX,0
// init_fs3(...)
 56756 call 44428
 56759 sstack EBP:-8,EAX
 56763 rstack EAX,EBP:-7
// fs3_disk_format arg #4 (float block_size)
 56767 push EAX
 56769 rstack EAX,EBP:-6
// fs3_disk_format arg #3 (float disk_size)
 56773 push EAX
 56775 rstack EAX,EBP:-5
// fs3_disk_format arg #2 (float disk_addr)
 56779 push EAX
 56781 rstack EAX,EBP:-8
// fs3_disk_format arg #1 (float fs3)
 56785 push EAX
 56787 mov ECX,4
// fs3_disk_format(...)
 56790 call 44539
 56793 add ESP,4
 56796 jmp 56825
__2394:
__2390:
__2396:
 56799 rstack EAX,EBP:4
 56803 add EAX,0
 56806 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 56808 push #EBX
 56810 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 56814 push EAX
 56816 mov ECX,2
// cmdHelp2(...)
 56819 call 40759
 56822 add ESP,2
__2395:
__2388:
__2386:
 56825 leave 
 56826 ret 
__2392:
 56827 db "device size = %d
",0
__2393:
 56845 db "block size = %d
",0
__2391:
 56862 db "formatting device %d
(%s) @ %d
as lightfs3
",0
cmdDir:
// cmdDir(shell,argc,argv)
 56906 enter 16
__2398:
// assert_type arg #2 (float t)
 56909 push 37328
 56912 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 56916 push EAX
 56918 mov ECX,2
// assert_type(...)
 56921 call 10123
 56924 add ESP,2
 56927 rstack EAX,EBP:2
 56931 add EAX,3
 56934 mov EBX,EAX
 56936 sstack EBP:-1,#EBX
__2400:
 56940 rstack EAX,EBP:-1
 56944 lneg EAX
 56946 mov EBX,EAX
// if (!fs3)
 56948 cmp 0,EBX
 56951 jge 56968
// printf arg #1 (char* format)
 56954 push 57847
 56957 mov ECX,1
// printf(...)
 56960 call 21772
 56963 add ESP,1
 56966 leave 
 56967 ret 
__2401:
__2399:
// malloc arg #1 (float n)
 56968 push 32
 56971 mov ECX,1
// malloc(...)
 56974 call 28486
 56977 add ESP,1
 56980 sstack EBP:-2,EAX
 56984 rstack EAX,EBP:2
 56988 add EAX,100
 56991 mov EBX,EAX
 56993 sstack EBP:-3,EBX
// fopen arg #3 (float mode)
 56997 push 43181
 57000 rstack EAX,EBP:-3
// fopen arg #2 (float filepath)
 57004 push EAX
 57006 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 57010 push EAX
 57012 mov ECX,3
// fopen(...)
 57015 call 53191
 57018 add ESP,3
 57021 sstack EBP:-4,EAX
__2404:
 57025 rstack EAX,EBP:-4
// if (fh_dir)
 57029 cmp 0,EAX
 57032 jge 57038
 57035 jmp 57055
__2406:
__2405:
__2408:
// printf arg #2 (unknown)
 57038 push 990
// printf arg #1 (char* format)
 57041 push 57811
 57044 mov ECX,2
// printf(...)
 57047 call 21772
 57050 add ESP,2
 57053 leave 
 57054 ret 
__2407:
__2403:
 57055 sstack EBP:-5,0
// malloc arg #1 (float n)
 57060 push 200
 57063 mov ECX,1
// malloc(...)
 57066 call 28486
 57069 add ESP,1
 57072 sstack EBP:-6,EAX
// malloc arg #1 (float n)
 57076 push 10
 57079 mov ECX,1
// malloc(...)
 57082 call 28486
 57085 add ESP,1
 57088 sstack EBP:-7,EAX
// malloc arg #1 (float n)
 57092 push 10
 57095 mov ECX,1
// malloc(...)
 57098 call 28486
 57101 add ESP,1
 57104 sstack EBP:-8,EAX
// malloc arg #1 (float n)
 57108 push #46699
 57111 mov ECX,1
// malloc(...)
 57114 call 28486
 57117 add ESP,1
 57120 sstack EBP:-9,EAX
 57124 sstack EBP:-10,0
__2411:
// if (1
 57129 cmp 0,1
 57133 jz 57409
 57136 rstack EAX,EBP:-2
// fs3_dir_get_filename arg #4 (float res_str)
 57140 push EAX
 57142 rstack EAX,EBP:-5
// fs3_dir_get_filename arg #3 (float I)
 57146 push EAX
 57148 rstack EAX,EBP:-4
// fs3_dir_get_filename arg #2 (float fh_dir)
 57152 push EAX
 57154 rstack EAX,EBP:-1
// fs3_dir_get_filename arg #1 (float fs3)
 57158 push EAX
 57160 mov ECX,4
// fs3_dir_get_filename(...)
 57163 call 48149
 57166 add ESP,4
 57169 sstack EBP:-14,EAX
__2413:
 57173 rstack EAX,EBP:-14
// if (res)
 57177 cmp 0,EAX
 57180 jge 57403
 57183 rstack EAX,EBP:-10
 57187 mul EAX,20
 57190 mov EBX,EAX
 57192 rstack EAX,EBP:-6
 57196 add EAX,EBX
 57198 mov EBX,EAX
// p_filename=filenames+num_files*20
 57200 sstack EBP:-11,EBX
// memcpy arg #3 (float n)
 57204 push 20
 57207 rstack EAX,EBP:-2
// memcpy arg #2 (void* src)
 57211 push EAX
 57213 rstack EAX,EBP:-11
// memcpy arg #1 (void* dest)
 57217 push EAX
 57219 mov ECX,3
// memcpy(...)
 57222 call 10355
 57225 add ESP,3
 57228 rstack EAX,EBP:-11
 57232 add EAX,20
 57235 mov EBX,EAX
// p_filename[20]=0
 57237 mov #EBX,0
 57240 rstack EAX,EBP:-5
// fs3_dir_get_filesize arg #3 (float I)
 57244 push EAX
 57246 rstack EAX,EBP:-4
// fs3_dir_get_filesize arg #2 (float fh_dir)
 57250 push EAX
 57252 rstack EAX,EBP:-1
// fs3_dir_get_filesize arg #1 (float fs3)
 57256 push EAX
 57258 mov ECX,3
// fs3_dir_get_filesize(...)
 57261 call 48960
 57264 add ESP,3
// f_size=fs3_dir_get_filesize(fs3,fh_dir,I)
 57267 sstack EBP:-12,EAX
 57271 rstack EAX,EBP:-9
// fs3_dir_read_entry arg #4 (float buff)
 57275 push EAX
 57277 rstack EAX,EBP:-5
// fs3_dir_read_entry arg #3 (float I)
 57281 push EAX
 57283 rstack EAX,EBP:-4
// fs3_dir_read_entry arg #2 (float fh_dir)
 57287 push EAX
 57289 rstack EAX,EBP:-1
// fs3_dir_read_entry arg #1 (float fs3)
 57293 push EAX
 57295 mov ECX,4
// fs3_dir_read_entry(...)
 57298 call 47365
 57301 add ESP,4
 57304 rstack EAX,EBP:-9
 57308 add EAX,1
 57311 mov EBX,EAX
 57313 sstack EBP:-15,#EBX
 57317 rstack EAX,EBP:-15
 57321 rstack EBX,EBP:-10
 57325 rstack ECX,EBP:-8
 57329 add ECX,EBX
 57331 mov EBX,ECX
// filetypes[num_files]=type
 57333 mov #EBX,EAX
 57335 rstack EAX,EBP:-12
 57339 rstack EBX,EBP:-10
 57343 rstack ECX,EBP:-7
 57347 add ECX,EBX
 57349 mov EBX,ECX
// filesizes[num_files]=f_size
 57351 mov #EBX,EAX
 57353 rstack EAX,EBP:-10
// num_files++
 57357 inc EAX
 57359 sstack EBP:-10,EAX
__2416:
 57363 rstack EAX,EBP:-10
 57367 mov EBX,10
 57370 sub EBX,EAX
 57372 neg EBX
 57374 fsgn EBX,EBX
 57376 inc EBX
 57378 max EBX,0
// if (num_files>=10)
 57381 cmp 0,EBX
 57384 jge 57390
 57387 jmp 57409
__2417:
__2415:
 57390 rstack EAX,EBP:-5
// I++
 57394 inc EAX
 57396 sstack EBP:-5,EAX
 57400 jmp 57406
__2418:
__2414:
__2420:
 57403 jmp 57409
__2419:
__2412:
 57406 jmp 57129
__2410:
cmdDirDerp:
__2422:
 57409 rstack EAX,EBP:-5
 57413 mov EBX,0
 57416 sub EBX,EAX
 57418 fabs EBX,EBX
 57420 fsgn EBX,EBX
 57422 lneg EBX
// if (I==0)
 57424 cmp 0,EBX
 57427 jge 57454
 57430 rstack EAX,EBP:-3
// printf arg #3 (unknown)
 57434 push EAX
// printf arg #2 (unknown)
 57436 push 880
// printf arg #1 (char* format)
 57439 push 57737
 57442 mov ECX,3
// printf(...)
 57445 call 21772
 57448 add ESP,3
 57451 jmp 57690
__2425:
__2423:
__2427:
// printf arg #2 (unknown)
 57454 push 90
// printf arg #1 (char* format)
 57457 push 57908
 57460 mov ECX,2
// printf(...)
 57463 call 21772
 57466 add ESP,2
 57469 rstack EAX,EBP:-3
// printf arg #4 (unknown)
 57473 push EAX
 57475 rstack EAX,EBP:-10
// printf arg #3 (unknown)
 57479 push EAX
// printf arg #2 (unknown)
 57481 push 90
// printf arg #1 (char* format)
 57484 push 57878
 57487 mov ECX,4
// printf(...)
 57490 call 21772
 57493 add ESP,4
// printf arg #2 (unknown)
 57496 push 90
// printf arg #1 (char* format)
 57499 push 57832
 57502 mov ECX,2
// printf(...)
 57505 call 21772
 57508 add ESP,2
// init loop
 57511 sstack EBP:-5,0
__2432:
 57516 rstack EAX,EBP:-5
 57520 rstack EBX,EBP:-10
 57524 sub EBX,EAX
 57526 mov EAX,EBX
 57528 fsgn EAX,EAX
// condition
 57530 max EAX,0
 57533 cmp 0,EAX
 57536 jz 57675
 57539 rstack EAX,EBP:-5
 57543 mul EAX,20
 57546 mov EBX,EAX
 57548 rstack EAX,EBP:-6
 57552 add EAX,EBX
 57554 mov EBX,EAX
// p_filename=filenames+I*20
 57556 sstack EBP:-11,EBX
 57560 rstack EAX,EBP:-5
 57564 rstack EBX,EBP:-7
 57568 add EBX,EAX
 57570 mov EAX,EBX
// f_size=filesizes[I]
 57572 sstack EBP:-12,#EAX
 57576 sstack EBP:-16,90
 57581 rstack EAX,EBP:-5
 57585 rstack EBX,EBP:-8
 57589 add EBX,EAX
 57591 mov EAX,EBX
// f_type=filetypes[I]
 57593 sstack EBP:-13,#EAX
__2434:
 57597 rstack EAX,EBP:-13
 57601 mov EBX,1
 57604 sub EBX,EAX
 57606 fabs EBX,EBX
 57608 fsgn EBX,EBX
 57610 lneg EBX
// if (f_type==1)
 57612 cmp 0,EBX
 57615 jge 57623
// typecol=990
 57618 sstack EBP:-16,990
__2435:
__2433:
 57623 rstack EAX,EBP:-11
// printf arg #6 (unknown)
 57627 push EAX
 57629 rstack EAX,EBP:-16
// printf arg #5 (unknown)
 57633 push EAX
 57635 rstack EAX,EBP:-12
// printf arg #4 (unknown)
 57639 push EAX
 57641 rstack EAX,EBP:-5
// printf arg #3 (unknown)
 57645 push EAX
// printf arg #2 (unknown)
 57647 push 90
// printf arg #1 (char* format)
 57650 push 57795
 57653 mov ECX,6
// printf(...)
 57656 call 21772
 57659 add ESP,6
 57662 rstack EAX,EBP:-5
// loop step
 57666 inc EAX
 57668 sstack EBP:-5,EAX
 57672 jmp 57516
__2431:
// printf arg #2 (unknown)
 57675 push 90
// printf arg #1 (char* format)
 57678 push 57767
 57681 mov ECX,2
// printf(...)
 57684 call 21772
 57687 add ESP,2
__2426:
__2421:
 57690 rstack EAX,EBP:-7
// free arg #1 (float* ptr)
 57694 push EAX
 57696 mov ECX,1
// free(...)
 57699 call 28980
 57702 add ESP,1
 57705 rstack EAX,EBP:-6
// free arg #1 (float* ptr)
 57709 push EAX
 57711 mov ECX,1
// free(...)
 57714 call 28980
 57717 add ESP,1
 57720 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 57724 push EAX
 57726 mov ECX,1
// free(...)
 57729 call 28980
 57732 add ESP,1
__2397:
 57735 leave 
 57736 ret 
__2424:
 57737 db "%mthere are no files in [%s]
",0
__2437:
 57767 db "%m------------------------
",0
__2436:
 57795 db "%m%d	%d	%m[%s]
",0
__2409:
 57811 db "%mcan't open fh_dir
",0
__2430:
 57832 db "%mn	size	name
",0
__2402:
 57847 db "no filesystem (use mount, cd)
",0
__2429:
 57878 db "%mthere are %d files in [%s]
",0
__2428:
 57908 db "
%m------------------------
",0
cmdMkDir:
// cmdMkDir(shell,argc,argv)
 57937 enter 2
__2439:
// assert_type arg #2 (float t)
 57940 push 37328
 57943 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 57947 push EAX
 57949 mov ECX,2
// assert_type(...)
 57952 call 10123
 57955 add ESP,2
 57958 rstack EAX,EBP:2
 57962 add EAX,3
 57965 mov EBX,EAX
 57967 sstack EBP:-1,#EBX
__2441:
 57971 rstack EAX,EBP:-1
 57975 lneg EAX
 57977 mov EBX,EAX
// if (!fs3)
 57979 cmp 0,EBX
 57982 jge 57999
// printf arg #1 (char* format)
 57985 push 57847
 57988 mov ECX,1
// printf(...)
 57991 call 21772
 57994 add ESP,1
 57997 leave 
 57998 ret 
__2442:
__2440:
__2444:
 57999 rstack EAX,EBP:3
 58003 mov EBX,1
 58006 sub EBX,EAX
 58008 neg EBX
 58010 fsgn EBX,EBX
 58012 max EBX,0
// if (argc>1)
 58015 cmp 0,EBX
 58018 jge 58079
 58021 rstack EAX,EBP:4
 58025 add EAX,1
 58028 mov EBX,EAX
 58030 sstack EBP:-2,#EBX
 58034 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 58038 push EAX
// printf arg #2 (unknown)
 58040 push 90
// printf arg #1 (char* format)
 58043 push 58107
 58046 mov ECX,3
// printf(...)
 58049 call 21772
 58052 add ESP,3
 58055 rstack EAX,EBP:-2
// fs3_mkdir arg #2 (float filepath)
 58059 push EAX
 58061 rstack EAX,EBP:2
// fs3_mkdir arg #1 (float shell)
 58065 push EAX
 58067 mov ECX,2
// fs3_mkdir(...)
 58070 call 53850
 58073 add ESP,2
 58076 jmp 58105
__2447:
__2445:
__2449:
 58079 rstack EAX,EBP:4
 58083 add EAX,0
 58086 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 58088 push #EBX
 58090 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 58094 push EAX
 58096 mov ECX,2
// cmdHelp2(...)
 58099 call 40759
 58102 add ESP,2
__2448:
__2443:
__2438:
 58105 leave 
 58106 ret 
__2446:
 58107 db "%mmaking directory [%s]
",0
cmdDel:
// cmdDel(shell,argc,argv)
 58132 enter -0
__2451:
// assert_type arg #2 (float t)
 58135 push 37328
 58138 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 58142 push EAX
 58144 mov ECX,2
// assert_type(...)
 58147 call 10123
 58150 add ESP,2
 58153 rstack EAX,EBP:3
 58157 add EAX,1
 58160 mov EBX,EAX
// fs3_delFile arg #2 (float filepath)
 58162 push #EBX
 58164 rstack EAX,EBP:2
// fs3_delFile arg #1 (float shell)
 58168 push EAX
 58170 mov ECX,2
// fs3_delFile(...)
 58173 call 54284
 58176 add ESP,2
__2450:
 58179 leave 
 58180 ret 
cmdMem:
// cmdMem(shell,argc,argv)
 58181 enter 9
__2453:
// assert_type arg #2 (float t)
 58184 push 37328
 58187 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 58191 push EAX
 58193 mov ECX,2
// assert_type(...)
 58196 call 10123
 58199 add ESP,2
__2455:
 58202 rstack EAX,EBP:3
 58206 mov EBX,2
 58209 sub EBX,EAX
 58211 neg EBX
 58213 fsgn EBX,EBX
 58215 max EBX,0
// if (argc>2)
 58218 cmp 0,EBX
 58221 jge 58819
 58224 rstack EAX,EBP:4
 58228 add EAX,1
 58231 mov EBX,EAX
// str2num arg #1 (char* str)
 58233 push #EBX
 58235 mov ECX,1
// str2num(...)
 58238 call 12270
 58241 add ESP,1
 58244 sstack EBP:-1,EAX
 58248 rstack EAX,EBP:4
 58252 add EAX,2
 58255 mov EBX,EAX
// str2num arg #1 (char* str)
 58257 push #EBX
 58259 mov ECX,1
// str2num(...)
 58262 call 12270
 58265 add ESP,1
 58268 sstack EBP:-2,EAX
__2458:
 58272 rstack EAX,EBP:3
 58276 mov EBX,3
 58279 sub EBX,EAX
 58281 neg EBX
 58283 fsgn EBX,EBX
 58285 max EBX,0
// if (argc>3)
 58288 cmp 0,EBX
 58291 jge 58668
__2462:
// strcmp arg #2 (char* dest)
 58294 push 58868
 58297 rstack EAX,EBP:4
 58301 add EAX,3
 58304 mov EBX,EAX
// strcmp arg #1 (char* src)
 58306 push #EBX
 58308 mov ECX,2
// strcmp(...)
 58311 call 10763
 58314 add ESP,2
 58317 mov EBX,0
 58320 sub EBX,EAX
 58322 fabs EBX,EBX
 58324 fsgn EBX,EBX
 58326 lneg EBX
// if (strcmp(argv[3],"-disk")==0)
 58328 cmp 0,EBX
 58331 jge 58443
 58334 rstack EAX,EBP:2
 58338 add EAX,3
 58341 mov EBX,EAX
 58343 sstack EBP:-3,#EBX
__2465:
 58347 rstack EAX,EBP:-3
 58351 lneg EAX
 58353 mov EBX,EAX
// if (!fs3)
 58355 cmp 0,EBX
 58358 jge 58375
// printf arg #1 (char* format)
 58361 push 57847
 58364 mov ECX,1
// printf(...)
 58367 call 21772
 58370 add ESP,1
 58373 leave 
 58374 ret 
__2466:
__2464:
// assert_type arg #2 (float t)
 58375 push 44420
 58378 rstack EAX,EBP:-3
// assert_type arg #1 (float self)
 58382 push EAX
 58384 mov ECX,2
// assert_type(...)
 58387 call 10123
 58390 add ESP,2
 58393 rstack EAX,EBP:-3
 58397 add EAX,1
 58400 mov EBX,EAX
 58402 sstack EBP:-4,#EBX
 58406 rstack EAX,EBP:-4
// printf arg #2 (unknown)
 58410 push EAX
// printf arg #1 (char* format)
 58412 push 58885
 58415 mov ECX,2
// printf(...)
 58418 call 21772
 58421 add ESP,2
 58424 rstack EAX,EBP:-4
 58428 rstack EBX,EBP:-1
 58432 add EBX,EAX
 58434 mov EAX,EBX
// addr_from=addr_from+diskAdr
 58436 sstack EBP:-1,EAX
 58440 jmp 58668
__2468:
__2463:
__2470:
__2473:
// strcmp arg #2 (char* dest)
 58443 push 58940
 58446 rstack EAX,EBP:4
 58450 add EAX,3
 58453 mov EBX,EAX
// strcmp arg #1 (char* src)
 58455 push #EBX
 58457 mov ECX,2
// strcmp(...)
 58460 call 10763
 58463 add ESP,2
 58466 mov EBX,0
 58469 sub EBX,EAX
 58471 fabs EBX,EBX
 58473 fsgn EBX,EBX
 58475 lneg EBX
// if (strcmp(argv[3],"-d")==0)
 58477 cmp 0,EBX
 58480 jge 58642
__2476:
 58483 rstack EAX,EBP:3
 58487 mov EBX,4
 58490 sub EBX,EAX
 58492 neg EBX
 58494 fsgn EBX,EBX
 58496 max EBX,0
// if (argc>4)
 58499 cmp 0,EBX
 58502 jge 58613
 58505 rstack EAX,EBP:4
 58509 add EAX,4
 58512 mov EBX,EAX
// str2num arg #1 (char* str)
 58514 push #EBX
 58516 mov ECX,1
// str2num(...)
 58519 call 12270
 58522 add ESP,1
 58525 sstack EBP:-5,EAX
 58529 rstack EAX,EBP:-5
// EBcb_get_entry arg #2 (float num)
 58533 push EAX
// EBcb_get_entry arg #1 (float this)
 58535 push 66989
 58538 mov ECX,2
// EBcb_get_entry(...)
 58541 call 19801
 58544 add ESP,2
 58547 sstack EBP:-6,EAX
 58551 rstack EAX,EBP:-6
// EBcb_entry_get_addr arg #1 (float this)
 58555 push EAX
 58557 mov ECX,1
// EBcb_entry_get_addr(...)
 58560 call 19657
 58563 add ESP,1
 58566 sstack EBP:-7,EAX
 58570 rstack EAX,EBP:-7
// printf arg #3 (unknown)
 58574 push EAX
 58576 rstack EAX,EBP:-5
// printf arg #2 (unknown)
 58580 push EAX
// printf arg #1 (char* format)
 58582 push 58847
 58585 mov ECX,3
// printf(...)
 58588 call 21772
 58591 add ESP,3
 58594 rstack EAX,EBP:-7
 58598 rstack EBX,EBP:-1
 58602 add EBX,EAX
 58604 mov EAX,EBX
// addr_from=addr_from+devAdr
 58606 sstack EBP:-1,EAX
 58610 jmp 58639
__2479:
__2477:
__2481:
 58613 rstack EAX,EBP:4
 58617 add EAX,0
 58620 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 58622 push #EBX
 58624 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 58628 push EAX
 58630 mov ECX,2
// cmdHelp2(...)
 58633 call 40759
 58636 add ESP,2
__2480:
__2475:
 58639 jmp 58668
__2482:
__2474:
__2484:
 58642 rstack EAX,EBP:4
 58646 add EAX,0
 58649 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 58651 push #EBX
 58653 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 58657 push EAX
 58659 mov ECX,2
// cmdHelp2(...)
 58662 call 40759
 58665 add ESP,2
__2483:
__2472:
__2469:
__2461:
__2459:
__2457:
__2486:
 58668 rstack EAX,EBP:-2
 58672 mov EBX,100
 58675 sub EBX,EAX
 58677 neg EBX
 58679 fsgn EBX,EBX
 58681 max EBX,0
// if (num_bytes>100)
 58684 cmp 0,EBX
 58687 jge 58713
// num_bytes=10
 58690 sstack EBP:-2,10
 58695 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 58699 push EAX
// printf arg #1 (char* format)
 58701 push 58904
 58704 mov ECX,2
// printf(...)
 58707 call 21772
 58710 add ESP,2
__2487:
__2485:
__2490:
 58713 rstack EAX,EBP:-2
 58717 mov EBX,EAX
 58719 dec EAX
 58721 sstack EBP:-2,EAX
// if (num_bytes--
 58725 cmp 0,EBX
 58728 jz 58816
 58731 rstack EAX,EBP:-1
 58735 sstack EBP:-8,#EAX
 58739 sstack EBP:-9,32
__2492:
 58744 rstack EAX,EBP:-8
// isPrint arg #1 (char C)
 58748 push EAX
 58750 mov ECX,1
// isPrint(...)
 58753 call 15309
 58756 add ESP,1
// if (isprint(byte))
 58759 cmp 0,EAX
 58762 jge 58773
 58765 rstack EAX,EBP:-8
// bch=byte
 58769 sstack EBP:-9,EAX
__2493:
__2491:
 58773 rstack EAX,EBP:-9
// printf arg #4 (unknown)
 58777 push EAX
 58779 rstack EAX,EBP:-8
// printf arg #3 (unknown)
 58783 push EAX
 58785 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 58789 push EAX
// printf arg #1 (char* format)
 58791 push 58874
 58794 mov ECX,4
// printf(...)
 58797 call 21772
 58800 add ESP,4
 58803 rstack EAX,EBP:-1
// addr_from++
 58807 inc EAX
 58809 sstack EBP:-1,EAX
 58813 jmp 58713
__2489:
 58816 jmp 58845
__2495:
__2456:
__2497:
 58819 rstack EAX,EBP:4
 58823 add EAX,0
 58826 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 58828 push #EBX
 58830 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 58834 push EAX
 58836 mov ECX,2
// cmdHelp2(...)
 58839 call 40759
 58842 add ESP,2
__2496:
__2454:
__2452:
 58845 leave 
 58846 ret 
__2478:
 58847 db "rel. to dev %d @ %d
",0
__2460:
 58868 db "-disk",0
__2494:
 58874 db "%d:	%d	%c
",0
__2467:
 58885 db "rel. to disk @ %d
",0
__2488:
 58904 db "num_bytes too high, limiting to %d
",0
__2471:
 58940 db "-d",0
cmdWrite:
// cmdWrite(shell,argc,argv)
 58943 enter 6
__2499:
// assert_type arg #2 (float t)
 58946 push 37328
 58949 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 58953 push EAX
 58955 mov ECX,2
// assert_type(...)
 58958 call 10123
 58961 add ESP,2
__2501:
 58964 rstack EAX,EBP:3
 58968 mov EBX,1
 58971 sub EBX,EAX
 58973 neg EBX
 58975 fsgn EBX,EBX
 58977 max EBX,0
// if (argc>1)
 58980 cmp 0,EBX
 58983 jge 59280
__2505:
// strcmp arg #2 (char* dest)
 58986 push 59342
 58989 rstack EAX,EBP:4
 58993 add EAX,1
 58996 mov EBX,EAX
// strcmp arg #1 (char* src)
 58998 push #EBX
 59000 mov ECX,2
// strcmp(...)
 59003 call 10763
 59006 add ESP,2
 59009 mov EBX,0
 59012 sub EBX,EAX
 59014 fabs EBX,EBX
 59016 fsgn EBX,EBX
 59018 lneg EBX
// if (strcmp(argv[1],"-f")==0)
 59020 cmp 0,EBX
 59023 jge 59280
__2508:
 59026 rstack EAX,EBP:3
 59030 mov EBX,2
 59033 sub EBX,EAX
 59035 neg EBX
 59037 fsgn EBX,EBX
 59039 max EBX,0
// if (argc>2)
 59042 cmp 0,EBX
 59045 jge 59280
 59048 rstack EAX,EBP:4
 59052 add EAX,2
 59055 mov EBX,EAX
 59057 sstack EBP:-1,#EBX
// fopen arg #3 (float mode)
 59061 push 43183
 59064 rstack EAX,EBP:-1
// fopen arg #2 (float filepath)
 59068 push EAX
 59070 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 59074 push EAX
 59076 mov ECX,3
// fopen(...)
 59079 call 53191
 59082 add ESP,3
 59085 sstack EBP:-2,EAX
__2511:
 59089 rstack EAX,EBP:-2
 59093 lneg EAX
 59095 mov EBX,EAX
// if (!fh)
 59097 cmp 0,EBX
 59100 jge 59123
// printf arg #1 (char* format)
 59103 push 59345
 59106 mov ECX,1
// printf(...)
 59109 call 21772
 59112 add ESP,1
 59115 mov EAX,0
 59118 leave 
 59119 ret 
 59120 jmp 59138
__2514:
__2512:
__2516:
// printf arg #2 (unknown)
 59123 push 90
// printf arg #1 (char* format)
 59126 push 59313
 59129 mov ECX,2
// printf(...)
 59132 call 21772
 59135 add ESP,2
__2515:
__2510:
// init loop
 59138 sstack EBP:-3,3
__2519:
 59143 rstack EAX,EBP:-3
 59147 rstack EBX,EBP:3
 59151 sub EBX,EAX
 59153 mov EAX,EBX
 59155 fsgn EAX,EAX
// condition
 59157 max EAX,0
 59160 cmp 0,EAX
 59163 jz 59275
 59166 rstack EAX,EBP:-3
 59170 rstack EBX,EBP:4
 59174 add EBX,EAX
 59176 mov EAX,EBX
 59178 sstack EBP:-4,#EAX
 59182 rstack EAX,EBP:-4
// strlen arg #1 (char* str)
 59186 push EAX
 59188 mov ECX,1
// strlen(...)
 59191 call 11121
 59194 add ESP,1
 59197 sstack EBP:-5,EAX
 59201 rstack EAX,EBP:-2
// fwrite arg #3 (float fp)
 59205 push EAX
 59207 rstack EAX,EBP:-5
// fwrite arg #2 (float size)
 59211 push EAX
 59213 rstack EAX,EBP:-4
// fwrite arg #1 (float from)
 59217 push EAX
 59219 mov ECX,3
// fwrite(...)
 59222 call 52831
 59225 add ESP,3
 59228 sstack EBP:-6,EAX
__2521:
 59232 rstack EAX,EBP:-6
// if (res)
 59236 cmp 0,EAX
 59239 jge 59245
 59242 jmp 59262
__2523:
__2522:
__2525:
// printf arg #1 (char* format)
 59245 push 59328
 59248 mov ECX,1
// printf(...)
 59251 call 21772
 59254 add ESP,1
 59257 mov EAX,0
 59260 leave 
 59261 ret 
__2524:
__2520:
 59262 rstack EAX,EBP:-3
// loop step
 59266 inc EAX
 59268 sstack EBP:-3,EAX
 59272 jmp 59143
__2518:
 59275 mov EAX,1
 59278 leave 
 59279 ret 
__2509:
__2507:
__2506:
__2504:
__2502:
__2500:
 59280 rstack EAX,EBP:4
 59284 add EAX,0
 59287 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 59289 push #EBX
 59291 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 59295 push EAX
 59297 mov ECX,2
// cmdHelp2(...)
 59300 call 40759
 59303 add ESP,2
 59306 mov EAX,0
 59309 leave 
 59310 ret 
__2498:
 59311 leave 
 59312 ret 
__2517:
 59313 db "%mfile opened
",0
__2526:
 59328 db "can't fwrite
",0
__2503:
 59342 db "-f",0
__2513:
 59345 db "can't open file
",0
cmdRead:
// cmdRead(shell,argc,argv)
 59362 enter 5
__2528:
// assert_type arg #2 (float t)
 59365 push 37328
 59368 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 59372 push EAX
 59374 mov ECX,2
// assert_type(...)
 59377 call 10123
 59380 add ESP,2
__2530:
 59383 rstack EAX,EBP:3
 59387 mov EBX,1
 59390 sub EBX,EAX
 59392 neg EBX
 59394 fsgn EBX,EBX
 59396 max EBX,0
// if (argc>1)
 59399 cmp 0,EBX
 59402 jge 59750
__2533:
// strcmp arg #2 (char* dest)
 59405 push 59342
 59408 rstack EAX,EBP:4
 59412 add EAX,1
 59415 mov EBX,EAX
// strcmp arg #1 (char* src)
 59417 push #EBX
 59419 mov ECX,2
// strcmp(...)
 59422 call 10763
 59425 add ESP,2
 59428 mov EBX,0
 59431 sub EBX,EAX
 59433 fabs EBX,EBX
 59435 fsgn EBX,EBX
 59437 lneg EBX
// if (strcmp(argv[1],"-f")==0)
 59439 cmp 0,EBX
 59442 jge 59750
__2536:
 59445 rstack EAX,EBP:3
 59449 mov EBX,2
 59452 sub EBX,EAX
 59454 neg EBX
 59456 fsgn EBX,EBX
 59458 max EBX,0
// if (argc>2)
 59461 cmp 0,EBX
 59464 jge 59750
 59467 rstack EAX,EBP:4
 59471 add EAX,2
 59474 mov EBX,EAX
 59476 sstack EBP:-1,#EBX
 59480 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 59484 push EAX
// printf arg #1 (char* format)
 59486 push 59802
 59489 mov ECX,2
// printf(...)
 59492 call 21772
 59495 add ESP,2
// fopen arg #3 (float mode)
 59498 push 43181
 59501 rstack EAX,EBP:-1
// fopen arg #2 (float filepath)
 59505 push EAX
 59507 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 59511 push EAX
 59513 mov ECX,3
// fopen(...)
 59516 call 53191
 59519 add ESP,3
 59522 sstack EBP:-2,EAX
__2540:
 59526 rstack EAX,EBP:-2
 59530 lneg EAX
 59532 mov EBX,EAX
// if (!fh)
 59534 cmp 0,EBX
 59537 jge 59560
// printf arg #1 (char* format)
 59540 push 59345
 59543 mov ECX,1
// printf(...)
 59546 call 21772
 59549 add ESP,1
 59552 mov EAX,0
 59555 leave 
 59556 ret 
 59557 jmp 59575
__2542:
__2541:
__2544:
// printf arg #2 (unknown)
 59560 push 90
// printf arg #1 (char* format)
 59563 push 59313
 59566 mov ECX,2
// printf(...)
 59569 call 21772
 59572 add ESP,2
__2543:
__2539:
 59575 rstack EAX,EBP:-2
// fsize arg #1 (float fp)
 59579 push EAX
 59581 mov ECX,1
// fsize(...)
 59584 call 52392
 59587 add ESP,1
 59590 sstack EBP:-3,EAX
 59594 rstack EAX,EBP:-3
 59598 add EAX,1
 59601 mov EBX,EAX
// malloc arg #1 (float n)
 59603 push EBX
 59605 mov ECX,1
// malloc(...)
 59608 call 28486
 59611 add ESP,1
 59614 sstack EBP:-4,EAX
 59618 rstack EAX,EBP:-2
// fread arg #3 (float fp)
 59622 push EAX
 59624 rstack EAX,EBP:-3
// fread arg #2 (float size)
 59628 push EAX
 59630 rstack EAX,EBP:-4
// fread arg #1 (float to)
 59634 push EAX
 59636 mov ECX,3
// fread(...)
 59639 call 52657
 59642 add ESP,3
 59645 sstack EBP:-5,EAX
 59649 rstack EAX,EBP:-3
 59653 rstack EBX,EBP:-4
 59657 add EBX,EAX
 59659 mov EAX,EBX
// buff[len]=0
 59661 mov #EAX,0
__2546:
 59664 rstack EAX,EBP:-5
// if (res)
 59668 cmp 0,EAX
 59671 jge 59713
 59674 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 59678 push EAX
// printf arg #2 (unknown)
 59680 push 90
// printf arg #1 (char* format)
 59683 push 59783
 59686 mov ECX,3
// printf(...)
 59689 call 21772
 59692 add ESP,3
 59695 rstack EAX,EBP:-4
// free arg #1 (float* ptr)
 59699 push EAX
 59701 mov ECX,1
// free(...)
 59704 call 28980
 59707 add ESP,1
 59710 jmp 59745
__2549:
__2547:
__2551:
// printf arg #1 (char* format)
 59713 push 59789
 59716 mov ECX,1
// printf(...)
 59719 call 21772
 59722 add ESP,1
 59725 rstack EAX,EBP:-4
// free arg #1 (float* ptr)
 59729 push EAX
 59731 mov ECX,1
// free(...)
 59734 call 28980
 59737 add ESP,1
 59740 mov EAX,0
 59743 leave 
 59744 ret 
__2550:
__2545:
 59745 mov EAX,1
 59748 leave 
 59749 ret 
__2537:
__2535:
__2534:
__2532:
__2531:
__2529:
 59750 rstack EAX,EBP:4
 59754 add EAX,0
 59757 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 59759 push #EBX
 59761 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 59765 push EAX
 59767 mov ECX,2
// cmdHelp2(...)
 59770 call 40759
 59773 add ESP,2
 59776 mov EAX,0
 59779 leave 
 59780 ret 
__2527:
 59781 leave 
 59782 ret 
__2548:
 59783 db "%m%s
",0
__2552:
 59789 db "can't fread
",0
__2538:
 59802 db "read from file [%s]
",0
countHDD:
// countHDD(fs3,ret_bytes_free,ret_bytes_used,ret_bytes_total,ret_blocks_free,ret_blocks_used,ret_blocks_total)
 59823 enter 15
__2554:
// fs3_low_read arg #4 (float size)
 59826 push 1
 59829 mov EAX,SS:EBP
 59832 add EAX,-1
// fs3_low_read arg #3 (float to)
 59835 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 59837 push 12
 59840 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 59844 push EAX
 59846 mov ECX,4
// fs3_low_read(...)
 59849 call 46027
 59852 add ESP,4
// fs3_low_read arg #4 (float size)
 59855 push 1
 59858 mov EAX,SS:EBP
 59861 add EAX,-2
// fs3_low_read arg #3 (float to)
 59864 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 59866 push 13
 59869 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 59873 push EAX
 59875 mov ECX,4
// fs3_low_read(...)
 59878 call 46027
 59881 add ESP,4
// fs3_low_read arg #4 (float size)
 59884 push 1
 59887 mov EAX,SS:EBP
 59890 add EAX,-3
// fs3_low_read arg #3 (float to)
 59893 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 59895 push 14
 59898 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 59902 push EAX
 59904 mov ECX,4
// fs3_low_read(...)
 59907 call 46027
 59910 add ESP,4
 59913 rstack EAX,EBP:-2
 59917 mul EAX,2
 59920 mov EBX,EAX
 59922 sstack EBP:-4,EBX
 59926 rstack EAX,EBP:-4
// malloc arg #1 (float n)
 59930 push EAX
 59932 mov ECX,1
// malloc(...)
 59935 call 28486
 59938 add ESP,1
 59941 sstack EBP:-5,EAX
 59945 rstack EAX,EBP:-4
// fs3_low_read arg #4 (float size)
 59949 push EAX
 59951 rstack EAX,EBP:-5
// fs3_low_read arg #3 (float to)
 59955 push EAX
 59957 rstack EAX,EBP:-3
// fs3_low_read arg #2 (float disk_ptr)
 59961 push EAX
 59963 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 59967 push EAX
 59969 mov ECX,4
// fs3_low_read(...)
 59972 call 46027
 59975 add ESP,4
 59978 sstack EBP:-11,0
 59983 sstack EBP:-12,0
// init loop
 59988 sstack EBP:-10,0
__2556:
 59993 rstack EAX,EBP:-10
 59997 rstack EBX,EBP:-2
 60001 sub EBX,EAX
 60003 mov EAX,EBX
 60005 fsgn EAX,EAX
// condition
 60007 max EAX,0
 60010 cmp 0,EAX
 60013 jz 60107
 60016 rstack EAX,EBP:-10
 60020 mul EAX,2
 60023 mov EBX,EAX
 60025 rstack EAX,EBP:-5
 60029 add EAX,EBX
 60031 mov EBX,EAX
// B=blockmap+I*2
 60033 sstack EBP:-6,EBX
 60037 rstack EAX,EBP:-6
 60041 add EAX,0
 60044 mov EBX,EAX
// Buser=B[0]
 60046 sstack EBP:-7,#EBX
__2558:
 60050 rstack EAX,EBP:-7
 60054 mov EBX,0
 60057 sub EBX,EAX
 60059 fabs EBX,EBX
 60061 fsgn EBX,EBX
 60063 lneg EBX
// if (Buser==0)
 60065 cmp 0,EBX
 60068 jge 60084
 60071 rstack EAX,EBP:-11
// num_free++
 60075 inc EAX
 60077 sstack EBP:-11,EAX
 60081 jmp 60094
__2560:
__2559:
__2562:
 60084 rstack EAX,EBP:-12
// num_used++
 60088 inc EAX
 60090 sstack EBP:-12,EAX
__2561:
__2557:
 60094 rstack EAX,EBP:-10
// loop step
 60098 inc EAX
 60100 sstack EBP:-10,EAX
 60104 jmp 59993
__2555:
 60107 rstack EAX,EBP:-1
 60111 rstack EBX,EBP:-2
 60115 mul EBX,EAX
 60117 mov EAX,EBX
 60119 sstack EBP:-13,EAX
 60123 rstack EAX,EBP:-11
 60127 rstack EBX,EBP:-1
 60131 mul EBX,EAX
 60133 mov EAX,EBX
 60135 sstack EBP:-14,EAX
 60139 rstack EAX,EBP:-14
 60143 neg EAX
 60145 mov EBX,EAX
 60147 rstack EAX,EBP:-13
 60151 add EAX,EBX
 60153 mov EBX,EAX
 60155 sstack EBP:-15,EBX
__2564:
 60159 rstack EAX,EBP:3
// if (ret_bytes_free)
 60163 cmp 0,EAX
 60166 jge 60179
 60169 rstack EAX,EBP:-14
 60173 rstack EBX,EBP:3
// *ret_bytes_free=bytes_free
 60177 mov #EBX,EAX
__2565:
__2563:
__2567:
 60179 rstack EAX,EBP:4
// if (ret_bytes_used)
 60183 cmp 0,EAX
 60186 jge 60199
 60189 rstack EAX,EBP:-15
 60193 rstack EBX,EBP:4
// *ret_bytes_used=bytes_used
 60197 mov #EBX,EAX
__2568:
__2566:
__2570:
 60199 rstack EAX,EBP:5
// if (ret_bytes_total)
 60203 cmp 0,EAX
 60206 jge 60219
 60209 rstack EAX,EBP:-13
 60213 rstack EBX,EBP:5
// *ret_bytes_total=bytes_total
 60217 mov #EBX,EAX
__2571:
__2569:
__2573:
 60219 rstack EAX,EBP:6
// if (ret_blocks_free)
 60223 cmp 0,EAX
 60226 jge 60239
 60229 rstack EAX,EBP:-11
 60233 rstack EBX,EBP:6
// *ret_blocks_free=num_free
 60237 mov #EBX,EAX
__2574:
__2572:
__2576:
 60239 rstack EAX,EBP:7
// if (ret_blocks_used)
 60243 cmp 0,EAX
 60246 jge 60259
 60249 rstack EAX,EBP:-12
 60253 rstack EBX,EBP:7
// *ret_blocks_used=num_used
 60257 mov #EBX,EAX
__2577:
__2575:
__2579:
 60259 rstack EAX,EBP:8
// if (ret_blocks_total)
 60263 cmp 0,EAX
 60266 jge 60279
 60269 rstack EAX,EBP:-2
 60273 rstack EBX,EBP:8
// *ret_blocks_total=num_blocks
 60277 mov #EBX,EAX
__2580:
__2578:
__2553:
 60279 leave 
 60280 ret 
printBlockmap:
// printBlockmap(fs3,from,count)
 60281 enter 10
__2582:
// fs3_low_read arg #4 (float size)
 60284 push 1
 60287 mov EAX,SS:EBP
 60290 add EAX,-1
// fs3_low_read arg #3 (float to)
 60293 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 60295 push 12
 60298 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 60302 push EAX
 60304 mov ECX,4
// fs3_low_read(...)
 60307 call 46027
 60310 add ESP,4
// fs3_low_read arg #4 (float size)
 60313 push 1
 60316 mov EAX,SS:EBP
 60319 add EAX,-2
// fs3_low_read arg #3 (float to)
 60322 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 60324 push 13
 60327 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 60331 push EAX
 60333 mov ECX,4
// fs3_low_read(...)
 60336 call 46027
 60339 add ESP,4
// fs3_low_read arg #4 (float size)
 60342 push 1
 60345 mov EAX,SS:EBP
 60348 add EAX,-3
// fs3_low_read arg #3 (float to)
 60351 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 60353 push 14
 60356 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 60360 push EAX
 60362 mov ECX,4
// fs3_low_read(...)
 60365 call 46027
 60368 add ESP,4
 60371 rstack EAX,EBP:-2
 60375 mul EAX,2
 60378 mov EBX,EAX
 60380 sstack EBP:-4,EBX
 60384 rstack EAX,EBP:-4
// malloc arg #1 (float n)
 60388 push EAX
 60390 mov ECX,1
// malloc(...)
 60393 call 28486
 60396 add ESP,1
 60399 sstack EBP:-5,EAX
 60403 rstack EAX,EBP:-4
// fs3_low_read arg #4 (float size)
 60407 push EAX
 60409 rstack EAX,EBP:-5
// fs3_low_read arg #3 (float to)
 60413 push EAX
 60415 rstack EAX,EBP:-3
// fs3_low_read arg #2 (float disk_ptr)
 60419 push EAX
 60421 rstack EAX,EBP:2
// fs3_low_read arg #1 (float fs3)
 60425 push EAX
 60427 mov ECX,4
// fs3_low_read(...)
 60430 call 46027
 60433 add ESP,4
__2584:
 60436 rstack EAX,EBP:3
 60440 rstack EBX,EBP:-2
 60444 sub EBX,EAX
 60446 mov EAX,EBX
 60448 neg EAX
 60450 fsgn EAX,EAX
 60452 max EAX,0
// if (from>num_blocks)
 60455 cmp 0,EAX
 60458 jge 60474
 60461 rstack EAX,EBP:-2
 60465 add EAX,-1
 60468 mov EBX,EAX
// from=num_blocks-1
 60470 sstack EBP:3,EBX
__2585:
__2583:
__2587:
 60474 rstack EAX,EBP:4
 60478 rstack EBX,EBP:3
 60482 neg EBX
 60484 mov ECX,EBX
 60486 add ECX,-1
 60489 rstack EBX,EBP:-2
 60493 add EBX,ECX
 60495 mov ECX,EBX
 60497 sub ECX,EAX
 60499 neg ECX
 60501 fsgn ECX,ECX
 60503 max ECX,0
// if (count>(num_blocks-from-1))
 60506 cmp 0,ECX
 60509 jge 60532
 60512 rstack EAX,EBP:3
 60516 neg EAX
 60518 mov EBX,EAX
 60520 rstack EAX,EBP:-2
 60524 add EAX,EBX
 60526 mov EBX,EAX
// count=num_blocks-from
 60528 sstack EBP:4,EBX
__2588:
__2586:
__2590:
 60532 rstack EAX,EBP:4
 60536 mov EBX,30
 60539 sub EBX,EAX
 60541 neg EBX
 60543 fsgn EBX,EBX
 60545 max EBX,0
// if (count>30)
 60548 cmp 0,EBX
 60551 jge 60559
// count=30
 60554 sstack EBP:4,30
__2591:
__2589:
// printf arg #1 (char* format)
 60559 push 60784
 60562 mov ECX,1
// printf(...)
 60565 call 21772
 60568 add ESP,1
 60571 rstack EAX,EBP:3
// init loop
 60575 sstack EBP:-10,EAX
__2594:
 60579 rstack EAX,EBP:-10
 60583 rstack EBX,EBP:4
 60587 sub EBX,EAX
 60589 mov EAX,EBX
 60591 fsgn EAX,EAX
// condition
 60593 max EAX,0
 60596 cmp 0,EAX
 60599 jz 60782
 60602 rstack EAX,EBP:-10
 60606 mul EAX,2
 60609 mov EBX,EAX
 60611 rstack EAX,EBP:-5
 60615 add EAX,EBX
 60617 mov EBX,EAX
// B=blockmap+I*2
 60619 sstack EBP:-6,EBX
 60623 rstack EAX,EBP:-6
 60627 add EAX,0
 60630 mov EBX,EAX
// Buser=B[0]
 60632 sstack EBP:-7,#EBX
 60636 rstack EAX,EBP:-6
 60640 add EAX,1
 60643 mov EBX,EAX
// Bnext=B[1]
 60645 sstack EBP:-8,#EBX
// col=900
 60649 sstack EBP:-9,900
__2596:
 60654 rstack EAX,EBP:-7
 60658 mov EBX,0
 60661 sub EBX,EAX
 60663 fabs EBX,EBX
 60665 fsgn EBX,EBX
 60667 lneg EBX
// if (Buser==0)
 60669 cmp 0,EBX
 60672 jge 60680
// col=575
 60675 sstack EBP:-9,575
__2597:
__2595:
__2599:
 60680 rstack EAX,EBP:-7
 60684 mov EBX,1
 60687 sub EBX,EAX
 60689 fabs EBX,EBX
 60691 fsgn EBX,EBX
 60693 lneg EBX
// if (Buser==1)
 60695 cmp 0,EBX
 60698 jge 60706
// col=229
 60701 sstack EBP:-9,229
__2600:
__2598:
__2602:
 60706 rstack EAX,EBP:-7
 60710 mov EBX,1
 60713 sub EBX,EAX
 60715 neg EBX
 60717 fsgn EBX,EBX
 60719 max EBX,0
// if (Buser>1)
 60722 cmp 0,EBX
 60725 jge 60733
// col=755
 60728 sstack EBP:-9,755
__2603:
__2601:
 60733 rstack EAX,EBP:-8
// printf arg #5 (unknown)
 60737 push EAX
 60739 rstack EAX,EBP:-7
// printf arg #4 (unknown)
 60743 push EAX
 60745 rstack EAX,EBP:-10
// printf arg #3 (unknown)
 60749 push EAX
 60751 rstack EAX,EBP:-9
// printf arg #2 (unknown)
 60755 push EAX
// printf arg #1 (char* format)
 60757 push 60801
 60760 mov ECX,5
// printf(...)
 60763 call 21772
 60766 add ESP,5
 60769 rstack EAX,EBP:-10
// loop step
 60773 inc EAX
 60775 sstack EBP:-10,EAX
 60779 jmp 60579
__2593:
__2581:
 60782 leave 
 60783 ret 
__2592:
 60784 db "block	user	next
",0
__2604:
 60801 db "%m%d    %d    %d
",0
cmdFS:
// cmdFS(shell,argc,argv)
 60819 enter 10
__2606:
// assert_type arg #2 (float t)
 60822 push 37328
 60825 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 60829 push EAX
 60831 mov ECX,2
// assert_type(...)
 60834 call 10123
 60837 add ESP,2
 60840 rstack EAX,EBP:2
 60844 add EAX,3
 60847 mov EBX,EAX
 60849 sstack EBP:-1,#EBX
__2608:
 60853 rstack EAX,EBP:-1
 60857 lneg EAX
 60859 mov EBX,EAX
// if (!fs3)
 60861 cmp 0,EBX
 60864 jge 60884
// printf arg #1 (char* format)
 60867 push 62100
 60870 mov ECX,1
// printf(...)
 60873 call 21772
 60876 add ESP,1
 60879 mov EAX,0
 60882 leave 
 60883 ret 
__2609:
__2607:
__2612:
 60884 rstack EAX,EBP:3
 60888 mov EBX,1
 60891 sub EBX,EAX
 60893 neg EBX
 60895 fsgn EBX,EBX
 60897 max EBX,0
// if (argc>1)
 60900 cmp 0,EBX
 60903 jge 61778
__2615:
// strcmp arg #2 (char* dest)
 60906 push 42252
 60909 rstack EAX,EBP:4
 60913 add EAX,1
 60916 mov EBX,EAX
// strcmp arg #1 (char* src)
 60918 push #EBX
 60920 mov ECX,2
// strcmp(...)
 60923 call 10763
 60926 add ESP,2
 60929 mov EBX,0
 60932 sub EBX,EAX
 60934 fabs EBX,EBX
 60936 fsgn EBX,EBX
 60938 lneg EBX
// if (strcmp(argv[1],"info")==0)
 60940 cmp 0,EBX
 60943 jge 61280
// malloc arg #1 (float n)
 60946 push 17
 60949 mov ECX,1
// malloc(...)
 60952 call 28486
 60955 add ESP,1
 60958 sstack EBP:-2,EAX
// fs3_low_read arg #4 (float size)
 60962 push 16
 60965 rstack EAX,EBP:-2
// fs3_low_read arg #3 (float to)
 60969 push EAX
// fs3_low_read arg #2 (float disk_ptr)
 60971 push 0
 60974 rstack EAX,EBP:-1
// fs3_low_read arg #1 (float fs3)
 60978 push EAX
 60980 mov ECX,4
// fs3_low_read(...)
 60983 call 46027
 60986 add ESP,4
 60989 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 60993 push EAX
// printf arg #1 (char* format)
 60995 push 62086
 60998 mov ECX,2
// printf(...)
 61001 call 21772
 61004 add ESP,2
 61007 rstack EAX,EBP:-2
 61011 add EAX,11
 61014 mov EBX,EAX
// printf arg #2 (unknown)
 61016 push #EBX
// printf arg #1 (char* format)
 61018 push 61909
 61021 mov ECX,2
// printf(...)
 61024 call 21772
 61027 add ESP,2
 61030 rstack EAX,EBP:-2
 61034 add EAX,12
 61037 mov EBX,EAX
// printf arg #2 (unknown)
 61039 push #EBX
// printf arg #1 (char* format)
 61041 push 61888
 61044 mov ECX,2
// printf(...)
 61047 call 21772
 61050 add ESP,2
 61053 rstack EAX,EBP:-2
 61057 add EAX,13
 61060 mov EBX,EAX
// printf arg #2 (unknown)
 61062 push #EBX
// printf arg #1 (char* format)
 61064 push 61815
 61067 mov ECX,2
// printf(...)
 61070 call 21772
 61073 add ESP,2
 61076 rstack EAX,EBP:-2
 61080 add EAX,14
 61083 mov EBX,EAX
// printf arg #2 (unknown)
 61085 push #EBX
// printf arg #1 (char* format)
 61087 push 61929
 61090 mov ECX,2
// printf(...)
 61093 call 21772
 61096 add ESP,2
 61099 rstack EAX,EBP:-2
 61103 add EAX,15
 61106 mov EBX,EAX
// printf arg #2 (unknown)
 61108 push #EBX
// printf arg #1 (char* format)
 61110 push 62175
 61113 mov ECX,2
// printf(...)
 61116 call 21772
 61119 add ESP,2
 61122 rstack EAX,EBP:-2
 61126 add EAX,16
 61129 mov EBX,EAX
// printf arg #2 (unknown)
 61131 push #EBX
// printf arg #1 (char* format)
 61133 push 61852
 61136 mov ECX,2
// printf(...)
 61139 call 21772
 61142 add ESP,2
 61145 rstack EAX,EBP:-2
// free arg #1 (float* ptr)
 61149 push EAX
 61151 mov ECX,1
// free(...)
 61154 call 28980
 61157 add ESP,1
 61160 mov EAX,SS:EBP
 61163 add EAX,-5
// countHDD arg #7 (float ret_blocks_total)
 61166 push EAX
 61168 mov EAX,SS:EBP
 61171 add EAX,-4
// countHDD arg #6 (float ret_blocks_used)
 61174 push EAX
 61176 mov EAX,SS:EBP
 61179 add EAX,-3
// countHDD arg #5 (float ret_blocks_free)
 61182 push EAX
 61184 mov EAX,SS:EBP
 61187 add EAX,-8
// countHDD arg #4 (float ret_bytes_total)
 61190 push EAX
 61192 mov EAX,SS:EBP
 61195 add EAX,-7
// countHDD arg #3 (float ret_bytes_used)
 61198 push EAX
 61200 mov EAX,SS:EBP
 61203 add EAX,-6
// countHDD arg #2 (float ret_bytes_free)
 61206 push EAX
 61208 rstack EAX,EBP:-1
// countHDD arg #1 (float fs3)
 61212 push EAX
 61214 mov ECX,7
// countHDD(...)
 61217 call 59823
 61220 add ESP,7
 61223 rstack EAX,EBP:-5
// printf arg #4 (unknown)
 61227 push EAX
 61229 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 61233 push EAX
 61235 rstack EAX,EBP:-3
// printf arg #2 (unknown)
 61239 push EAX
// printf arg #1 (char* format)
 61241 push 62045
 61244 mov ECX,4
// printf(...)
 61247 call 21772
 61250 add ESP,4
 61253 rstack EAX,EBP:-8
// printf arg #3 (unknown)
 61257 push EAX
 61259 rstack EAX,EBP:-6
// printf arg #2 (unknown)
 61263 push EAX
// printf arg #1 (char* format)
 61265 push 61994
 61268 mov ECX,3
// printf(...)
 61271 call 21772
 61274 add ESP,3
 61277 jmp 61775
__2626:
__2616:
__2628:
__2631:
// strcmp arg #2 (char* dest)
 61280 push 62168
 61283 rstack EAX,EBP:4
 61287 add EAX,1
 61290 mov EBX,EAX
// strcmp arg #1 (char* src)
 61292 push #EBX
 61294 mov ECX,2
// strcmp(...)
 61297 call 10763
 61300 add ESP,2
 61303 mov EBX,0
 61306 sub EBX,EAX
 61308 fabs EBX,EBX
 61310 fsgn EBX,EBX
 61312 lneg EBX
// if (strcmp(argv[1],"blocks")==0)
 61314 cmp 0,EBX
 61317 jge 61435
__2634:
 61320 rstack EAX,EBP:3
 61324 mov EBX,3
 61327 sub EBX,EAX
 61329 neg EBX
 61331 fsgn EBX,EBX
 61333 max EBX,0
// if (argc>3)
 61336 cmp 0,EBX
 61339 jge 61420
 61342 rstack EAX,EBP:4
 61346 add EAX,2
 61349 mov EBX,EAX
// str2num arg #1 (char* str)
 61351 push #EBX
 61353 mov ECX,1
// str2num(...)
 61356 call 12270
 61359 add ESP,1
 61362 sstack EBP:-9,EAX
 61366 rstack EAX,EBP:4
 61370 add EAX,3
 61373 mov EBX,EAX
// str2num arg #1 (char* str)
 61375 push #EBX
 61377 mov ECX,1
// str2num(...)
 61380 call 12270
 61383 add ESP,1
 61386 sstack EBP:-10,EAX
 61390 rstack EAX,EBP:-10
// printBlockmap arg #3 (float count)
 61394 push EAX
 61396 rstack EAX,EBP:-9
// printBlockmap arg #2 (float from)
 61400 push EAX
 61402 rstack EAX,EBP:-1
// printBlockmap arg #1 (float fs3)
 61406 push EAX
 61408 mov ECX,3
// printBlockmap(...)
 61411 call 60281
 61414 add ESP,3
 61417 jmp 61432
__2636:
__2635:
__2638:
// printf arg #1 (char* format)
 61420 push 61945
 61423 mov ECX,1
// printf(...)
 61426 call 21772
 61429 add ESP,1
__2637:
__2633:
 61432 jmp 61775
__2640:
__2632:
__2642:
__2645:
// strcmp arg #2 (char* dest)
 61435 push 61809
 61438 rstack EAX,EBP:4
 61442 add EAX,1
 61445 mov EBX,EAX
// strcmp arg #1 (char* src)
 61447 push #EBX
 61449 mov ECX,2
// strcmp(...)
 61452 call 10763
 61455 add ESP,2
 61458 mov EBX,0
 61461 sub EBX,EAX
 61463 fabs EBX,EBX
 61465 fsgn EBX,EBX
 61467 lneg EBX
// if (strcmp(argv[1],"cache")==0)
 61469 cmp 0,EBX
 61472 jge 61749
__2648:
 61475 rstack EAX,EBP:3
 61479 mov EBX,2
 61482 sub EBX,EAX
 61484 neg EBX
 61486 fsgn EBX,EBX
 61488 max EBX,0
// if (argc>2)
 61491 cmp 0,EBX
 61494 jge 61692
__2652:
// strcmp arg #2 (char* dest)
 61497 push 61806
 61500 rstack EAX,EBP:4
 61504 add EAX,2
 61507 mov EBX,EAX
// strcmp arg #1 (char* src)
 61509 push #EBX
 61511 mov ECX,2
// strcmp(...)
 61514 call 10763
 61517 add ESP,2
 61520 mov EBX,0
 61523 sub EBX,EAX
 61525 fabs EBX,EBX
 61527 fsgn EBX,EBX
 61529 lneg EBX
// if (strcmp(argv[2],"on")==0)
 61531 cmp 0,EBX
 61534 jge 61561
 61537 rstack EAX,EBP:-1
 61541 add EAX,4
 61544 mov EBX,EAX
// fs3[4]=1
 61546 mov #EBX,1
// printf arg #1 (char* format)
 61549 push 61868
 61552 mov ECX,1
// printf(...)
 61555 call 21772
 61558 add ESP,1
__2653:
__2651:
__2657:
// strcmp arg #2 (char* dest)
 61561 push 62082
 61564 rstack EAX,EBP:4
 61568 add EAX,2
 61571 mov EBX,EAX
// strcmp arg #1 (char* src)
 61573 push #EBX
 61575 mov ECX,2
// strcmp(...)
 61578 call 10763
 61581 add ESP,2
 61584 mov EBX,0
 61587 sub EBX,EAX
 61589 fabs EBX,EBX
 61591 fsgn EBX,EBX
 61593 lneg EBX
// if (strcmp(argv[2],"off")==0)
 61595 cmp 0,EBX
 61598 jge 61625
 61601 rstack EAX,EBP:-1
 61605 add EAX,4
 61608 mov EBX,EAX
// fs3[4]=0
 61610 mov #EBX,0
// printf arg #1 (char* format)
 61613 push 61831
 61616 mov ECX,1
// printf(...)
 61619 call 21772
 61622 add ESP,1
__2658:
__2656:
__2662:
// strcmp arg #2 (char* dest)
 61625 push 62039
 61628 rstack EAX,EBP:4
 61632 add EAX,2
 61635 mov EBX,EAX
// strcmp arg #1 (char* src)
 61637 push #EBX
 61639 mov ECX,2
// strcmp(...)
 61642 call 10763
 61645 add ESP,2
 61648 mov EBX,0
 61651 sub EBX,EAX
 61653 fabs EBX,EBX
 61655 fsgn EBX,EBX
 61657 lneg EBX
// if (strcmp(argv[2],"reset")==0)
 61659 cmp 0,EBX
 61662 jge 61689
// printf arg #1 (char* format)
 61665 push 62019
 61668 mov ECX,1
// printf(...)
 61671 call 21772
 61674 add ESP,1
// printf arg #1 (char* format)
 61677 push 61977
 61680 mov ECX,1
// printf(...)
 61683 call 21772
 61686 add ESP,1
__2663:
__2661:
 61689 jmp 61746
__2666:
__2649:
__2668:
// printf arg #1 (char* format)
 61692 push 62145
 61695 mov ECX,1
// printf(...)
 61698 call 21772
 61701 add ESP,1
__2671:
 61704 rstack EAX,EBP:-1
 61708 add EAX,4
 61711 mov EBX,EAX
// if (fs3[4])
 61713 cmp 0,#EBX
 61716 jge 61734
// printf arg #1 (char* format)
 61719 push 61925
 61722 mov ECX,1
// printf(...)
 61725 call 21772
 61728 add ESP,1
 61731 jmp 61746
__2674:
__2672:
__2676:
// printf arg #1 (char* format)
 61734 push 61904
 61737 mov ECX,1
// printf(...)
 61740 call 21772
 61743 add ESP,1
__2675:
__2670:
__2667:
__2647:
 61746 jmp 61775
__2678:
__2646:
__2680:
 61749 rstack EAX,EBP:4
 61753 add EAX,0
 61756 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 61758 push #EBX
 61760 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 61764 push EAX
 61766 mov ECX,2
// cmdHelp2(...)
 61769 call 40759
 61772 add ESP,2
__2679:
__2644:
__2641:
__2630:
__2627:
__2614:
 61775 jmp 61804
__2681:
__2613:
__2683:
 61778 rstack EAX,EBP:4
 61782 add EAX,0
 61785 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 61787 push #EBX
 61789 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 61793 push EAX
 61795 mov ECX,2
// cmdHelp2(...)
 61798 call 40759
 61801 add ESP,2
__2682:
__2611:
__2605:
 61804 leave 
 61805 ret 
__2650:
 61806 db "on",0
__2643:
 61809 db "cache",0
__2620:
 61815 db "num blocks: %d
",0
__2659:
 61831 db "fs cache turned off
",0
__2623:
 61852 db "max index:  %d
",0
__2654:
 61868 db "fs cache turned on
",0
__2619:
 61888 db "block size: %d
",0
__2677:
 61904 db "OFF
",0
__2618:
 61909 db "total size: %d
",0
__2673:
 61925 db "ON
",0
__2621:
 61929 db "blockmap @: %d
",0
__2639:
 61945 db "usage: fs blocks [from][count]
",0
__2665:
 61977 db "<unimplimented>
",0
__2625:
 61994 db "HDD: %d / %d bytes free
",0
__2664:
 62019 db "fs cache was reset
",0
__2660:
 62039 db "reset",0
__2624:
 62045 db "blocks:
 %d free
 %d used
 %d total
",0
__2655:
 62082 db "off",0
__2617:
 62086 db "format: [%s]
",0
__2610:
 62100 db "filesystem not mounted, use "mount" or "cd"
",0
__2669:
 62145 db "fs cache is currently ",0
__2629:
 62168 db "blocks",0
__2622:
 62175 db "blocks @:   %d
",0
printKbs:
// printKbs(bytes)
 62191 enter -0
__2685:
__2687:
 62194 rstack EAX,EBP:2
 62198 mov EBX,1000000
 62201 sub EBX,EAX
 62203 neg EBX
 62205 fsgn EBX,EBX
 62207 max EBX,0
// if (bytes>1000000)
 62210 cmp 0,EBX
 62213 jge 62258
 62216 rstack EAX,EBP:2
 62220 div EAX,1000000
 62223 mov EBX,EAX
// floor arg #1 (float A)
 62225 push EBX
 62227 mov ECX,1
// floor(...)
 62230 call 30221
 62233 add ESP,1
// bytes=floor(bytes/1000000)
 62236 sstack EBP:2,EAX
 62240 rstack EAX,EBP:2
// printf arg #2 (unknown)
 62244 push EAX
// printf arg #1 (char* format)
 62246 push 62345
 62249 mov ECX,2
// printf(...)
 62252 call 21772
 62255 add ESP,2
__2688:
__2686:
__2691:
 62258 rstack EAX,EBP:2
 62262 mov EBX,1000
 62265 sub EBX,EAX
 62267 neg EBX
 62269 fsgn EBX,EBX
 62271 max EBX,0
// if (bytes>1000)
 62274 cmp 0,EBX
 62277 jge 62325
 62280 rstack EAX,EBP:2
 62284 div EAX,1000
 62287 mov EBX,EAX
// floor arg #1 (float A)
 62289 push EBX
 62291 mov ECX,1
// floor(...)
 62294 call 30221
 62297 add ESP,1
// bytes=floor(bytes/1000)
 62300 sstack EBP:2,EAX
 62304 rstack EAX,EBP:2
// printf arg #2 (unknown)
 62308 push EAX
// printf arg #1 (char* format)
 62310 push 62351
 62313 mov ECX,2
// printf(...)
 62316 call 21772
 62319 add ESP,2
 62322 jmp 62343
__2694:
__2692:
__2696:
 62325 rstack EAX,EBP:2
// printf arg #2 (unknown)
 62329 push EAX
// printf arg #1 (char* format)
 62331 push 62357
 62334 mov ECX,2
// printf(...)
 62337 call 21772
 62340 add ESP,2
__2695:
__2690:
__2684:
 62343 leave 
 62344 ret 
__2689:
 62345 db "%d Mb",0
__2693:
 62351 db "%d kb",0
__2697:
 62357 db "%d bytes",0
cmdDiag:
// cmdDiag(shell,argc,argv)
 62366 enter 9
__2699:
 62369 push 62950
 62372 mov ECX,1
// overstack_fenter(...)
 62375 call 65797
 62378 add ESP,1
 62381 sstack EBP:-1,EAX
// assert_type arg #2 (float t)
 62385 push 37328
 62388 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 62392 push EAX
 62394 mov ECX,2
// assert_type(...)
 62397 call 10123
 62400 add ESP,2
__2702:
 62403 rstack EAX,EBP:3
 62407 mov EBX,1
 62410 sub EBX,EAX
 62412 neg EBX
 62414 fsgn EBX,EBX
 62416 max EBX,0
// if (argc>1)
 62419 cmp 0,EBX
 62422 jge 62857
__2706:
// strcmp arg #2 (char* dest)
 62425 push 62944
 62428 rstack EAX,EBP:4
 62432 add EAX,1
 62435 mov EBX,EAX
// strcmp arg #1 (char* src)
 62437 push #EBX
 62439 mov ECX,2
// strcmp(...)
 62442 call 10763
 62445 add ESP,2
 62448 mov EBX,0
 62451 sub EBX,EAX
 62453 fabs EBX,EBX
 62455 fsgn EBX,EBX
 62457 lneg EBX
// if (strcmp(argv[1],"stack")==0)
 62459 cmp 0,EBX
 62462 jge 62551
// printf arg #1 (char* format)
 62465 push 62926
 62468 mov ECX,1
// printf(...)
 62471 call 21772
 62474 add ESP,1
 62477 mov ECX,0
// kernelSize(...)
 62480 call 85312
 62483 sstack EBP:-2,EAX
 62487 sstack EBP:-3,SS
 62491 sstack EBP:-4,ESP
 62495 rstack EAX,EBP:-4
// printf arg #4 (unknown)
 62499 push EAX
 62501 rstack EAX,EBP:-3
// printf arg #3 (unknown)
 62505 push EAX
 62507 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 62511 push EAX
// printf arg #1 (char* format)
 62513 push 63024
 62516 mov ECX,4
// printf(...)
 62519 call 21772
 62522 add ESP,4
 62525 push 62950
 62528 rstack EAX,EBP:-1
 62532 push EAX
 62534 mov ECX,2
// overstack_fexit(...)
 62537 call 65865
 62540 add ESP,2
 62543 mov EAX,1
 62546 leave 
 62547 ret 
 62548 jmp 62857
__2710:
__2707:
__2712:
__2715:
// strcmp arg #2 (char* dest)
 62551 push 62983
 62554 rstack EAX,EBP:4
 62558 add EAX,1
 62561 mov EBX,EAX
// strcmp arg #1 (char* src)
 62563 push #EBX
 62565 mov ECX,2
// strcmp(...)
 62568 call 10763
 62571 add ESP,2
 62574 mov EBX,0
 62577 sub EBX,EAX
 62579 fabs EBX,EBX
 62581 fsgn EBX,EBX
 62583 lneg EBX
// if (strcmp(argv[1],"heap")==0)
 62585 cmp 0,EBX
 62588 jge 62782
// printf arg #1 (char* format)
 62591 push 62966
 62594 mov ECX,1
// printf(...)
 62597 call 21772
 62600 add ESP,1
 62603 mov ECX,0
// malloc_test(...)
 62606 call 27100
 62609 sstack EBP:-5,EAX
__2719:
 62613 rstack EAX,EBP:-5
 62617 mov EBX,0
 62620 sub EBX,EAX
 62622 fabs EBX,EBX
 62624 fsgn EBX,EBX
 62626 lneg EBX
// if (res==0)
 62628 cmp 0,EBX
 62631 jge 62649
// printf arg #2 (unknown)
 62634 push 90
// printf arg #1 (char* format)
 62637 push 62908
 62640 mov ECX,2
// printf(...)
 62643 call 21772
 62646 add ESP,2
__2720:
__2718:
 62649 mov EAX,SS:EBP
 62652 add EAX,-9
// malloc_count arg #4 (float* usedcount)
 62655 push EAX
 62657 mov EAX,SS:EBP
 62660 add EAX,-8
// malloc_count arg #3 (float* freecount)
 62663 push EAX
 62665 mov EAX,SS:EBP
 62668 add EAX,-7
// malloc_count arg #2 (float* usedsize)
 62671 push EAX
 62673 mov EAX,SS:EBP
 62676 add EAX,-6
// malloc_count arg #1 (float* freesize)
 62679 push EAX
 62681 mov ECX,4
// malloc_count(...)
 62684 call 27440
 62687 add ESP,4
// printf arg #1 (char* format)
 62690 push 62988
 62693 mov ECX,1
// printf(...)
 62696 call 21772
 62699 add ESP,1
 62702 rstack EAX,EBP:-7
// printKbs arg #1 (float bytes)
 62706 push EAX
 62708 mov ECX,1
// printKbs(...)
 62711 call 62191
 62714 add ESP,1
// printf arg #1 (char* format)
 62717 push 62958
 62720 mov ECX,1
// printf(...)
 62723 call 21772
 62726 add ESP,1
 62729 rstack EAX,EBP:-6
// printKbs arg #1 (float bytes)
 62733 push EAX
 62735 mov ECX,1
// printKbs(...)
 62738 call 62191
 62741 add ESP,1
// printf arg #1 (char* format)
 62744 push 62995
 62747 mov ECX,1
// printf(...)
 62750 call 21772
 62753 add ESP,1
 62756 push 62950
 62759 rstack EAX,EBP:-1
 62763 push EAX
 62765 mov ECX,2
// overstack_fexit(...)
 62768 call 65865
 62771 add ESP,2
 62774 mov EAX,1
 62777 leave 
 62778 ret 
 62779 jmp 62857
__2725:
__2716:
__2727:
__2730:
// strcmp arg #2 (char* dest)
 62782 push 63019
 62785 rstack EAX,EBP:4
 62789 add EAX,1
 62792 mov EBX,EAX
// strcmp arg #1 (char* src)
 62794 push #EBX
 62796 mov ECX,2
// strcmp(...)
 62799 call 10763
 62802 add ESP,2
 62805 mov EBX,0
 62808 sub EBX,EAX
 62810 fabs EBX,EBX
 62812 fsgn EBX,EBX
 62814 lneg EBX
// if (strcmp(argv[1],"disk")==0)
 62816 cmp 0,EBX
 62819 jge 62857
// printf arg #1 (char* format)
 62822 push 63002
 62825 mov ECX,1
// printf(...)
 62828 call 21772
 62831 add ESP,1
 62834 push 62950
 62837 rstack EAX,EBP:-1
 62841 push EAX
 62843 mov ECX,2
// overstack_fexit(...)
 62846 call 65865
 62849 add ESP,2
 62852 mov EAX,1
 62855 leave 
 62856 ret 
__2731:
__2729:
__2726:
__2714:
__2711:
__2705:
__2703:
__2701:
 62857 rstack EAX,EBP:4
 62861 add EAX,0
 62864 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 62866 push #EBX
 62868 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 62872 push EAX
 62874 mov ECX,2
// cmdHelp2(...)
 62877 call 40759
 62880 add ESP,2
 62883 push 62950
 62886 rstack EAX,EBP:-1
 62890 push EAX
 62892 mov ECX,2
// overstack_fexit(...)
 62895 call 65865
 62898 add ESP,2
 62901 mov EAX,0
 62904 leave 
 62905 ret 
__2698:
 62906 leave 
 62907 ret 
__2721:
 62908 db "malloc test %mOK
",0
__2708:
 62926 db "stack diagnostic
",0
__2704:
 62944 db "stack",0
__2700:
 62950 db "cmdDiag",0
__2723:
 62958 db " used, ",0
__2717:
 62966 db "heap diagnostic
",0
__2713:
 62983 db "heap",0
__2722:
 62988 db "heap: ",0
__2724:
 62995 db " free
",0
__2732:
 63002 db "disk diagnostic
",0
__2728:
 63019 db "disk",0
__2709:
 63024 db "code size = %d
stack segment = %d
esp = %d
",0
cmdOverstack:
// cmdOverstack(shell,argc,argv)
 63068 enter 1
__2734:
 63071 push 63125
 63074 mov ECX,1
// overstack_fenter(...)
 63077 call 65797
 63080 add ESP,1
 63083 sstack EBP:-1,EAX
// printf arg #1 (char* format)
 63087 push 63138
 63090 mov ECX,1
// printf(...)
 63093 call 21772
 63096 add ESP,1
 63099 mov ECX,0
// overstack_trace(...)
 63102 call 66411
 63105 push 63125
 63108 rstack EAX,EBP:-1
 63112 push EAX
 63114 mov ECX,2
// overstack_fexit(...)
 63117 call 65865
 63120 add ESP,2
__2733:
 63123 leave 
 63124 ret 
__2735:
 63125 db "cmdOverstack",0
__2736:
 63138 db "overstack test:",0
cmdDump:
// cmdDump(shell,argc,argv)
 63154 enter 7
__2738:
// assert_type arg #2 (float t)
 63157 push 37328
 63160 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 63164 push EAX
 63166 mov ECX,2
// assert_type(...)
 63169 call 10123
 63172 add ESP,2
__2740:
 63175 rstack EAX,EBP:3
 63179 mov EBX,2
 63182 sub EBX,EAX
 63184 neg EBX
 63186 fsgn EBX,EBX
 63188 max EBX,0
// if (argc>2)
 63191 cmp 0,EBX
 63194 jge 63509
 63197 rstack EAX,EBP:4
 63201 add EAX,1
 63204 mov EBX,EAX
// str2num arg #1 (char* str)
 63206 push #EBX
 63208 mov ECX,1
// str2num(...)
 63211 call 12270
 63214 add ESP,1
 63217 sstack EBP:-1,EAX
 63221 rstack EAX,EBP:4
 63225 add EAX,2
 63228 mov EBX,EAX
 63230 sstack EBP:-2,#EBX
 63234 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 63238 push EAX
 63240 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 63244 push EAX
// printf arg #1 (char* format)
 63246 push 63550
 63249 mov ECX,3
// printf(...)
 63252 call 21772
 63255 add ESP,3
 63258 rstack EAX,EBP:-1
// EBcb_get_entry arg #2 (float num)
 63262 push EAX
// EBcb_get_entry arg #1 (float this)
 63264 push 66989
 63267 mov ECX,2
// EBcb_get_entry(...)
 63270 call 19801
 63273 add ESP,2
 63276 sstack EBP:-3,EAX
 63280 rstack EAX,EBP:-3
// EBcb_entry_get_addr arg #1 (float this)
 63284 push EAX
 63286 mov ECX,1
// EBcb_entry_get_addr(...)
 63289 call 19657
 63292 add ESP,1
 63295 sstack EBP:-4,EAX
 63299 rstack EAX,EBP:-4
 63303 add EAX,0
 63306 mov EBX,EAX
 63308 sstack EBP:-5,#EBX
 63312 rstack EAX,EBP:-5
// printf arg #2 (unknown)
 63316 push EAX
// printf arg #1 (char* format)
 63318 push 63625
 63321 mov ECX,2
// printf(...)
 63324 call 21772
 63327 add ESP,2
__2745:
 63330 rstack EAX,EBP:-5
 63334 mov EBX,5000
 63337 sub EBX,EAX
 63339 neg EBX
 63341 fsgn EBX,EBX
 63343 max EBX,0
 63346 rstack EAX,EBP:-5
 63350 mov ECX,0
 63353 sub ECX,EAX
 63355 fsgn ECX,ECX
 63357 max ECX,0
 63360 or ECX,EBX
// if ((psize<0)||(psize>5000))
 63362 cmp 0,ECX
 63365 jge 63385
// printf arg #1 (char* format)
 63368 push 63602
 63371 mov ECX,1
// printf(...)
 63374 call 21772
 63377 add ESP,1
 63380 mov EAX,1
 63383 leave 
 63384 ret 
__2746:
__2744:
// fopen arg #3 (float mode)
 63385 push 43179
 63388 rstack EAX,EBP:-2
// fopen arg #2 (float filepath)
 63392 push EAX
 63394 rstack EAX,EBP:2
// fopen arg #1 (float shell)
 63398 push EAX
 63400 mov ECX,3
// fopen(...)
 63403 call 53191
 63406 add ESP,3
 63409 sstack EBP:-6,EAX
__2749:
 63413 rstack EAX,EBP:-6
// if (fp)
 63417 cmp 0,EAX
 63420 jge 63438
// printf arg #1 (char* format)
 63423 push 63537
 63426 mov ECX,1
// printf(...)
 63429 call 21772
 63432 add ESP,1
 63435 jmp 63455
__2752:
__2750:
__2754:
// printf arg #1 (char* format)
 63438 push 59345
 63441 mov ECX,1
// printf(...)
 63444 call 21772
 63447 add ESP,1
 63450 mov EAX,1
 63453 leave 
 63454 ret 
__2753:
__2748:
 63455 rstack EAX,EBP:-6
// fwrite arg #3 (float fp)
 63459 push EAX
 63461 rstack EAX,EBP:-5
// fwrite arg #2 (float size)
 63465 push EAX
 63467 rstack EAX,EBP:-4
// fwrite arg #1 (float from)
 63471 push EAX
 63473 mov ECX,3
// fwrite(...)
 63476 call 52831
 63479 add ESP,3
 63482 sstack EBP:-7,EAX
 63486 rstack EAX,EBP:-7
// printf arg #2 (unknown)
 63490 push EAX
// printf arg #1 (char* format)
 63492 push 63580
 63495 mov ECX,2
// printf(...)
 63498 call 21772
 63501 add ESP,2
 63504 mov EAX,0
 63507 leave 
 63508 ret 
__2741:
__2739:
 63509 rstack EAX,EBP:4
 63513 add EAX,0
 63516 mov EBX,EAX
// cmdHelp2 arg #2 (float str_cmd)
 63518 push #EBX
 63520 rstack EAX,EBP:2
// cmdHelp2 arg #1 (float shell)
 63524 push EAX
 63526 mov ECX,2
// cmdHelp2(...)
 63529 call 40759
 63532 add ESP,2
__2737:
 63535 leave 
 63536 ret 
__2751:
 63537 db "file opened
",0
__2742:
 63550 db "dumping device %d to file %s
",0
__2755:
 63580 db "wrote %d bytes, done
",0
__2747:
 63602 db "file too large, abort
",0
__2743:
 63625 db "file size = %d
",0
libmarker18:
 63641 db 0
typeof_page_manager:
 63642 db "page_manager",0
sizeof_page_manager:
 63655 db 3
page_manager_constructor:
// page_manager_constructor(self)
 63656 enter 2
__2757:
 63659 rstack EAX,EBP:2
 63663 add EAX,0
 63666 mov EBX,EAX
// self[0]=typeof_page_manager
 63668 mov #EBX,63642
// malloc arg #1 (float n)
 63671 push #31358
 63674 mov ECX,1
// malloc(...)
 63677 call 28486
 63680 add ESP,1
 63683 sstack EBP:-1,EAX
// vector_constructor arg #2 (float element_size)
 63687 push 2
 63690 rstack EAX,EBP:-1
// vector_constructor arg #1 (void* self)
 63694 push EAX
 63696 mov ECX,2
// vector_constructor(...)
 63699 call 31359
 63702 add ESP,2
 63705 rstack EAX,EBP:-1
 63709 rstack EBX,EBP:2
 63713 add EBX,1
 63716 mov ECX,EBX
// self[1]=V
 63718 mov #ECX,EAX
 63720 rstack EAX,EBP:-1
// vector_array arg #1 (void* self)
 63724 push EAX
 63726 mov ECX,1
// vector_array(...)
 63729 call 34499
 63732 add ESP,1
 63735 sstack EBP:-2,EAX
 63739 rstack EAX,EBP:-2
 63743 rstack EBX,EBP:2
 63747 add EBX,2
 63750 mov ECX,EBX
// self[2]=PT
 63752 mov #ECX,EAX
__2756:
 63754 leave 
 63755 ret 
page_manager_assign_default_page:
// page_manager_assign_default_page(PM,page)
 63756 enter 2
__2759:
// assert_type arg #2 (float t)
 63759 push 63642
 63762 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 63766 push EAX
 63768 mov ECX,2
// assert_type(...)
 63771 call 10123
 63774 add ESP,2
 63777 rstack EAX,EBP:2
 63781 add EAX,2
 63784 mov EBX,EAX
 63786 sstack EBP:-1,#EBX
 63790 rstack EAX,EBP:-1
 63794 add EAX,0
 63797 mov EBX,EAX
 63799 sstack EBP:-2,EBX
 63803 rstack EAX,EBP:3
 63807 add EAX,0
 63810 mov EBX,EAX
 63812 rstack EAX,EBP:-2
 63816 add EAX,0
 63819 mov ECX,EAX
// dpage[0]=page[0]
 63821 mov #ECX,#EBX
 63823 rstack EAX,EBP:3
 63827 add EAX,1
 63830 mov EBX,EAX
 63832 rstack EAX,EBP:-2
 63836 add EAX,1
 63839 mov ECX,EAX
// dpage[1]=page[1]
 63841 mov #ECX,#EBX
__2758:
 63843 leave 
 63844 ret 
page_manager_check_size:
// page_manager_check_size(PM,maxpage)
 63845 enter 4
__2761:
// assert_type arg #2 (float t)
 63848 push 63642
 63851 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 63855 push EAX
 63857 mov ECX,2
// assert_type(...)
 63860 call 10123
 63863 add ESP,2
 63866 rstack EAX,EBP:2
 63870 add EAX,1
 63873 mov EBX,EAX
 63875 sstack EBP:-1,#EBX
 63879 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 63883 push EAX
 63885 mov ECX,1
// vector_size(...)
 63888 call 32667
 63891 add ESP,1
 63894 sstack EBP:-2,EAX
 63898 rstack EAX,EBP:3
 63902 add EAX,1
 63905 mov EBX,EAX
 63907 sstack EBP:-3,EBX
__2763:
 63911 rstack EAX,EBP:-2
 63915 rstack EBX,EBP:-3
 63919 sub EBX,EAX
 63921 mov EAX,EBX
 63923 fsgn EAX,EAX
 63925 max EAX,0
// if (Vsize<needSize)
 63928 cmp 0,EAX
 63931 jge 63989
 63934 rstack EAX,EBP:-3
// vector_resize arg #2 (float newsize)
 63938 push EAX
 63940 rstack EAX,EBP:-1
// vector_resize arg #1 (void* self)
 63944 push EAX
 63946 mov ECX,2
// vector_resize(...)
 63949 call 34319
 63952 add ESP,2
 63955 rstack EAX,EBP:-1
// vector_array arg #1 (void* self)
 63959 push EAX
 63961 mov ECX,1
// vector_array(...)
 63964 call 34499
 63967 add ESP,1
 63970 sstack EBP:-4,EAX
 63974 rstack EAX,EBP:-4
 63978 rstack EBX,EBP:2
 63982 add EBX,2
 63985 mov ECX,EBX
// PM[2]=PT
 63987 mov #ECX,EAX
__2764:
__2762:
__2760:
 63989 leave 
 63990 ret 
page_manager_assign_page_range:
// page_manager_assign_page_range(PM,page,pn_from,pn_to)
 63991 enter 4
__2766:
// assert_type arg #2 (float t)
 63994 push 63642
 63997 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 64001 push EAX
 64003 mov ECX,2
// assert_type(...)
 64006 call 10123
 64009 add ESP,2
 64012 rstack EAX,EBP:2
 64016 add EAX,1
 64019 mov EBX,EAX
 64021 sstack EBP:-1,#EBX
 64025 rstack EAX,EBP:5
 64029 add EAX,1
 64032 mov EBX,EAX
// pn_to=pn_to+1
 64034 sstack EBP:5,EBX
 64038 rstack EAX,EBP:5
// page_manager_check_size arg #2 (float maxpage)
 64042 push EAX
 64044 rstack EAX,EBP:2
// page_manager_check_size arg #1 (float PM)
 64048 push EAX
 64050 mov ECX,2
// page_manager_check_size(...)
 64053 call 63845
 64056 add ESP,2
 64059 rstack EAX,EBP:2
 64063 add EAX,2
 64066 mov EBX,EAX
 64068 sstack EBP:-2,#EBX
 64072 rstack EAX,EBP:4
// init loop
 64076 sstack EBP:-3,EAX
__2768:
 64080 rstack EAX,EBP:-3
 64084 rstack EBX,EBP:5
 64088 sub EBX,EAX
 64090 mov EAX,EBX
 64092 fsgn EAX,EAX
// condition
 64094 max EAX,0
 64097 cmp 0,EAX
 64100 jz 64180
 64103 rstack EAX,EBP:-3
 64107 add EAX,1
 64110 mov EBX,EAX
 64112 mul EBX,2
 64115 rstack EAX,EBP:-2
 64119 add EAX,EBX
 64121 mov EBX,EAX
 64123 sstack EBP:-4,EBX
 64127 rstack EAX,EBP:3
 64131 add EAX,0
 64134 mov EBX,EAX
 64136 rstack EAX,EBP:-4
 64140 add EAX,0
 64143 mov ECX,EAX
// pt_page[0]=page[0]
 64145 mov #ECX,#EBX
 64147 rstack EAX,EBP:3
 64151 add EAX,1
 64154 mov EBX,EAX
 64156 rstack EAX,EBP:-4
 64160 add EAX,1
 64163 mov ECX,EAX
// pt_page[1]=page[1]
 64165 mov #ECX,#EBX
 64167 rstack EAX,EBP:-3
// loop step
 64171 inc EAX
 64173 sstack EBP:-3,EAX
 64177 jmp 64080
__2767:
__2765:
 64180 leave 
 64181 ret 
page_manager_map_1_to_1:
// page_manager_map_1_to_1(PM,pn_from,pn_to)
 64182 enter 3
__2770:
// assert_type arg #2 (float t)
 64185 push 63642
 64188 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 64192 push EAX
 64194 mov ECX,2
// assert_type(...)
 64197 call 10123
 64200 add ESP,2
 64203 rstack EAX,EBP:4
 64207 add EAX,1
 64210 mov EBX,EAX
// pn_to=pn_to+1
 64212 sstack EBP:4,EBX
 64216 rstack EAX,EBP:4
// page_manager_check_size arg #2 (float maxpage)
 64220 push EAX
 64222 rstack EAX,EBP:2
// page_manager_check_size arg #1 (float PM)
 64226 push EAX
 64228 mov ECX,2
// page_manager_check_size(...)
 64231 call 63845
 64234 add ESP,2
 64237 rstack EAX,EBP:2
 64241 add EAX,2
 64244 mov EBX,EAX
 64246 sstack EBP:-1,#EBX
 64250 rstack EAX,EBP:3
// init loop
 64254 sstack EBP:-2,EAX
__2772:
 64258 rstack EAX,EBP:-2
 64262 rstack EBX,EBP:4
 64266 sub EBX,EAX
 64268 mov EAX,EBX
 64270 fsgn EAX,EAX
// condition
 64272 max EAX,0
 64275 cmp 0,EAX
 64278 jz 64333
 64281 rstack EAX,EBP:-2
 64285 add EAX,1
 64288 mov EBX,EAX
 64290 mul EBX,2
 64293 rstack EAX,EBP:-1
 64297 add EAX,EBX
 64299 mov EBX,EAX
 64301 sstack EBP:-3,EBX
 64305 rstack EAX,EBP:-2
 64309 rstack EBX,EBP:-3
 64313 add EBX,1
 64316 mov ECX,EBX
// page[1]=I
 64318 mov #ECX,EAX
 64320 rstack EAX,EBP:-2
// loop step
 64324 inc EAX
 64326 sstack EBP:-2,EAX
 64330 jmp 64258
__2771:
__2769:
 64333 leave 
 64334 ret 
page_manager_activate:
// page_manager_activate(PM)
 64335 enter 4
__2774:
// assert_type arg #2 (float t)
 64338 push 63642
 64341 rstack EAX,EBP:2
// assert_type arg #1 (float self)
 64345 push EAX
 64347 mov ECX,2
// assert_type(...)
 64350 call 10123
 64353 add ESP,2
 64356 rstack EAX,EBP:2
 64360 add EAX,1
 64363 mov EBX,EAX
 64365 sstack EBP:-1,#EBX
 64369 rstack EAX,EBP:-1
// vector_size arg #1 (void* self)
 64373 push EAX
 64375 mov ECX,1
// vector_size(...)
 64378 call 32667
 64381 add ESP,1
 64384 sstack EBP:-2,EAX
 64388 rstack EAX,EBP:-2
 64392 sstack EBP:-3,EAX
 64396 rstack EAX,EBP:2
 64400 add EAX,2
 64403 mov EBX,EAX
 64405 sstack EBP:-4,#EBX
 64409 rstack EAX,EBP:-3
// setPageTable arg #2 (float size)
 64413 push EAX
 64415 rstack EAX,EBP:-4
// setPageTable arg #1 (float PT)
 64419 push EAX
 64421 mov ECX,2
// setPageTable(...)
 64424 call 36335
 64427 add ESP,2
__2773:
 64430 leave 
 64431 ret 
libmarker19:
 64432 db 0
getIntStackTrace:
// getIntStackTrace(buff)
 64433 enter 5
__2776:
 64436 sstack EBP:-1,EBP
 64440 rstack EAX,EBP:-1
 64444 add EAX,1
 64447 mov EBX,EAX
 64449 sstack EBP:-2,EBX
 64453 rstack EAX,EBP:-2
 64457 mov EBX,SS
 64459 add EBX,EAX
 64461 sstack EBP:-3,#EBX
 64465 rstack EAX,EBP:-3
 64469 rstack EBX,EBP:2
 64473 add EBX,0
 64476 mov ECX,EBX
// buff[0]=PrevIP
 64478 mov #ECX,EAX
 64480 rstack EAX,EBP:-1
 64484 mov EBX,SS
 64486 add EBX,EAX
 64488 sstack EBP:-4,#EBX
 64492 rstack EAX,EBP:-4
// pEBP=PrevEBP
 64496 sstack EBP:-1,EAX
 64500 rstack EAX,EBP:-1
 64504 add EAX,2
 64507 mov EBX,EAX
// pPrevIP=pEBP+2
 64509 sstack EBP:-2,EBX
 64513 sstack EBP:-5,1
__2778:
 64518 rstack EAX,EBP:-5
 64522 mov EBX,80
 64525 sub EBX,EAX
 64527 fsgn EBX,EBX
 64529 max EBX,0
// if (I<80
 64532 cmp 0,EBX
 64535 jz 64638
 64538 rstack EAX,EBP:-2
 64542 mov EBX,SS
 64544 add EBX,EAX
// PrevIP=*(SS+pPrevIP)
 64546 sstack EBP:-3,#EBX
 64550 rstack EAX,EBP:-1
 64554 mov EBX,SS
 64556 add EBX,EAX
// PrevEBP=*(SS+pEBP)
 64558 sstack EBP:-4,#EBX
 64562 rstack EAX,EBP:-3
 64566 rstack EBX,EBP:-5
 64570 rstack ECX,EBP:2
 64574 add ECX,EBX
 64576 mov EBX,ECX
// buff[I]=PrevIP
 64578 mov #EBX,EAX
 64580 rstack EAX,EBP:-5
// I++
 64584 inc EAX
 64586 sstack EBP:-5,EAX
__2780:
 64590 rstack EAX,EBP:-4
 64594 mov EBX,0
 64597 sub EBX,EAX
 64599 fabs EBX,EBX
 64601 fsgn EBX,EBX
 64603 lneg EBX
// if (PrevEBP==0)
 64605 cmp 0,EBX
 64608 jge 64614
 64611 jmp 64638
__2781:
__2779:
 64614 rstack EAX,EBP:-4
// pEBP=PrevEBP
 64618 sstack EBP:-1,EAX
 64622 rstack EAX,EBP:-1
 64626 add EAX,1
 64629 mov EBX,EAX
// pPrevIP=pEBP+1
 64631 sstack EBP:-2,EBX
 64635 jmp 64518
__2777:
 64638 rstack EAX,EBP:-5
 64642 rstack EBX,EBP:2
 64646 add EBX,EAX
 64648 mov EAX,EBX
// buff[I]=0
 64650 mov #EAX,0
__2775:
 64653 leave 
 64654 ret 
getStackTrace:
// getStackTrace(buff)
 64655 enter 5
__2783:
 64658 sstack EBP:-1,EBP
 64662 rstack EAX,EBP:-1
 64666 add EAX,1
 64669 mov EBX,EAX
 64671 sstack EBP:-2,EBX
 64675 sstack EBP:-3,0
__2785:
 64680 rstack EAX,EBP:-3
 64684 mov EBX,80
 64687 sub EBX,EAX
 64689 fsgn EBX,EBX
 64691 max EBX,0
// if (I<80
 64694 cmp 0,EBX
 64697 jz 64800
 64700 rstack EAX,EBP:-2
 64704 mov EBX,SS
 64706 add EBX,EAX
 64708 sstack EBP:-4,#EBX
 64712 rstack EAX,EBP:-1
 64716 mov EBX,SS
 64718 add EBX,EAX
 64720 sstack EBP:-5,#EBX
 64724 rstack EAX,EBP:-4
 64728 rstack EBX,EBP:-3
 64732 rstack ECX,EBP:2
 64736 add ECX,EBX
 64738 mov EBX,ECX
// buff[I]=PrevIP
 64740 mov #EBX,EAX
 64742 rstack EAX,EBP:-3
// I++
 64746 inc EAX
 64748 sstack EBP:-3,EAX
__2787:
 64752 rstack EAX,EBP:-5
 64756 mov EBX,0
 64759 sub EBX,EAX
 64761 fabs EBX,EBX
 64763 fsgn EBX,EBX
 64765 lneg EBX
// if (PrevEBP==0)
 64767 cmp 0,EBX
 64770 jge 64776
 64773 jmp 64800
__2788:
__2786:
 64776 rstack EAX,EBP:-5
// pEBP=PrevEBP
 64780 sstack EBP:-1,EAX
 64784 rstack EAX,EBP:-1
 64788 add EAX,1
 64791 mov EBX,EAX
// pPrevIP=pEBP+1
 64793 sstack EBP:-2,EBX
 64797 jmp 64680
__2784:
 64800 rstack EAX,EBP:-3
 64804 rstack EBX,EBP:2
 64808 add EBX,EAX
 64810 mov EAX,EBX
// buff[I]=0
 64812 mov #EAX,0
__2782:
 64815 leave 
 64816 ret 
printStackTrace:
// printStackTrace(buff)
 64817 enter 5
__2790:
// printf arg #1 (char* format)
 64820 push 64983
 64823 mov ECX,1
// printf(...)
 64826 call 21772
 64829 add ESP,1
 64832 sstack EBP:-1,0
__2793:
 64837 rstack EAX,EBP:-1
 64841 rstack EBX,EBP:2
 64845 add EBX,EAX
 64847 mov EAX,EBX
 64849 mov EBX,0
 64852 sub EBX,#EAX
 64854 fabs EBX,EBX
 64856 fsgn EBX,EBX
// if (buff[I]!=0
 64858 cmp 0,EBX
 64861 jz 64981
 64864 rstack EAX,EBP:-1
 64868 rstack EBX,EBP:2
 64872 add EBX,EAX
 64874 mov EAX,EBX
// fIP=buff[I]
 64876 sstack EBP:-2,#EAX
 64880 rstack EAX,EBP:-2
 64884 push EAX
 64886 mov ECX,1
// findClosestFunc(...)
 64889 call 65008
 64892 add ESP,1
 64895 sstack EBP:-3,EAX
 64899 rstack EAX,EBP:-3
 64903 push EAX
 64905 mov ECX,1
// getFuncName(...)
 64908 call 65182
 64911 add ESP,1
 64914 sstack EBP:-4,EAX
 64918 rstack EAX,EBP:-3
 64922 neg EAX
 64924 mov EBX,EAX
 64926 rstack EAX,EBP:-2
 64930 add EAX,EBX
 64932 mov EBX,EAX
 64934 sstack EBP:-5,EBX
 64938 rstack EAX,EBP:-5
// printf arg #4 (unknown)
 64942 push EAX
 64944 rstack EAX,EBP:-4
// printf arg #3 (unknown)
 64948 push EAX
 64950 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 64954 push EAX
// printf arg #1 (char* format)
 64956 push 64996
 64959 mov ECX,4
// printf(...)
 64962 call 21772
 64965 add ESP,4
 64968 rstack EAX,EBP:-1
// I++
 64972 inc EAX
 64974 sstack EBP:-1,EAX
 64978 jmp 64837
__2792:
__2789:
 64981 leave 
 64982 ret 
__2791:
 64983 db "call trace:
",0
__2794:
 64996 db "%d: %s +%d
",0
findClosestFunc:
// findClosestFunc(fIP)
 65008 enter 5
__2796:
__2798:
 65011 rstack EAX,EBP:2
 65015 lneg EAX
 65017 mov EBX,EAX
// if (!fIP)
 65019 cmp 0,EBX
 65022 jge 65030
 65025 mov EAX,0
 65028 leave 
 65029 ret 
__2799:
__2797:
 65030 sstack EBP:-1,0
 65035 sstack EBP:-2,9999999
 65040 sstack EBP:-3,85322
__2801:
 65045 rstack EAX,EBP:-3
 65049 mov EBX,85394
 65052 sub EBX,EAX
 65054 fsgn EBX,EBX
 65056 max EBX,0
// if (ptr<func_table_end
 65059 cmp 0,EBX
 65062 jz 65174
 65065 rstack EAX,EBP:-3
 65069 add EAX,0
 65072 mov EBX,EAX
 65074 sstack EBP:-4,#EBX
__2803:
 65078 rstack EAX,EBP:-4
 65082 rstack EBX,EBP:2
 65086 sub EBX,EAX
 65088 mov EAX,EBX
 65090 fsgn EAX,EAX
 65092 max EAX,0
// if (f2<fIP)
 65095 cmp 0,EAX
 65098 jge 65160
 65101 rstack EAX,EBP:-4
 65105 neg EAX
 65107 mov EBX,EAX
 65109 rstack EAX,EBP:2
 65113 add EAX,EBX
 65115 mov EBX,EAX
 65117 sstack EBP:-5,EBX
__2806:
 65121 rstack EAX,EBP:-5
 65125 rstack EBX,EBP:-2
 65129 sub EBX,EAX
 65131 mov EAX,EBX
 65133 fsgn EAX,EAX
 65135 max EAX,0
// if (diff<bestdiff)
 65138 cmp 0,EAX
 65141 jge 65160
 65144 rstack EAX,EBP:-5
// bestdiff=diff
 65148 sstack EBP:-2,EAX
 65152 rstack EAX,EBP:-4
// bestf=f2
 65156 sstack EBP:-1,EAX
__2807:
__2805:
__2804:
__2802:
 65160 rstack EAX,EBP:-3
// ptr+=2
 65164 add EAX,2
 65167 sstack EBP:-3,EAX
 65171 jmp 65045
__2800:
 65174 rstack EAX,EBP:-1
 65178 leave 
 65179 ret 
__2795:
 65180 leave 
 65181 ret 
getFuncName:
// getFuncName(fIP)
 65182 enter 1
__2809:
__2811:
 65185 rstack EAX,EBP:2
 65189 lneg EAX
 65191 mov EBX,EAX
// if (!fIP)
 65193 cmp 0,EBX
 65196 jge 65204
 65199 mov EAX,0
 65202 leave 
 65203 ret 
__2812:
__2810:
 65204 sstack EBP:-1,85322
__2814:
 65209 rstack EAX,EBP:-1
 65213 mov EBX,85394
 65216 sub EBX,EAX
 65218 fsgn EBX,EBX
 65220 max EBX,0
// if (ptr<func_table_end
 65223 cmp 0,EBX
 65226 jz 65285
__2816:
 65229 rstack EAX,EBP:-1
 65233 add EAX,0
 65236 mov EBX,EAX
 65238 rstack EAX,EBP:2
 65242 sub EAX,#EBX
 65244 mov EBX,EAX
 65246 fabs EBX,EBX
 65248 fsgn EBX,EBX
 65250 lneg EBX
// if (ptr[0]==fIP)
 65252 cmp 0,EBX
 65255 jge 65271
 65258 rstack EAX,EBP:-1
 65262 add EAX,1
 65265 mov EBX,EAX
 65267 mov EAX,#EBX
 65269 leave 
 65270 ret 
__2817:
__2815:
 65271 rstack EAX,EBP:-1
// ptr+=2
 65275 add EAX,2
 65278 sstack EBP:-1,EAX
 65282 jmp 65209
__2813:
 65285 mov EAX,0
 65288 leave 
 65289 ret 
__2808:
 65290 leave 
 65291 ret 
getVarName:
// getVarName(vIP)
 65292 enter 1
__2819:
__2821:
 65295 rstack EAX,EBP:2
 65299 lneg EAX
 65301 mov EBX,EAX
// if (!vIP)
 65303 cmp 0,EBX
 65306 jge 65314
 65309 mov EAX,0
 65312 leave 
 65313 ret 
__2822:
__2820:
 65314 sstack EBP:-1,85394
__2824:
 65319 rstack EAX,EBP:-1
 65323 mov EBX,85416
 65326 sub EBX,EAX
 65328 fsgn EBX,EBX
 65330 max EBX,0
// if (ptr<var_table_end
 65333 cmp 0,EBX
 65336 jz 65395
__2826:
 65339 rstack EAX,EBP:-1
 65343 add EAX,0
 65346 mov EBX,EAX
 65348 rstack EAX,EBP:2
 65352 sub EAX,#EBX
 65354 mov EBX,EAX
 65356 fabs EBX,EBX
 65358 fsgn EBX,EBX
 65360 lneg EBX
// if (ptr[0]==vIP)
 65362 cmp 0,EBX
 65365 jge 65381
 65368 rstack EAX,EBP:-1
 65372 add EAX,1
 65375 mov EBX,EAX
 65377 mov EAX,#EBX
 65379 leave 
 65380 ret 
__2827:
__2825:
 65381 rstack EAX,EBP:-1
// ptr+=2
 65385 add EAX,2
 65388 sstack EBP:-1,EAX
 65392 jmp 65319
__2823:
 65395 mov EAX,0
 65398 leave 
 65399 ret 
__2818:
 65400 leave 
 65401 ret 
getSymbolName:
// getSymbolName(sIP)
 65402 enter 1
__2829:
 65405 rstack EAX,EBP:2
// getFuncName arg #1 (float fIP)
 65409 push EAX
 65411 mov ECX,1
// getFuncName(...)
 65414 call 65182
 65417 add ESP,1
 65420 sstack EBP:-1,EAX
__2831:
 65424 rstack EAX,EBP:-1
 65428 lneg EAX
 65430 mov EBX,EAX
// if (!name)
 65432 cmp 0,EBX
 65435 jge 65457
 65438 rstack EAX,EBP:2
// getVarName arg #1 (float vIP)
 65442 push EAX
 65444 mov ECX,1
// getVarName(...)
 65447 call 65292
 65450 add ESP,1
// name=getVarName(sIP)
 65453 sstack EBP:-1,EAX
__2832:
__2830:
 65457 rstack EAX,EBP:-1
 65461 leave 
 65462 ret 
__2828:
 65463 leave 
 65464 ret 
findSymbolByName:
// findSymbolByName(name)
 65465 enter 1
__2834:
 65468 rstack EAX,EBP:2
 65472 push EAX
 65474 mov ECX,1
// findFuncByName(...)
 65477 call 65535
 65480 add ESP,1
 65483 sstack EBP:-1,EAX
__2836:
 65487 rstack EAX,EBP:-1
 65491 mov EBX,-1
 65494 sub EBX,EAX
 65496 fabs EBX,EBX
 65498 fsgn EBX,EBX
 65500 lneg EBX
// if (def==-1)
 65502 cmp 0,EBX
 65505 jge 65527
 65508 rstack EAX,EBP:2
 65512 push EAX
 65514 mov ECX,1
// findVarByName(...)
 65517 call 65648
 65520 add ESP,1
// def=findVarByName(name)
 65523 sstack EBP:-1,EAX
__2837:
__2835:
 65527 rstack EAX,EBP:-1
 65531 leave 
 65532 ret 
__2833:
 65533 leave 
 65534 ret 
findFuncByName:
// findFuncByName(name)
 65535 enter 2
__2839:
 65538 sstack EBP:-1,85322
__2841:
 65543 rstack EAX,EBP:-1
 65547 mov EBX,85394
 65550 sub EBX,EAX
 65552 fsgn EBX,EBX
 65554 max EBX,0
// if (ptr<func_table_end
 65557 cmp 0,EBX
 65560 jz 65641
 65563 rstack EAX,EBP:-1
 65567 add EAX,1
 65570 mov EBX,EAX
 65572 sstack EBP:-2,#EBX
__2843:
 65576 rstack EAX,EBP:2
// strcmp arg #2 (char* dest)
 65580 push EAX
 65582 rstack EAX,EBP:-2
// strcmp arg #1 (char* src)
 65586 push EAX
 65588 mov ECX,2
// strcmp(...)
 65591 call 10763
 65594 add ESP,2
 65597 mov EBX,0
 65600 sub EBX,EAX
 65602 fabs EBX,EBX
 65604 fsgn EBX,EBX
 65606 lneg EBX
// if (strcmp(name2,name)==0)
 65608 cmp 0,EBX
 65611 jge 65627
 65614 rstack EAX,EBP:-1
 65618 add EAX,0
 65621 mov EBX,EAX
 65623 mov EAX,#EBX
 65625 leave 
 65626 ret 
__2844:
__2842:
 65627 rstack EAX,EBP:-1
// ptr+=2
 65631 add EAX,2
 65634 sstack EBP:-1,EAX
 65638 jmp 65543
__2840:
 65641 mov EAX,-1
 65644 leave 
 65645 ret 
__2838:
 65646 leave 
 65647 ret 
findVarByName:
// findVarByName(name)
 65648 enter 2
__2846:
 65651 sstack EBP:-1,85394
__2848:
 65656 rstack EAX,EBP:-1
 65660 mov EBX,85416
 65663 sub EBX,EAX
 65665 fsgn EBX,EBX
 65667 max EBX,0
// if (ptr<var_table_end
 65670 cmp 0,EBX
 65673 jz 65754
 65676 rstack EAX,EBP:-1
 65680 add EAX,1
 65683 mov EBX,EAX
 65685 sstack EBP:-2,#EBX
__2850:
 65689 rstack EAX,EBP:2
// strcmp arg #2 (char* dest)
 65693 push EAX
 65695 rstack EAX,EBP:-2
// strcmp arg #1 (char* src)
 65699 push EAX
 65701 mov ECX,2
// strcmp(...)
 65704 call 10763
 65707 add ESP,2
 65710 mov EBX,0
 65713 sub EBX,EAX
 65715 fabs EBX,EBX
 65717 fsgn EBX,EBX
 65719 lneg EBX
// if (strcmp(name2,name)==0)
 65721 cmp 0,EBX
 65724 jge 65740
 65727 rstack EAX,EBP:-1
 65731 add EAX,0
 65734 mov EBX,EAX
 65736 mov EAX,#EBX
 65738 leave 
 65739 ret 
__2851:
__2849:
 65740 rstack EAX,EBP:-1
// ptr+=2
 65744 add EAX,2
 65747 sstack EBP:-1,EAX
 65751 jmp 65656
__2847:
 65754 mov EAX,-1
 65757 leave 
 65758 ret 
__2845:
 65759 leave 
 65760 ret 
libmarker20:
 65761 db 0
overstack_init:
// overstack_init()
 65762 enter -0
__2853:
// malloc arg #1 (float n)
 65765 push #31358
 65768 mov ECX,1
// malloc(...)
 65771 call 28486
 65774 add ESP,1
// overstack_func_stack=malloc(sizeof_vector)
 65777 mov #66988,EAX
// vector_constructor arg #2 (float element_size)
 65780 push 1
// vector_constructor arg #1 (void* self)
 65783 push #66988
 65786 mov ECX,2
// vector_constructor(...)
 65789 call 31359
 65792 add ESP,2
__2852:
 65795 leave 
 65796 ret 
overstack_fenter:
// overstack_fenter(name)
 65797 enter 1
__2855:
__2857:
 65800 mov EAX,0
 65803 sub EAX,#66988
 65806 fabs EAX,EAX
 65808 fsgn EAX,EAX
 65810 lneg EAX
// if (overstack_func_stack==0)
 65812 cmp 0,EAX
 65815 jge 65823
 65818 mov EAX,0
 65821 leave 
 65822 ret 
__2858:
__2856:
 65823 rstack EAX,EBP:2
// vector_push arg #2 (void* element)
 65827 push EAX
// vector_push arg #1 (void* self)
 65829 push #66988
 65832 mov ECX,2
// vector_push(...)
 65835 call 32078
 65838 add ESP,2
// vector_size arg #1 (void* self)
 65841 push #66988
 65844 mov ECX,1
// vector_size(...)
 65847 call 32667
 65850 add ESP,1
 65853 sstack EBP:-1,EAX
 65857 rstack EAX,EBP:-1
 65861 leave 
 65862 ret 
__2854:
 65863 leave 
 65864 ret 
overstack_fexit:
// overstack_fexit(name,pos)
 65865 enter 4
__2860:
__2862:
 65868 mov EAX,0
 65871 sub EAX,#66988
 65874 fabs EAX,EAX
 65876 fsgn EAX,EAX
 65878 lneg EAX
// if (overstack_func_stack==0)
 65880 cmp 0,EAX
 65883 jge 65891
 65886 mov EAX,0
 65889 leave 
 65890 ret 
__2863:
__2861:
// vector_size arg #1 (void* self)
 65891 push #66988
 65894 mov ECX,1
// vector_size(...)
 65897 call 32667
 65900 add ESP,1
 65903 sstack EBP:-1,EAX
 65907 rstack EAX,EBP:-1
 65911 add EAX,-1
 65914 mov EBX,EAX
 65916 sstack EBP:-2,EBX
__2865:
 65920 rstack EAX,EBP:3
 65924 rstack EBX,EBP:-2
 65928 sub EBX,EAX
 65930 mov EAX,EBX
 65932 fsgn EAX,EAX
 65934 inc EAX
 65936 max EAX,0
// if (pos<=last)
 65939 cmp 0,EAX
 65942 jge 66142
__2868:
 65945 rstack EAX,EBP:3
 65949 rstack EBX,EBP:-2
 65953 sub EBX,EAX
 65955 mov EAX,EBX
 65957 fabs EAX,EAX
 65959 fsgn EAX,EAX
 65961 lneg EAX
// if (pos==last)
 65963 cmp 0,EAX
 65966 jge 66080
 65969 rstack EAX,EBP:3
// vector_get arg #3 (float pos)
 65973 push EAX
// vector_get arg #2 (void* element)
 65975 push 0
// vector_get arg #1 (void* self)
 65978 push #66988
 65981 mov ECX,3
// vector_get(...)
 65984 call 32750
 65987 add ESP,3
 65990 sstack EBP:-3,EAX
__2871:
 65994 rstack EAX,EBP:2
 65998 rstack EBX,EBP:-3
 66002 sub EBX,EAX
 66004 mov EAX,EBX
 66006 fabs EAX,EAX
 66008 fsgn EAX,EAX
 66010 lneg EAX
// if (name==name2)
 66012 cmp 0,EAX
 66015 jge 66038
// vector_pop arg #1 (void* self)
 66018 push #66988
 66021 mov ECX,1
// vector_pop(...)
 66024 call 32428
 66027 add ESP,1
 66030 mov EAX,0
 66033 leave 
 66034 ret 
 66035 jmp 66077
__2873:
__2872:
__2875:
 66038 rstack EAX,EBP:-3
// printf arg #4 (unknown)
 66042 push EAX
 66044 rstack EAX,EBP:2
// printf arg #3 (unknown)
 66048 push EAX
// printf arg #2 (unknown)
 66050 push 900
// printf arg #1 (char* format)
 66053 push 66322
 66056 mov ECX,4
// printf(...)
 66059 call 21772
 66062 add ESP,4
 66065 push 66299
 66068 mov ECX,1
// overstack_error(...)
 66071 call 66369
 66074 add ESP,1
__2874:
__2870:
 66077 jmp 66139
__2878:
__2869:
__2880:
 66080 rstack EAX,EBP:3
 66084 neg EAX
 66086 mov EBX,EAX
 66088 rstack EAX,EBP:-2
 66092 add EAX,EBX
 66094 mov EBX,EAX
 66096 sstack EBP:-4,EBX
 66100 rstack EAX,EBP:-4
// printf arg #4 (unknown)
 66104 push EAX
 66106 rstack EAX,EBP:2
// printf arg #3 (unknown)
 66110 push EAX
// printf arg #2 (unknown)
 66112 push 900
// printf arg #1 (char* format)
 66115 push 66244
 66118 mov ECX,4
// printf(...)
 66121 call 21772
 66124 add ESP,4
 66127 push 66299
 66130 mov ECX,1
// overstack_error(...)
 66133 call 66369
 66136 add ESP,1
__2879:
__2867:
 66139 jmp 66187
__2882:
__2866:
__2884:
 66142 rstack EAX,EBP:-2
// printf arg #5 (unknown)
 66146 push EAX
 66148 rstack EAX,EBP:3
// printf arg #4 (unknown)
 66152 push EAX
 66154 rstack EAX,EBP:2
// printf arg #3 (unknown)
 66158 push EAX
// printf arg #2 (unknown)
 66160 push 900
// printf arg #1 (char* format)
 66163 push 66189
 66166 mov ECX,5
// printf(...)
 66169 call 21772
 66172 add ESP,5
 66175 push 66299
 66178 mov ECX,1
// overstack_error(...)
 66181 call 66369
 66184 add ESP,1
__2883:
__2864:
__2859:
 66187 leave 
 66188 ret 
__2885:
 66189 db "mErr: func [%s] exited with pos %d but last pos is %d
",0
__2881:
 66244 db "%mErr: func [%s] exited but [%d] more funcs are above
",0
__2877:
 66299 db "function exit misfile
",0
__2876:
 66322 db "%mErr: func [%s] exited but last func is [%s]
",0
overstack_error:
// overstack_error(str)
 66369 enter -0
__2887:
// printf arg #1 (char* format)
 66372 push 66392
 66375 mov ECX,1
// printf(...)
 66378 call 21772
 66381 add ESP,1
 66384 mov ECX,0
// panic(...)
 66387 call 85274
__2886:
 66390 leave 
 66391 ret 
__2888:
 66392 db "%mErr:overstack:%s",0
overstack_trace:
// overstack_trace()
 66411 enter 3
__2890:
__2892:
 66414 mov EAX,0
 66417 sub EAX,#66988
 66420 fabs EAX,EAX
 66422 fsgn EAX,EAX
 66424 lneg EAX
// if (overstack_func_stack==0)
 66426 cmp 0,EAX
 66429 jge 66437
 66432 mov EAX,0
 66435 leave 
 66436 ret 
__2893:
__2891:
// vector_size arg #1 (void* self)
 66437 push #66988
 66440 mov ECX,1
// vector_size(...)
 66443 call 32667
 66446 add ESP,1
 66449 sstack EBP:-1,EAX
 66453 rstack EAX,EBP:-1
 66457 add EAX,-1
 66460 mov EBX,EAX
 66462 sstack EBP:-2,EBX
__2895:
 66466 rstack EAX,EBP:-2
// if (I
 66470 cmp 0,EAX
 66473 jz 66538
 66476 rstack EAX,EBP:-2
// vector_get arg #3 (float pos)
 66480 push EAX
// vector_get arg #2 (void* element)
 66482 push 0
// vector_get arg #1 (void* self)
 66485 push #66988
 66488 mov ECX,3
// vector_get(...)
 66491 call 32750
 66494 add ESP,3
 66497 sstack EBP:-3,EAX
 66501 rstack EAX,EBP:-3
// printf arg #3 (unknown)
 66505 push EAX
 66507 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 66511 push EAX
// printf arg #1 (char* format)
 66513 push 66540
 66516 mov ECX,3
// printf(...)
 66519 call 21772
 66522 add ESP,3
 66525 rstack EAX,EBP:-2
// I--
 66529 dec EAX
 66531 sstack EBP:-2,EAX
 66535 jmp 66466
__2894:
__2889:
 66538 leave 
 66539 ret 
__2896:
 66540 db "%d: %s
",0
libmarker21:
 66548 db 0
 66549 alloc 128
all_globals:
cs_last_x:
 66677 db 29
cs_last_y:
 66678 db 17
printScrX:
 66679 db 0
printScrY:
 66680 db 0
AdrScreen:
 66681 alloc 1
screen_print_x_min:
 66682 db 0
screen_print_y_min:
 66683 db 0
screen_print_x_max:
 66684 db 0
screen_print_y_max:
 66685 db 0
LIBSTRING_VARS:
c2str_str:
 66686 alloc 2
Constr:
 66688 alloc 256
Nbase:
 66944 db 10
Nprec:
 66945 db 3
Nstack:
 66946 alloc 16
Array:
 66962 alloc 16
ZMALLOC_VARS:
malloc_debug:
 66978 db 0
malloc_print:
 66979 db 0
malloc_num2str:
 66980 db 0
malloc_disk:
 66981 alloc 1
malloc_max_disk:
 66982 alloc 1
malloc_header:
 66983 alloc 1
malloc_user:
 66984 alloc 1
lastFreeAllocation:
 66985 db 1
malloc_debug_iters:
 66986 db 0
ptrKB:
 66987 alloc 1
overstack_func_stack:
 66988 db 0
main_globals:
EBcb_1:
 66989 alloc 50
EB_Addr_Screen:
 67039 db 0
timerPeriod:
 67040 db 0
timerLogicTimeout:
 67041 db 0
v_proclist:
 67042 db 0
proclist_I:
 67043 db 0
switcherOn:
 67044 db 0
k_page_manager:
 67045 db 0
strbuff:
 67046 alloc 80
trans_buffer:
 67126 alloc 10
main_globals_end:
 67136 db 0
 67137 alloc 128
stack_buffer:
 67265 alloc 12800
stack_buffer_end:
 80065 db 0
 80066 alloc 128
trap_unmapped:
 80194 int 41
trap_unmapped_end:
 80197 db 0
main:
// main()
 80198 enter 1
__2898:
 80201 push 67136
 80204 push 66989
 80207 mov ECX,2
// clear_globals(...)
 80210 call 80501
 80213 add ESP,2
 80216 mov ECX,0
// libconsolescreen_init(...)
 80219 call 17204
// EBcb_constructor arg #1 (float this)
 80222 push 66989
 80225 mov ECX,1
// EBcb_constructor(...)
 80228 call 19706
 80231 add ESP,1
// EBcb_get_entry arg #2 (float num)
 80234 push 0
// EBcb_get_entry arg #1 (float this)
 80237 push 66989
 80240 mov ECX,2
// EBcb_get_entry(...)
 80243 call 19801
 80246 add ESP,2
 80249 sstack EBP:-1,EAX
// EBcb_entry_set_addr arg #2 (float val)
 80253 push 1048576
 80256 rstack EAX,EBP:-1
// EBcb_entry_set_addr arg #1 (float this)
 80260 push EAX
 80262 mov ECX,2
// EBcb_entry_set_addr(...)
 80265 call 19581
 80268 add ESP,2
// EBcb_autoconf arg #1 (float this)
 80271 push 66989
 80274 mov ECX,1
// EBcb_autoconf(...)
 80277 call 20156
 80280 add ESP,1
// EBcb_device_bind_addr arg #4 (float res)
 80283 push 67039
// EBcb_device_bind_addr arg #3 (float user)
 80286 push 1
// EBcb_device_bind_addr arg #2 (float type)
 80289 push 11
// EBcb_device_bind_addr arg #1 (float this)
 80292 push 66989
 80295 mov ECX,4
// EBcb_device_bind_addr(...)
 80298 call 21124
 80301 add ESP,4
__2900:
 80304 mov EAX,#67039
 80307 lneg EAX
// if (!EB_Addr_Screen)
 80309 cmp 0,EAX
 80312 jge 80327
 80315 push 32
 80318 mov ECX,1
// error(...)
 80321 call 85291
 80324 add ESP,1
__2901:
__2899:
// screen_set arg #1 (float scr)
 80327 push #67039
 80330 mov ECX,1
// screen_set(...)
 80333 call 17973
 80336 add ESP,1
 80339 mov ECX,0
// kernel_thread(...)
 80342 call 80675
__2897:
 80345 leave 
 80346 ret 
set_trampoline:
// set_trampoline(dest_start,dest_end,trp_start,trp_end)
 80347 enter 4
__2903:
 80350 rstack EAX,EBP:4
 80354 neg EAX
 80356 mov EBX,EAX
 80358 rstack EAX,EBP:5
 80362 add EAX,EBX
 80364 mov EBX,EAX
 80366 sstack EBP:-1,EBX
 80370 rstack EAX,EBP:2
 80374 neg EAX
 80376 mov EBX,EAX
 80378 rstack EAX,EBP:3
 80382 add EAX,EBX
 80384 mov EBX,EAX
 80386 sstack EBP:-2,EBX
 80390 rstack EAX,EBP:-1
 80394 rstack EBX,EBP:-2
 80398 div EBX,EAX
 80400 mov EAX,EBX
// floor arg #1 (float A)
 80402 push EAX
 80404 mov ECX,1
// floor(...)
 80407 call 30221
 80410 add ESP,1
 80413 sstack EBP:-3,EAX
// init loop
 80417 sstack EBP:-4,0
__2905:
 80422 rstack EAX,EBP:-4
 80426 rstack EBX,EBP:-3
 80430 sub EBX,EAX
 80432 mov EAX,EBX
 80434 fsgn EAX,EAX
// condition
 80436 max EAX,0
 80439 cmp 0,EAX
 80442 jz 80499
 80445 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 80449 push EAX
 80451 rstack EAX,EBP:4
// memcpy arg #2 (void* src)
 80455 push EAX
 80457 rstack EAX,EBP:2
// memcpy arg #1 (void* dest)
 80461 push EAX
 80463 mov ECX,3
// memcpy(...)
 80466 call 10355
 80469 add ESP,3
 80472 rstack EAX,EBP:-1
 80476 rstack EBX,EBP:2
// dest_start+=trp_len
 80480 add EBX,EAX
 80482 sstack EBP:2,EBX
 80486 rstack EAX,EBP:-4
// loop step
 80490 inc EAX
 80492 sstack EBP:-4,EAX
 80496 jmp 80422
__2904:
__2902:
 80499 leave 
 80500 ret 
clear_globals:
// clear_globals(start,end)
 80501 enter 1
__2907:
 80504 rstack EAX,EBP:2
// init loop
 80508 sstack EBP:-1,EAX
__2909:
 80512 rstack EAX,EBP:-1
 80516 rstack EBX,EBP:3
 80520 sub EBX,EAX
 80522 mov EAX,EBX
 80524 fsgn EAX,EAX
// condition
 80526 max EAX,0
 80529 cmp 0,EAX
 80532 jz 80555
 80535 rstack EAX,EBP:-1
// *I=0
 80539 mov #EAX,0
 80542 rstack EAX,EBP:-1
// loop step
 80546 inc EAX
 80548 sstack EBP:-1,EAX
 80552 jmp 80512
__2908:
__2906:
 80555 leave 
 80556 ret 
kprints:
// kprints(s)
 80557 enter -0
__2911:
 80560 push 0
 80563 push 0
 80566 rstack EAX,EBP:2
 80570 push EAX
 80572 push 1
 80575 mov ECX,4
// kcall(...)
 80578 call 84834
 80581 add ESP,4
__2910:
 80584 leave 
 80585 ret 
kprintn:
// kprintn(n)
 80586 enter -0
__2913:
 80589 push 0
 80592 push 0
 80595 rstack EAX,EBP:2
 80599 push EAX
 80601 push 2
 80604 mov ECX,4
// kcall(...)
 80607 call 84834
 80610 add ESP,4
__2912:
 80613 leave 
 80614 ret 
kprintf:
// kprintf(fmt)
 80615 enter 2
__2915:
 80618 sstack EBP:-1,ECX
 80622 mov EAX,SS:EBP
 80625 add EAX,2
 80628 push EAX
 80630 mov ECX,1
// va_start(...)
 80633 call 10002
 80636 add ESP,1
 80639 sstack EBP:-2,EAX
 80643 rstack EAX,EBP:-2
 80647 push EAX
 80649 rstack EAX,EBP:-1
 80653 push EAX
 80655 rstack EAX,EBP:2
 80659 push EAX
 80661 push 3
 80664 mov ECX,4
// kcall(...)
 80667 call 84834
 80670 add ESP,4
__2914:
 80673 leave 
 80674 ret 
kernel_thread:
// kernel_thread()
 80675 enter 4
__2917:
 80678 mov ECX,0
// screen_clear(...)
 80681 call 17985
// printf arg #2 (unknown)
 80684 push 191
// printf arg #1 (char* format)
 80687 push 81133
 80690 mov ECX,2
// printf(...)
 80693 call 21772
 80696 add ESP,2
// malloc_set_disk arg #2 (float disk_size)
 80699 push 500000
// malloc_set_disk arg #1 (float* disk)
 80702 push 86010
 80705 mov ECX,2
// malloc_set_disk(...)
 80708 call 26789
 80711 add ESP,2
 80714 mov ECX,0
// malloc_init(...)
 80717 call 26820
// printf arg #2 (unknown)
 80720 push 86010
// printf arg #1 (char* format)
 80723 push 81020
 80726 mov ECX,2
// printf(...)
 80729 call 21772
 80732 add ESP,2
// malloc arg #1 (float n)
 80735 push 100
 80738 mov ECX,1
// malloc(...)
 80741 call 28486
 80744 add ESP,1
 80747 sstack EBP:-1,EAX
 80751 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 80755 push EAX
// printf arg #1 (char* format)
 80757 push 81002
 80760 mov ECX,2
// printf(...)
 80763 call 21772
 80766 add ESP,2
// printf arg #1 (char* format)
 80769 push 81057
 80772 mov ECX,1
// printf(...)
 80775 call 21772
 80778 add ESP,1
 80781 sstack EBP:-2,32
 80786 sstack EBP:-3,96
 80791 rstack EAX,EBP:-2
// initInterrupts arg #5 (float flags)
 80795 push EAX
// initInterrupts arg #4 (float handler)
 80797 push 83625
// initInterrupts arg #3 (float size)
 80800 push 50
// initInterrupts arg #2 (float first)
 80803 push 2
// initInterrupts arg #1 (float IT)
 80806 push 1280
 80809 mov ECX,5
// initInterrupts(...)
 80812 call 34543
 80815 add ESP,5
// printf arg #1 (char* format)
 80818 push 81104
 80821 mov ECX,1
// printf(...)
 80824 call 21772
 80827 add ESP,1
 80830 mov ECX,0
// protect_kernel_pages(...)
 80833 call 81657
 80836 cpuset 69,1
 80840 stef 
 80841 stm 
// printf arg #1 (char* format)
 80842 push 81157
 80845 mov ECX,1
// printf(...)
 80848 call 21772
 80851 add ESP,1
// printf arg #1 (char* format)
 80854 push 80996
 80857 mov ECX,1
// printf(...)
 80860 call 21772
 80863 add ESP,1
// printf arg #1 (char* format)
 80866 push 80958
 80869 mov ECX,1
// printf(...)
 80872 call 21772
 80875 add ESP,1
 80878 mov ECX,0
// overstack_init(...)
 80881 call 65762
// printf arg #1 (char* format)
 80884 push 80996
 80887 mov ECX,1
// printf(...)
 80890 call 21772
 80893 add ESP,1
// printf arg #1 (char* format)
 80896 push 81085
 80899 mov ECX,1
// printf(...)
 80902 call 21772
 80905 add ESP,1
 80908 mov ECX,0
// init_shell2(...)
 80911 call 37338
 80914 sstack EBP:-4,EAX
 80918 rstack EAX,EBP:-4
// shell2_open arg #1 (float self)
 80922 push EAX
 80924 mov ECX,1
// shell2_open(...)
 80927 call 38752
 80930 add ESP,1
// printf arg #1 (char* format)
 80933 push 80976
 80936 mov ECX,1
// printf(...)
 80939 call 21772
 80942 add ESP,1
__2929:
// if (1
 80945 cmp 0,1
 80949 jz 80956
 80952 nop 
 80953 jmp 80945
__2928:
__2916:
 80956 leave 
 80957 ret 
__2925:
 80958 db "overstack init...",0
__2927:
 80976 db "...back to kernel.
",0
__2924:
 80996 db "done
",0
__2920:
 81002 db "malloc(100) = %d
",0
__2919:
 81020 db "malloc initialized (heap disk = %d)
",0
__2921:
 81057 db "initializing interrupts...
",0
__2926:
 81085 db "starting shell...
",0
__2922:
 81104 db "engaging page protection...
",0
__2918:
 81133 db "%mHello World! I am OS
",0
__2923:
 81157 db "paging is on.
",0
exec_test:
// exec_test(buff)
 81172 enter 2
__2931:
 81175 sstack EBP:-1,4
 81180 sstack EBP:-2,0
 81185 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 81189 push EAX
// printf arg #1 (char* format)
 81191 push 81310
 81194 mov ECX,2
// printf(...)
 81197 call 21772
 81200 add ESP,2
// printf arg #1 (char* format)
 81203 push 81293
 81206 mov ECX,1
// printf(...)
 81209 call 21772
 81212 add ESP,1
 81215 rstack EAX,EBP:-1
// memcpy arg #3 (float n)
 81219 push EAX
// memcpy arg #2 (void* src)
 81221 push 81374
 81224 rstack EAX,EBP:2
// memcpy arg #1 (void* dest)
 81228 push EAX
 81230 mov ECX,3
// memcpy(...)
 81233 call 10355
 81236 add ESP,3
// printf arg #1 (char* format)
 81239 push 81338
 81242 mov ECX,1
// printf(...)
 81245 call 21772
 81248 add ESP,1
 81251 mov EAX,0
 81254 mov ECX,0
 81257 rstack EAX,EBP:2
// buff(...)
 81261 call EAX
// x=buff()
 81263 sstack EBP:-2,EAX
 81267 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 81271 push EAX
// printf arg #1 (char* format)
 81273 push 81355
 81276 mov ECX,2
// printf(...)
 81279 call 21772
 81282 add ESP,2
 81285 rstack EAX,EBP:-2
 81289 leave 
 81290 ret 
__2930:
 81291 leave 
 81292 ret 
__2933:
 81293 db "copying code...
",0
__2932:
 81310 db "exec code size is %d bytes
",0
__2934:
 81338 db "calling code...
",0
__2935:
 81355 db "code returned %d.
",0
exec_test_code:
 81374 mov EAX,1
 81377 ret 
exec_test_code_end:
 81378 db 0
write_test:
// write_test(func)
 81379 enter 1
__2937:
 81382 rstack EAX,EBP:2
 81386 add EAX,0
 81389 mov EBX,EAX
 81391 sstack EBP:-1,#EBX
 81395 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 81399 push EAX
// printf arg #1 (char* format)
 81401 push 81570
 81404 mov ECX,2
// printf(...)
 81407 call 21772
 81410 add ESP,2
 81413 mov EAX,0
 81416 add EAX,80615
// kprintf[0]=0
 81419 mov #EAX,0
__2940:
 81422 mov EAX,0
 81425 add EAX,80615
 81428 mov EBX,0
 81431 sub EBX,#EAX
 81433 fabs EBX,EBX
 81435 fsgn EBX,EBX
 81437 lneg EBX
// if (kprintf[0]==0)
 81439 cmp 0,EBX
 81442 jge 81460
// printf arg #1 (char* format)
 81445 push 81591
 81448 mov ECX,1
// printf(...)
 81451 call 21772
 81454 add ESP,1
 81457 jmp 81521
__2943:
__2941:
__2945:
__2947:
 81460 mov EAX,0
 81463 add EAX,80615
 81466 rstack EBX,EBP:-1
 81470 sub EBX,#EAX
 81472 mov EAX,EBX
 81474 fabs EAX,EAX
 81476 fsgn EAX,EAX
 81478 lneg EAX
// if (kprintf[0]==x)
 81480 cmp 0,EAX
 81483 jge 81501
// printf arg #1 (char* format)
 81486 push 81623
 81489 mov ECX,1
// printf(...)
 81492 call 21772
 81495 add ESP,1
 81498 jmp 81521
__2950:
__2948:
__2952:
 81501 mov EAX,0
 81504 add EAX,80615
// printf arg #2 (unknown)
 81507 push #EAX
// printf arg #1 (char* format)
 81509 push 81523
 81512 mov ECX,2
// printf(...)
 81515 call 21772
 81518 add ESP,2
__2951:
__2946:
__2944:
__2939:
__2936:
 81521 leave 
 81522 ret 
__2953:
 81523 db "write test failed mysteriously (kprintf = %d)
",0
__2938:
 81570 db "write test (x = %d)
",0
__2942:
 81591 db "write test failed (full write)
",0
__2949:
 81623 db "write test failed (but no write)
",0
protect_kernel_pages:
// protect_kernel_pages()
 81657 enter 5
__2955:
// malloc arg #1 (float n)
 81660 push #63655
 81663 mov ECX,1
// malloc(...)
 81666 call 28486
 81669 add ESP,1
 81672 sstack EBP:-1,EAX
 81676 rstack EAX,EBP:-1
// page_manager_constructor arg #1 (float self)
 81680 push EAX
 81682 mov ECX,1
// page_manager_constructor(...)
 81685 call 63656
 81688 add ESP,1
 81691 rstack EAX,EBP:-1
// k_page_manager=PM
 81695 mov #67045,EAX
// page[0]=0
 81698 sstack EBP:-5,0
// page[1]=0
 81703 sstack EBP:-4,0
// setPageRunLevel arg #2 (float level)
 81708 push 1
 81711 mov EAX,SS:EBP
 81714 add EAX,-5
// setPageRunLevel arg #1 (float page)
 81717 push EAX
 81719 mov ECX,2
// setPageRunLevel(...)
 81722 call 36508
 81725 add ESP,2
// setPageFlags arg #2 (float flags)
 81728 push 64
 81731 mov EAX,SS:EBP
 81734 add EAX,-5
// setPageFlags arg #1 (float page)
 81737 push EAX
 81739 mov ECX,2
// setPageFlags(...)
 81742 call 36407
 81745 add ESP,2
// toPage arg #1 (float addr)
 81748 push 0
 81751 mov ECX,1
// toPage(...)
 81754 call 36857
 81757 add ESP,1
// pfrom=toPage(0)
 81760 sstack EBP:-2,EAX
// toPage arg #1 (float addr)
 81764 push 86010
 81767 mov ECX,1
// toPage(...)
 81770 call 36857
 81773 add ESP,1
// pto=toPage(heap)
 81776 sstack EBP:-3,EAX
 81780 rstack EAX,EBP:-3
// page_manager_assign_page_range arg #4 (float pn_to)
 81784 push EAX
 81786 rstack EAX,EBP:-2
// page_manager_assign_page_range arg #3 (float pn_from)
 81790 push EAX
 81792 mov EAX,SS:EBP
 81795 add EAX,-5
// page_manager_assign_page_range arg #2 (float page)
 81798 push EAX
 81800 rstack EAX,EBP:-1
// page_manager_assign_page_range arg #1 (float PM)
 81804 push EAX
 81806 mov ECX,4
// page_manager_assign_page_range(...)
 81809 call 63991
 81812 add ESP,4
// setPageFlags arg #2 (float flags)
 81815 push 128
 81818 mov EAX,SS:EBP
 81821 add EAX,-5
// setPageFlags arg #1 (float page)
 81824 push EAX
 81826 mov ECX,2
// setPageFlags(...)
 81829 call 36407
 81832 add ESP,2
// toPage arg #1 (float addr)
 81835 push 66677
 81838 mov ECX,1
// toPage(...)
 81841 call 36857
 81844 add ESP,1
// pfrom=toPage(all_globals)
 81847 sstack EBP:-2,EAX
// toPage arg #1 (float addr)
 81851 push 67136
 81854 mov ECX,1
// toPage(...)
 81857 call 36857
 81860 add ESP,1
// pto=toPage(main_globals_end)
 81863 sstack EBP:-3,EAX
 81867 rstack EAX,EBP:-3
// page_manager_assign_page_range arg #4 (float pn_to)
 81871 push EAX
 81873 rstack EAX,EBP:-2
// page_manager_assign_page_range arg #3 (float pn_from)
 81877 push EAX
 81879 mov EAX,SS:EBP
 81882 add EAX,-5
// page_manager_assign_page_range arg #2 (float page)
 81885 push EAX
 81887 rstack EAX,EBP:-1
// page_manager_assign_page_range arg #1 (float PM)
 81891 push EAX
 81893 mov ECX,4
// page_manager_assign_page_range(...)
 81896 call 63991
 81899 add ESP,4
// toPage arg #1 (float addr)
 81902 push 67265
 81905 mov ECX,1
// toPage(...)
 81908 call 36857
 81911 add ESP,1
// pfrom=toPage(stack_buffer)
 81914 sstack EBP:-2,EAX
// toPage arg #1 (float addr)
 81918 push 80065
 81921 mov ECX,1
// toPage(...)
 81924 call 36857
 81927 add ESP,1
// pto=toPage(stack_buffer_end)
 81930 sstack EBP:-3,EAX
 81934 rstack EAX,EBP:-3
// page_manager_assign_page_range arg #4 (float pn_to)
 81938 push EAX
 81940 rstack EAX,EBP:-2
// page_manager_assign_page_range arg #3 (float pn_from)
 81944 push EAX
 81946 mov EAX,SS:EBP
 81949 add EAX,-5
// page_manager_assign_page_range arg #2 (float page)
 81952 push EAX
 81954 rstack EAX,EBP:-1
// page_manager_assign_page_range arg #1 (float PM)
 81958 push EAX
 81960 mov ECX,4
// page_manager_assign_page_range(...)
 81963 call 63991
 81966 add ESP,4
 81969 mov EAX,SS:EBP
 81972 add EAX,-5
// page_manager_assign_default_page arg #2 (float page)
 81975 push EAX
 81977 rstack EAX,EBP:-1
// page_manager_assign_default_page arg #1 (float PM)
 81981 push EAX
 81983 mov ECX,2
// page_manager_assign_default_page(...)
 81986 call 63756
 81989 add ESP,2
// page[0]=0
 81992 sstack EBP:-5,0
// page[1]=0
 81997 sstack EBP:-4,0
// setPageRunLevel arg #2 (float level)
 82002 push 1
 82005 mov EAX,SS:EBP
 82008 add EAX,-5
// setPageRunLevel arg #1 (float page)
 82011 push EAX
 82013 mov ECX,2
// setPageRunLevel(...)
 82016 call 36508
 82019 add ESP,2
// setPageFlags arg #2 (float flags)
 82022 push 64
 82025 mov EAX,SS:EBP
 82028 add EAX,-5
// setPageFlags arg #1 (float page)
 82031 push EAX
 82033 mov ECX,2
// setPageFlags(...)
 82036 call 36407
 82039 add ESP,2
// toPage arg #1 (float addr)
 82042 push 1280
 82045 mov ECX,1
// toPage(...)
 82048 call 36857
 82051 add ESP,1
// pfrom=toPage(interruptTable)
 82054 sstack EBP:-2,EAX
 82058 rstack EAX,EBP:-2
 82062 add EAX,1
 82065 mov EBX,EAX
// pto=pfrom+1
 82067 sstack EBP:-3,EBX
 82071 rstack EAX,EBP:-3
// page_manager_assign_page_range arg #4 (float pn_to)
 82075 push EAX
 82077 rstack EAX,EBP:-2
// page_manager_assign_page_range arg #3 (float pn_from)
 82081 push EAX
 82083 mov EAX,SS:EBP
 82086 add EAX,-5
// page_manager_assign_page_range arg #2 (float page)
 82089 push EAX
 82091 rstack EAX,EBP:-1
// page_manager_assign_page_range arg #1 (float PM)
 82095 push EAX
 82097 mov ECX,4
// page_manager_assign_page_range(...)
 82100 call 63991
 82103 add ESP,4
// setPageRunLevel arg #2 (float level)
 82106 push 0
 82109 mov EAX,SS:EBP
 82112 add EAX,-5
// setPageRunLevel arg #1 (float page)
 82115 push EAX
 82117 mov ECX,2
// setPageRunLevel(...)
 82120 call 36508
 82123 add ESP,2
// setPageFlags arg #2 (float flags)
 82126 push 64
 82129 mov EAX,SS:EBP
 82132 add EAX,-5
// setPageFlags arg #1 (float page)
 82135 push EAX
 82137 mov ECX,2
// setPageFlags(...)
 82140 call 36407
 82143 add ESP,2
// toPage arg #1 (float addr)
 82146 push 82960
 82149 mov ECX,1
// toPage(...)
 82152 call 36857
 82155 add ESP,1
// pfrom=toPage(pg_int_handlers)
 82158 sstack EBP:-2,EAX
// toPage arg #1 (float addr)
 82162 push 84375
 82165 mov ECX,1
// toPage(...)
 82168 call 36857
 82171 add ESP,1
// pto=toPage(pg_int_handlers_end)
 82174 sstack EBP:-3,EAX
 82178 rstack EAX,EBP:-3
// page_manager_assign_page_range arg #4 (float pn_to)
 82182 push EAX
 82184 rstack EAX,EBP:-2
// page_manager_assign_page_range arg #3 (float pn_from)
 82188 push EAX
 82190 mov EAX,SS:EBP
 82193 add EAX,-5
// page_manager_assign_page_range arg #2 (float page)
 82196 push EAX
 82198 rstack EAX,EBP:-1
// page_manager_assign_page_range arg #1 (float PM)
 82202 push EAX
 82204 mov ECX,4
// page_manager_assign_page_range(...)
 82207 call 63991
 82210 add ESP,4
 82213 rstack EAX,EBP:-1
// page_manager_activate arg #1 (float PM)
 82217 push EAX
 82219 mov ECX,1
// page_manager_activate(...)
 82222 call 64335
 82225 add ESP,1
__2954:
 82228 leave 
 82229 ret 
init_ktimer:
// init_ktimer()
 82230 enter -0
__2957:
// printf arg #1 (char* format)
 82233 push 82267
 82236 mov ECX,1
// printf(...)
 82239 call 21772
 82242 add ESP,1
// timerPeriod=400000
 82245 mov #67040,400000
// timerN=0
 82249 mov #82292,0
 82253 cpuset 65,#67040
 82257 cpuset 64,2
 82261 cpuset 67,42
__2956:
 82265 leave 
 82266 ret 
__2958:
 82267 db "setting timer
",0
derpTable:
 82282 alloc 10
timerN:
 82292 db 0
retAlert:
// retAlert(p)
 82293 enter 2
__2960:
 82296 rstack EAX,EBP:2
 82300 add EAX,1
 82303 mov EBX,EAX
 82305 sstack EBP:-1,#EBX
 82309 rstack EAX,EBP:2
 82313 add EAX,2
 82316 mov EBX,EAX
 82318 sstack EBP:-2,#EBX
__2962:
 82322 rstack EAX,EBP:-1
 82326 mov EBX,0
 82329 sub EBX,EAX
 82331 fabs EBX,EBX
 82333 fsgn EBX,EBX
// if (prevCS!=0)
 82335 cmp 0,EBX
 82338 jge 82562
 82341 cpuset 64,0
// printf arg #1 (char* format)
 82345 push 82668
 82348 mov ECX,1
// printf(...)
 82351 call 21772
 82354 add ESP,1
// printf arg #1 (char* format)
 82357 push 82631
 82360 mov ECX,1
// printf(...)
 82363 call 21772
 82366 add ESP,1
 82369 rstack EAX,EBP:2
 82373 add EAX,-2
 82376 mov EBX,EAX
// printf arg #3 (unknown)
 82378 push #EBX
 82380 rstack EAX,EBP:2
 82384 add EAX,-2
 82387 mov EBX,EAX
// printf arg #2 (unknown)
 82389 push EBX
// printf arg #1 (char* format)
 82391 push 82583
 82394 mov ECX,3
// printf(...)
 82397 call 21772
 82400 add ESP,3
 82403 rstack EAX,EBP:2
 82407 add EAX,-1
 82410 mov EBX,EAX
// printf arg #3 (unknown)
 82412 push #EBX
 82414 rstack EAX,EBP:2
 82418 add EAX,-1
 82421 mov EBX,EAX
// printf arg #2 (unknown)
 82423 push EBX
// printf arg #1 (char* format)
 82425 push 82683
 82428 mov ECX,3
// printf(...)
 82431 call 21772
 82434 add ESP,3
 82437 rstack EAX,EBP:2
 82441 add EAX,0
 82444 mov EBX,EAX
// printf arg #3 (unknown)
 82446 push #EBX
 82448 rstack EAX,EBP:2
 82452 add EAX,0
 82455 mov EBX,EAX
// printf arg #2 (unknown)
 82457 push EBX
// printf arg #1 (char* format)
 82459 push 82652
 82462 mov ECX,3
// printf(...)
 82465 call 21772
 82468 add ESP,3
 82471 rstack EAX,EBP:2
 82475 add EAX,1
 82478 mov EBX,EAX
// printf arg #3 (unknown)
 82480 push #EBX
 82482 rstack EAX,EBP:2
 82486 add EAX,1
 82489 mov EBX,EAX
// printf arg #2 (unknown)
 82491 push EBX
// printf arg #1 (char* format)
 82493 push 82615
 82496 mov ECX,3
// printf(...)
 82499 call 21772
 82502 add ESP,3
 82505 rstack EAX,EBP:2
 82509 add EAX,2
 82512 mov EBX,EAX
// printf arg #3 (unknown)
 82514 push #EBX
 82516 rstack EAX,EBP:2
 82520 add EAX,2
 82523 mov EBX,EAX
// printf arg #2 (unknown)
 82525 push EBX
// printf arg #1 (char* format)
 82527 push 82599
 82530 mov ECX,3
// printf(...)
 82533 call 21772
 82536 add ESP,3
// printf arg #1 (char* format)
 82539 push 82564
 82542 mov ECX,1
// printf(...)
 82545 call 21772
 82548 add ESP,1
__2973:
// if (1
 82551 cmp 0,1
 82555 jz 82562
 82558 nop 
 82559 jmp 82551
__2972:
__2963:
__2961:
__2959:
 82562 leave 
 82563 ret 
__2971:
 82564 db "printing prevEBP:
",0
__2966:
 82583 db "p-2 = %d -> %d
",0
__2970:
 82599 db "p+2 = %d -> %d
",0
__2969:
 82615 db "p+1 = %d -> %d
",0
__2965:
 82631 db "printing given ptr:
",0
__2968:
 82652 db "p+0 = %d -> %d
",0
__2964:
 82668 db "Return alert!
",0
__2967:
 82683 db "p-1 = %d -> %d
",0
unfuckEntry:
// unfuckEntry(ptr)
 82699 enter 3
__2975:
 82702 sstack EBP:-1,EBP
 82706 sstack EBP:-2,#EBP
 82710 rstack EAX,EBP:-2
 82714 add EAX,1
 82717 mov EBX,EAX
 82719 sstack EBP:-3,#EBX
__2977:
 82723 rstack EAX,EBP:-3
 82727 mov EBX,0
 82730 sub EBX,EAX
 82732 fabs EBX,EBX
 82734 fsgn EBX,EBX
// if (prevCS!=0)
 82736 cmp 0,EBX
 82739 jge 82797
// printf arg #2 (unknown)
 82742 push 990
// printf arg #1 (char* format)
 82745 push 82804
 82748 mov ECX,2
// printf(...)
 82751 call 21772
 82754 add ESP,2
 82757 rstack EAX,EBP:-2
 82761 add EAX,0
 82764 mov EBX,EAX
 82766 rstack EAX,EBP:-2
 82770 add EAX,18
 82773 mov ECX,EAX
// EP[18]=EP[0]
 82775 mov #ECX,#EBX
 82777 rstack EAX,EBP:-2
 82781 add EAX,18
 82784 mov EBX,EAX
 82786 rstack EAX,EBP:-1
// *E=EP+18
 82790 mov #EAX,EBX
 82792 mov EAX,1
 82795 leave 
 82796 ret 
__2978:
__2976:
 82797 mov EAX,0
 82800 leave 
 82801 ret 
__2974:
 82802 leave 
 82803 ret 
__2979:
 82804 db "%mentry fucked. Unfucking.
",0
 82832 alloc 128
pg_int_handlers:
KernellCallIntHandler:
// KernellCallIntHandler()
 82960 enter 10
__2981:
 82963 cli 
__2983:
 82964 mov ECX,0
// timerShouldRun(...)
 82967 call 83902
// if (timerShouldRun())
 82970 cmp 0,EAX
 82973 jge 82994
// printf arg #1 (char* format)
 82976 push 83386
 82979 mov ECX,1
// printf(...)
 82982 call 21772
 82985 add ESP,1
 82988 mov ECX,0
// timerLogic(...)
 82991 call 83921
__2984:
__2982:
 82994 sti 
 82995 sstack EBP:-1,R0
 82999 sstack EBP:-2,R1
 83003 sstack EBP:-3,R2
 83007 sstack EBP:-4,R3
 83011 mov ECX,0
// switchToKernel(...)
 83014 call 430
 83017 sstack EBP:-5,0
__2987:
 83022 rstack EAX,EBP:-1
 83026 mov EBX,1
 83029 sub EBX,EAX
 83031 fabs EBX,EBX
 83033 fsgn EBX,EBX
 83035 lneg EBX
// if (arg1==1)
 83037 cmp 0,EBX
 83040 jge 83085
// found=1
 83043 sstack EBP:-5,1
 83048 rstack EAX,EBP:-2
 83052 push EAX
 83054 mov ECX,1
// toAbsSpace(...)
 83057 call 84672
 83060 add ESP,1
 83063 sstack EBP:-6,EAX
 83067 rstack EAX,EBP:-6
// printf arg #2 (unknown)
 83071 push EAX
// printf arg #1 (char* format)
 83073 push 39469
 83076 mov ECX,2
// printf(...)
 83079 call 21772
 83082 add ESP,2
__2988:
__2986:
__2990:
 83085 rstack EAX,EBP:-1
 83089 mov EBX,2
 83092 sub EBX,EAX
 83094 fabs EBX,EBX
 83096 fsgn EBX,EBX
 83098 lneg EBX
// if (arg1==2)
 83100 cmp 0,EBX
 83103 jge 83129
// found=1
 83106 sstack EBP:-5,1
 83111 rstack EAX,EBP:-2
// printf arg #2 (unknown)
 83115 push EAX
// printf arg #1 (char* format)
 83117 push 83444
 83120 mov ECX,2
// printf(...)
 83123 call 21772
 83126 add ESP,2
__2991:
__2989:
__2994:
 83129 rstack EAX,EBP:-1
 83133 mov EBX,3
 83136 sub EBX,EAX
 83138 fabs EBX,EBX
 83140 fsgn EBX,EBX
 83142 lneg EBX
// if (arg1==3)
 83144 cmp 0,EBX
 83147 jge 83217
// found=1
 83150 sstack EBP:-5,1
 83155 rstack EAX,EBP:-2
 83159 push EAX
 83161 mov ECX,1
// toAbsSpace(...)
 83164 call 84672
 83167 add ESP,1
 83170 sstack EBP:-7,EAX
 83174 rstack EAX,EBP:-3
 83178 sstack EBP:-8,EAX
 83182 rstack EAX,EBP:-4
 83186 sstack EBP:-9,EAX
 83190 rstack EAX,EBP:-9
 83194 push EAX
 83196 rstack EAX,EBP:-8
 83200 push EAX
 83202 rstack EAX,EBP:-7
 83206 push EAX
 83208 mov ECX,3
// vprintf(...)
 83211 call 84866
 83214 add ESP,3
__2995:
__2993:
__2997:
 83217 rstack EAX,EBP:-1
 83221 mov EBX,4
 83224 sub EBX,EAX
 83226 fabs EBX,EBX
 83228 fsgn EBX,EBX
 83230 lneg EBX
// if (arg1==4)
 83232 cmp 0,EBX
 83235 jge 83260
// found=1
 83238 sstack EBP:-5,1
__3000:
// if (lastProcess)
 83243 cmp 0,#257
 83247 jge 83260
// current_thread=0
 83250 mov #256,0
 83254 mov ECX,0
// jmpThreadExitPoint(...)
 83257 call 84456
__3001:
__2999:
__2998:
__2996:
__3003:
 83260 rstack EAX,EBP:-1
 83264 mov EBX,5
 83267 sub EBX,EAX
 83269 fabs EBX,EBX
 83271 fsgn EBX,EBX
 83273 lneg EBX
// if (arg1==5)
 83275 cmp 0,EBX
 83278 jge 83315
// found=1
 83281 sstack EBP:-5,1
__3006:
// if (lastProcess)
 83286 cmp 0,#257
 83290 jge 83315
// process_h_get_procID arg #1 (float this)
 83293 push #257
 83296 mov ECX,1
// process_h_get_procID(...)
 83299 call 25206
 83302 add ESP,1
 83305 sstack EBP:-10,EAX
 83309 rstack EAX,EBP:-10
 83313 mov R0,EAX
__3007:
__3005:
__3004:
__3002:
__3009:
 83315 rstack EAX,EBP:-5
 83319 lneg EAX
 83321 mov EBX,EAX
// if (!found)
 83323 cmp 0,EBX
 83326 jge 83365
 83329 rstack EAX,EBP:-4
// printf arg #5 (unknown)
 83333 push EAX
 83335 rstack EAX,EBP:-3
// printf arg #4 (unknown)
 83339 push EAX
 83341 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 83345 push EAX
 83347 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 83351 push EAX
// printf arg #1 (char* format)
 83353 push 83402
 83356 mov ECX,5
// printf(...)
 83359 call 21772
 83362 add ESP,5
__3010:
__3008:
 83365 mov ECX,0
// switchToLastProcess(...)
 83368 call 258
 83371 leave 
// retAlert arg #1 (float p)
 83372 push ESP
 83374 mov ECX,1
// retAlert(...)
 83377 call 82293
 83380 add ESP,1
 83383 iret 
__2980:
 83384 leave 
 83385 ret 
__2985:
 83386 db "-running timer
",0
__3011:
 83402 db "unrecognized kernell call %d, %d, %d, %d
",0
__2992:
 83444 db "%d",0
UnmappedPageIntHandler:
// UnmappedPageIntHandler()
 83447 enter 2
__3013:
 83450 cli 
 83451 sstack EBP:-1,EBP:#1
 83457 sstack EBP:-2,EBP:#2
 83463 mov ECX,0
// switchToKernel(...)
 83466 call 430
 83469 rstack EAX,EBP:-1
// printf arg #4 (unknown)
 83473 push EAX
 83475 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 83479 push EAX
// printf arg #2 (unknown)
 83481 push 900
// printf arg #1 (char* format)
 83484 push 83552
 83487 mov ECX,4
// printf(...)
 83490 call 21772
 83493 add ESP,4
__3016:
// if (lastProcess)
 83496 cmp 0,#257
 83500 jge 83509
 83503 mov ECX,0
// thread_terminate(...)
 83506 call 84376
__3017:
__3015:
// printf arg #1 (char* format)
 83509 push 83601
 83512 mov ECX,1
// printf(...)
 83515 call 21772
 83518 add ESP,1
__3020:
 83521 mov ECX,0
// hasKey(...)
 83524 call 35732
 83527 lneg EAX
// if (!hasKey()
 83529 cmp 0,EAX
 83532 jz 83538
 83535 jmp 83521
__3019:
 83538 mov ECX,0
// readKey(...)
 83541 call 35705
 83544 int 0
 83547 leave 
 83548 sti 
 83549 iret 
__3012:
 83550 leave 
 83551 ret 
__3014:
 83552 db "%mu:Access to unmapped page from (IP %d:CS %d) 
",0
__3018:
 83601 db "Press any key to reset
",0
defaultIntHandler:
// defaultIntHandler()
 83625 enter 86
__3022:
 83628 cli 
 83629 rstack EAX,EBP:-1
 83633 cpuget EAX,27
 83636 sstack EBP:-1,EAX
 83640 rstack EAX,EBP:-2
 83644 cpuget EAX,28
 83647 sstack EBP:-2,EAX
 83651 sstack EBP:-3,EBP:#1
 83657 sstack EBP:-4,EBP:#2
 83663 rstack EAX,EBP:-3
// printf arg #6 (unknown)
 83667 push EAX
 83669 rstack EAX,EBP:-4
// printf arg #5 (unknown)
 83673 push EAX
 83675 rstack EAX,EBP:-1
// printf arg #4 (unknown)
 83679 push EAX
 83681 rstack EAX,EBP:-2
// printf arg #3 (unknown)
 83685 push EAX
// printf arg #2 (unknown)
 83687 push 810
// printf arg #1 (char* format)
 83690 push 83876
 83693 mov ECX,6
// printf(...)
 83696 call 21772
 83699 add ESP,6
 83702 rstack EAX,EBP:-2
// intnum_to_str arg #1 (float num)
 83706 push EAX
 83708 mov ECX,1
// intnum_to_str(...)
 83711 call 34999
 83714 add ESP,1
 83717 sstack EBP:-5,EAX
 83721 rstack EAX,EBP:-5
// printf arg #3 (unknown)
 83725 push EAX
// printf arg #2 (unknown)
 83727 push 810
// printf arg #1 (char* format)
 83730 push 59783
 83733 mov ECX,3
// printf(...)
 83736 call 21772
 83739 add ESP,3
 83742 sstack EBP:-6,148
 83747 rstack EAX,EBP:-6
// printf arg #2 (unknown)
 83751 push EAX
// printf arg #1 (char* format)
 83753 push 83829
 83756 mov ECX,2
// printf(...)
 83759 call 21772
 83762 add ESP,2
 83765 mov EAX,SS:EBP
 83768 add EAX,-86
// getIntStackTrace arg #1 (float buff)
 83771 push EAX
 83773 mov ECX,1
// getIntStackTrace(...)
 83776 call 64433
 83779 add ESP,1
 83782 mov EAX,SS:EBP
 83785 add EAX,-86
// printStackTrace arg #1 (float buff)
 83788 push EAX
 83790 mov ECX,1
// printStackTrace(...)
 83793 call 64817
 83796 add ESP,1
// printf arg #2 (unknown)
 83799 push 159
// printf arg #1 (char* format)
 83802 push 83857
 83805 mov ECX,2
// printf(...)
 83808 call 21772
 83811 add ESP,2
__3027:
// if (1
 83814 cmp 0,1
 83818 jz 83824
 83821 jmp 83814
__3026:
 83824 leave 
 83825 sti 
 83826 iret 
__3021:
 83827 leave 
 83828 ret 
__3024:
 83829 db "%mgathering stack trace...
",0
__3025:
 83857 db "%m~ halting CPU ~
",0
__3023:
 83876 db "%md:INT %d:%d from %d:%d
",0
timerShouldRun:
// timerShouldRun()
 83902 enter -0
__3029:
// timePassed arg #1 (float timestamp)
 83905 push #67041
 83908 mov ECX,1
// timePassed(...)
 83911 call 25066
 83914 add ESP,1
 83917 leave 
 83918 ret 
__3028:
 83919 leave 
 83920 ret 
timerLogic:
// timerLogic()
 83921 enter 2
__3031:
// setTimeout arg #1 (float timeleft)
 83924 push 1.5
 83927 mov ECX,1
// setTimeout(...)
 83930 call 25029
 83933 add ESP,1
// timerLogicTimeout=setTimeout(1.5)
 83936 mov #67041,EAX
// printf arg #3 (unknown)
 83939 push #82292
// printf arg #2 (unknown)
 83942 push 59
// printf arg #1 (char* format)
 83945 push 84045
 83948 mov ECX,3
// printf(...)
 83951 call 21772
 83954 add ESP,3
// timerN++
 83957 inc #82292
__3034:
// if (switcherOn)
 83960 cmp 0,#67044
 83964 jge 84043
// vector_size arg #1 (void* self)
 83967 push #67042
 83970 mov ECX,1
// vector_size(...)
 83973 call 32667
 83976 add ESP,1
 83979 sstack EBP:-1,EAX
// vector_get arg #3 (float pos)
 83983 push #67043
// vector_get arg #2 (void* element)
 83986 push 0
// vector_get arg #1 (void* self)
 83989 push #67042
 83992 mov ECX,3
// vector_get(...)
 83995 call 32750
 83998 add ESP,3
 84001 sstack EBP:-2,EAX
// proclist_I++
 84005 inc #67043
__3037:
 84008 rstack EAX,EBP:-1
 84012 sub EAX,#67043
 84015 mov EBX,EAX
 84017 neg EBX
 84019 fsgn EBX,EBX
 84021 inc EBX
 84023 max EBX,0
// if (proclist_I>=size)
 84026 cmp 0,EBX
 84029 jge 84036
// proclist_I=0
 84032 mov #67043,0
__3038:
__3036:
 84036 rstack EAX,EBP:-2
// lastProcess=proc
 84040 mov #257,EAX
__3035:
__3033:
__3030:
 84043 leave 
 84044 ret 
__3032:
 84045 db "%m<T%d>",0
timerIntHandler:
// timerIntHandler()
 84053 enter -0
__3040:
 84056 cli 
 84057 mov ECX,0
// switchToKernel(...)
 84060 call 430
 84063 mov ECX,0
// timerLogic(...)
 84066 call 83921
 84069 mov ECX,0
// switchToLastProcess(...)
 84072 call 258
 84075 leave 
 84076 sti 
 84077 extret 
__3039:
 84078 leave 
 84079 ret 
pageTrapHandler:
// pageTrapHandler()
 84080 enter -0
__3042:
 84083 cli 
 84084 mov ECX,0
// switchToKernel(...)
 84087 call 430
// printf arg #1 (char* format)
 84090 push 84113
 84093 mov ECX,1
// printf(...)
 84096 call 21772
 84099 add ESP,1
 84102 mov ECX,0
// switchToLastProcess(...)
 84105 call 258
 84108 leave 
 84109 sti 
 84110 extret 
__3041:
 84111 leave 
 84112 ret 
__3043:
 84113 db "---page trap---
",0
pageReadHandler:
// pageReadHandler()
 84130 enter 1
__3045:
 84133 cli 
 84134 sstack EBP:-1,#256
 84139 mov ECX,0
// switchToKernel(...)
 84142 call 430
 84145 rstack EAX,EBP:-1
// printf arg #2 (unknown)
 84149 push EAX
// printf arg #1 (char* format)
 84151 push 84174
 84154 mov ECX,2
// printf(...)
 84157 call 21772
 84160 add ESP,2
 84163 mov ECX,0
// switchToLastProcess(...)
 84166 call 258
 84169 leave 
 84170 sti 
 84171 extret 
__3044:
 84172 leave 
 84173 ret 
__3046:
 84174 db "---read trap (%d)---
",0
pageWriteHandler:
// pageWriteHandler()
 84196 enter -0
__3048:
 84199 cli 
 84200 mov ECX,0
// switchToKernel(...)
 84203 call 430
// printf arg #1 (char* format)
 84206 push 84229
 84209 mov ECX,1
// printf(...)
 84212 call 21772
 84215 add ESP,1
 84218 mov ECX,0
// switchToLastProcess(...)
 84221 call 258
 84224 leave 
 84225 sti 
 84226 extret 
__3047:
 84227 leave 
 84228 ret 
__3049:
 84229 db "---write trap---
",0
 84247 alloc 128
pg_int_handlers_end:
 84375 db 0
thread_terminate:
// thread_terminate()
 84376 enter -0
__3051:
// printf arg #2 (unknown)
 84379 push 900
// printf arg #1 (char* format)
 84382 push 84406
 84385 mov ECX,2
// printf(...)
 84388 call 21772
 84391 add ESP,2
// current_thread=0
 84394 mov #256,0
 84398 mov ECX,0
// jmpThreadExitPoint(...)
 84401 call 84456
__3050:
 84404 leave 
 84405 ret 
__3052:
 84406 db "%mThread terminated
",0
threadExit_ebp:
 84427 alloc 1
threadExit_esp:
 84428 alloc 1
threadExit_pos:
 84429 alloc 1
setThreadExitPoint:
// setThreadExitPoint(c_ebp,c_esp,c_pos)
 84430 enter -0
__3054:
 84433 rstack EAX,EBP:2
// threadExit_ebp=c_ebp
 84437 mov #84427,EAX
 84440 rstack EAX,EBP:3
// threadExit_esp=c_esp
 84444 mov #84428,EAX
 84447 rstack EAX,EBP:4
// threadExit_pos=c_pos
 84451 mov #84429,EAX
__3053:
 84454 leave 
 84455 ret 
jmpThreadExitPoint:
// jmpThreadExitPoint()
 84456 enter -0
__3056:
 84459 push #84429
 84462 push #84428
 84465 push #84427
 84468 mov ECX,3
// farjump(...)
 84471 call 84479
 84474 add ESP,3
__3055:
 84477 leave 
 84478 ret 
farjump:
// farjump(c_ebp,c_esp,c_pos)
 84479 enter -0
__3058:
 84482 rstack EAX,EBP:2
 84486 mov R0,EAX
 84488 rstack EAX,EBP:3
 84492 mov R1,EAX
 84494 rstack EAX,EBP:4
 84498 mov R2,EAX
 84500 mov EBP,R0
 84502 mov ESP,R1
 84504 jmp R2
__3057:
 84506 leave 
 84507 ret 
findJmp:
// findJmp(addr,nbytes,pres)
 84508 enter 4
__3060:
// init loop
 84511 sstack EBP:-1,0
__3062:
 84516 rstack EAX,EBP:-1
 84520 rstack EBX,EBP:3
 84524 sub EBX,EAX
 84526 mov EAX,EBX
 84528 fsgn EAX,EAX
// condition
 84530 max EAX,0
 84533 cmp 0,EAX
 84536 jz 84665
 84539 rstack EAX,EBP:-1
 84543 rstack EBX,EBP:2
 84547 add EBX,EAX
 84549 mov EAX,EBX
 84551 sstack EBP:-2,EAX
 84555 rstack EAX,EBP:-2
 84559 add EAX,0
 84562 mov EBX,EAX
 84564 mov EAX,2
 84567 sub EAX,#EBX
 84569 fabs EAX,EAX
 84571 fsgn EAX,EAX
 84573 lneg EAX
 84575 sstack EBP:-3,EAX
 84579 rstack EAX,EBP:-2
 84583 add EAX,1
 84586 mov EBX,EAX
 84588 mov EAX,0
 84591 sub EAX,#EBX
 84593 fabs EAX,EAX
 84595 fsgn EAX,EAX
 84597 lneg EAX
 84599 sstack EBP:-4,EAX
__3064:
 84603 rstack EAX,EBP:-4
 84607 rstack EBX,EBP:-3
 84611 and EBX,EAX
 84613 mov EAX,EBX
// if (b1&&b2)
 84615 cmp 0,EAX
 84618 jge 84652
__3067:
 84621 rstack EAX,EBP:4
// if (pres)
 84625 cmp 0,EAX
 84628 jge 84646
 84631 rstack EAX,EBP:-2
 84635 add EAX,2
 84638 mov EBX,EAX
 84640 rstack EAX,EBP:4
// *pres=ptr[2]
 84644 mov #EAX,#EBX
__3068:
__3066:
 84646 rstack EAX,EBP:-1
 84650 leave 
 84651 ret 
__3065:
__3063:
 84652 rstack EAX,EBP:-1
// loop step
 84656 inc EAX
 84658 sstack EBP:-1,EAX
 84662 jmp 84516
__3061:
 84665 mov EAX,-1
 84668 leave 
 84669 ret 
__3059:
 84670 leave 
 84671 ret 
toAbsSpace:
// toAbsSpace(p)
 84672 enter 7
__3070:
__3072:
// if (lastProcess)
 84675 cmp 0,#257
 84679 jge 84826
// process_h_get_pagemap arg #1 (float this)
 84682 push #257
 84685 mov ECX,1
// process_h_get_pagemap(...)
 84688 call 25296
 84691 add ESP,1
 84694 sstack EBP:-1,EAX
 84698 rstack EAX,EBP:-1
// vector_array arg #1 (void* self)
 84702 push EAX
 84704 mov ECX,1
// vector_array(...)
 84707 call 34499
 84710 add ESP,1
 84713 sstack EBP:-2,EAX
 84717 rstack EAX,EBP:2
 84721 mod EAX,128
 84724 mov EBX,EAX
 84726 sstack EBP:-3,EBX
 84730 rstack EAX,EBP:2
 84734 div EAX,128
 84737 mov EBX,EAX
// floor arg #1 (float A)
 84739 push EBX
 84741 mov ECX,1
// floor(...)
 84744 call 30221
 84747 add ESP,1
 84750 sstack EBP:-4,EAX
 84754 rstack EAX,EBP:-4
// getPage arg #2 (float page)
 84758 push EAX
 84760 rstack EAX,EBP:-2
// getPage arg #1 (float PT)
 84764 push EAX
 84766 mov ECX,2
// getPage(...)
 84769 call 36354
 84772 add ESP,2
 84775 sstack EBP:-5,EAX
 84779 rstack EAX,EBP:-5
// getPageMapping arg #1 (float page)
 84783 push EAX
 84785 mov ECX,1
// getPageMapping(...)
 84788 call 36629
 84791 add ESP,1
 84794 sstack EBP:-6,EAX
 84798 rstack EAX,EBP:-3
 84802 rstack EBX,EBP:-6
 84806 mul EBX,128
 84809 mov ECX,EBX
 84811 add ECX,EAX
 84813 sstack EBP:-7,ECX
 84817 rstack EAX,EBP:-7
 84821 leave 
 84822 ret 
 84823 jmp 84832
__3074:
__3073:
__3076:
 84826 rstack EAX,EBP:2
 84830 leave 
 84831 ret 
__3075:
__3071:
__3069:
 84832 leave 
 84833 ret 
kcall:
// kcall(a,b,c,d)
 84834 enter -0
__3078:
 84837 rstack EAX,EBP:2
 84841 mov R0,EAX
 84843 rstack EAX,EBP:3
 84847 mov R1,EAX
 84849 rstack EAX,EBP:4
 84853 mov R2,EAX
 84855 rstack EAX,EBP:5
 84859 mov R3,EAX
 84861 int 40
__3077:
 84864 leave 
 84865 ret 
vprintf:
// vprintf(fmt,nargs,va)
 84866 enter 3
__3080:
 84869 rstack EAX,EBP:3
 84873 add EAX,-1
 84876 mov EBX,EAX
 84878 push EBX
 84880 mov ECX,1
// stack_alloc(...)
 84883 call 11635
 84886 add ESP,1
 84889 sstack EBP:-1,EAX
// init loop
 84893 sstack EBP:-2,-1
__3082:
 84898 rstack EAX,EBP:-2
 84902 rstack EBX,EBP:3
 84906 add EBX,-2
 84909 mov ECX,EBX
 84911 sub ECX,EAX
 84913 fsgn ECX,ECX
// condition
 84915 max ECX,0
 84918 cmp 0,ECX
 84921 jz 84976
 84924 mov EAX,SS:EBP
 84927 add EAX,4
 84930 push EAX
 84932 mov ECX,1
// va_next(...)
 84935 call 10016
 84938 add ESP,1
 84941 sstack EBP:-3,EAX
 84945 rstack EAX,EBP:-3
 84949 rstack EBX,EBP:-2
 84953 rstack ECX,EBP:-1
 84957 add ECX,EBX
 84959 mov EBX,ECX
// args[I]=arg
 84961 mov #EBX,EAX
 84963 rstack EAX,EBP:-2
// loop step
 84967 inc EAX
 84969 sstack EBP:-2,EAX
 84973 jmp 84898
__3081:
 84976 rstack EAX,EBP:2
 84980 push EAX
 84982 rstack EAX,EBP:3
 84986 mov ECX,EAX
 84988 call 21772
__3079:
 84991 leave 
 84992 ret 
bios_prints:
// bios_prints(s)
 84993 enter 1
__3084:
__3086:
// ioRead arg #1 (float pos)
 84996 push 0
 84999 mov ECX,1
// ioRead(...)
 85002 call 21399
 85005 add ESP,1
 85008 mov EBX,2
 85011 sub EBX,EAX
 85013 fabs EBX,EBX
 85015 fsgn EBX,EBX
 85017 lneg EBX
// if (ioRead(0)==2
 85019 cmp 0,EBX
 85022 jz 85029
 85025 nop 
 85026 jmp 84996
__3085:
// ioWrite arg #2 (float val)
 85029 push 1
// ioWrite arg #1 (float pos)
 85032 push 1
 85035 mov ECX,2
// ioWrite(...)
 85038 call 21535
 85041 add ESP,2
 85044 rstack EAX,EBP:2
// strlen arg #1 (char* str)
 85048 push EAX
 85050 mov ECX,1
// strlen(...)
 85053 call 11121
 85056 add ESP,1
 85059 sstack EBP:-1,EAX
 85063 rstack EAX,EBP:-1
 85067 add EAX,1
 85070 mov EBX,EAX
// ioWriteBuff arg #3 (float size)
 85072 push EBX
 85074 rstack EAX,EBP:2
// ioWriteBuff arg #2 (float src)
 85078 push EAX
// ioWriteBuff arg #1 (float dest)
 85080 push 2
 85083 mov ECX,3
// ioWriteBuff(...)
 85086 call 21568
 85089 add ESP,3
// ioWrite arg #2 (float val)
 85092 push 2
// ioWrite arg #1 (float pos)
 85095 push 0
 85098 mov ECX,2
// ioWrite(...)
 85101 call 21535
 85104 add ESP,2
__3088:
// ioRead arg #1 (float pos)
 85107 push 0
 85110 mov ECX,1
// ioRead(...)
 85113 call 21399
 85116 add ESP,1
 85119 mov EBX,2
 85122 sub EBX,EAX
 85124 fabs EBX,EBX
 85126 fsgn EBX,EBX
// if (ioRead(0)!=2
 85128 cmp 0,EBX
 85131 jz 85138
 85134 nop 
 85135 jmp 85107
__3087:
__3083:
 85138 leave 
 85139 ret 
bios_printn:
// bios_printn(n)
 85140 enter -0
__3090:
__3092:
// ioRead arg #1 (float pos)
 85143 push 0
 85146 mov ECX,1
// ioRead(...)
 85149 call 21399
 85152 add ESP,1
 85155 mov EBX,2
 85158 sub EBX,EAX
 85160 fabs EBX,EBX
 85162 fsgn EBX,EBX
 85164 lneg EBX
// if (ioRead(0)==2
 85166 cmp 0,EBX
 85169 jz 85176
 85172 nop 
 85173 jmp 85143
__3091:
// ioWrite arg #2 (float val)
 85176 push 2
// ioWrite arg #1 (float pos)
 85179 push 1
 85182 mov ECX,2
// ioWrite(...)
 85185 call 21535
 85188 add ESP,2
 85191 rstack EAX,EBP:2
// ioWrite arg #2 (float val)
 85195 push EAX
// ioWrite arg #1 (float pos)
 85197 push 2
 85200 mov ECX,2
// ioWrite(...)
 85203 call 21535
 85206 add ESP,2
// ioWrite arg #2 (float val)
 85209 push 2
// ioWrite arg #1 (float pos)
 85212 push 0
 85215 mov ECX,2
// ioWrite(...)
 85218 call 21535
 85221 add ESP,2
__3094:
// ioRead arg #1 (float pos)
 85224 push 0
 85227 mov ECX,1
// ioRead(...)
 85230 call 21399
 85233 add ESP,1
 85236 mov EBX,2
 85239 sub EBX,EAX
 85241 fabs EBX,EBX
 85243 fsgn EBX,EBX
// if (ioRead(0)!=2
 85245 cmp 0,EBX
 85248 jz 85255
 85251 nop 
 85252 jmp 85224
__3093:
__3089:
 85255 leave 
 85256 ret 
Perr:
// Perr()
 85257 enter -0
__3096:
 85260 push 45
 85263 mov ECX,1
// error(...)
 85266 call 85291
 85269 add ESP,1
__3095:
 85272 leave 
 85273 ret 
panic:
// panic()
 85274 enter -0
__3098:
 85277 push 46
 85280 mov ECX,1
// error(...)
 85283 call 85291
 85286 add ESP,1
__3097:
 85289 leave 
 85290 ret 
error:
// error(n)
 85291 enter -0
__3100:
 85294 rstack EAX,EBP:2
 85298 int EAX
__3102:
// if (1
 85300 cmp 0,1
 85304 jz 85310
 85307 jmp 85300
__3101:
__3099:
 85310 leave 
 85311 ret 
kernelSize:
// kernelSize()
 85312 enter -0
__3104:
 85315 mov EAX,86010
 85318 leave 
 85319 ret 
__3103:
 85320 leave 
 85321 ret 
func_table:
 85322 db 80198
 85323 db 85416
 85324 db 80347
 85325 db 85421
 85326 db 80501
 85327 db 85436
 85328 db 80557
 85329 db 85450
 85330 db 80586
 85331 db 85458
 85332 db 80615
 85333 db 85466
 85334 db 80675
 85335 db 85474
 85336 db 81172
 85337 db 85488
 85338 db 81379
 85339 db 85498
 85340 db 81657
 85341 db 85509
 85342 db 82230
 85343 db 85530
 85344 db 82293
 85345 db 85542
 85346 db 82699
 85347 db 85551
 85348 db 82960
 85349 db 85563
 85350 db 83447
 85351 db 85585
 85352 db 83625
 85353 db 85608
 85354 db 83902
 85355 db 85626
 85356 db 83921
 85357 db 85641
 85358 db 84053
 85359 db 85652
 85360 db 84080
 85361 db 85668
 85362 db 84130
 85363 db 85684
 85364 db 84196
 85365 db 85700
 85366 db 84376
 85367 db 85717
 85368 db 84430
 85369 db 85734
 85370 db 84456
 85371 db 85753
 85372 db 84479
 85373 db 85772
 85374 db 84508
 85375 db 85780
 85376 db 84672
 85377 db 85788
 85378 db 84834
 85379 db 85799
 85380 db 84866
 85381 db 85805
 85382 db 84993
 85383 db 85813
 85384 db 85140
 85385 db 85825
 85386 db 85257
 85387 db 85837
 85388 db 85274
 85389 db 85842
 85390 db 85291
 85391 db 85848
 85392 db 85312
 85393 db 85854
func_table_end:
var_table:
 85394 db 67039
 85395 db 85865
 85396 db 67040
 85397 db 85880
 85398 db 67041
 85399 db 85892
 85400 db 67042
 85401 db 85910
 85402 db 67043
 85403 db 85921
 85404 db 67044
 85405 db 85932
 85406 db 67045
 85407 db 85943
 85408 db 82292
 85409 db 85958
 85410 db 84427
 85411 db 85965
 85412 db 84428
 85413 db 85980
 85414 db 84429
 85415 db 85995
var_table_end:
func_name_table:
str_main:
 85416 db "main"
 85420 db 0
str_set_trampoline:
 85421 db "set_trampoline"
 85435 db 0
str_clear_globals:
 85436 db "clear_globals"
 85449 db 0
str_kprints:
 85450 db "kprints"
 85457 db 0
str_kprintn:
 85458 db "kprintn"
 85465 db 0
str_kprintf:
 85466 db "kprintf"
 85473 db 0
str_kernel_thread:
 85474 db "kernel_thread"
 85487 db 0
str_exec_test:
 85488 db "exec_test"
 85497 db 0
str_write_test:
 85498 db "write_test"
 85508 db 0
str_protect_kernel_pages:
 85509 db "protect_kernel_pages"
 85529 db 0
str_init_ktimer:
 85530 db "init_ktimer"
 85541 db 0
str_retAlert:
 85542 db "retAlert"
 85550 db 0
str_unfuckEntry:
 85551 db "unfuckEntry"
 85562 db 0
str_KernellCallIntHandler:
 85563 db "KernellCallIntHandler"
 85584 db 0
str_UnmappedPageIntHandler:
 85585 db "UnmappedPageIntHandler"
 85607 db 0
str_defaultIntHandler:
 85608 db "defaultIntHandler"
 85625 db 0
str_timerShouldRun:
 85626 db "timerShouldRun"
 85640 db 0
str_timerLogic:
 85641 db "timerLogic"
 85651 db 0
str_timerIntHandler:
 85652 db "timerIntHandler"
 85667 db 0
str_pageTrapHandler:
 85668 db "pageTrapHandler"
 85683 db 0
str_pageReadHandler:
 85684 db "pageReadHandler"
 85699 db 0
str_pageWriteHandler:
 85700 db "pageWriteHandler"
 85716 db 0
str_thread_terminate:
 85717 db "thread_terminate"
 85733 db 0
str_setThreadExitPoint:
 85734 db "setThreadExitPoint"
 85752 db 0
str_jmpThreadExitPoint:
 85753 db "jmpThreadExitPoint"
 85771 db 0
str_farjump:
 85772 db "farjump"
 85779 db 0
str_findJmp:
 85780 db "findJmp"
 85787 db 0
str_toAbsSpace:
 85788 db "toAbsSpace"
 85798 db 0
str_kcall:
 85799 db "kcall"
 85804 db 0
str_vprintf:
 85805 db "vprintf"
 85812 db 0
str_bios_prints:
 85813 db "bios_prints"
 85824 db 0
str_bios_printn:
 85825 db "bios_printn"
 85836 db 0
str_Perr:
 85837 db "Perr"
 85841 db 0
str_panic:
 85842 db "panic"
 85847 db 0
str_error:
 85848 db "error"
 85853 db 0
str_kernelSize:
 85854 db "kernelSize"
 85864 db 0
func_name_table_end:
var_name_table:
str_EB_Addr_Screen:
 85865 db "EB_Addr_Screen"
 85879 db 0
str_timerPeriod:
 85880 db "timerPeriod"
 85891 db 0
str_timerLogicTimeout:
 85892 db "timerLogicTimeout"
 85909 db 0
str_v_proclist:
 85910 db "v_proclist"
 85920 db 0
str_proclist_I:
 85921 db "proclist_I"
 85931 db 0
str_switcherOn:
 85932 db "switcherOn"
 85942 db 0
str_k_page_manager:
 85943 db "k_page_manager"
 85957 db 0
str_timerN:
 85958 db "timerN"
 85964 db 0
str_threadExit_ebp:
 85965 db "threadExit_ebp"
 85979 db 0
str_threadExit_esp:
 85980 db "threadExit_esp"
 85994 db 0
str_threadExit_pos:
 85995 db "threadExit_pos"
 86009 db 0
var_name_table_end:
heap:
 86010 db 0
 86011 alloc 10000
